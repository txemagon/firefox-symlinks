/*
 * DO NOT EDIT.  THIS FILE IS GENERATED FROM /home/txema/work/firefox-20.0+build1/js/xpconnect/idl/xpccomponents.idl
 */

#ifndef __gen_xpccomponents_h__
#define __gen_xpccomponents_h__


#ifndef __gen_nsISupports_h__
#include "nsISupports.h"
#endif

#ifndef __gen_xpcexception_h__
#include "xpcexception.h"
#endif

#ifndef __gen_xpcjsid_h__
#include "xpcjsid.h"
#endif

#ifndef __gen_nsIComponentManager_h__
#include "nsIComponentManager.h"
#endif

#include "jspubtd.h"

/* For IDL files that don't want to include root IDL files. */
#ifndef NS_NO_VTABLE
#define NS_NO_VTABLE
#endif
#include "jspubtd.h"
class xpcIJSWeakReference; /* forward declaration */


/* starting interface:    nsIXPCComponents_InterfacesByID */
#define NS_IXPCCOMPONENTS_INTERFACESBYID_IID_STR "c99cffac-5aed-4267-ad2f-f4a4c9d4a081"

#define NS_IXPCCOMPONENTS_INTERFACESBYID_IID \
  {0xc99cffac, 0x5aed, 0x4267, \
    { 0xad, 0x2f, 0xf4, 0xa4, 0xc9, 0xd4, 0xa0, 0x81 }}

class NS_NO_VTABLE nsIXPCComponents_InterfacesByID : public nsISupports {
 public: 

  NS_DECLARE_STATIC_IID_ACCESSOR(NS_IXPCCOMPONENTS_INTERFACESBYID_IID)

};

  NS_DEFINE_STATIC_IID_ACCESSOR(nsIXPCComponents_InterfacesByID, NS_IXPCCOMPONENTS_INTERFACESBYID_IID)

/* Use this macro when declaring classes that implement this interface. */
#define NS_DECL_NSIXPCCOMPONENTS_INTERFACESBYID \
  /* no methods! */

/* Use this macro to declare functions that forward the behavior of this interface to another object. */
#define NS_FORWARD_NSIXPCCOMPONENTS_INTERFACESBYID(_to) \
  /* no methods! */

/* Use this macro to declare functions that forward the behavior of this interface to another object in a safe way. */
#define NS_FORWARD_SAFE_NSIXPCCOMPONENTS_INTERFACESBYID(_to) \
  /* no methods! */

#if 0
/* Use the code below as a template for the implementation class for this interface. */

/* Header file */
class nsXPCComponents_InterfacesByID : public nsIXPCComponents_InterfacesByID
{
public:
  NS_DECL_ISUPPORTS
  NS_DECL_NSIXPCCOMPONENTS_INTERFACESBYID

  nsXPCComponents_InterfacesByID();

private:
  ~nsXPCComponents_InterfacesByID();

protected:
  /* additional members */
};

/* Implementation file */
NS_IMPL_ISUPPORTS1(nsXPCComponents_InterfacesByID, nsIXPCComponents_InterfacesByID)

nsXPCComponents_InterfacesByID::nsXPCComponents_InterfacesByID()
{
  /* member initializers and constructor code */
}

nsXPCComponents_InterfacesByID::~nsXPCComponents_InterfacesByID()
{
  /* destructor code */
}

/* End of implementation class template. */
#endif


/* starting interface:    nsIXPCComponents_Interfaces */
#define NS_IXPCCOMPONENTS_INTERFACES_IID_STR "b8c31bba-79db-4a1d-930d-4cdd68713f9e"

#define NS_IXPCCOMPONENTS_INTERFACES_IID \
  {0xb8c31bba, 0x79db, 0x4a1d, \
    { 0x93, 0x0d, 0x4c, 0xdd, 0x68, 0x71, 0x3f, 0x9e }}

class NS_NO_VTABLE nsIXPCComponents_Interfaces : public nsISupports {
 public: 

  NS_DECLARE_STATIC_IID_ACCESSOR(NS_IXPCCOMPONENTS_INTERFACES_IID)

};

  NS_DEFINE_STATIC_IID_ACCESSOR(nsIXPCComponents_Interfaces, NS_IXPCCOMPONENTS_INTERFACES_IID)

/* Use this macro when declaring classes that implement this interface. */
#define NS_DECL_NSIXPCCOMPONENTS_INTERFACES \
  /* no methods! */

/* Use this macro to declare functions that forward the behavior of this interface to another object. */
#define NS_FORWARD_NSIXPCCOMPONENTS_INTERFACES(_to) \
  /* no methods! */

/* Use this macro to declare functions that forward the behavior of this interface to another object in a safe way. */
#define NS_FORWARD_SAFE_NSIXPCCOMPONENTS_INTERFACES(_to) \
  /* no methods! */

#if 0
/* Use the code below as a template for the implementation class for this interface. */

/* Header file */
class nsXPCComponents_Interfaces : public nsIXPCComponents_Interfaces
{
public:
  NS_DECL_ISUPPORTS
  NS_DECL_NSIXPCCOMPONENTS_INTERFACES

  nsXPCComponents_Interfaces();

private:
  ~nsXPCComponents_Interfaces();

protected:
  /* additional members */
};

/* Implementation file */
NS_IMPL_ISUPPORTS1(nsXPCComponents_Interfaces, nsIXPCComponents_Interfaces)

nsXPCComponents_Interfaces::nsXPCComponents_Interfaces()
{
  /* member initializers and constructor code */
}

nsXPCComponents_Interfaces::~nsXPCComponents_Interfaces()
{
  /* destructor code */
}

/* End of implementation class template. */
#endif


/* starting interface:    nsIXPCComponents_Classes */
#define NS_IXPCCOMPONENTS_CLASSES_IID_STR "978ff520-d26c-11d2-9842-006008962422"

#define NS_IXPCCOMPONENTS_CLASSES_IID \
  {0x978ff520, 0xd26c, 0x11d2, \
    { 0x98, 0x42, 0x00, 0x60, 0x08, 0x96, 0x24, 0x22 }}

class NS_NO_VTABLE nsIXPCComponents_Classes : public nsISupports {
 public: 

  NS_DECLARE_STATIC_IID_ACCESSOR(NS_IXPCCOMPONENTS_CLASSES_IID)

};

  NS_DEFINE_STATIC_IID_ACCESSOR(nsIXPCComponents_Classes, NS_IXPCCOMPONENTS_CLASSES_IID)

/* Use this macro when declaring classes that implement this interface. */
#define NS_DECL_NSIXPCCOMPONENTS_CLASSES \
  /* no methods! */

/* Use this macro to declare functions that forward the behavior of this interface to another object. */
#define NS_FORWARD_NSIXPCCOMPONENTS_CLASSES(_to) \
  /* no methods! */

/* Use this macro to declare functions that forward the behavior of this interface to another object in a safe way. */
#define NS_FORWARD_SAFE_NSIXPCCOMPONENTS_CLASSES(_to) \
  /* no methods! */

#if 0
/* Use the code below as a template for the implementation class for this interface. */

/* Header file */
class nsXPCComponents_Classes : public nsIXPCComponents_Classes
{
public:
  NS_DECL_ISUPPORTS
  NS_DECL_NSIXPCCOMPONENTS_CLASSES

  nsXPCComponents_Classes();

private:
  ~nsXPCComponents_Classes();

protected:
  /* additional members */
};

/* Implementation file */
NS_IMPL_ISUPPORTS1(nsXPCComponents_Classes, nsIXPCComponents_Classes)

nsXPCComponents_Classes::nsXPCComponents_Classes()
{
  /* member initializers and constructor code */
}

nsXPCComponents_Classes::~nsXPCComponents_Classes()
{
  /* destructor code */
}

/* End of implementation class template. */
#endif


/* starting interface:    nsIXPCComponents_ClassesByID */
#define NS_IXPCCOMPONENTS_CLASSESBYID_IID_STR "336a9590-4d19-11d3-9893-006008962422"

#define NS_IXPCCOMPONENTS_CLASSESBYID_IID \
  {0x336a9590, 0x4d19, 0x11d3, \
    { 0x98, 0x93, 0x00, 0x60, 0x08, 0x96, 0x24, 0x22 }}

class NS_NO_VTABLE nsIXPCComponents_ClassesByID : public nsISupports {
 public: 

  NS_DECLARE_STATIC_IID_ACCESSOR(NS_IXPCCOMPONENTS_CLASSESBYID_IID)

};

  NS_DEFINE_STATIC_IID_ACCESSOR(nsIXPCComponents_ClassesByID, NS_IXPCCOMPONENTS_CLASSESBYID_IID)

/* Use this macro when declaring classes that implement this interface. */
#define NS_DECL_NSIXPCCOMPONENTS_CLASSESBYID \
  /* no methods! */

/* Use this macro to declare functions that forward the behavior of this interface to another object. */
#define NS_FORWARD_NSIXPCCOMPONENTS_CLASSESBYID(_to) \
  /* no methods! */

/* Use this macro to declare functions that forward the behavior of this interface to another object in a safe way. */
#define NS_FORWARD_SAFE_NSIXPCCOMPONENTS_CLASSESBYID(_to) \
  /* no methods! */

#if 0
/* Use the code below as a template for the implementation class for this interface. */

/* Header file */
class nsXPCComponents_ClassesByID : public nsIXPCComponents_ClassesByID
{
public:
  NS_DECL_ISUPPORTS
  NS_DECL_NSIXPCCOMPONENTS_CLASSESBYID

  nsXPCComponents_ClassesByID();

private:
  ~nsXPCComponents_ClassesByID();

protected:
  /* additional members */
};

/* Implementation file */
NS_IMPL_ISUPPORTS1(nsXPCComponents_ClassesByID, nsIXPCComponents_ClassesByID)

nsXPCComponents_ClassesByID::nsXPCComponents_ClassesByID()
{
  /* member initializers and constructor code */
}

nsXPCComponents_ClassesByID::~nsXPCComponents_ClassesByID()
{
  /* destructor code */
}

/* End of implementation class template. */
#endif


/* starting interface:    nsIXPCComponents_Results */
#define NS_IXPCCOMPONENTS_RESULTS_IID_STR "2fc229a0-5860-11d3-9899-006008962422"

#define NS_IXPCCOMPONENTS_RESULTS_IID \
  {0x2fc229a0, 0x5860, 0x11d3, \
    { 0x98, 0x99, 0x00, 0x60, 0x08, 0x96, 0x24, 0x22 }}

class NS_NO_VTABLE nsIXPCComponents_Results : public nsISupports {
 public: 

  NS_DECLARE_STATIC_IID_ACCESSOR(NS_IXPCCOMPONENTS_RESULTS_IID)

};

  NS_DEFINE_STATIC_IID_ACCESSOR(nsIXPCComponents_Results, NS_IXPCCOMPONENTS_RESULTS_IID)

/* Use this macro when declaring classes that implement this interface. */
#define NS_DECL_NSIXPCCOMPONENTS_RESULTS \
  /* no methods! */

/* Use this macro to declare functions that forward the behavior of this interface to another object. */
#define NS_FORWARD_NSIXPCCOMPONENTS_RESULTS(_to) \
  /* no methods! */

/* Use this macro to declare functions that forward the behavior of this interface to another object in a safe way. */
#define NS_FORWARD_SAFE_NSIXPCCOMPONENTS_RESULTS(_to) \
  /* no methods! */

#if 0
/* Use the code below as a template for the implementation class for this interface. */

/* Header file */
class nsXPCComponents_Results : public nsIXPCComponents_Results
{
public:
  NS_DECL_ISUPPORTS
  NS_DECL_NSIXPCCOMPONENTS_RESULTS

  nsXPCComponents_Results();

private:
  ~nsXPCComponents_Results();

protected:
  /* additional members */
};

/* Implementation file */
NS_IMPL_ISUPPORTS1(nsXPCComponents_Results, nsIXPCComponents_Results)

nsXPCComponents_Results::nsXPCComponents_Results()
{
  /* member initializers and constructor code */
}

nsXPCComponents_Results::~nsXPCComponents_Results()
{
  /* destructor code */
}

/* End of implementation class template. */
#endif


/* starting interface:    nsIXPCComponents_ID */
#define NS_IXPCCOMPONENTS_ID_IID_STR "7994a6e0-e028-11d3-8f5d-0010a4e73d9a"

#define NS_IXPCCOMPONENTS_ID_IID \
  {0x7994a6e0, 0xe028, 0x11d3, \
    { 0x8f, 0x5d, 0x00, 0x10, 0xa4, 0xe7, 0x3d, 0x9a }}

class NS_NO_VTABLE nsIXPCComponents_ID : public nsISupports {
 public: 

  NS_DECLARE_STATIC_IID_ACCESSOR(NS_IXPCCOMPONENTS_ID_IID)

};

  NS_DEFINE_STATIC_IID_ACCESSOR(nsIXPCComponents_ID, NS_IXPCCOMPONENTS_ID_IID)

/* Use this macro when declaring classes that implement this interface. */
#define NS_DECL_NSIXPCCOMPONENTS_ID \
  /* no methods! */

/* Use this macro to declare functions that forward the behavior of this interface to another object. */
#define NS_FORWARD_NSIXPCCOMPONENTS_ID(_to) \
  /* no methods! */

/* Use this macro to declare functions that forward the behavior of this interface to another object in a safe way. */
#define NS_FORWARD_SAFE_NSIXPCCOMPONENTS_ID(_to) \
  /* no methods! */

#if 0
/* Use the code below as a template for the implementation class for this interface. */

/* Header file */
class nsXPCComponents_ID : public nsIXPCComponents_ID
{
public:
  NS_DECL_ISUPPORTS
  NS_DECL_NSIXPCCOMPONENTS_ID

  nsXPCComponents_ID();

private:
  ~nsXPCComponents_ID();

protected:
  /* additional members */
};

/* Implementation file */
NS_IMPL_ISUPPORTS1(nsXPCComponents_ID, nsIXPCComponents_ID)

nsXPCComponents_ID::nsXPCComponents_ID()
{
  /* member initializers and constructor code */
}

nsXPCComponents_ID::~nsXPCComponents_ID()
{
  /* destructor code */
}

/* End of implementation class template. */
#endif


/* starting interface:    nsIXPCComponents_Exception */
#define NS_IXPCCOMPONENTS_EXCEPTION_IID_STR "5bf039c0-e028-11d3-8f5d-0010a4e73d9a"

#define NS_IXPCCOMPONENTS_EXCEPTION_IID \
  {0x5bf039c0, 0xe028, 0x11d3, \
    { 0x8f, 0x5d, 0x00, 0x10, 0xa4, 0xe7, 0x3d, 0x9a }}

class NS_NO_VTABLE nsIXPCComponents_Exception : public nsISupports {
 public: 

  NS_DECLARE_STATIC_IID_ACCESSOR(NS_IXPCCOMPONENTS_EXCEPTION_IID)

};

  NS_DEFINE_STATIC_IID_ACCESSOR(nsIXPCComponents_Exception, NS_IXPCCOMPONENTS_EXCEPTION_IID)

/* Use this macro when declaring classes that implement this interface. */
#define NS_DECL_NSIXPCCOMPONENTS_EXCEPTION \
  /* no methods! */

/* Use this macro to declare functions that forward the behavior of this interface to another object. */
#define NS_FORWARD_NSIXPCCOMPONENTS_EXCEPTION(_to) \
  /* no methods! */

/* Use this macro to declare functions that forward the behavior of this interface to another object in a safe way. */
#define NS_FORWARD_SAFE_NSIXPCCOMPONENTS_EXCEPTION(_to) \
  /* no methods! */

#if 0
/* Use the code below as a template for the implementation class for this interface. */

/* Header file */
class nsXPCComponents_Exception : public nsIXPCComponents_Exception
{
public:
  NS_DECL_ISUPPORTS
  NS_DECL_NSIXPCCOMPONENTS_EXCEPTION

  nsXPCComponents_Exception();

private:
  ~nsXPCComponents_Exception();

protected:
  /* additional members */
};

/* Implementation file */
NS_IMPL_ISUPPORTS1(nsXPCComponents_Exception, nsIXPCComponents_Exception)

nsXPCComponents_Exception::nsXPCComponents_Exception()
{
  /* member initializers and constructor code */
}

nsXPCComponents_Exception::~nsXPCComponents_Exception()
{
  /* destructor code */
}

/* End of implementation class template. */
#endif


/* starting interface:    nsIXPCComponents_Constructor */
#define NS_IXPCCOMPONENTS_CONSTRUCTOR_IID_STR "88655640-e028-11d3-8f5d-0010a4e73d9a"

#define NS_IXPCCOMPONENTS_CONSTRUCTOR_IID \
  {0x88655640, 0xe028, 0x11d3, \
    { 0x8f, 0x5d, 0x00, 0x10, 0xa4, 0xe7, 0x3d, 0x9a }}

class NS_NO_VTABLE nsIXPCComponents_Constructor : public nsISupports {
 public: 

  NS_DECLARE_STATIC_IID_ACCESSOR(NS_IXPCCOMPONENTS_CONSTRUCTOR_IID)

};

  NS_DEFINE_STATIC_IID_ACCESSOR(nsIXPCComponents_Constructor, NS_IXPCCOMPONENTS_CONSTRUCTOR_IID)

/* Use this macro when declaring classes that implement this interface. */
#define NS_DECL_NSIXPCCOMPONENTS_CONSTRUCTOR \
  /* no methods! */

/* Use this macro to declare functions that forward the behavior of this interface to another object. */
#define NS_FORWARD_NSIXPCCOMPONENTS_CONSTRUCTOR(_to) \
  /* no methods! */

/* Use this macro to declare functions that forward the behavior of this interface to another object in a safe way. */
#define NS_FORWARD_SAFE_NSIXPCCOMPONENTS_CONSTRUCTOR(_to) \
  /* no methods! */

#if 0
/* Use the code below as a template for the implementation class for this interface. */

/* Header file */
class nsXPCComponents_Constructor : public nsIXPCComponents_Constructor
{
public:
  NS_DECL_ISUPPORTS
  NS_DECL_NSIXPCCOMPONENTS_CONSTRUCTOR

  nsXPCComponents_Constructor();

private:
  ~nsXPCComponents_Constructor();

protected:
  /* additional members */
};

/* Implementation file */
NS_IMPL_ISUPPORTS1(nsXPCComponents_Constructor, nsIXPCComponents_Constructor)

nsXPCComponents_Constructor::nsXPCComponents_Constructor()
{
  /* member initializers and constructor code */
}

nsXPCComponents_Constructor::~nsXPCComponents_Constructor()
{
  /* destructor code */
}

/* End of implementation class template. */
#endif


/* starting interface:    nsIXPCConstructor */
#define NS_IXPCCONSTRUCTOR_IID_STR "c814ca20-e0dc-11d3-8f5f-0010a4e73d9a"

#define NS_IXPCCONSTRUCTOR_IID \
  {0xc814ca20, 0xe0dc, 0x11d3, \
    { 0x8f, 0x5f, 0x00, 0x10, 0xa4, 0xe7, 0x3d, 0x9a }}

class NS_NO_VTABLE nsIXPCConstructor : public nsISupports {
 public: 

  NS_DECLARE_STATIC_IID_ACCESSOR(NS_IXPCCONSTRUCTOR_IID)

  /* readonly attribute nsIJSCID classID; */
  NS_IMETHOD GetClassID(nsIJSCID * *aClassID) = 0;

  /* readonly attribute nsIJSIID interfaceID; */
  NS_IMETHOD GetInterfaceID(nsIJSIID * *aInterfaceID) = 0;

  /* readonly attribute string initializer; */
  NS_IMETHOD GetInitializer(char * *aInitializer) = 0;

};

  NS_DEFINE_STATIC_IID_ACCESSOR(nsIXPCConstructor, NS_IXPCCONSTRUCTOR_IID)

/* Use this macro when declaring classes that implement this interface. */
#define NS_DECL_NSIXPCCONSTRUCTOR \
  NS_IMETHOD GetClassID(nsIJSCID * *aClassID); \
  NS_IMETHOD GetInterfaceID(nsIJSIID * *aInterfaceID); \
  NS_IMETHOD GetInitializer(char * *aInitializer); 

/* Use this macro to declare functions that forward the behavior of this interface to another object. */
#define NS_FORWARD_NSIXPCCONSTRUCTOR(_to) \
  NS_IMETHOD GetClassID(nsIJSCID * *aClassID) { return _to GetClassID(aClassID); } \
  NS_IMETHOD GetInterfaceID(nsIJSIID * *aInterfaceID) { return _to GetInterfaceID(aInterfaceID); } \
  NS_IMETHOD GetInitializer(char * *aInitializer) { return _to GetInitializer(aInitializer); } 

/* Use this macro to declare functions that forward the behavior of this interface to another object in a safe way. */
#define NS_FORWARD_SAFE_NSIXPCCONSTRUCTOR(_to) \
  NS_IMETHOD GetClassID(nsIJSCID * *aClassID) { return !_to ? NS_ERROR_NULL_POINTER : _to->GetClassID(aClassID); } \
  NS_IMETHOD GetInterfaceID(nsIJSIID * *aInterfaceID) { return !_to ? NS_ERROR_NULL_POINTER : _to->GetInterfaceID(aInterfaceID); } \
  NS_IMETHOD GetInitializer(char * *aInitializer) { return !_to ? NS_ERROR_NULL_POINTER : _to->GetInitializer(aInitializer); } 

#if 0
/* Use the code below as a template for the implementation class for this interface. */

/* Header file */
class nsXPCConstructor : public nsIXPCConstructor
{
public:
  NS_DECL_ISUPPORTS
  NS_DECL_NSIXPCCONSTRUCTOR

  nsXPCConstructor();

private:
  ~nsXPCConstructor();

protected:
  /* additional members */
};

/* Implementation file */
NS_IMPL_ISUPPORTS1(nsXPCConstructor, nsIXPCConstructor)

nsXPCConstructor::nsXPCConstructor()
{
  /* member initializers and constructor code */
}

nsXPCConstructor::~nsXPCConstructor()
{
  /* destructor code */
}

/* readonly attribute nsIJSCID classID; */
NS_IMETHODIMP nsXPCConstructor::GetClassID(nsIJSCID * *aClassID)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* readonly attribute nsIJSIID interfaceID; */
NS_IMETHODIMP nsXPCConstructor::GetInterfaceID(nsIJSIID * *aInterfaceID)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* readonly attribute string initializer; */
NS_IMETHODIMP nsXPCConstructor::GetInitializer(char * *aInitializer)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* End of implementation class template. */
#endif


/* starting interface:    nsIXPCComponents_utils_Sandbox */
#define NS_IXPCCOMPONENTS_UTILS_SANDBOX_IID_STR "4f8ae0dc-d266-4a32-875b-6a9de71a8ce9"

#define NS_IXPCCOMPONENTS_UTILS_SANDBOX_IID \
  {0x4f8ae0dc, 0xd266, 0x4a32, \
    { 0x87, 0x5b, 0x6a, 0x9d, 0xe7, 0x1a, 0x8c, 0xe9 }}

class NS_NO_VTABLE nsIXPCComponents_utils_Sandbox : public nsISupports {
 public: 

  NS_DECLARE_STATIC_IID_ACCESSOR(NS_IXPCCOMPONENTS_UTILS_SANDBOX_IID)

};

  NS_DEFINE_STATIC_IID_ACCESSOR(nsIXPCComponents_utils_Sandbox, NS_IXPCCOMPONENTS_UTILS_SANDBOX_IID)

/* Use this macro when declaring classes that implement this interface. */
#define NS_DECL_NSIXPCCOMPONENTS_UTILS_SANDBOX \
  /* no methods! */

/* Use this macro to declare functions that forward the behavior of this interface to another object. */
#define NS_FORWARD_NSIXPCCOMPONENTS_UTILS_SANDBOX(_to) \
  /* no methods! */

/* Use this macro to declare functions that forward the behavior of this interface to another object in a safe way. */
#define NS_FORWARD_SAFE_NSIXPCCOMPONENTS_UTILS_SANDBOX(_to) \
  /* no methods! */

#if 0
/* Use the code below as a template for the implementation class for this interface. */

/* Header file */
class nsXPCComponents_utils_Sandbox : public nsIXPCComponents_utils_Sandbox
{
public:
  NS_DECL_ISUPPORTS
  NS_DECL_NSIXPCCOMPONENTS_UTILS_SANDBOX

  nsXPCComponents_utils_Sandbox();

private:
  ~nsXPCComponents_utils_Sandbox();

protected:
  /* additional members */
};

/* Implementation file */
NS_IMPL_ISUPPORTS1(nsXPCComponents_utils_Sandbox, nsIXPCComponents_utils_Sandbox)

nsXPCComponents_utils_Sandbox::nsXPCComponents_utils_Sandbox()
{
  /* member initializers and constructor code */
}

nsXPCComponents_utils_Sandbox::~nsXPCComponents_utils_Sandbox()
{
  /* destructor code */
}

/* End of implementation class template. */
#endif


/* starting interface:    ScheduledGCCallback */
#define SCHEDULEDGCCALLBACK_IID_STR "71000535-b0fd-44d1-8ce0-909760e3953c"

#define SCHEDULEDGCCALLBACK_IID \
  {0x71000535, 0xb0fd, 0x44d1, \
    { 0x8c, 0xe0, 0x90, 0x97, 0x60, 0xe3, 0x95, 0x3c }}

class NS_NO_VTABLE ScheduledGCCallback : public nsISupports {
 public: 

  NS_DECLARE_STATIC_IID_ACCESSOR(SCHEDULEDGCCALLBACK_IID)

  /* void callback (); */
  NS_IMETHOD Callback(void) = 0;

};

  NS_DEFINE_STATIC_IID_ACCESSOR(ScheduledGCCallback, SCHEDULEDGCCALLBACK_IID)

/* Use this macro when declaring classes that implement this interface. */
#define NS_DECL_SCHEDULEDGCCALLBACK \
  NS_IMETHOD Callback(void); 

/* Use this macro to declare functions that forward the behavior of this interface to another object. */
#define NS_FORWARD_SCHEDULEDGCCALLBACK(_to) \
  NS_IMETHOD Callback(void) { return _to Callback(); } 

/* Use this macro to declare functions that forward the behavior of this interface to another object in a safe way. */
#define NS_FORWARD_SAFE_SCHEDULEDGCCALLBACK(_to) \
  NS_IMETHOD Callback(void) { return !_to ? NS_ERROR_NULL_POINTER : _to->Callback(); } 

#if 0
/* Use the code below as a template for the implementation class for this interface. */

/* Header file */
class _MYCLASS_ : public ScheduledGCCallback
{
public:
  NS_DECL_ISUPPORTS
  NS_DECL_SCHEDULEDGCCALLBACK

  _MYCLASS_();

private:
  ~_MYCLASS_();

protected:
  /* additional members */
};

/* Implementation file */
NS_IMPL_ISUPPORTS1(_MYCLASS_, ScheduledGCCallback)

_MYCLASS_::_MYCLASS_()
{
  /* member initializers and constructor code */
}

_MYCLASS_::~_MYCLASS_()
{
  /* destructor code */
}

/* void callback (); */
NS_IMETHODIMP _MYCLASS_::Callback()
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* End of implementation class template. */
#endif


/* starting interface:    nsIXPCComponents_Utils */
#define NS_IXPCCOMPONENTS_UTILS_IID_STR "0d0fd2f7-3250-4092-9340-ca9bcb7be470"

#define NS_IXPCCOMPONENTS_UTILS_IID \
  {0x0d0fd2f7, 0x3250, 0x4092, \
    { 0x93, 0x40, 0xca, 0x9b, 0xcb, 0x7b, 0xe4, 0x70 }}

class NS_NO_VTABLE nsIXPCComponents_Utils : public nsISupports {
 public: 

  NS_DECLARE_STATIC_IID_ACCESSOR(NS_IXPCCOMPONENTS_UTILS_IID)

  /* [implicit_jscontext] void reportError (in jsval error); */
  NS_IMETHOD ReportError(const JS::Value & error, JSContext* cx) = 0;

  /* [implicit_jscontext] jsval lookupMethod (in jsval obj, in jsval name); */
  NS_IMETHOD LookupMethod(const JS::Value & obj, const JS::Value & name, JSContext* cx, JS::Value *_retval) = 0;

  /* readonly attribute nsIXPCComponents_utils_Sandbox Sandbox; */
  NS_IMETHOD GetSandbox(nsIXPCComponents_utils_Sandbox * *aSandbox) = 0;

  /* [implicit_jscontext,optional_argc] jsval evalInSandbox (in AString source, in jsval sandbox, [optional] in jsval version, [optional] in jsval filename, [optional] in long lineNo); */
  NS_IMETHOD EvalInSandbox(const nsAString & source, const JS::Value & sandbox, const JS::Value & version, const JS::Value & filename, int32_t lineNo, JSContext* cx, uint8_t _argc, JS::Value *_retval) = 0;

  /* [implicit_jscontext,optional_argc] jsval import (in AUTF8String aResourceURI, [optional] in jsval targetObj); */
  NS_IMETHOD Import(const nsACString & aResourceURI, const JS::Value & targetObj, JSContext* cx, uint8_t _argc, JS::Value *_retval) = 0;

  /* void unload (in AUTF8String registryLocation); */
  NS_IMETHOD Unload(const nsACString & registryLocation) = 0;

  /* [implicit_jscontext] xpcIJSWeakReference getWeakReference (in jsval obj); */
  NS_IMETHOD GetWeakReference(const JS::Value & obj, JSContext* cx, xpcIJSWeakReference * *_retval) = 0;

  /* void forceGC (); */
  NS_IMETHOD ForceGC(void) = 0;

  /* void forceCC (); */
  NS_IMETHOD ForceCC(void) = 0;

  /* void forceShrinkingGC (); */
  NS_IMETHOD ForceShrinkingGC(void) = 0;

  /* void schedulePreciseGC (in ScheduledGCCallback callback); */
  NS_IMETHOD SchedulePreciseGC(ScheduledGCCallback *callback) = 0;

  /* void schedulePreciseShrinkingGC (in ScheduledGCCallback callback); */
  NS_IMETHOD SchedulePreciseShrinkingGC(ScheduledGCCallback *callback) = 0;

  /* [implicit_jscontext] jsval nondeterministicGetWeakMapKeys (in jsval aMap); */
  NS_IMETHOD NondeterministicGetWeakMapKeys(const JS::Value & aMap, JSContext* cx, JS::Value *_retval) = 0;

  /* [implicit_jscontext] jsval getJSTestingFunctions (); */
  NS_IMETHOD GetJSTestingFunctions(JSContext* cx, JS::Value *_retval) = 0;

  /* [implicit_jscontext] jsval getGlobalForObject (in jsval obj); */
  NS_IMETHOD GetGlobalForObject(const JS::Value & obj, JSContext* cx, JS::Value *_retval) = 0;

  /* [implicit_jscontext] jsval createObjectIn (in jsval vobj); */
  NS_IMETHOD CreateObjectIn(const JS::Value & vobj, JSContext* cx, JS::Value *_retval) = 0;

  /* [implicit_jscontext] jsval createArrayIn (in jsval vobj); */
  NS_IMETHOD CreateArrayIn(const JS::Value & vobj, JSContext* cx, JS::Value *_retval) = 0;

  /* [implicit_jscontext] jsval createDateIn (in jsval vobj, in long long msec); */
  NS_IMETHOD CreateDateIn(const JS::Value & vobj, int64_t msec, JSContext* cx, JS::Value *_retval) = 0;

  /* [implicit_jscontext] void makeObjectPropsNormal (in jsval vobj); */
  NS_IMETHOD MakeObjectPropsNormal(const JS::Value & vobj, JSContext* cx) = 0;

  /* bool isDeadWrapper (in jsval obj); */
  NS_IMETHOD IsDeadWrapper(const JS::Value & obj, bool *_retval) = 0;

  /* [implicit_jscontext] void recomputeWrappers ([optional] in jsval vobj); */
  NS_IMETHOD RecomputeWrappers(const JS::Value & vobj, JSContext* cx) = 0;

  /* [implicit_jscontext] void setWantXrays (in jsval vscope); */
  NS_IMETHOD SetWantXrays(const JS::Value & vscope, JSContext* cx) = 0;

  /* [implicit_jscontext] jsval getComponentsForScope (in jsval vscope); */
  NS_IMETHOD GetComponentsForScope(const JS::Value & vscope, JSContext* cx, JS::Value *_retval) = 0;

  /* [implicit_jscontext] void dispatch (in jsval runnable, [optional] in jsval scope); */
  NS_IMETHOD Dispatch(const JS::Value & runnable, const JS::Value & scope, JSContext* cx) = 0;

  /* [implicit_jscontext] attribute boolean strict; */
  NS_IMETHOD GetStrict(JSContext* cx, bool *aStrict) = 0;
  NS_IMETHOD SetStrict(JSContext* cx, bool aStrict) = 0;

  /* [implicit_jscontext] attribute boolean werror; */
  NS_IMETHOD GetWerror(JSContext* cx, bool *aWerror) = 0;
  NS_IMETHOD SetWerror(JSContext* cx, bool aWerror) = 0;

  /* [implicit_jscontext] attribute boolean atline; */
  NS_IMETHOD GetAtline(JSContext* cx, bool *aAtline) = 0;
  NS_IMETHOD SetAtline(JSContext* cx, bool aAtline) = 0;

  /* [implicit_jscontext] attribute boolean xml; */
  NS_IMETHOD GetXml(JSContext* cx, bool *aXml) = 0;
  NS_IMETHOD SetXml(JSContext* cx, bool aXml) = 0;

  /* [implicit_jscontext] attribute boolean methodjit; */
  NS_IMETHOD GetMethodjit(JSContext* cx, bool *aMethodjit) = 0;
  NS_IMETHOD SetMethodjit(JSContext* cx, bool aMethodjit) = 0;

  /* [implicit_jscontext] attribute boolean methodjit_always; */
  NS_IMETHOD GetMethodjit_always(JSContext* cx, bool *aMethodjit_always) = 0;
  NS_IMETHOD SetMethodjit_always(JSContext* cx, bool aMethodjit_always) = 0;

  /* [implicit_jscontext] attribute boolean strict_mode; */
  NS_IMETHOD GetStrict_mode(JSContext* cx, bool *aStrict_mode) = 0;
  NS_IMETHOD SetStrict_mode(JSContext* cx, bool aStrict_mode) = 0;

  /* [implicit_jscontext] attribute boolean ion; */
  NS_IMETHOD GetIon(JSContext* cx, bool *aIon) = 0;
  NS_IMETHOD SetIon(JSContext* cx, bool aIon) = 0;

  /* [implicit_jscontext] void setGCZeal (in long zeal); */
  NS_IMETHOD SetGCZeal(int32_t zeal, JSContext* cx) = 0;

  /* [implicit_jscontext] void nukeSandbox (in jsval obj); */
  NS_IMETHOD NukeSandbox(const JS::Value & obj, JSContext* cx) = 0;

  /* bool isXrayWrapper (in jsval obj); */
  NS_IMETHOD IsXrayWrapper(const JS::Value & obj, bool *_retval) = 0;

};

  NS_DEFINE_STATIC_IID_ACCESSOR(nsIXPCComponents_Utils, NS_IXPCCOMPONENTS_UTILS_IID)

/* Use this macro when declaring classes that implement this interface. */
#define NS_DECL_NSIXPCCOMPONENTS_UTILS \
  NS_IMETHOD ReportError(const JS::Value & error, JSContext* cx); \
  NS_IMETHOD LookupMethod(const JS::Value & obj, const JS::Value & name, JSContext* cx, JS::Value *_retval); \
  NS_IMETHOD GetSandbox(nsIXPCComponents_utils_Sandbox * *aSandbox); \
  NS_IMETHOD EvalInSandbox(const nsAString & source, const JS::Value & sandbox, const JS::Value & version, const JS::Value & filename, int32_t lineNo, JSContext* cx, uint8_t _argc, JS::Value *_retval); \
  NS_IMETHOD Import(const nsACString & aResourceURI, const JS::Value & targetObj, JSContext* cx, uint8_t _argc, JS::Value *_retval); \
  NS_IMETHOD Unload(const nsACString & registryLocation); \
  NS_IMETHOD GetWeakReference(const JS::Value & obj, JSContext* cx, xpcIJSWeakReference * *_retval); \
  NS_IMETHOD ForceGC(void); \
  NS_IMETHOD ForceCC(void); \
  NS_IMETHOD ForceShrinkingGC(void); \
  NS_IMETHOD SchedulePreciseGC(ScheduledGCCallback *callback); \
  NS_IMETHOD SchedulePreciseShrinkingGC(ScheduledGCCallback *callback); \
  NS_IMETHOD NondeterministicGetWeakMapKeys(const JS::Value & aMap, JSContext* cx, JS::Value *_retval); \
  NS_IMETHOD GetJSTestingFunctions(JSContext* cx, JS::Value *_retval); \
  NS_IMETHOD GetGlobalForObject(const JS::Value & obj, JSContext* cx, JS::Value *_retval); \
  NS_IMETHOD CreateObjectIn(const JS::Value & vobj, JSContext* cx, JS::Value *_retval); \
  NS_IMETHOD CreateArrayIn(const JS::Value & vobj, JSContext* cx, JS::Value *_retval); \
  NS_IMETHOD CreateDateIn(const JS::Value & vobj, int64_t msec, JSContext* cx, JS::Value *_retval); \
  NS_IMETHOD MakeObjectPropsNormal(const JS::Value & vobj, JSContext* cx); \
  NS_IMETHOD IsDeadWrapper(const JS::Value & obj, bool *_retval); \
  NS_IMETHOD RecomputeWrappers(const JS::Value & vobj, JSContext* cx); \
  NS_IMETHOD SetWantXrays(const JS::Value & vscope, JSContext* cx); \
  NS_IMETHOD GetComponentsForScope(const JS::Value & vscope, JSContext* cx, JS::Value *_retval); \
  NS_IMETHOD Dispatch(const JS::Value & runnable, const JS::Value & scope, JSContext* cx); \
  NS_IMETHOD GetStrict(JSContext* cx, bool *aStrict); \
  NS_IMETHOD SetStrict(JSContext* cx, bool aStrict); \
  NS_IMETHOD GetWerror(JSContext* cx, bool *aWerror); \
  NS_IMETHOD SetWerror(JSContext* cx, bool aWerror); \
  NS_IMETHOD GetAtline(JSContext* cx, bool *aAtline); \
  NS_IMETHOD SetAtline(JSContext* cx, bool aAtline); \
  NS_IMETHOD GetXml(JSContext* cx, bool *aXml); \
  NS_IMETHOD SetXml(JSContext* cx, bool aXml); \
  NS_IMETHOD GetMethodjit(JSContext* cx, bool *aMethodjit); \
  NS_IMETHOD SetMethodjit(JSContext* cx, bool aMethodjit); \
  NS_IMETHOD GetMethodjit_always(JSContext* cx, bool *aMethodjit_always); \
  NS_IMETHOD SetMethodjit_always(JSContext* cx, bool aMethodjit_always); \
  NS_IMETHOD GetStrict_mode(JSContext* cx, bool *aStrict_mode); \
  NS_IMETHOD SetStrict_mode(JSContext* cx, bool aStrict_mode); \
  NS_IMETHOD GetIon(JSContext* cx, bool *aIon); \
  NS_IMETHOD SetIon(JSContext* cx, bool aIon); \
  NS_IMETHOD SetGCZeal(int32_t zeal, JSContext* cx); \
  NS_IMETHOD NukeSandbox(const JS::Value & obj, JSContext* cx); \
  NS_IMETHOD IsXrayWrapper(const JS::Value & obj, bool *_retval); 

/* Use this macro to declare functions that forward the behavior of this interface to another object. */
#define NS_FORWARD_NSIXPCCOMPONENTS_UTILS(_to) \
  NS_IMETHOD ReportError(const JS::Value & error, JSContext* cx) { return _to ReportError(error, cx); } \
  NS_IMETHOD LookupMethod(const JS::Value & obj, const JS::Value & name, JSContext* cx, JS::Value *_retval) { return _to LookupMethod(obj, name, cx, _retval); } \
  NS_IMETHOD GetSandbox(nsIXPCComponents_utils_Sandbox * *aSandbox) { return _to GetSandbox(aSandbox); } \
  NS_IMETHOD EvalInSandbox(const nsAString & source, const JS::Value & sandbox, const JS::Value & version, const JS::Value & filename, int32_t lineNo, JSContext* cx, uint8_t _argc, JS::Value *_retval) { return _to EvalInSandbox(source, sandbox, version, filename, lineNo, cx, _argc, _retval); } \
  NS_IMETHOD Import(const nsACString & aResourceURI, const JS::Value & targetObj, JSContext* cx, uint8_t _argc, JS::Value *_retval) { return _to Import(aResourceURI, targetObj, cx, _argc, _retval); } \
  NS_IMETHOD Unload(const nsACString & registryLocation) { return _to Unload(registryLocation); } \
  NS_IMETHOD GetWeakReference(const JS::Value & obj, JSContext* cx, xpcIJSWeakReference * *_retval) { return _to GetWeakReference(obj, cx, _retval); } \
  NS_IMETHOD ForceGC(void) { return _to ForceGC(); } \
  NS_IMETHOD ForceCC(void) { return _to ForceCC(); } \
  NS_IMETHOD ForceShrinkingGC(void) { return _to ForceShrinkingGC(); } \
  NS_IMETHOD SchedulePreciseGC(ScheduledGCCallback *callback) { return _to SchedulePreciseGC(callback); } \
  NS_IMETHOD SchedulePreciseShrinkingGC(ScheduledGCCallback *callback) { return _to SchedulePreciseShrinkingGC(callback); } \
  NS_IMETHOD NondeterministicGetWeakMapKeys(const JS::Value & aMap, JSContext* cx, JS::Value *_retval) { return _to NondeterministicGetWeakMapKeys(aMap, cx, _retval); } \
  NS_IMETHOD GetJSTestingFunctions(JSContext* cx, JS::Value *_retval) { return _to GetJSTestingFunctions(cx, _retval); } \
  NS_IMETHOD GetGlobalForObject(const JS::Value & obj, JSContext* cx, JS::Value *_retval) { return _to GetGlobalForObject(obj, cx, _retval); } \
  NS_IMETHOD CreateObjectIn(const JS::Value & vobj, JSContext* cx, JS::Value *_retval) { return _to CreateObjectIn(vobj, cx, _retval); } \
  NS_IMETHOD CreateArrayIn(const JS::Value & vobj, JSContext* cx, JS::Value *_retval) { return _to CreateArrayIn(vobj, cx, _retval); } \
  NS_IMETHOD CreateDateIn(const JS::Value & vobj, int64_t msec, JSContext* cx, JS::Value *_retval) { return _to CreateDateIn(vobj, msec, cx, _retval); } \
  NS_IMETHOD MakeObjectPropsNormal(const JS::Value & vobj, JSContext* cx) { return _to MakeObjectPropsNormal(vobj, cx); } \
  NS_IMETHOD IsDeadWrapper(const JS::Value & obj, bool *_retval) { return _to IsDeadWrapper(obj, _retval); } \
  NS_IMETHOD RecomputeWrappers(const JS::Value & vobj, JSContext* cx) { return _to RecomputeWrappers(vobj, cx); } \
  NS_IMETHOD SetWantXrays(const JS::Value & vscope, JSContext* cx) { return _to SetWantXrays(vscope, cx); } \
  NS_IMETHOD GetComponentsForScope(const JS::Value & vscope, JSContext* cx, JS::Value *_retval) { return _to GetComponentsForScope(vscope, cx, _retval); } \
  NS_IMETHOD Dispatch(const JS::Value & runnable, const JS::Value & scope, JSContext* cx) { return _to Dispatch(runnable, scope, cx); } \
  NS_IMETHOD GetStrict(JSContext* cx, bool *aStrict) { return _to GetStrict(cx, aStrict); } \
  NS_IMETHOD SetStrict(JSContext* cx, bool aStrict) { return _to SetStrict(cx, aStrict); } \
  NS_IMETHOD GetWerror(JSContext* cx, bool *aWerror) { return _to GetWerror(cx, aWerror); } \
  NS_IMETHOD SetWerror(JSContext* cx, bool aWerror) { return _to SetWerror(cx, aWerror); } \
  NS_IMETHOD GetAtline(JSContext* cx, bool *aAtline) { return _to GetAtline(cx, aAtline); } \
  NS_IMETHOD SetAtline(JSContext* cx, bool aAtline) { return _to SetAtline(cx, aAtline); } \
  NS_IMETHOD GetXml(JSContext* cx, bool *aXml) { return _to GetXml(cx, aXml); } \
  NS_IMETHOD SetXml(JSContext* cx, bool aXml) { return _to SetXml(cx, aXml); } \
  NS_IMETHOD GetMethodjit(JSContext* cx, bool *aMethodjit) { return _to GetMethodjit(cx, aMethodjit); } \
  NS_IMETHOD SetMethodjit(JSContext* cx, bool aMethodjit) { return _to SetMethodjit(cx, aMethodjit); } \
  NS_IMETHOD GetMethodjit_always(JSContext* cx, bool *aMethodjit_always) { return _to GetMethodjit_always(cx, aMethodjit_always); } \
  NS_IMETHOD SetMethodjit_always(JSContext* cx, bool aMethodjit_always) { return _to SetMethodjit_always(cx, aMethodjit_always); } \
  NS_IMETHOD GetStrict_mode(JSContext* cx, bool *aStrict_mode) { return _to GetStrict_mode(cx, aStrict_mode); } \
  NS_IMETHOD SetStrict_mode(JSContext* cx, bool aStrict_mode) { return _to SetStrict_mode(cx, aStrict_mode); } \
  NS_IMETHOD GetIon(JSContext* cx, bool *aIon) { return _to GetIon(cx, aIon); } \
  NS_IMETHOD SetIon(JSContext* cx, bool aIon) { return _to SetIon(cx, aIon); } \
  NS_IMETHOD SetGCZeal(int32_t zeal, JSContext* cx) { return _to SetGCZeal(zeal, cx); } \
  NS_IMETHOD NukeSandbox(const JS::Value & obj, JSContext* cx) { return _to NukeSandbox(obj, cx); } \
  NS_IMETHOD IsXrayWrapper(const JS::Value & obj, bool *_retval) { return _to IsXrayWrapper(obj, _retval); } 

/* Use this macro to declare functions that forward the behavior of this interface to another object in a safe way. */
#define NS_FORWARD_SAFE_NSIXPCCOMPONENTS_UTILS(_to) \
  NS_IMETHOD ReportError(const JS::Value & error, JSContext* cx) { return !_to ? NS_ERROR_NULL_POINTER : _to->ReportError(error, cx); } \
  NS_IMETHOD LookupMethod(const JS::Value & obj, const JS::Value & name, JSContext* cx, JS::Value *_retval) { return !_to ? NS_ERROR_NULL_POINTER : _to->LookupMethod(obj, name, cx, _retval); } \
  NS_IMETHOD GetSandbox(nsIXPCComponents_utils_Sandbox * *aSandbox) { return !_to ? NS_ERROR_NULL_POINTER : _to->GetSandbox(aSandbox); } \
  NS_IMETHOD EvalInSandbox(const nsAString & source, const JS::Value & sandbox, const JS::Value & version, const JS::Value & filename, int32_t lineNo, JSContext* cx, uint8_t _argc, JS::Value *_retval) { return !_to ? NS_ERROR_NULL_POINTER : _to->EvalInSandbox(source, sandbox, version, filename, lineNo, cx, _argc, _retval); } \
  NS_IMETHOD Import(const nsACString & aResourceURI, const JS::Value & targetObj, JSContext* cx, uint8_t _argc, JS::Value *_retval) { return !_to ? NS_ERROR_NULL_POINTER : _to->Import(aResourceURI, targetObj, cx, _argc, _retval); } \
  NS_IMETHOD Unload(const nsACString & registryLocation) { return !_to ? NS_ERROR_NULL_POINTER : _to->Unload(registryLocation); } \
  NS_IMETHOD GetWeakReference(const JS::Value & obj, JSContext* cx, xpcIJSWeakReference * *_retval) { return !_to ? NS_ERROR_NULL_POINTER : _to->GetWeakReference(obj, cx, _retval); } \
  NS_IMETHOD ForceGC(void) { return !_to ? NS_ERROR_NULL_POINTER : _to->ForceGC(); } \
  NS_IMETHOD ForceCC(void) { return !_to ? NS_ERROR_NULL_POINTER : _to->ForceCC(); } \
  NS_IMETHOD ForceShrinkingGC(void) { return !_to ? NS_ERROR_NULL_POINTER : _to->ForceShrinkingGC(); } \
  NS_IMETHOD SchedulePreciseGC(ScheduledGCCallback *callback) { return !_to ? NS_ERROR_NULL_POINTER : _to->SchedulePreciseGC(callback); } \
  NS_IMETHOD SchedulePreciseShrinkingGC(ScheduledGCCallback *callback) { return !_to ? NS_ERROR_NULL_POINTER : _to->SchedulePreciseShrinkingGC(callback); } \
  NS_IMETHOD NondeterministicGetWeakMapKeys(const JS::Value & aMap, JSContext* cx, JS::Value *_retval) { return !_to ? NS_ERROR_NULL_POINTER : _to->NondeterministicGetWeakMapKeys(aMap, cx, _retval); } \
  NS_IMETHOD GetJSTestingFunctions(JSContext* cx, JS::Value *_retval) { return !_to ? NS_ERROR_NULL_POINTER : _to->GetJSTestingFunctions(cx, _retval); } \
  NS_IMETHOD GetGlobalForObject(const JS::Value & obj, JSContext* cx, JS::Value *_retval) { return !_to ? NS_ERROR_NULL_POINTER : _to->GetGlobalForObject(obj, cx, _retval); } \
  NS_IMETHOD CreateObjectIn(const JS::Value & vobj, JSContext* cx, JS::Value *_retval) { return !_to ? NS_ERROR_NULL_POINTER : _to->CreateObjectIn(vobj, cx, _retval); } \
  NS_IMETHOD CreateArrayIn(const JS::Value & vobj, JSContext* cx, JS::Value *_retval) { return !_to ? NS_ERROR_NULL_POINTER : _to->CreateArrayIn(vobj, cx, _retval); } \
  NS_IMETHOD CreateDateIn(const JS::Value & vobj, int64_t msec, JSContext* cx, JS::Value *_retval) { return !_to ? NS_ERROR_NULL_POINTER : _to->CreateDateIn(vobj, msec, cx, _retval); } \
  NS_IMETHOD MakeObjectPropsNormal(const JS::Value & vobj, JSContext* cx) { return !_to ? NS_ERROR_NULL_POINTER : _to->MakeObjectPropsNormal(vobj, cx); } \
  NS_IMETHOD IsDeadWrapper(const JS::Value & obj, bool *_retval) { return !_to ? NS_ERROR_NULL_POINTER : _to->IsDeadWrapper(obj, _retval); } \
  NS_IMETHOD RecomputeWrappers(const JS::Value & vobj, JSContext* cx) { return !_to ? NS_ERROR_NULL_POINTER : _to->RecomputeWrappers(vobj, cx); } \
  NS_IMETHOD SetWantXrays(const JS::Value & vscope, JSContext* cx) { return !_to ? NS_ERROR_NULL_POINTER : _to->SetWantXrays(vscope, cx); } \
  NS_IMETHOD GetComponentsForScope(const JS::Value & vscope, JSContext* cx, JS::Value *_retval) { return !_to ? NS_ERROR_NULL_POINTER : _to->GetComponentsForScope(vscope, cx, _retval); } \
  NS_IMETHOD Dispatch(const JS::Value & runnable, const JS::Value & scope, JSContext* cx) { return !_to ? NS_ERROR_NULL_POINTER : _to->Dispatch(runnable, scope, cx); } \
  NS_IMETHOD GetStrict(JSContext* cx, bool *aStrict) { return !_to ? NS_ERROR_NULL_POINTER : _to->GetStrict(cx, aStrict); } \
  NS_IMETHOD SetStrict(JSContext* cx, bool aStrict) { return !_to ? NS_ERROR_NULL_POINTER : _to->SetStrict(cx, aStrict); } \
  NS_IMETHOD GetWerror(JSContext* cx, bool *aWerror) { return !_to ? NS_ERROR_NULL_POINTER : _to->GetWerror(cx, aWerror); } \
  NS_IMETHOD SetWerror(JSContext* cx, bool aWerror) { return !_to ? NS_ERROR_NULL_POINTER : _to->SetWerror(cx, aWerror); } \
  NS_IMETHOD GetAtline(JSContext* cx, bool *aAtline) { return !_to ? NS_ERROR_NULL_POINTER : _to->GetAtline(cx, aAtline); } \
  NS_IMETHOD SetAtline(JSContext* cx, bool aAtline) { return !_to ? NS_ERROR_NULL_POINTER : _to->SetAtline(cx, aAtline); } \
  NS_IMETHOD GetXml(JSContext* cx, bool *aXml) { return !_to ? NS_ERROR_NULL_POINTER : _to->GetXml(cx, aXml); } \
  NS_IMETHOD SetXml(JSContext* cx, bool aXml) { return !_to ? NS_ERROR_NULL_POINTER : _to->SetXml(cx, aXml); } \
  NS_IMETHOD GetMethodjit(JSContext* cx, bool *aMethodjit) { return !_to ? NS_ERROR_NULL_POINTER : _to->GetMethodjit(cx, aMethodjit); } \
  NS_IMETHOD SetMethodjit(JSContext* cx, bool aMethodjit) { return !_to ? NS_ERROR_NULL_POINTER : _to->SetMethodjit(cx, aMethodjit); } \
  NS_IMETHOD GetMethodjit_always(JSContext* cx, bool *aMethodjit_always) { return !_to ? NS_ERROR_NULL_POINTER : _to->GetMethodjit_always(cx, aMethodjit_always); } \
  NS_IMETHOD SetMethodjit_always(JSContext* cx, bool aMethodjit_always) { return !_to ? NS_ERROR_NULL_POINTER : _to->SetMethodjit_always(cx, aMethodjit_always); } \
  NS_IMETHOD GetStrict_mode(JSContext* cx, bool *aStrict_mode) { return !_to ? NS_ERROR_NULL_POINTER : _to->GetStrict_mode(cx, aStrict_mode); } \
  NS_IMETHOD SetStrict_mode(JSContext* cx, bool aStrict_mode) { return !_to ? NS_ERROR_NULL_POINTER : _to->SetStrict_mode(cx, aStrict_mode); } \
  NS_IMETHOD GetIon(JSContext* cx, bool *aIon) { return !_to ? NS_ERROR_NULL_POINTER : _to->GetIon(cx, aIon); } \
  NS_IMETHOD SetIon(JSContext* cx, bool aIon) { return !_to ? NS_ERROR_NULL_POINTER : _to->SetIon(cx, aIon); } \
  NS_IMETHOD SetGCZeal(int32_t zeal, JSContext* cx) { return !_to ? NS_ERROR_NULL_POINTER : _to->SetGCZeal(zeal, cx); } \
  NS_IMETHOD NukeSandbox(const JS::Value & obj, JSContext* cx) { return !_to ? NS_ERROR_NULL_POINTER : _to->NukeSandbox(obj, cx); } \
  NS_IMETHOD IsXrayWrapper(const JS::Value & obj, bool *_retval) { return !_to ? NS_ERROR_NULL_POINTER : _to->IsXrayWrapper(obj, _retval); } 

#if 0
/* Use the code below as a template for the implementation class for this interface. */

/* Header file */
class nsXPCComponents_Utils : public nsIXPCComponents_Utils
{
public:
  NS_DECL_ISUPPORTS
  NS_DECL_NSIXPCCOMPONENTS_UTILS

  nsXPCComponents_Utils();

private:
  ~nsXPCComponents_Utils();

protected:
  /* additional members */
};

/* Implementation file */
NS_IMPL_ISUPPORTS1(nsXPCComponents_Utils, nsIXPCComponents_Utils)

nsXPCComponents_Utils::nsXPCComponents_Utils()
{
  /* member initializers and constructor code */
}

nsXPCComponents_Utils::~nsXPCComponents_Utils()
{
  /* destructor code */
}

/* [implicit_jscontext] void reportError (in jsval error); */
NS_IMETHODIMP nsXPCComponents_Utils::ReportError(const JS::Value & error, JSContext* cx)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* [implicit_jscontext] jsval lookupMethod (in jsval obj, in jsval name); */
NS_IMETHODIMP nsXPCComponents_Utils::LookupMethod(const JS::Value & obj, const JS::Value & name, JSContext* cx, JS::Value *_retval)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* readonly attribute nsIXPCComponents_utils_Sandbox Sandbox; */
NS_IMETHODIMP nsXPCComponents_Utils::GetSandbox(nsIXPCComponents_utils_Sandbox * *aSandbox)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* [implicit_jscontext,optional_argc] jsval evalInSandbox (in AString source, in jsval sandbox, [optional] in jsval version, [optional] in jsval filename, [optional] in long lineNo); */
NS_IMETHODIMP nsXPCComponents_Utils::EvalInSandbox(const nsAString & source, const JS::Value & sandbox, const JS::Value & version, const JS::Value & filename, int32_t lineNo, JSContext* cx, uint8_t _argc, JS::Value *_retval)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* [implicit_jscontext,optional_argc] jsval import (in AUTF8String aResourceURI, [optional] in jsval targetObj); */
NS_IMETHODIMP nsXPCComponents_Utils::Import(const nsACString & aResourceURI, const JS::Value & targetObj, JSContext* cx, uint8_t _argc, JS::Value *_retval)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* void unload (in AUTF8String registryLocation); */
NS_IMETHODIMP nsXPCComponents_Utils::Unload(const nsACString & registryLocation)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* [implicit_jscontext] xpcIJSWeakReference getWeakReference (in jsval obj); */
NS_IMETHODIMP nsXPCComponents_Utils::GetWeakReference(const JS::Value & obj, JSContext* cx, xpcIJSWeakReference * *_retval)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* void forceGC (); */
NS_IMETHODIMP nsXPCComponents_Utils::ForceGC()
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* void forceCC (); */
NS_IMETHODIMP nsXPCComponents_Utils::ForceCC()
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* void forceShrinkingGC (); */
NS_IMETHODIMP nsXPCComponents_Utils::ForceShrinkingGC()
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* void schedulePreciseGC (in ScheduledGCCallback callback); */
NS_IMETHODIMP nsXPCComponents_Utils::SchedulePreciseGC(ScheduledGCCallback *callback)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* void schedulePreciseShrinkingGC (in ScheduledGCCallback callback); */
NS_IMETHODIMP nsXPCComponents_Utils::SchedulePreciseShrinkingGC(ScheduledGCCallback *callback)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* [implicit_jscontext] jsval nondeterministicGetWeakMapKeys (in jsval aMap); */
NS_IMETHODIMP nsXPCComponents_Utils::NondeterministicGetWeakMapKeys(const JS::Value & aMap, JSContext* cx, JS::Value *_retval)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* [implicit_jscontext] jsval getJSTestingFunctions (); */
NS_IMETHODIMP nsXPCComponents_Utils::GetJSTestingFunctions(JSContext* cx, JS::Value *_retval)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* [implicit_jscontext] jsval getGlobalForObject (in jsval obj); */
NS_IMETHODIMP nsXPCComponents_Utils::GetGlobalForObject(const JS::Value & obj, JSContext* cx, JS::Value *_retval)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* [implicit_jscontext] jsval createObjectIn (in jsval vobj); */
NS_IMETHODIMP nsXPCComponents_Utils::CreateObjectIn(const JS::Value & vobj, JSContext* cx, JS::Value *_retval)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* [implicit_jscontext] jsval createArrayIn (in jsval vobj); */
NS_IMETHODIMP nsXPCComponents_Utils::CreateArrayIn(const JS::Value & vobj, JSContext* cx, JS::Value *_retval)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* [implicit_jscontext] jsval createDateIn (in jsval vobj, in long long msec); */
NS_IMETHODIMP nsXPCComponents_Utils::CreateDateIn(const JS::Value & vobj, int64_t msec, JSContext* cx, JS::Value *_retval)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* [implicit_jscontext] void makeObjectPropsNormal (in jsval vobj); */
NS_IMETHODIMP nsXPCComponents_Utils::MakeObjectPropsNormal(const JS::Value & vobj, JSContext* cx)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* bool isDeadWrapper (in jsval obj); */
NS_IMETHODIMP nsXPCComponents_Utils::IsDeadWrapper(const JS::Value & obj, bool *_retval)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* [implicit_jscontext] void recomputeWrappers ([optional] in jsval vobj); */
NS_IMETHODIMP nsXPCComponents_Utils::RecomputeWrappers(const JS::Value & vobj, JSContext* cx)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* [implicit_jscontext] void setWantXrays (in jsval vscope); */
NS_IMETHODIMP nsXPCComponents_Utils::SetWantXrays(const JS::Value & vscope, JSContext* cx)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* [implicit_jscontext] jsval getComponentsForScope (in jsval vscope); */
NS_IMETHODIMP nsXPCComponents_Utils::GetComponentsForScope(const JS::Value & vscope, JSContext* cx, JS::Value *_retval)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* [implicit_jscontext] void dispatch (in jsval runnable, [optional] in jsval scope); */
NS_IMETHODIMP nsXPCComponents_Utils::Dispatch(const JS::Value & runnable, const JS::Value & scope, JSContext* cx)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* [implicit_jscontext] attribute boolean strict; */
NS_IMETHODIMP nsXPCComponents_Utils::GetStrict(JSContext* cx, bool *aStrict)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}
NS_IMETHODIMP nsXPCComponents_Utils::SetStrict(JSContext* cx, bool aStrict)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* [implicit_jscontext] attribute boolean werror; */
NS_IMETHODIMP nsXPCComponents_Utils::GetWerror(JSContext* cx, bool *aWerror)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}
NS_IMETHODIMP nsXPCComponents_Utils::SetWerror(JSContext* cx, bool aWerror)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* [implicit_jscontext] attribute boolean atline; */
NS_IMETHODIMP nsXPCComponents_Utils::GetAtline(JSContext* cx, bool *aAtline)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}
NS_IMETHODIMP nsXPCComponents_Utils::SetAtline(JSContext* cx, bool aAtline)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* [implicit_jscontext] attribute boolean xml; */
NS_IMETHODIMP nsXPCComponents_Utils::GetXml(JSContext* cx, bool *aXml)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}
NS_IMETHODIMP nsXPCComponents_Utils::SetXml(JSContext* cx, bool aXml)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* [implicit_jscontext] attribute boolean methodjit; */
NS_IMETHODIMP nsXPCComponents_Utils::GetMethodjit(JSContext* cx, bool *aMethodjit)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}
NS_IMETHODIMP nsXPCComponents_Utils::SetMethodjit(JSContext* cx, bool aMethodjit)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* [implicit_jscontext] attribute boolean methodjit_always; */
NS_IMETHODIMP nsXPCComponents_Utils::GetMethodjit_always(JSContext* cx, bool *aMethodjit_always)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}
NS_IMETHODIMP nsXPCComponents_Utils::SetMethodjit_always(JSContext* cx, bool aMethodjit_always)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* [implicit_jscontext] attribute boolean strict_mode; */
NS_IMETHODIMP nsXPCComponents_Utils::GetStrict_mode(JSContext* cx, bool *aStrict_mode)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}
NS_IMETHODIMP nsXPCComponents_Utils::SetStrict_mode(JSContext* cx, bool aStrict_mode)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* [implicit_jscontext] attribute boolean ion; */
NS_IMETHODIMP nsXPCComponents_Utils::GetIon(JSContext* cx, bool *aIon)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}
NS_IMETHODIMP nsXPCComponents_Utils::SetIon(JSContext* cx, bool aIon)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* [implicit_jscontext] void setGCZeal (in long zeal); */
NS_IMETHODIMP nsXPCComponents_Utils::SetGCZeal(int32_t zeal, JSContext* cx)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* [implicit_jscontext] void nukeSandbox (in jsval obj); */
NS_IMETHODIMP nsXPCComponents_Utils::NukeSandbox(const JS::Value & obj, JSContext* cx)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* bool isXrayWrapper (in jsval obj); */
NS_IMETHODIMP nsXPCComponents_Utils::IsXrayWrapper(const JS::Value & obj, bool *_retval)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* End of implementation class template. */
#endif


/* starting interface:    nsIXPCComponents */
#define NS_IXPCCOMPONENTS_IID_STR "8406dedb-23cc-42db-9f69-1f18785091b5"

#define NS_IXPCCOMPONENTS_IID \
  {0x8406dedb, 0x23cc, 0x42db, \
    { 0x9f, 0x69, 0x1f, 0x18, 0x78, 0x50, 0x91, 0xb5 }}

class NS_NO_VTABLE nsIXPCComponents : public nsISupports {
 public: 

  NS_DECLARE_STATIC_IID_ACCESSOR(NS_IXPCCOMPONENTS_IID)

  /* readonly attribute nsIXPCComponents_Interfaces interfaces; */
  NS_IMETHOD GetInterfaces(nsIXPCComponents_Interfaces * *aInterfaces) = 0;

  /* readonly attribute nsIXPCComponents_InterfacesByID interfacesByID; */
  NS_IMETHOD GetInterfacesByID(nsIXPCComponents_InterfacesByID * *aInterfacesByID) = 0;

  /* readonly attribute nsIXPCComponents_Classes classes; */
  NS_IMETHOD GetClasses(nsIXPCComponents_Classes * *aClasses) = 0;

  /* readonly attribute nsIXPCComponents_ClassesByID classesByID; */
  NS_IMETHOD GetClassesByID(nsIXPCComponents_ClassesByID * *aClassesByID) = 0;

  /* readonly attribute nsIStackFrame stack; */
  NS_IMETHOD GetStack(nsIStackFrame * *aStack) = 0;

  /* readonly attribute nsIXPCComponents_Results results; */
  NS_IMETHOD GetResults(nsIXPCComponents_Results * *aResults) = 0;

  /* readonly attribute nsIComponentManager manager; */
  NS_IMETHOD GetManager(nsIComponentManager * *aManager) = 0;

  /* readonly attribute nsIXPCComponents_Utils utils; */
  NS_IMETHOD GetUtils(nsIXPCComponents_Utils * *aUtils) = 0;

  /* readonly attribute nsIXPCComponents_ID ID; */
  NS_IMETHOD GetID(nsIXPCComponents_ID * *aID) = 0;

  /* readonly attribute nsIXPCComponents_Exception Exception; */
  NS_IMETHOD GetException(nsIXPCComponents_Exception * *aException) = 0;

  /* readonly attribute nsIXPCComponents_Constructor Constructor; */
  NS_IMETHOD GetConstructor(nsIXPCComponents_Constructor * *aConstructor) = 0;

  /* boolean isSuccessCode (in nsresult result); */
  NS_IMETHOD IsSuccessCode(nsresult result, bool *_retval) = 0;

  /* [deprecated,implicit_jscontext] jsval lookupMethod (in jsval obj, in jsval name); */
  NS_IMETHOD LookupMethod(const JS::Value & obj, const JS::Value & name, JSContext* cx, JS::Value *_retval) = 0;

  /* [deprecated,implicit_jscontext] void reportError (in jsval error); */
  NS_IMETHOD ReportError(const JS::Value & error, JSContext* cx) = 0;

};

  NS_DEFINE_STATIC_IID_ACCESSOR(nsIXPCComponents, NS_IXPCCOMPONENTS_IID)

/* Use this macro when declaring classes that implement this interface. */
#define NS_DECL_NSIXPCCOMPONENTS \
  NS_IMETHOD GetInterfaces(nsIXPCComponents_Interfaces * *aInterfaces); \
  NS_IMETHOD GetInterfacesByID(nsIXPCComponents_InterfacesByID * *aInterfacesByID); \
  NS_IMETHOD GetClasses(nsIXPCComponents_Classes * *aClasses); \
  NS_IMETHOD GetClassesByID(nsIXPCComponents_ClassesByID * *aClassesByID); \
  NS_IMETHOD GetStack(nsIStackFrame * *aStack); \
  NS_IMETHOD GetResults(nsIXPCComponents_Results * *aResults); \
  NS_IMETHOD GetManager(nsIComponentManager * *aManager); \
  NS_IMETHOD GetUtils(nsIXPCComponents_Utils * *aUtils); \
  NS_IMETHOD GetID(nsIXPCComponents_ID * *aID); \
  NS_IMETHOD GetException(nsIXPCComponents_Exception * *aException); \
  NS_IMETHOD GetConstructor(nsIXPCComponents_Constructor * *aConstructor); \
  NS_IMETHOD IsSuccessCode(nsresult result, bool *_retval); \
  NS_IMETHOD LookupMethod(const JS::Value & obj, const JS::Value & name, JSContext* cx, JS::Value *_retval); \
  NS_IMETHOD ReportError(const JS::Value & error, JSContext* cx); 

/* Use this macro to declare functions that forward the behavior of this interface to another object. */
#define NS_FORWARD_NSIXPCCOMPONENTS(_to) \
  NS_IMETHOD GetInterfaces(nsIXPCComponents_Interfaces * *aInterfaces) { return _to GetInterfaces(aInterfaces); } \
  NS_IMETHOD GetInterfacesByID(nsIXPCComponents_InterfacesByID * *aInterfacesByID) { return _to GetInterfacesByID(aInterfacesByID); } \
  NS_IMETHOD GetClasses(nsIXPCComponents_Classes * *aClasses) { return _to GetClasses(aClasses); } \
  NS_IMETHOD GetClassesByID(nsIXPCComponents_ClassesByID * *aClassesByID) { return _to GetClassesByID(aClassesByID); } \
  NS_IMETHOD GetStack(nsIStackFrame * *aStack) { return _to GetStack(aStack); } \
  NS_IMETHOD GetResults(nsIXPCComponents_Results * *aResults) { return _to GetResults(aResults); } \
  NS_IMETHOD GetManager(nsIComponentManager * *aManager) { return _to GetManager(aManager); } \
  NS_IMETHOD GetUtils(nsIXPCComponents_Utils * *aUtils) { return _to GetUtils(aUtils); } \
  NS_IMETHOD GetID(nsIXPCComponents_ID * *aID) { return _to GetID(aID); } \
  NS_IMETHOD GetException(nsIXPCComponents_Exception * *aException) { return _to GetException(aException); } \
  NS_IMETHOD GetConstructor(nsIXPCComponents_Constructor * *aConstructor) { return _to GetConstructor(aConstructor); } \
  NS_IMETHOD IsSuccessCode(nsresult result, bool *_retval) { return _to IsSuccessCode(result, _retval); } \
  NS_IMETHOD LookupMethod(const JS::Value & obj, const JS::Value & name, JSContext* cx, JS::Value *_retval) { return _to LookupMethod(obj, name, cx, _retval); } \
  NS_IMETHOD ReportError(const JS::Value & error, JSContext* cx) { return _to ReportError(error, cx); } 

/* Use this macro to declare functions that forward the behavior of this interface to another object in a safe way. */
#define NS_FORWARD_SAFE_NSIXPCCOMPONENTS(_to) \
  NS_IMETHOD GetInterfaces(nsIXPCComponents_Interfaces * *aInterfaces) { return !_to ? NS_ERROR_NULL_POINTER : _to->GetInterfaces(aInterfaces); } \
  NS_IMETHOD GetInterfacesByID(nsIXPCComponents_InterfacesByID * *aInterfacesByID) { return !_to ? NS_ERROR_NULL_POINTER : _to->GetInterfacesByID(aInterfacesByID); } \
  NS_IMETHOD GetClasses(nsIXPCComponents_Classes * *aClasses) { return !_to ? NS_ERROR_NULL_POINTER : _to->GetClasses(aClasses); } \
  NS_IMETHOD GetClassesByID(nsIXPCComponents_ClassesByID * *aClassesByID) { return !_to ? NS_ERROR_NULL_POINTER : _to->GetClassesByID(aClassesByID); } \
  NS_IMETHOD GetStack(nsIStackFrame * *aStack) { return !_to ? NS_ERROR_NULL_POINTER : _to->GetStack(aStack); } \
  NS_IMETHOD GetResults(nsIXPCComponents_Results * *aResults) { return !_to ? NS_ERROR_NULL_POINTER : _to->GetResults(aResults); } \
  NS_IMETHOD GetManager(nsIComponentManager * *aManager) { return !_to ? NS_ERROR_NULL_POINTER : _to->GetManager(aManager); } \
  NS_IMETHOD GetUtils(nsIXPCComponents_Utils * *aUtils) { return !_to ? NS_ERROR_NULL_POINTER : _to->GetUtils(aUtils); } \
  NS_IMETHOD GetID(nsIXPCComponents_ID * *aID) { return !_to ? NS_ERROR_NULL_POINTER : _to->GetID(aID); } \
  NS_IMETHOD GetException(nsIXPCComponents_Exception * *aException) { return !_to ? NS_ERROR_NULL_POINTER : _to->GetException(aException); } \
  NS_IMETHOD GetConstructor(nsIXPCComponents_Constructor * *aConstructor) { return !_to ? NS_ERROR_NULL_POINTER : _to->GetConstructor(aConstructor); } \
  NS_IMETHOD IsSuccessCode(nsresult result, bool *_retval) { return !_to ? NS_ERROR_NULL_POINTER : _to->IsSuccessCode(result, _retval); } \
  NS_IMETHOD LookupMethod(const JS::Value & obj, const JS::Value & name, JSContext* cx, JS::Value *_retval) { return !_to ? NS_ERROR_NULL_POINTER : _to->LookupMethod(obj, name, cx, _retval); } \
  NS_IMETHOD ReportError(const JS::Value & error, JSContext* cx) { return !_to ? NS_ERROR_NULL_POINTER : _to->ReportError(error, cx); } 

#if 0
/* Use the code below as a template for the implementation class for this interface. */

/* Header file */
class nsXPCComponents : public nsIXPCComponents
{
public:
  NS_DECL_ISUPPORTS
  NS_DECL_NSIXPCCOMPONENTS

  nsXPCComponents();

private:
  ~nsXPCComponents();

protected:
  /* additional members */
};

/* Implementation file */
NS_IMPL_ISUPPORTS1(nsXPCComponents, nsIXPCComponents)

nsXPCComponents::nsXPCComponents()
{
  /* member initializers and constructor code */
}

nsXPCComponents::~nsXPCComponents()
{
  /* destructor code */
}

/* readonly attribute nsIXPCComponents_Interfaces interfaces; */
NS_IMETHODIMP nsXPCComponents::GetInterfaces(nsIXPCComponents_Interfaces * *aInterfaces)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* readonly attribute nsIXPCComponents_InterfacesByID interfacesByID; */
NS_IMETHODIMP nsXPCComponents::GetInterfacesByID(nsIXPCComponents_InterfacesByID * *aInterfacesByID)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* readonly attribute nsIXPCComponents_Classes classes; */
NS_IMETHODIMP nsXPCComponents::GetClasses(nsIXPCComponents_Classes * *aClasses)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* readonly attribute nsIXPCComponents_ClassesByID classesByID; */
NS_IMETHODIMP nsXPCComponents::GetClassesByID(nsIXPCComponents_ClassesByID * *aClassesByID)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* readonly attribute nsIStackFrame stack; */
NS_IMETHODIMP nsXPCComponents::GetStack(nsIStackFrame * *aStack)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* readonly attribute nsIXPCComponents_Results results; */
NS_IMETHODIMP nsXPCComponents::GetResults(nsIXPCComponents_Results * *aResults)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* readonly attribute nsIComponentManager manager; */
NS_IMETHODIMP nsXPCComponents::GetManager(nsIComponentManager * *aManager)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* readonly attribute nsIXPCComponents_Utils utils; */
NS_IMETHODIMP nsXPCComponents::GetUtils(nsIXPCComponents_Utils * *aUtils)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* readonly attribute nsIXPCComponents_ID ID; */
NS_IMETHODIMP nsXPCComponents::GetID(nsIXPCComponents_ID * *aID)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* readonly attribute nsIXPCComponents_Exception Exception; */
NS_IMETHODIMP nsXPCComponents::GetException(nsIXPCComponents_Exception * *aException)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* readonly attribute nsIXPCComponents_Constructor Constructor; */
NS_IMETHODIMP nsXPCComponents::GetConstructor(nsIXPCComponents_Constructor * *aConstructor)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* boolean isSuccessCode (in nsresult result); */
NS_IMETHODIMP nsXPCComponents::IsSuccessCode(nsresult result, bool *_retval)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* [deprecated,implicit_jscontext] jsval lookupMethod (in jsval obj, in jsval name); */
NS_IMETHODIMP nsXPCComponents::LookupMethod(const JS::Value & obj, const JS::Value & name, JSContext* cx, JS::Value *_retval)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* [deprecated,implicit_jscontext] void reportError (in jsval error); */
NS_IMETHODIMP nsXPCComponents::ReportError(const JS::Value & error, JSContext* cx)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* End of implementation class template. */
#endif


#endif /* __gen_xpccomponents_h__ */
