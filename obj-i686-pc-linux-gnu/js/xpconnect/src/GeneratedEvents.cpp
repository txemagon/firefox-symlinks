/* THIS FILE IS AUTOGENERATED - DO NOT EDIT */

#include "GeneratedEvents.h"
#include "nsDOMClassInfoID.h"
#include "nsPresContext.h"
#include "nsGUIEvent.h"
#include "nsDOMEvent.h"
#include "DictionaryHelpers.h"
#include "nsContentUtils.h"
#include "nsIDOMApplicationRegistry.h"
#include "nsIDOMProgressEvent.h"
#include "nsIDOMStorageEvent.h"
#include "nsIDOMDeviceProximityEvent.h"
#include "nsIDOMMozSettingsEvent.h"
#include "nsIDOMUserProximityEvent.h"
#include "nsIDOMCustomEvent.h"
#include "nsIDOMPageTransitionEvent.h"
#include "nsIDOMDOMTransactionEvent.h"
#include "nsIDOMPopStateEvent.h"
#include "nsIDOMHashChangeEvent.h"
#include "nsIDOMCloseEvent.h"
#include "nsIDOMMozContactChangeEvent.h"
#include "nsIDOMDeviceOrientationEvent.h"
#include "nsIDOMDeviceLightEvent.h"
#include "nsIDOMMozApplicationEvent.h"
#include "nsIDOMDeviceStorageChangeEvent.h"
#include "nsIDOMPopupBlockedEvent.h"
#include "nsIDOMEventTarget.h"
#include "nsIDOMStorage.h"
#include "nsIVariant.h"
#include "nsIDOMWindow.h"
#include "nsIURI.h"

class nsDOMProgressEvent : public nsDOMEvent, public nsIDOMProgressEvent
{
public:
  nsDOMProgressEvent(nsPresContext* aPresContext, nsEvent* aEvent)
  : nsDOMEvent(aPresContext, aEvent),
    mLengthComputable(false),
    mLoaded(0),
    mTotal(0)
  {}
  virtual ~nsDOMProgressEvent() {}

  NS_DECL_ISUPPORTS_INHERITED
  NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED(nsDOMProgressEvent, nsDOMEvent)
  NS_FORWARD_TO_NSDOMEVENT
  NS_DECL_NSIDOMPROGRESSEVENT
  virtual nsresult InitFromCtor(const nsAString& aType, JSContext* aCx, jsval* aVal);
protected:
  bool mLengthComputable;
  uint64_t mLoaded;
  uint64_t mTotal;
};

NS_IMPL_CYCLE_COLLECTION_CLASS(nsDOMProgressEvent)

NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(nsDOMProgressEvent, nsDOMEvent)
NS_IMPL_CYCLE_COLLECTION_UNLINK_END

NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(nsDOMProgressEvent, nsDOMEvent)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END

NS_IMPL_ADDREF_INHERITED(nsDOMProgressEvent, nsDOMEvent)
NS_IMPL_RELEASE_INHERITED(nsDOMProgressEvent, nsDOMEvent)

DOMCI_DATA(ProgressEvent, nsDOMProgressEvent)

NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED(nsDOMProgressEvent)
  NS_INTERFACE_MAP_ENTRY(nsIDOMProgressEvent)
  NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(ProgressEvent)
NS_INTERFACE_MAP_END_INHERITING(nsDOMEvent)

nsresult
nsDOMProgressEvent::InitFromCtor(const nsAString& aType, JSContext* aCx, jsval* aVal)
{
  mozilla::dom::ProgressEventInit d;
  nsresult rv = d.Init(aCx, aVal);
  NS_ENSURE_SUCCESS(rv, rv);
  return InitProgressEvent(aType, d.bubbles, d.cancelable, d.lengthComputable, d.loaded, d.total);
}

NS_IMETHODIMP
nsDOMProgressEvent::InitProgressEvent(const nsAString& aType, bool aCanBubble, bool aCancelable, bool  aLengthComputable, uint64_t  aLoaded, uint64_t  aTotal)
{
  nsresult rv = nsDOMEvent::InitEvent(aType, aCanBubble, aCancelable);
  NS_ENSURE_SUCCESS(rv, rv);
  mLengthComputable = aLengthComputable;
  mLoaded = aLoaded;
  mTotal = aTotal;
  return NS_OK;
}

NS_IMETHODIMP
nsDOMProgressEvent::GetLengthComputable(bool *aLengthComputable)
{
  *aLengthComputable = mLengthComputable;
  return NS_OK;
}

NS_IMETHODIMP
nsDOMProgressEvent::GetLoaded(uint64_t *aLoaded)
{
  *aLoaded = mLoaded;
  return NS_OK;
}

NS_IMETHODIMP
nsDOMProgressEvent::GetTotal(uint64_t *aTotal)
{
  *aTotal = mTotal;
  return NS_OK;
}

nsresult
NS_NewDOMProgressEvent(nsIDOMEvent** aInstance, nsPresContext* aPresContext, nsEvent* aEvent)
{
  nsDOMProgressEvent* it = new nsDOMProgressEvent(aPresContext, aEvent);
  return CallQueryInterface(it, aInstance);
}


class nsDOMStorageEvent : public nsDOMEvent, public nsIDOMStorageEvent
{
public:
  nsDOMStorageEvent(nsPresContext* aPresContext, nsEvent* aEvent)
  : nsDOMEvent(aPresContext, aEvent),
    mKey(),
    mOldValue(),
    mNewValue(),
    mUrl(),
    mStorageArea(nullptr)
  {}
  virtual ~nsDOMStorageEvent() {}

  NS_DECL_ISUPPORTS_INHERITED
  NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED(nsDOMStorageEvent, nsDOMEvent)
  NS_FORWARD_TO_NSDOMEVENT
  NS_DECL_NSIDOMSTORAGEEVENT
  virtual nsresult InitFromCtor(const nsAString& aType, JSContext* aCx, jsval* aVal);
protected:
  nsString mKey;
  nsString mOldValue;
  nsString mNewValue;
  nsString mUrl;
  nsCOMPtr<nsIDOMStorage> mStorageArea;
};

NS_IMPL_CYCLE_COLLECTION_CLASS(nsDOMStorageEvent)

NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(nsDOMStorageEvent, nsDOMEvent)
  NS_IMPL_CYCLE_COLLECTION_UNLINK(mStorageArea)
NS_IMPL_CYCLE_COLLECTION_UNLINK_END

NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(nsDOMStorageEvent, nsDOMEvent)
  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mStorageArea)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END

NS_IMPL_ADDREF_INHERITED(nsDOMStorageEvent, nsDOMEvent)
NS_IMPL_RELEASE_INHERITED(nsDOMStorageEvent, nsDOMEvent)

DOMCI_DATA(StorageEvent, nsDOMStorageEvent)

NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED(nsDOMStorageEvent)
  NS_INTERFACE_MAP_ENTRY(nsIDOMStorageEvent)
  NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(StorageEvent)
NS_INTERFACE_MAP_END_INHERITING(nsDOMEvent)

nsresult
nsDOMStorageEvent::InitFromCtor(const nsAString& aType, JSContext* aCx, jsval* aVal)
{
  mozilla::dom::StorageEventInit d;
  nsresult rv = d.Init(aCx, aVal);
  NS_ENSURE_SUCCESS(rv, rv);
  return InitStorageEvent(aType, d.bubbles, d.cancelable, d.key, d.oldValue, d.newValue, d.url, d.storageArea);
}

NS_IMETHODIMP
nsDOMStorageEvent::InitStorageEvent(const nsAString& aType, bool aCanBubble, bool aCancelable, const nsAString& aKey, const nsAString& aOldValue, const nsAString& aNewValue, const nsAString& aUrl, nsIDOMStorage* aStorageArea)
{
  nsresult rv = nsDOMEvent::InitEvent(aType, aCanBubble, aCancelable);
  NS_ENSURE_SUCCESS(rv, rv);
  mKey = aKey;
  mOldValue = aOldValue;
  mNewValue = aNewValue;
  mUrl = aUrl;
  mStorageArea = aStorageArea;
  return NS_OK;
}

NS_IMETHODIMP
nsDOMStorageEvent::GetKey(nsAString& aKey)
{
  aKey = mKey;
  return NS_OK;
}

NS_IMETHODIMP
nsDOMStorageEvent::GetOldValue(nsAString& aOldValue)
{
  aOldValue = mOldValue;
  return NS_OK;
}

NS_IMETHODIMP
nsDOMStorageEvent::GetNewValue(nsAString& aNewValue)
{
  aNewValue = mNewValue;
  return NS_OK;
}

NS_IMETHODIMP
nsDOMStorageEvent::GetUrl(nsAString& aUrl)
{
  aUrl = mUrl;
  return NS_OK;
}

NS_IMETHODIMP
nsDOMStorageEvent::GetStorageArea(nsIDOMStorage** aStorageArea)
{
  NS_IF_ADDREF(*aStorageArea = mStorageArea);
  return NS_OK;
}

nsresult
NS_NewDOMStorageEvent(nsIDOMEvent** aInstance, nsPresContext* aPresContext, nsEvent* aEvent)
{
  nsDOMStorageEvent* it = new nsDOMStorageEvent(aPresContext, aEvent);
  return CallQueryInterface(it, aInstance);
}


class nsDOMDeviceProximityEvent : public nsDOMEvent, public nsIDOMDeviceProximityEvent
{
public:
  nsDOMDeviceProximityEvent(nsPresContext* aPresContext, nsEvent* aEvent)
  : nsDOMEvent(aPresContext, aEvent),
    mValue(0),
    mMin(0),
    mMax(0)
  {}
  virtual ~nsDOMDeviceProximityEvent() {}

  NS_DECL_ISUPPORTS_INHERITED
  NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED(nsDOMDeviceProximityEvent, nsDOMEvent)
  NS_FORWARD_TO_NSDOMEVENT
  NS_DECL_NSIDOMDEVICEPROXIMITYEVENT
  virtual nsresult InitFromCtor(const nsAString& aType, JSContext* aCx, jsval* aVal);
protected:
  double mValue;
  double mMin;
  double mMax;
};

NS_IMPL_CYCLE_COLLECTION_CLASS(nsDOMDeviceProximityEvent)

NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(nsDOMDeviceProximityEvent, nsDOMEvent)
NS_IMPL_CYCLE_COLLECTION_UNLINK_END

NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(nsDOMDeviceProximityEvent, nsDOMEvent)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END

NS_IMPL_ADDREF_INHERITED(nsDOMDeviceProximityEvent, nsDOMEvent)
NS_IMPL_RELEASE_INHERITED(nsDOMDeviceProximityEvent, nsDOMEvent)

DOMCI_DATA(DeviceProximityEvent, nsDOMDeviceProximityEvent)

NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED(nsDOMDeviceProximityEvent)
  NS_INTERFACE_MAP_ENTRY(nsIDOMDeviceProximityEvent)
  NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(DeviceProximityEvent)
NS_INTERFACE_MAP_END_INHERITING(nsDOMEvent)

nsresult
nsDOMDeviceProximityEvent::InitFromCtor(const nsAString& aType, JSContext* aCx, jsval* aVal)
{
  mozilla::dom::DeviceProximityEventInit d;
  nsresult rv = d.Init(aCx, aVal);
  NS_ENSURE_SUCCESS(rv, rv);
  return InitDeviceProximityEvent(aType, d.bubbles, d.cancelable, d.value, d.min, d.max);
}

NS_IMETHODIMP
nsDOMDeviceProximityEvent::InitDeviceProximityEvent(const nsAString& aType, bool aCanBubble, bool aCancelable, double  aValue, double  aMin, double  aMax)
{
  nsresult rv = nsDOMEvent::InitEvent(aType, aCanBubble, aCancelable);
  NS_ENSURE_SUCCESS(rv, rv);
  mValue = aValue;
  mMin = aMin;
  mMax = aMax;
  return NS_OK;
}

NS_IMETHODIMP
nsDOMDeviceProximityEvent::GetValue(double *aValue)
{
  *aValue = mValue;
  return NS_OK;
}

NS_IMETHODIMP
nsDOMDeviceProximityEvent::GetMin(double *aMin)
{
  *aMin = mMin;
  return NS_OK;
}

NS_IMETHODIMP
nsDOMDeviceProximityEvent::GetMax(double *aMax)
{
  *aMax = mMax;
  return NS_OK;
}

nsresult
NS_NewDOMDeviceProximityEvent(nsIDOMEvent** aInstance, nsPresContext* aPresContext, nsEvent* aEvent)
{
  nsDOMDeviceProximityEvent* it = new nsDOMDeviceProximityEvent(aPresContext, aEvent);
  return CallQueryInterface(it, aInstance);
}


class nsDOMMozSettingsEvent : public nsDOMEvent, public nsIDOMMozSettingsEvent
{
public:
  nsDOMMozSettingsEvent(nsPresContext* aPresContext, nsEvent* aEvent)
  : nsDOMEvent(aPresContext, aEvent),
    mSettingName(),
    mSettingValue(nullptr)
  {}
  virtual ~nsDOMMozSettingsEvent() {}

  NS_DECL_ISUPPORTS_INHERITED
  NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED(nsDOMMozSettingsEvent, nsDOMEvent)
  NS_FORWARD_TO_NSDOMEVENT
  NS_DECL_NSIDOMMOZSETTINGSEVENT
  virtual nsresult InitFromCtor(const nsAString& aType, JSContext* aCx, jsval* aVal);
protected:
  nsString mSettingName;
  nsCOMPtr<nsIVariant> mSettingValue;
};

NS_IMPL_CYCLE_COLLECTION_CLASS(nsDOMMozSettingsEvent)

NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(nsDOMMozSettingsEvent, nsDOMEvent)
  NS_IMPL_CYCLE_COLLECTION_UNLINK(mSettingValue)
NS_IMPL_CYCLE_COLLECTION_UNLINK_END

NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(nsDOMMozSettingsEvent, nsDOMEvent)
  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mSettingValue)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END

NS_IMPL_ADDREF_INHERITED(nsDOMMozSettingsEvent, nsDOMEvent)
NS_IMPL_RELEASE_INHERITED(nsDOMMozSettingsEvent, nsDOMEvent)

DOMCI_DATA(MozSettingsEvent, nsDOMMozSettingsEvent)

NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED(nsDOMMozSettingsEvent)
  NS_INTERFACE_MAP_ENTRY(nsIDOMMozSettingsEvent)
  NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(MozSettingsEvent)
NS_INTERFACE_MAP_END_INHERITING(nsDOMEvent)

nsresult
nsDOMMozSettingsEvent::InitFromCtor(const nsAString& aType, JSContext* aCx, jsval* aVal)
{
  mozilla::dom::MozSettingsEventInit d;
  nsresult rv = d.Init(aCx, aVal);
  NS_ENSURE_SUCCESS(rv, rv);
  return InitMozSettingsEvent(aType, d.bubbles, d.cancelable, d.settingName, d.settingValue);
}

NS_IMETHODIMP
nsDOMMozSettingsEvent::InitMozSettingsEvent(const nsAString& aType, bool aCanBubble, bool aCancelable, const nsAString& aSettingName, nsIVariant* aSettingValue)
{
  nsresult rv = nsDOMEvent::InitEvent(aType, aCanBubble, aCancelable);
  NS_ENSURE_SUCCESS(rv, rv);
  mSettingName = aSettingName;
  mSettingValue = aSettingValue;
  return NS_OK;
}

NS_IMETHODIMP
nsDOMMozSettingsEvent::GetSettingName(nsAString& aSettingName)
{
  aSettingName = mSettingName;
  return NS_OK;
}

NS_IMETHODIMP
nsDOMMozSettingsEvent::GetSettingValue(nsIVariant** aSettingValue)
{
  NS_IF_ADDREF(*aSettingValue = mSettingValue);
  return NS_OK;
}

nsresult
NS_NewDOMMozSettingsEvent(nsIDOMEvent** aInstance, nsPresContext* aPresContext, nsEvent* aEvent)
{
  nsDOMMozSettingsEvent* it = new nsDOMMozSettingsEvent(aPresContext, aEvent);
  return CallQueryInterface(it, aInstance);
}


class nsDOMUserProximityEvent : public nsDOMEvent, public nsIDOMUserProximityEvent
{
public:
  nsDOMUserProximityEvent(nsPresContext* aPresContext, nsEvent* aEvent)
  : nsDOMEvent(aPresContext, aEvent),
    mNear(false)
  {}
  virtual ~nsDOMUserProximityEvent() {}

  NS_DECL_ISUPPORTS_INHERITED
  NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED(nsDOMUserProximityEvent, nsDOMEvent)
  NS_FORWARD_TO_NSDOMEVENT
  NS_DECL_NSIDOMUSERPROXIMITYEVENT
  virtual nsresult InitFromCtor(const nsAString& aType, JSContext* aCx, jsval* aVal);
protected:
  bool mNear;
};

NS_IMPL_CYCLE_COLLECTION_CLASS(nsDOMUserProximityEvent)

NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(nsDOMUserProximityEvent, nsDOMEvent)
NS_IMPL_CYCLE_COLLECTION_UNLINK_END

NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(nsDOMUserProximityEvent, nsDOMEvent)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END

NS_IMPL_ADDREF_INHERITED(nsDOMUserProximityEvent, nsDOMEvent)
NS_IMPL_RELEASE_INHERITED(nsDOMUserProximityEvent, nsDOMEvent)

DOMCI_DATA(UserProximityEvent, nsDOMUserProximityEvent)

NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED(nsDOMUserProximityEvent)
  NS_INTERFACE_MAP_ENTRY(nsIDOMUserProximityEvent)
  NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(UserProximityEvent)
NS_INTERFACE_MAP_END_INHERITING(nsDOMEvent)

nsresult
nsDOMUserProximityEvent::InitFromCtor(const nsAString& aType, JSContext* aCx, jsval* aVal)
{
  mozilla::dom::UserProximityEventInit d;
  nsresult rv = d.Init(aCx, aVal);
  NS_ENSURE_SUCCESS(rv, rv);
  return InitUserProximityEvent(aType, d.bubbles, d.cancelable, d.near);
}

NS_IMETHODIMP
nsDOMUserProximityEvent::InitUserProximityEvent(const nsAString& aType, bool aCanBubble, bool aCancelable, bool  aNear)
{
  nsresult rv = nsDOMEvent::InitEvent(aType, aCanBubble, aCancelable);
  NS_ENSURE_SUCCESS(rv, rv);
  mNear = aNear;
  return NS_OK;
}

NS_IMETHODIMP
nsDOMUserProximityEvent::GetNear(bool *aNear)
{
  *aNear = mNear;
  return NS_OK;
}

nsresult
NS_NewDOMUserProximityEvent(nsIDOMEvent** aInstance, nsPresContext* aPresContext, nsEvent* aEvent)
{
  nsDOMUserProximityEvent* it = new nsDOMUserProximityEvent(aPresContext, aEvent);
  return CallQueryInterface(it, aInstance);
}


class nsDOMCustomEvent : public nsDOMEvent, public nsIDOMCustomEvent
{
public:
  nsDOMCustomEvent(nsPresContext* aPresContext, nsEvent* aEvent)
  : nsDOMEvent(aPresContext, aEvent),
    mDetail(nullptr)
  {}
  virtual ~nsDOMCustomEvent() {}

  NS_DECL_ISUPPORTS_INHERITED
  NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED(nsDOMCustomEvent, nsDOMEvent)
  NS_FORWARD_TO_NSDOMEVENT
  NS_DECL_NSIDOMCUSTOMEVENT
  virtual nsresult InitFromCtor(const nsAString& aType, JSContext* aCx, jsval* aVal);
protected:
  nsCOMPtr<nsIVariant> mDetail;
};

NS_IMPL_CYCLE_COLLECTION_CLASS(nsDOMCustomEvent)

NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(nsDOMCustomEvent, nsDOMEvent)
  NS_IMPL_CYCLE_COLLECTION_UNLINK(mDetail)
NS_IMPL_CYCLE_COLLECTION_UNLINK_END

NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(nsDOMCustomEvent, nsDOMEvent)
  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mDetail)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END

NS_IMPL_ADDREF_INHERITED(nsDOMCustomEvent, nsDOMEvent)
NS_IMPL_RELEASE_INHERITED(nsDOMCustomEvent, nsDOMEvent)

DOMCI_DATA(CustomEvent, nsDOMCustomEvent)

NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED(nsDOMCustomEvent)
  NS_INTERFACE_MAP_ENTRY(nsIDOMCustomEvent)
  NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(CustomEvent)
NS_INTERFACE_MAP_END_INHERITING(nsDOMEvent)

nsresult
nsDOMCustomEvent::InitFromCtor(const nsAString& aType, JSContext* aCx, jsval* aVal)
{
  mozilla::dom::CustomEventInit d;
  nsresult rv = d.Init(aCx, aVal);
  NS_ENSURE_SUCCESS(rv, rv);
  return InitCustomEvent(aType, d.bubbles, d.cancelable, d.detail);
}

NS_IMETHODIMP
nsDOMCustomEvent::InitCustomEvent(const nsAString& aType, bool aCanBubble, bool aCancelable, nsIVariant* aDetail)
{
  nsresult rv = nsDOMEvent::InitEvent(aType, aCanBubble, aCancelable);
  NS_ENSURE_SUCCESS(rv, rv);
  mDetail = aDetail;
  return NS_OK;
}

NS_IMETHODIMP
nsDOMCustomEvent::GetDetail(nsIVariant** aDetail)
{
  NS_IF_ADDREF(*aDetail = mDetail);
  return NS_OK;
}

nsresult
NS_NewDOMCustomEvent(nsIDOMEvent** aInstance, nsPresContext* aPresContext, nsEvent* aEvent)
{
  nsDOMCustomEvent* it = new nsDOMCustomEvent(aPresContext, aEvent);
  return CallQueryInterface(it, aInstance);
}


class nsDOMPageTransitionEvent : public nsDOMEvent, public nsIDOMPageTransitionEvent
{
public:
  nsDOMPageTransitionEvent(nsPresContext* aPresContext, nsEvent* aEvent)
  : nsDOMEvent(aPresContext, aEvent),
    mPersisted(false)
  {}
  virtual ~nsDOMPageTransitionEvent() {}

  NS_DECL_ISUPPORTS_INHERITED
  NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED(nsDOMPageTransitionEvent, nsDOMEvent)
  NS_FORWARD_TO_NSDOMEVENT
  NS_DECL_NSIDOMPAGETRANSITIONEVENT
  virtual nsresult InitFromCtor(const nsAString& aType, JSContext* aCx, jsval* aVal);
protected:
  bool mPersisted;
};

NS_IMPL_CYCLE_COLLECTION_CLASS(nsDOMPageTransitionEvent)

NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(nsDOMPageTransitionEvent, nsDOMEvent)
NS_IMPL_CYCLE_COLLECTION_UNLINK_END

NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(nsDOMPageTransitionEvent, nsDOMEvent)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END

NS_IMPL_ADDREF_INHERITED(nsDOMPageTransitionEvent, nsDOMEvent)
NS_IMPL_RELEASE_INHERITED(nsDOMPageTransitionEvent, nsDOMEvent)

DOMCI_DATA(PageTransitionEvent, nsDOMPageTransitionEvent)

NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED(nsDOMPageTransitionEvent)
  NS_INTERFACE_MAP_ENTRY(nsIDOMPageTransitionEvent)
  NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(PageTransitionEvent)
NS_INTERFACE_MAP_END_INHERITING(nsDOMEvent)

nsresult
nsDOMPageTransitionEvent::InitFromCtor(const nsAString& aType, JSContext* aCx, jsval* aVal)
{
  mozilla::dom::PageTransitionEventInit d;
  nsresult rv = d.Init(aCx, aVal);
  NS_ENSURE_SUCCESS(rv, rv);
  return InitPageTransitionEvent(aType, d.bubbles, d.cancelable, d.persisted);
}

NS_IMETHODIMP
nsDOMPageTransitionEvent::InitPageTransitionEvent(const nsAString& aType, bool aCanBubble, bool aCancelable, bool  aPersisted)
{
  nsresult rv = nsDOMEvent::InitEvent(aType, aCanBubble, aCancelable);
  NS_ENSURE_SUCCESS(rv, rv);
  mPersisted = aPersisted;
  return NS_OK;
}

NS_IMETHODIMP
nsDOMPageTransitionEvent::GetPersisted(bool *aPersisted)
{
  *aPersisted = mPersisted;
  return NS_OK;
}

nsresult
NS_NewDOMPageTransitionEvent(nsIDOMEvent** aInstance, nsPresContext* aPresContext, nsEvent* aEvent)
{
  nsDOMPageTransitionEvent* it = new nsDOMPageTransitionEvent(aPresContext, aEvent);
  return CallQueryInterface(it, aInstance);
}


class nsDOMDOMTransactionEvent : public nsDOMEvent, public nsIDOMDOMTransactionEvent
{
public:
  nsDOMDOMTransactionEvent(nsPresContext* aPresContext, nsEvent* aEvent)
  : nsDOMEvent(aPresContext, aEvent),
    mTransactions(nullptr)
  {}
  virtual ~nsDOMDOMTransactionEvent() {}

  NS_DECL_ISUPPORTS_INHERITED
  NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED(nsDOMDOMTransactionEvent, nsDOMEvent)
  NS_FORWARD_TO_NSDOMEVENT
  NS_DECL_NSIDOMDOMTRANSACTIONEVENT
  virtual nsresult InitFromCtor(const nsAString& aType, JSContext* aCx, jsval* aVal);
protected:
  nsCOMPtr<nsIVariant> mTransactions;
};

NS_IMPL_CYCLE_COLLECTION_CLASS(nsDOMDOMTransactionEvent)

NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(nsDOMDOMTransactionEvent, nsDOMEvent)
  NS_IMPL_CYCLE_COLLECTION_UNLINK(mTransactions)
NS_IMPL_CYCLE_COLLECTION_UNLINK_END

NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(nsDOMDOMTransactionEvent, nsDOMEvent)
  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mTransactions)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END

NS_IMPL_ADDREF_INHERITED(nsDOMDOMTransactionEvent, nsDOMEvent)
NS_IMPL_RELEASE_INHERITED(nsDOMDOMTransactionEvent, nsDOMEvent)

DOMCI_DATA(DOMTransactionEvent, nsDOMDOMTransactionEvent)

NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED(nsDOMDOMTransactionEvent)
  NS_INTERFACE_MAP_ENTRY(nsIDOMDOMTransactionEvent)
  NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(DOMTransactionEvent)
NS_INTERFACE_MAP_END_INHERITING(nsDOMEvent)

nsresult
nsDOMDOMTransactionEvent::InitFromCtor(const nsAString& aType, JSContext* aCx, jsval* aVal)
{
  mozilla::dom::DOMTransactionEventInit d;
  nsresult rv = d.Init(aCx, aVal);
  NS_ENSURE_SUCCESS(rv, rv);
  return InitDOMTransactionEvent(aType, d.bubbles, d.cancelable, d.transactions);
}

NS_IMETHODIMP
nsDOMDOMTransactionEvent::InitDOMTransactionEvent(const nsAString& aType, bool aCanBubble, bool aCancelable, nsIVariant* aTransactions)
{
  nsresult rv = nsDOMEvent::InitEvent(aType, aCanBubble, aCancelable);
  NS_ENSURE_SUCCESS(rv, rv);
  mTransactions = aTransactions;
  return NS_OK;
}

NS_IMETHODIMP
nsDOMDOMTransactionEvent::GetTransactions(nsIVariant** aTransactions)
{
  NS_IF_ADDREF(*aTransactions = mTransactions);
  return NS_OK;
}

nsresult
NS_NewDOMDOMTransactionEvent(nsIDOMEvent** aInstance, nsPresContext* aPresContext, nsEvent* aEvent)
{
  nsDOMDOMTransactionEvent* it = new nsDOMDOMTransactionEvent(aPresContext, aEvent);
  return CallQueryInterface(it, aInstance);
}


class nsDOMPopStateEvent : public nsDOMEvent, public nsIDOMPopStateEvent
{
public:
  nsDOMPopStateEvent(nsPresContext* aPresContext, nsEvent* aEvent)
  : nsDOMEvent(aPresContext, aEvent),
    mState(nullptr)
  {}
  virtual ~nsDOMPopStateEvent() {}

  NS_DECL_ISUPPORTS_INHERITED
  NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED(nsDOMPopStateEvent, nsDOMEvent)
  NS_FORWARD_TO_NSDOMEVENT
  NS_DECL_NSIDOMPOPSTATEEVENT
  virtual nsresult InitFromCtor(const nsAString& aType, JSContext* aCx, jsval* aVal);
protected:
  nsCOMPtr<nsIVariant> mState;
};

NS_IMPL_CYCLE_COLLECTION_CLASS(nsDOMPopStateEvent)

NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(nsDOMPopStateEvent, nsDOMEvent)
  NS_IMPL_CYCLE_COLLECTION_UNLINK(mState)
NS_IMPL_CYCLE_COLLECTION_UNLINK_END

NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(nsDOMPopStateEvent, nsDOMEvent)
  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mState)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END

NS_IMPL_ADDREF_INHERITED(nsDOMPopStateEvent, nsDOMEvent)
NS_IMPL_RELEASE_INHERITED(nsDOMPopStateEvent, nsDOMEvent)

DOMCI_DATA(PopStateEvent, nsDOMPopStateEvent)

NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED(nsDOMPopStateEvent)
  NS_INTERFACE_MAP_ENTRY(nsIDOMPopStateEvent)
  NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(PopStateEvent)
NS_INTERFACE_MAP_END_INHERITING(nsDOMEvent)

nsresult
nsDOMPopStateEvent::InitFromCtor(const nsAString& aType, JSContext* aCx, jsval* aVal)
{
  mozilla::dom::PopStateEventInit d;
  nsresult rv = d.Init(aCx, aVal);
  NS_ENSURE_SUCCESS(rv, rv);
  return InitPopStateEvent(aType, d.bubbles, d.cancelable, d.state);
}

NS_IMETHODIMP
nsDOMPopStateEvent::InitPopStateEvent(const nsAString& aType, bool aCanBubble, bool aCancelable, nsIVariant* aState)
{
  nsresult rv = nsDOMEvent::InitEvent(aType, aCanBubble, aCancelable);
  NS_ENSURE_SUCCESS(rv, rv);
  mState = aState;
  return NS_OK;
}

NS_IMETHODIMP
nsDOMPopStateEvent::GetState(nsIVariant** aState)
{
  NS_IF_ADDREF(*aState = mState);
  return NS_OK;
}

nsresult
NS_NewDOMPopStateEvent(nsIDOMEvent** aInstance, nsPresContext* aPresContext, nsEvent* aEvent)
{
  nsDOMPopStateEvent* it = new nsDOMPopStateEvent(aPresContext, aEvent);
  return CallQueryInterface(it, aInstance);
}


class nsDOMHashChangeEvent : public nsDOMEvent, public nsIDOMHashChangeEvent
{
public:
  nsDOMHashChangeEvent(nsPresContext* aPresContext, nsEvent* aEvent)
  : nsDOMEvent(aPresContext, aEvent),
    mOldURL(),
    mNewURL()
  {}
  virtual ~nsDOMHashChangeEvent() {}

  NS_DECL_ISUPPORTS_INHERITED
  NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED(nsDOMHashChangeEvent, nsDOMEvent)
  NS_FORWARD_TO_NSDOMEVENT
  NS_DECL_NSIDOMHASHCHANGEEVENT
  virtual nsresult InitFromCtor(const nsAString& aType, JSContext* aCx, jsval* aVal);
protected:
  nsString mOldURL;
  nsString mNewURL;
};

NS_IMPL_CYCLE_COLLECTION_CLASS(nsDOMHashChangeEvent)

NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(nsDOMHashChangeEvent, nsDOMEvent)
NS_IMPL_CYCLE_COLLECTION_UNLINK_END

NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(nsDOMHashChangeEvent, nsDOMEvent)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END

NS_IMPL_ADDREF_INHERITED(nsDOMHashChangeEvent, nsDOMEvent)
NS_IMPL_RELEASE_INHERITED(nsDOMHashChangeEvent, nsDOMEvent)

DOMCI_DATA(HashChangeEvent, nsDOMHashChangeEvent)

NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED(nsDOMHashChangeEvent)
  NS_INTERFACE_MAP_ENTRY(nsIDOMHashChangeEvent)
  NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(HashChangeEvent)
NS_INTERFACE_MAP_END_INHERITING(nsDOMEvent)

nsresult
nsDOMHashChangeEvent::InitFromCtor(const nsAString& aType, JSContext* aCx, jsval* aVal)
{
  mozilla::dom::HashChangeEventInit d;
  nsresult rv = d.Init(aCx, aVal);
  NS_ENSURE_SUCCESS(rv, rv);
  return InitHashChangeEvent(aType, d.bubbles, d.cancelable, d.oldURL, d.newURL);
}

NS_IMETHODIMP
nsDOMHashChangeEvent::InitHashChangeEvent(const nsAString& aType, bool aCanBubble, bool aCancelable, const nsAString& aOldURL, const nsAString& aNewURL)
{
  nsresult rv = nsDOMEvent::InitEvent(aType, aCanBubble, aCancelable);
  NS_ENSURE_SUCCESS(rv, rv);
  mOldURL = aOldURL;
  mNewURL = aNewURL;
  return NS_OK;
}

NS_IMETHODIMP
nsDOMHashChangeEvent::GetOldURL(nsAString& aOldURL)
{
  aOldURL = mOldURL;
  return NS_OK;
}

NS_IMETHODIMP
nsDOMHashChangeEvent::GetNewURL(nsAString& aNewURL)
{
  aNewURL = mNewURL;
  return NS_OK;
}

nsresult
NS_NewDOMHashChangeEvent(nsIDOMEvent** aInstance, nsPresContext* aPresContext, nsEvent* aEvent)
{
  nsDOMHashChangeEvent* it = new nsDOMHashChangeEvent(aPresContext, aEvent);
  return CallQueryInterface(it, aInstance);
}


class nsDOMCloseEvent : public nsDOMEvent, public nsIDOMCloseEvent
{
public:
  nsDOMCloseEvent(nsPresContext* aPresContext, nsEvent* aEvent)
  : nsDOMEvent(aPresContext, aEvent),
    mWasClean(false),
    mCode(0),
    mReason()
  {}
  virtual ~nsDOMCloseEvent() {}

  NS_DECL_ISUPPORTS_INHERITED
  NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED(nsDOMCloseEvent, nsDOMEvent)
  NS_FORWARD_TO_NSDOMEVENT
  NS_DECL_NSIDOMCLOSEEVENT
  virtual nsresult InitFromCtor(const nsAString& aType, JSContext* aCx, jsval* aVal);
protected:
  bool mWasClean;
  uint16_t mCode;
  nsString mReason;
};

NS_IMPL_CYCLE_COLLECTION_CLASS(nsDOMCloseEvent)

NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(nsDOMCloseEvent, nsDOMEvent)
NS_IMPL_CYCLE_COLLECTION_UNLINK_END

NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(nsDOMCloseEvent, nsDOMEvent)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END

NS_IMPL_ADDREF_INHERITED(nsDOMCloseEvent, nsDOMEvent)
NS_IMPL_RELEASE_INHERITED(nsDOMCloseEvent, nsDOMEvent)

DOMCI_DATA(CloseEvent, nsDOMCloseEvent)

NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED(nsDOMCloseEvent)
  NS_INTERFACE_MAP_ENTRY(nsIDOMCloseEvent)
  NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(CloseEvent)
NS_INTERFACE_MAP_END_INHERITING(nsDOMEvent)

nsresult
nsDOMCloseEvent::InitFromCtor(const nsAString& aType, JSContext* aCx, jsval* aVal)
{
  mozilla::dom::CloseEventInit d;
  nsresult rv = d.Init(aCx, aVal);
  NS_ENSURE_SUCCESS(rv, rv);
  return InitCloseEvent(aType, d.bubbles, d.cancelable, d.wasClean, d.code, d.reason);
}

NS_IMETHODIMP
nsDOMCloseEvent::InitCloseEvent(const nsAString& aType, bool aCanBubble, bool aCancelable, bool  aWasClean, uint16_t  aCode, const nsAString& aReason)
{
  nsresult rv = nsDOMEvent::InitEvent(aType, aCanBubble, aCancelable);
  NS_ENSURE_SUCCESS(rv, rv);
  mWasClean = aWasClean;
  mCode = aCode;
  mReason = aReason;
  return NS_OK;
}

NS_IMETHODIMP
nsDOMCloseEvent::GetWasClean(bool *aWasClean)
{
  *aWasClean = mWasClean;
  return NS_OK;
}

NS_IMETHODIMP
nsDOMCloseEvent::GetCode(uint16_t *aCode)
{
  *aCode = mCode;
  return NS_OK;
}

NS_IMETHODIMP
nsDOMCloseEvent::GetReason(nsAString& aReason)
{
  aReason = mReason;
  return NS_OK;
}

nsresult
NS_NewDOMCloseEvent(nsIDOMEvent** aInstance, nsPresContext* aPresContext, nsEvent* aEvent)
{
  nsDOMCloseEvent* it = new nsDOMCloseEvent(aPresContext, aEvent);
  return CallQueryInterface(it, aInstance);
}


class nsDOMMozContactChangeEvent : public nsDOMEvent, public nsIDOMMozContactChangeEvent
{
public:
  nsDOMMozContactChangeEvent(nsPresContext* aPresContext, nsEvent* aEvent)
  : nsDOMEvent(aPresContext, aEvent),
    mContactID(),
    mReason()
  {}
  virtual ~nsDOMMozContactChangeEvent() {}

  NS_DECL_ISUPPORTS_INHERITED
  NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED(nsDOMMozContactChangeEvent, nsDOMEvent)
  NS_FORWARD_TO_NSDOMEVENT
  NS_DECL_NSIDOMMOZCONTACTCHANGEEVENT
  virtual nsresult InitFromCtor(const nsAString& aType, JSContext* aCx, jsval* aVal);
protected:
  nsString mContactID;
  nsString mReason;
};

NS_IMPL_CYCLE_COLLECTION_CLASS(nsDOMMozContactChangeEvent)

NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(nsDOMMozContactChangeEvent, nsDOMEvent)
NS_IMPL_CYCLE_COLLECTION_UNLINK_END

NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(nsDOMMozContactChangeEvent, nsDOMEvent)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END

NS_IMPL_ADDREF_INHERITED(nsDOMMozContactChangeEvent, nsDOMEvent)
NS_IMPL_RELEASE_INHERITED(nsDOMMozContactChangeEvent, nsDOMEvent)

DOMCI_DATA(MozContactChangeEvent, nsDOMMozContactChangeEvent)

NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED(nsDOMMozContactChangeEvent)
  NS_INTERFACE_MAP_ENTRY(nsIDOMMozContactChangeEvent)
  NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(MozContactChangeEvent)
NS_INTERFACE_MAP_END_INHERITING(nsDOMEvent)

nsresult
nsDOMMozContactChangeEvent::InitFromCtor(const nsAString& aType, JSContext* aCx, jsval* aVal)
{
  mozilla::dom::MozContactChangeEventInit d;
  nsresult rv = d.Init(aCx, aVal);
  NS_ENSURE_SUCCESS(rv, rv);
  return InitMozContactChangeEvent(aType, d.bubbles, d.cancelable, d.contactID, d.reason);
}

NS_IMETHODIMP
nsDOMMozContactChangeEvent::InitMozContactChangeEvent(const nsAString& aType, bool aCanBubble, bool aCancelable, const nsAString& aContactID, const nsAString& aReason)
{
  nsresult rv = nsDOMEvent::InitEvent(aType, aCanBubble, aCancelable);
  NS_ENSURE_SUCCESS(rv, rv);
  mContactID = aContactID;
  mReason = aReason;
  return NS_OK;
}

NS_IMETHODIMP
nsDOMMozContactChangeEvent::GetContactID(nsAString& aContactID)
{
  aContactID = mContactID;
  return NS_OK;
}

NS_IMETHODIMP
nsDOMMozContactChangeEvent::GetReason(nsAString& aReason)
{
  aReason = mReason;
  return NS_OK;
}

nsresult
NS_NewDOMMozContactChangeEvent(nsIDOMEvent** aInstance, nsPresContext* aPresContext, nsEvent* aEvent)
{
  nsDOMMozContactChangeEvent* it = new nsDOMMozContactChangeEvent(aPresContext, aEvent);
  return CallQueryInterface(it, aInstance);
}


class nsDOMDeviceOrientationEvent : public nsDOMEvent, public nsIDOMDeviceOrientationEvent
{
public:
  nsDOMDeviceOrientationEvent(nsPresContext* aPresContext, nsEvent* aEvent)
  : nsDOMEvent(aPresContext, aEvent),
    mAlpha(0),
    mBeta(0),
    mGamma(0),
    mAbsolute(false)
  {}
  virtual ~nsDOMDeviceOrientationEvent() {}

  NS_DECL_ISUPPORTS_INHERITED
  NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED(nsDOMDeviceOrientationEvent, nsDOMEvent)
  NS_FORWARD_TO_NSDOMEVENT
  NS_DECL_NSIDOMDEVICEORIENTATIONEVENT
  virtual nsresult InitFromCtor(const nsAString& aType, JSContext* aCx, jsval* aVal);
protected:
  double mAlpha;
  double mBeta;
  double mGamma;
  bool mAbsolute;
};

NS_IMPL_CYCLE_COLLECTION_CLASS(nsDOMDeviceOrientationEvent)

NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(nsDOMDeviceOrientationEvent, nsDOMEvent)
NS_IMPL_CYCLE_COLLECTION_UNLINK_END

NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(nsDOMDeviceOrientationEvent, nsDOMEvent)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END

NS_IMPL_ADDREF_INHERITED(nsDOMDeviceOrientationEvent, nsDOMEvent)
NS_IMPL_RELEASE_INHERITED(nsDOMDeviceOrientationEvent, nsDOMEvent)

DOMCI_DATA(DeviceOrientationEvent, nsDOMDeviceOrientationEvent)

NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED(nsDOMDeviceOrientationEvent)
  NS_INTERFACE_MAP_ENTRY(nsIDOMDeviceOrientationEvent)
  NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(DeviceOrientationEvent)
NS_INTERFACE_MAP_END_INHERITING(nsDOMEvent)

nsresult
nsDOMDeviceOrientationEvent::InitFromCtor(const nsAString& aType, JSContext* aCx, jsval* aVal)
{
  mozilla::dom::DeviceOrientationEventInit d;
  nsresult rv = d.Init(aCx, aVal);
  NS_ENSURE_SUCCESS(rv, rv);
  return InitDeviceOrientationEvent(aType, d.bubbles, d.cancelable, d.alpha, d.beta, d.gamma, d.absolute);
}

NS_IMETHODIMP
nsDOMDeviceOrientationEvent::InitDeviceOrientationEvent(const nsAString& aType, bool aCanBubble, bool aCancelable, double  aAlpha, double  aBeta, double  aGamma, bool  aAbsolute)
{
  nsresult rv = nsDOMEvent::InitEvent(aType, aCanBubble, aCancelable);
  NS_ENSURE_SUCCESS(rv, rv);
  mAlpha = aAlpha;
  mBeta = aBeta;
  mGamma = aGamma;
  mAbsolute = aAbsolute;
  return NS_OK;
}

NS_IMETHODIMP
nsDOMDeviceOrientationEvent::GetAlpha(double *aAlpha)
{
  *aAlpha = mAlpha;
  return NS_OK;
}

NS_IMETHODIMP
nsDOMDeviceOrientationEvent::GetBeta(double *aBeta)
{
  *aBeta = mBeta;
  return NS_OK;
}

NS_IMETHODIMP
nsDOMDeviceOrientationEvent::GetGamma(double *aGamma)
{
  *aGamma = mGamma;
  return NS_OK;
}

NS_IMETHODIMP
nsDOMDeviceOrientationEvent::GetAbsolute(bool *aAbsolute)
{
  *aAbsolute = mAbsolute;
  return NS_OK;
}

nsresult
NS_NewDOMDeviceOrientationEvent(nsIDOMEvent** aInstance, nsPresContext* aPresContext, nsEvent* aEvent)
{
  nsDOMDeviceOrientationEvent* it = new nsDOMDeviceOrientationEvent(aPresContext, aEvent);
  return CallQueryInterface(it, aInstance);
}


class nsDOMDeviceLightEvent : public nsDOMEvent, public nsIDOMDeviceLightEvent
{
public:
  nsDOMDeviceLightEvent(nsPresContext* aPresContext, nsEvent* aEvent)
  : nsDOMEvent(aPresContext, aEvent),
    mValue(0)
  {}
  virtual ~nsDOMDeviceLightEvent() {}

  NS_DECL_ISUPPORTS_INHERITED
  NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED(nsDOMDeviceLightEvent, nsDOMEvent)
  NS_FORWARD_TO_NSDOMEVENT
  NS_DECL_NSIDOMDEVICELIGHTEVENT
  virtual nsresult InitFromCtor(const nsAString& aType, JSContext* aCx, jsval* aVal);
protected:
  double mValue;
};

NS_IMPL_CYCLE_COLLECTION_CLASS(nsDOMDeviceLightEvent)

NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(nsDOMDeviceLightEvent, nsDOMEvent)
NS_IMPL_CYCLE_COLLECTION_UNLINK_END

NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(nsDOMDeviceLightEvent, nsDOMEvent)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END

NS_IMPL_ADDREF_INHERITED(nsDOMDeviceLightEvent, nsDOMEvent)
NS_IMPL_RELEASE_INHERITED(nsDOMDeviceLightEvent, nsDOMEvent)

DOMCI_DATA(DeviceLightEvent, nsDOMDeviceLightEvent)

NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED(nsDOMDeviceLightEvent)
  NS_INTERFACE_MAP_ENTRY(nsIDOMDeviceLightEvent)
  NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(DeviceLightEvent)
NS_INTERFACE_MAP_END_INHERITING(nsDOMEvent)

nsresult
nsDOMDeviceLightEvent::InitFromCtor(const nsAString& aType, JSContext* aCx, jsval* aVal)
{
  mozilla::dom::DeviceLightEventInit d;
  nsresult rv = d.Init(aCx, aVal);
  NS_ENSURE_SUCCESS(rv, rv);
  return InitDeviceLightEvent(aType, d.bubbles, d.cancelable, d.value);
}

NS_IMETHODIMP
nsDOMDeviceLightEvent::InitDeviceLightEvent(const nsAString& aType, bool aCanBubble, bool aCancelable, double  aValue)
{
  nsresult rv = nsDOMEvent::InitEvent(aType, aCanBubble, aCancelable);
  NS_ENSURE_SUCCESS(rv, rv);
  mValue = aValue;
  return NS_OK;
}

NS_IMETHODIMP
nsDOMDeviceLightEvent::GetValue(double *aValue)
{
  *aValue = mValue;
  return NS_OK;
}

nsresult
NS_NewDOMDeviceLightEvent(nsIDOMEvent** aInstance, nsPresContext* aPresContext, nsEvent* aEvent)
{
  nsDOMDeviceLightEvent* it = new nsDOMDeviceLightEvent(aPresContext, aEvent);
  return CallQueryInterface(it, aInstance);
}


class nsDOMMozApplicationEvent : public nsDOMEvent, public nsIDOMMozApplicationEvent
{
public:
  nsDOMMozApplicationEvent(nsPresContext* aPresContext, nsEvent* aEvent)
  : nsDOMEvent(aPresContext, aEvent),
    mApplication(nullptr)
  {}
  virtual ~nsDOMMozApplicationEvent() {}

  NS_DECL_ISUPPORTS_INHERITED
  NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED(nsDOMMozApplicationEvent, nsDOMEvent)
  NS_FORWARD_TO_NSDOMEVENT
  NS_DECL_NSIDOMMOZAPPLICATIONEVENT
  virtual nsresult InitFromCtor(const nsAString& aType, JSContext* aCx, jsval* aVal);
protected:
  nsCOMPtr<mozIDOMApplication> mApplication;
};

NS_IMPL_CYCLE_COLLECTION_CLASS(nsDOMMozApplicationEvent)

NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(nsDOMMozApplicationEvent, nsDOMEvent)
  NS_IMPL_CYCLE_COLLECTION_UNLINK(mApplication)
NS_IMPL_CYCLE_COLLECTION_UNLINK_END

NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(nsDOMMozApplicationEvent, nsDOMEvent)
  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mApplication)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END

NS_IMPL_ADDREF_INHERITED(nsDOMMozApplicationEvent, nsDOMEvent)
NS_IMPL_RELEASE_INHERITED(nsDOMMozApplicationEvent, nsDOMEvent)

DOMCI_DATA(MozApplicationEvent, nsDOMMozApplicationEvent)

NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED(nsDOMMozApplicationEvent)
  NS_INTERFACE_MAP_ENTRY(nsIDOMMozApplicationEvent)
  NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(MozApplicationEvent)
NS_INTERFACE_MAP_END_INHERITING(nsDOMEvent)

nsresult
nsDOMMozApplicationEvent::InitFromCtor(const nsAString& aType, JSContext* aCx, jsval* aVal)
{
  mozilla::dom::MozApplicationEventInit d;
  nsresult rv = d.Init(aCx, aVal);
  NS_ENSURE_SUCCESS(rv, rv);
  return InitMozApplicationEvent(aType, d.bubbles, d.cancelable, d.application);
}

NS_IMETHODIMP
nsDOMMozApplicationEvent::InitMozApplicationEvent(const nsAString& aType, bool aCanBubble, bool aCancelable, mozIDOMApplication* aApplication)
{
  nsresult rv = nsDOMEvent::InitEvent(aType, aCanBubble, aCancelable);
  NS_ENSURE_SUCCESS(rv, rv);
  mApplication = aApplication;
  return NS_OK;
}

NS_IMETHODIMP
nsDOMMozApplicationEvent::GetApplication(mozIDOMApplication** aApplication)
{
  NS_IF_ADDREF(*aApplication = mApplication);
  return NS_OK;
}

nsresult
NS_NewDOMMozApplicationEvent(nsIDOMEvent** aInstance, nsPresContext* aPresContext, nsEvent* aEvent)
{
  nsDOMMozApplicationEvent* it = new nsDOMMozApplicationEvent(aPresContext, aEvent);
  return CallQueryInterface(it, aInstance);
}


class nsDOMDeviceStorageChangeEvent : public nsDOMEvent, public nsIDOMDeviceStorageChangeEvent
{
public:
  nsDOMDeviceStorageChangeEvent(nsPresContext* aPresContext, nsEvent* aEvent)
  : nsDOMEvent(aPresContext, aEvent),
    mPath(),
    mReason()
  {}
  virtual ~nsDOMDeviceStorageChangeEvent() {}

  NS_DECL_ISUPPORTS_INHERITED
  NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED(nsDOMDeviceStorageChangeEvent, nsDOMEvent)
  NS_FORWARD_TO_NSDOMEVENT
  NS_DECL_NSIDOMDEVICESTORAGECHANGEEVENT
  virtual nsresult InitFromCtor(const nsAString& aType, JSContext* aCx, jsval* aVal);
protected:
  nsString mPath;
  nsString mReason;
};

NS_IMPL_CYCLE_COLLECTION_CLASS(nsDOMDeviceStorageChangeEvent)

NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(nsDOMDeviceStorageChangeEvent, nsDOMEvent)
NS_IMPL_CYCLE_COLLECTION_UNLINK_END

NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(nsDOMDeviceStorageChangeEvent, nsDOMEvent)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END

NS_IMPL_ADDREF_INHERITED(nsDOMDeviceStorageChangeEvent, nsDOMEvent)
NS_IMPL_RELEASE_INHERITED(nsDOMDeviceStorageChangeEvent, nsDOMEvent)

DOMCI_DATA(DeviceStorageChangeEvent, nsDOMDeviceStorageChangeEvent)

NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED(nsDOMDeviceStorageChangeEvent)
  NS_INTERFACE_MAP_ENTRY(nsIDOMDeviceStorageChangeEvent)
  NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(DeviceStorageChangeEvent)
NS_INTERFACE_MAP_END_INHERITING(nsDOMEvent)

nsresult
nsDOMDeviceStorageChangeEvent::InitFromCtor(const nsAString& aType, JSContext* aCx, jsval* aVal)
{
  mozilla::dom::DeviceStorageChangeEventInit d;
  nsresult rv = d.Init(aCx, aVal);
  NS_ENSURE_SUCCESS(rv, rv);
  return InitDeviceStorageChangeEvent(aType, d.bubbles, d.cancelable, d.path, d.reason);
}

NS_IMETHODIMP
nsDOMDeviceStorageChangeEvent::InitDeviceStorageChangeEvent(const nsAString& aType, bool aCanBubble, bool aCancelable, const nsAString& aPath, const nsAString& aReason)
{
  nsresult rv = nsDOMEvent::InitEvent(aType, aCanBubble, aCancelable);
  NS_ENSURE_SUCCESS(rv, rv);
  mPath = aPath;
  mReason = aReason;
  return NS_OK;
}

NS_IMETHODIMP
nsDOMDeviceStorageChangeEvent::GetPath(nsAString& aPath)
{
  aPath = mPath;
  return NS_OK;
}

NS_IMETHODIMP
nsDOMDeviceStorageChangeEvent::GetReason(nsAString& aReason)
{
  aReason = mReason;
  return NS_OK;
}

nsresult
NS_NewDOMDeviceStorageChangeEvent(nsIDOMEvent** aInstance, nsPresContext* aPresContext, nsEvent* aEvent)
{
  nsDOMDeviceStorageChangeEvent* it = new nsDOMDeviceStorageChangeEvent(aPresContext, aEvent);
  return CallQueryInterface(it, aInstance);
}


class nsDOMPopupBlockedEvent : public nsDOMEvent, public nsIDOMPopupBlockedEvent
{
public:
  nsDOMPopupBlockedEvent(nsPresContext* aPresContext, nsEvent* aEvent)
  : nsDOMEvent(aPresContext, aEvent),
    mRequestingWindow(nullptr),
    mPopupWindowURI(nullptr),
    mPopupWindowName(),
    mPopupWindowFeatures()
  {}
  virtual ~nsDOMPopupBlockedEvent() {}

  NS_DECL_ISUPPORTS_INHERITED
  NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED(nsDOMPopupBlockedEvent, nsDOMEvent)
  NS_FORWARD_TO_NSDOMEVENT
  NS_DECL_NSIDOMPOPUPBLOCKEDEVENT
  virtual nsresult InitFromCtor(const nsAString& aType, JSContext* aCx, jsval* aVal);
protected:
  nsCOMPtr<nsIDOMWindow> mRequestingWindow;
  nsCOMPtr<nsIURI> mPopupWindowURI;
  nsString mPopupWindowName;
  nsString mPopupWindowFeatures;
};

NS_IMPL_CYCLE_COLLECTION_CLASS(nsDOMPopupBlockedEvent)

NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(nsDOMPopupBlockedEvent, nsDOMEvent)
  NS_IMPL_CYCLE_COLLECTION_UNLINK(mRequestingWindow)
  NS_IMPL_CYCLE_COLLECTION_UNLINK(mPopupWindowURI)
NS_IMPL_CYCLE_COLLECTION_UNLINK_END

NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(nsDOMPopupBlockedEvent, nsDOMEvent)
  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mRequestingWindow)
  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mPopupWindowURI)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END

NS_IMPL_ADDREF_INHERITED(nsDOMPopupBlockedEvent, nsDOMEvent)
NS_IMPL_RELEASE_INHERITED(nsDOMPopupBlockedEvent, nsDOMEvent)

DOMCI_DATA(PopupBlockedEvent, nsDOMPopupBlockedEvent)

NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED(nsDOMPopupBlockedEvent)
  NS_INTERFACE_MAP_ENTRY(nsIDOMPopupBlockedEvent)
  NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(PopupBlockedEvent)
NS_INTERFACE_MAP_END_INHERITING(nsDOMEvent)

nsresult
nsDOMPopupBlockedEvent::InitFromCtor(const nsAString& aType, JSContext* aCx, jsval* aVal)
{
  mozilla::dom::PopupBlockedEventInit d;
  nsresult rv = d.Init(aCx, aVal);
  NS_ENSURE_SUCCESS(rv, rv);
  return InitPopupBlockedEvent(aType, d.bubbles, d.cancelable, d.requestingWindow, d.popupWindowURI, d.popupWindowName, d.popupWindowFeatures);
}

NS_IMETHODIMP
nsDOMPopupBlockedEvent::InitPopupBlockedEvent(const nsAString& aType, bool aCanBubble, bool aCancelable, nsIDOMWindow* aRequestingWindow, nsIURI* aPopupWindowURI, const nsAString& aPopupWindowName, const nsAString& aPopupWindowFeatures)
{
  nsresult rv = nsDOMEvent::InitEvent(aType, aCanBubble, aCancelable);
  NS_ENSURE_SUCCESS(rv, rv);
  mRequestingWindow = aRequestingWindow;
  mPopupWindowURI = aPopupWindowURI;
  mPopupWindowName = aPopupWindowName;
  mPopupWindowFeatures = aPopupWindowFeatures;
  return NS_OK;
}

NS_IMETHODIMP
nsDOMPopupBlockedEvent::GetRequestingWindow(nsIDOMWindow** aRequestingWindow)
{
  NS_IF_ADDREF(*aRequestingWindow = mRequestingWindow);
  return NS_OK;
}

NS_IMETHODIMP
nsDOMPopupBlockedEvent::GetPopupWindowURI(nsIURI** aPopupWindowURI)
{
  NS_IF_ADDREF(*aPopupWindowURI = mPopupWindowURI);
  return NS_OK;
}

NS_IMETHODIMP
nsDOMPopupBlockedEvent::GetPopupWindowName(nsAString& aPopupWindowName)
{
  aPopupWindowName = mPopupWindowName;
  return NS_OK;
}

NS_IMETHODIMP
nsDOMPopupBlockedEvent::GetPopupWindowFeatures(nsAString& aPopupWindowFeatures)
{
  aPopupWindowFeatures = mPopupWindowFeatures;
  return NS_OK;
}

nsresult
NS_NewDOMPopupBlockedEvent(nsIDOMEvent** aInstance, nsPresContext* aPresContext, nsEvent* aEvent)
{
  nsDOMPopupBlockedEvent* it = new nsDOMPopupBlockedEvent(aPresContext, aEvent);
  return CallQueryInterface(it, aInstance);
}

