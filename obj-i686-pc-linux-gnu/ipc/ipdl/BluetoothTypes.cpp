//
// Automatically generated by ipdlc.
// Edit at your own risk
//


#include "mozilla/dom/bluetooth/BluetoothTypes.h"


//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |union BluetoothValue|
//
namespace mozilla {
namespace dom {
namespace bluetooth {
bool
BluetoothValue::MaybeDestroy(Type aNewType)
{
    if ((mType) == (T__None)) {
        return true;
    }
    if ((mType) == (aNewType)) {
        return false;
    }
    switch (mType) {
    case Tuint32_t:
        {
            (ptr_uint32_t())->~uint32_t__tdef();
            break;
        }
    case TnsString:
        {
            (ptr_nsString())->~nsString__tdef();
            break;
        }
    case Tbool:
        {
            (ptr_bool())->~bool__tdef();
            break;
        }
    case TArrayOfnsString:
        {
            (ptr_ArrayOfnsString())->~ArrayOfnsString__tdef();
            break;
        }
    case TArrayOfuint8_t:
        {
            (ptr_ArrayOfuint8_t())->~ArrayOfuint8_t__tdef();
            break;
        }
    case TArrayOfBluetoothNamedValue:
        {
            delete ptr_ArrayOfBluetoothNamedValue();
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("not reached");
            break;
        }
    }
    return true;
}

BluetoothValue::BluetoothValue(const uint32_t& aOther)
{
    new (ptr_uint32_t()) uint32_t(aOther);
    mType = Tuint32_t;
}

BluetoothValue::BluetoothValue(const nsString& aOther)
{
    new (ptr_nsString()) nsString(aOther);
    mType = TnsString;
}

BluetoothValue::BluetoothValue(const bool& aOther)
{
    new (ptr_bool()) bool(aOther);
    mType = Tbool;
}

BluetoothValue::BluetoothValue(const InfallibleTArray<nsString>& aOther)
{
    new (ptr_ArrayOfnsString()) InfallibleTArray<nsString>(aOther);
    mType = TArrayOfnsString;
}

BluetoothValue::BluetoothValue(const InfallibleTArray<uint8_t>& aOther)
{
    new (ptr_ArrayOfuint8_t()) InfallibleTArray<uint8_t>(aOther);
    mType = TArrayOfuint8_t;
}

BluetoothValue::BluetoothValue(const InfallibleTArray<BluetoothNamedValue>& aOther)
{
    ptr_ArrayOfBluetoothNamedValue() = new InfallibleTArray<BluetoothNamedValue>(aOther);
    mType = TArrayOfBluetoothNamedValue;
}

BluetoothValue::BluetoothValue(const BluetoothValue& aOther)
{
    (aOther).AssertSanity();
    switch ((aOther).type()) {
    case Tuint32_t:
        {
            new (ptr_uint32_t()) uint32_t((aOther).get_uint32_t());
            break;
        }
    case TnsString:
        {
            new (ptr_nsString()) nsString((aOther).get_nsString());
            break;
        }
    case Tbool:
        {
            new (ptr_bool()) bool((aOther).get_bool());
            break;
        }
    case TArrayOfnsString:
        {
            new (ptr_ArrayOfnsString()) InfallibleTArray<nsString>((aOther).get_ArrayOfnsString());
            break;
        }
    case TArrayOfuint8_t:
        {
            new (ptr_ArrayOfuint8_t()) InfallibleTArray<uint8_t>((aOther).get_ArrayOfuint8_t());
            break;
        }
    case TArrayOfBluetoothNamedValue:
        {
            ptr_ArrayOfBluetoothNamedValue() = new InfallibleTArray<BluetoothNamedValue>((aOther).get_ArrayOfBluetoothNamedValue());
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return;
        }
    }
    mType = (aOther).type();
}

BluetoothValue::~BluetoothValue()
{
    MaybeDestroy(T__None);
}

BluetoothValue&
BluetoothValue::operator=(const uint32_t& aRhs)
{
    if (MaybeDestroy(Tuint32_t)) {
        new (ptr_uint32_t()) uint32_t;
    }
    (*(ptr_uint32_t())) = aRhs;
    mType = Tuint32_t;
    return (*(this));
}

BluetoothValue&
BluetoothValue::operator=(const nsString& aRhs)
{
    if (MaybeDestroy(TnsString)) {
        new (ptr_nsString()) nsString;
    }
    (*(ptr_nsString())) = aRhs;
    mType = TnsString;
    return (*(this));
}

BluetoothValue&
BluetoothValue::operator=(const bool& aRhs)
{
    if (MaybeDestroy(Tbool)) {
        new (ptr_bool()) bool;
    }
    (*(ptr_bool())) = aRhs;
    mType = Tbool;
    return (*(this));
}

BluetoothValue&
BluetoothValue::operator=(const InfallibleTArray<nsString>& aRhs)
{
    if (MaybeDestroy(TArrayOfnsString)) {
        new (ptr_ArrayOfnsString()) InfallibleTArray<nsString>;
    }
    (*(ptr_ArrayOfnsString())) = aRhs;
    mType = TArrayOfnsString;
    return (*(this));
}

BluetoothValue&
BluetoothValue::operator=(const InfallibleTArray<uint8_t>& aRhs)
{
    if (MaybeDestroy(TArrayOfuint8_t)) {
        new (ptr_ArrayOfuint8_t()) InfallibleTArray<uint8_t>;
    }
    (*(ptr_ArrayOfuint8_t())) = aRhs;
    mType = TArrayOfuint8_t;
    return (*(this));
}

BluetoothValue&
BluetoothValue::operator=(const InfallibleTArray<BluetoothNamedValue>& aRhs)
{
    if (MaybeDestroy(TArrayOfBluetoothNamedValue)) {
        ptr_ArrayOfBluetoothNamedValue() = new InfallibleTArray<BluetoothNamedValue>;
    }
    (*(ptr_ArrayOfBluetoothNamedValue())) = aRhs;
    mType = TArrayOfBluetoothNamedValue;
    return (*(this));
}

BluetoothValue&
BluetoothValue::operator=(const BluetoothValue& aRhs)
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case Tuint32_t:
        {
            if (MaybeDestroy(t)) {
                new (ptr_uint32_t()) uint32_t;
            }
            (*(ptr_uint32_t())) = (aRhs).get_uint32_t();
            break;
        }
    case TnsString:
        {
            if (MaybeDestroy(t)) {
                new (ptr_nsString()) nsString;
            }
            (*(ptr_nsString())) = (aRhs).get_nsString();
            break;
        }
    case Tbool:
        {
            if (MaybeDestroy(t)) {
                new (ptr_bool()) bool;
            }
            (*(ptr_bool())) = (aRhs).get_bool();
            break;
        }
    case TArrayOfnsString:
        {
            if (MaybeDestroy(t)) {
                new (ptr_ArrayOfnsString()) InfallibleTArray<nsString>;
            }
            (*(ptr_ArrayOfnsString())) = (aRhs).get_ArrayOfnsString();
            break;
        }
    case TArrayOfuint8_t:
        {
            if (MaybeDestroy(t)) {
                new (ptr_ArrayOfuint8_t()) InfallibleTArray<uint8_t>;
            }
            (*(ptr_ArrayOfuint8_t())) = (aRhs).get_ArrayOfuint8_t();
            break;
        }
    case TArrayOfBluetoothNamedValue:
        {
            if (MaybeDestroy(t)) {
                ptr_ArrayOfBluetoothNamedValue() = new InfallibleTArray<BluetoothNamedValue>;
            }
            (*(ptr_ArrayOfBluetoothNamedValue())) = (aRhs).get_ArrayOfBluetoothNamedValue();
            break;
        }
    case T__None:
        {
            MaybeDestroy(t);
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            break;
        }
    }
    mType = t;
    return (*(this));
}

bool
BluetoothValue::operator==(const uint32_t& aRhs) const
{
    return (get_uint32_t()) == (aRhs);
}

bool
BluetoothValue::operator==(const nsString& aRhs) const
{
    return (get_nsString()) == (aRhs);
}

bool
BluetoothValue::operator==(const bool& aRhs) const
{
    return (get_bool()) == (aRhs);
}

bool
BluetoothValue::operator==(const InfallibleTArray<nsString>& aRhs) const
{
    return (get_ArrayOfnsString()) == (aRhs);
}

bool
BluetoothValue::operator==(const InfallibleTArray<uint8_t>& aRhs) const
{
    return (get_ArrayOfuint8_t()) == (aRhs);
}

bool
BluetoothValue::operator==(const InfallibleTArray<BluetoothNamedValue>& aRhs) const
{
    return (get_ArrayOfBluetoothNamedValue()) == (aRhs);
}

bool
BluetoothValue::operator==(const BluetoothValue& aRhs) const
{
    if ((type()) != ((aRhs).type())) {
        return false;
    }

    switch (type()) {
    case Tuint32_t:
        {
            return (get_uint32_t()) == ((aRhs).get_uint32_t());
        }
    case TnsString:
        {
            return (get_nsString()) == ((aRhs).get_nsString());
        }
    case Tbool:
        {
            return (get_bool()) == ((aRhs).get_bool());
        }
    case TArrayOfnsString:
        {
            return (get_ArrayOfnsString()) == ((aRhs).get_ArrayOfnsString());
        }
    case TArrayOfuint8_t:
        {
            return (get_ArrayOfuint8_t()) == ((aRhs).get_ArrayOfuint8_t());
        }
    case TArrayOfBluetoothNamedValue:
        {
            return (get_ArrayOfBluetoothNamedValue()) == ((aRhs).get_ArrayOfBluetoothNamedValue());
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return false;
        }
    }
}

} // namespace bluetooth
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct BluetoothNamedValue|
//
namespace mozilla {
namespace dom {
namespace bluetooth {
BluetoothNamedValue::BluetoothNamedValue()
{
    Init();
}

BluetoothNamedValue::~BluetoothNamedValue()
{
    delete value_;
}

bool
BluetoothNamedValue::operator==(const BluetoothNamedValue& _o) const
{
    if ((!((name()) == ((_o).name())))) {
        return false;
    }
    if ((!((value()) == ((_o).value())))) {
        return false;
    }
    return true;
}

void
BluetoothNamedValue::Init()
{
    value_ = new BluetoothValue();
}

void
BluetoothNamedValue::Assign(
        const nsString& _name,
        const BluetoothValue& _value)
{
    name_ = _name;
    (*(value_)) = _value;
}

} // namespace bluetooth
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct BluetoothSignal|
//
namespace mozilla {
namespace dom {
namespace bluetooth {
BluetoothSignal::BluetoothSignal()
{
    Init();
}

BluetoothSignal::~BluetoothSignal()
{
}

bool
BluetoothSignal::operator==(const BluetoothSignal& _o) const
{
    if ((!((name()) == ((_o).name())))) {
        return false;
    }
    if ((!((path()) == ((_o).path())))) {
        return false;
    }
    if ((!((value()) == ((_o).value())))) {
        return false;
    }
    return true;
}

void
BluetoothSignal::Init()
{
}

void
BluetoothSignal::Assign(
        const nsString& _name,
        const nsString& _path,
        const BluetoothValue& _value)
{
    name_ = _name;
    path_ = _path;
    value_ = _value;
}

} // namespace bluetooth
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct BluetoothReplySuccess|
//
namespace mozilla {
namespace dom {
namespace bluetooth {
BluetoothReplySuccess::BluetoothReplySuccess()
{
    Init();
}

BluetoothReplySuccess::~BluetoothReplySuccess()
{
}

bool
BluetoothReplySuccess::operator==(const BluetoothReplySuccess& _o) const
{
    if ((!((value()) == ((_o).value())))) {
        return false;
    }
    return true;
}

void
BluetoothReplySuccess::Init()
{
}

void
BluetoothReplySuccess::Assign(const BluetoothValue& _value)
{
    value_ = _value;
}

} // namespace bluetooth
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct BluetoothReplyError|
//
namespace mozilla {
namespace dom {
namespace bluetooth {
BluetoothReplyError::BluetoothReplyError()
{
    Init();
}

BluetoothReplyError::~BluetoothReplyError()
{
}

bool
BluetoothReplyError::operator==(const BluetoothReplyError& _o) const
{
    if ((!((error()) == ((_o).error())))) {
        return false;
    }
    return true;
}

void
BluetoothReplyError::Init()
{
}

void
BluetoothReplyError::Assign(const nsString& _error)
{
    error_ = _error;
}

} // namespace bluetooth
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |union BluetoothReply|
//
namespace mozilla {
namespace dom {
namespace bluetooth {
bool
BluetoothReply::MaybeDestroy(Type aNewType)
{
    if ((mType) == (T__None)) {
        return true;
    }
    if ((mType) == (aNewType)) {
        return false;
    }
    switch (mType) {
    case TBluetoothReplySuccess:
        {
            (ptr_BluetoothReplySuccess())->~BluetoothReplySuccess__tdef();
            break;
        }
    case TBluetoothReplyError:
        {
            (ptr_BluetoothReplyError())->~BluetoothReplyError__tdef();
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("not reached");
            break;
        }
    }
    return true;
}

BluetoothReply::BluetoothReply(const BluetoothReplySuccess& aOther)
{
    new (ptr_BluetoothReplySuccess()) BluetoothReplySuccess(aOther);
    mType = TBluetoothReplySuccess;
}

BluetoothReply::BluetoothReply(const BluetoothReplyError& aOther)
{
    new (ptr_BluetoothReplyError()) BluetoothReplyError(aOther);
    mType = TBluetoothReplyError;
}

BluetoothReply::BluetoothReply(const BluetoothReply& aOther)
{
    (aOther).AssertSanity();
    switch ((aOther).type()) {
    case TBluetoothReplySuccess:
        {
            new (ptr_BluetoothReplySuccess()) BluetoothReplySuccess((aOther).get_BluetoothReplySuccess());
            break;
        }
    case TBluetoothReplyError:
        {
            new (ptr_BluetoothReplyError()) BluetoothReplyError((aOther).get_BluetoothReplyError());
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return;
        }
    }
    mType = (aOther).type();
}

BluetoothReply::~BluetoothReply()
{
    MaybeDestroy(T__None);
}

BluetoothReply&
BluetoothReply::operator=(const BluetoothReplySuccess& aRhs)
{
    if (MaybeDestroy(TBluetoothReplySuccess)) {
        new (ptr_BluetoothReplySuccess()) BluetoothReplySuccess;
    }
    (*(ptr_BluetoothReplySuccess())) = aRhs;
    mType = TBluetoothReplySuccess;
    return (*(this));
}

BluetoothReply&
BluetoothReply::operator=(const BluetoothReplyError& aRhs)
{
    if (MaybeDestroy(TBluetoothReplyError)) {
        new (ptr_BluetoothReplyError()) BluetoothReplyError;
    }
    (*(ptr_BluetoothReplyError())) = aRhs;
    mType = TBluetoothReplyError;
    return (*(this));
}

BluetoothReply&
BluetoothReply::operator=(const BluetoothReply& aRhs)
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case TBluetoothReplySuccess:
        {
            if (MaybeDestroy(t)) {
                new (ptr_BluetoothReplySuccess()) BluetoothReplySuccess;
            }
            (*(ptr_BluetoothReplySuccess())) = (aRhs).get_BluetoothReplySuccess();
            break;
        }
    case TBluetoothReplyError:
        {
            if (MaybeDestroy(t)) {
                new (ptr_BluetoothReplyError()) BluetoothReplyError;
            }
            (*(ptr_BluetoothReplyError())) = (aRhs).get_BluetoothReplyError();
            break;
        }
    case T__None:
        {
            MaybeDestroy(t);
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            break;
        }
    }
    mType = t;
    return (*(this));
}

bool
BluetoothReply::operator==(const BluetoothReplySuccess& aRhs) const
{
    return (get_BluetoothReplySuccess()) == (aRhs);
}

bool
BluetoothReply::operator==(const BluetoothReplyError& aRhs) const
{
    return (get_BluetoothReplyError()) == (aRhs);
}

bool
BluetoothReply::operator==(const BluetoothReply& aRhs) const
{
    if ((type()) != ((aRhs).type())) {
        return false;
    }

    switch (type()) {
    case TBluetoothReplySuccess:
        {
            return (get_BluetoothReplySuccess()) == ((aRhs).get_BluetoothReplySuccess());
        }
    case TBluetoothReplyError:
        {
            return (get_BluetoothReplyError()) == ((aRhs).get_BluetoothReplyError());
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return false;
        }
    }
}

} // namespace bluetooth
} // namespace dom
} // namespace mozilla
