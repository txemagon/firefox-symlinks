//
// Automatically generated by ipdlc.
// Edit at your own risk
//


#include "mozilla/jsipc/PObjectWrapper.h"

namespace mozilla {
namespace jsipc {
namespace PObjectWrapper {

bool
Transition(
        State from,
        mozilla::ipc::Trigger trigger,
        State* next)
{
    switch (from) {
    case __Null:
    case __Error:
        if ((Msg___delete____ID) == ((trigger).mMsg)) {
            (*(next)) = __Dead;
            return true;
        }
        return (__Null) == (from);
    case __Dead:
        NS_RUNTIMEABORT("__delete__()d actor");
        return false;
    case __Dying:
        NS_RUNTIMEABORT("__delete__()d (and unexpectedly dying) actor");
        return false;
    default:
        NS_RUNTIMEABORT("corrupted actor state");
        return false;
    }
    (*(next)) = __Error;
    return false;
}

} // namespace PObjectWrapper
} // namespace jsipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |union JSVariant|
//
namespace mozilla {
namespace jsipc {
bool
JSVariant::MaybeDestroy(Type aNewType)
{
    if ((mType) == (T__None)) {
        return true;
    }
    if ((mType) == (aNewType)) {
        return false;
    }
    switch (mType) {
    case Tvoid_t:
        {
            (ptr_void_t())->~void_t__tdef();
            break;
        }
    case TPObjectWrapperParent:
        {
            (ptr_PObjectWrapperParent())->~PObjectWrapperParent__tdef();
            break;
        }
    case TPObjectWrapperChild:
        {
            (ptr_PObjectWrapperChild())->~PObjectWrapperChild__tdef();
            break;
        }
    case TnsString:
        {
            (ptr_nsString())->~nsString__tdef();
            break;
        }
    case Tint:
        {
            (ptr_int())->~int__tdef();
            break;
        }
    case Tdouble:
        {
            (ptr_double())->~double__tdef();
            break;
        }
    case Tbool:
        {
            (ptr_bool())->~bool__tdef();
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("not reached");
            break;
        }
    }
    return true;
}

JSVariant::JSVariant(const void_t& aOther)
{
    new (ptr_void_t()) void_t(aOther);
    mType = Tvoid_t;
}

JSVariant::JSVariant(PObjectWrapperParent* aOther)
{
    new (ptr_PObjectWrapperParent()) PObjectWrapperParent*(const_cast<PObjectWrapperParent*>(aOther));
    mType = TPObjectWrapperParent;
}

JSVariant::JSVariant(PObjectWrapperChild* aOther)
{
    new (ptr_PObjectWrapperChild()) PObjectWrapperChild*(const_cast<PObjectWrapperChild*>(aOther));
    mType = TPObjectWrapperChild;
}

JSVariant::JSVariant(const nsString& aOther)
{
    new (ptr_nsString()) nsString(aOther);
    mType = TnsString;
}

JSVariant::JSVariant(const int& aOther)
{
    new (ptr_int()) int(aOther);
    mType = Tint;
}

JSVariant::JSVariant(const double& aOther)
{
    new (ptr_double()) double(aOther);
    mType = Tdouble;
}

JSVariant::JSVariant(const bool& aOther)
{
    new (ptr_bool()) bool(aOther);
    mType = Tbool;
}

JSVariant::JSVariant(const JSVariant& aOther)
{
    (aOther).AssertSanity();
    switch ((aOther).type()) {
    case Tvoid_t:
        {
            new (ptr_void_t()) void_t((aOther).get_void_t());
            break;
        }
    case TPObjectWrapperParent:
        {
            new (ptr_PObjectWrapperParent()) PObjectWrapperParent*(const_cast<PObjectWrapperParent*>((aOther).get_PObjectWrapperParent()));
            break;
        }
    case TPObjectWrapperChild:
        {
            new (ptr_PObjectWrapperChild()) PObjectWrapperChild*(const_cast<PObjectWrapperChild*>((aOther).get_PObjectWrapperChild()));
            break;
        }
    case TnsString:
        {
            new (ptr_nsString()) nsString((aOther).get_nsString());
            break;
        }
    case Tint:
        {
            new (ptr_int()) int((aOther).get_int());
            break;
        }
    case Tdouble:
        {
            new (ptr_double()) double((aOther).get_double());
            break;
        }
    case Tbool:
        {
            new (ptr_bool()) bool((aOther).get_bool());
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return;
        }
    }
    mType = (aOther).type();
}

JSVariant::~JSVariant()
{
    MaybeDestroy(T__None);
}

JSVariant&
JSVariant::operator=(const void_t& aRhs)
{
    if (MaybeDestroy(Tvoid_t)) {
        new (ptr_void_t()) void_t;
    }
    (*(ptr_void_t())) = aRhs;
    mType = Tvoid_t;
    return (*(this));
}

JSVariant&
JSVariant::operator=(PObjectWrapperParent* aRhs)
{
    if (MaybeDestroy(TPObjectWrapperParent)) {
        new (ptr_PObjectWrapperParent()) PObjectWrapperParent*;
    }
    (*(ptr_PObjectWrapperParent())) = const_cast<PObjectWrapperParent*>(aRhs);
    mType = TPObjectWrapperParent;
    return (*(this));
}

JSVariant&
JSVariant::operator=(PObjectWrapperChild* aRhs)
{
    if (MaybeDestroy(TPObjectWrapperChild)) {
        new (ptr_PObjectWrapperChild()) PObjectWrapperChild*;
    }
    (*(ptr_PObjectWrapperChild())) = const_cast<PObjectWrapperChild*>(aRhs);
    mType = TPObjectWrapperChild;
    return (*(this));
}

JSVariant&
JSVariant::operator=(const nsString& aRhs)
{
    if (MaybeDestroy(TnsString)) {
        new (ptr_nsString()) nsString;
    }
    (*(ptr_nsString())) = aRhs;
    mType = TnsString;
    return (*(this));
}

JSVariant&
JSVariant::operator=(const int& aRhs)
{
    if (MaybeDestroy(Tint)) {
        new (ptr_int()) int;
    }
    (*(ptr_int())) = aRhs;
    mType = Tint;
    return (*(this));
}

JSVariant&
JSVariant::operator=(const double& aRhs)
{
    if (MaybeDestroy(Tdouble)) {
        new (ptr_double()) double;
    }
    (*(ptr_double())) = aRhs;
    mType = Tdouble;
    return (*(this));
}

JSVariant&
JSVariant::operator=(const bool& aRhs)
{
    if (MaybeDestroy(Tbool)) {
        new (ptr_bool()) bool;
    }
    (*(ptr_bool())) = aRhs;
    mType = Tbool;
    return (*(this));
}

JSVariant&
JSVariant::operator=(const JSVariant& aRhs)
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case Tvoid_t:
        {
            if (MaybeDestroy(t)) {
                new (ptr_void_t()) void_t;
            }
            (*(ptr_void_t())) = (aRhs).get_void_t();
            break;
        }
    case TPObjectWrapperParent:
        {
            if (MaybeDestroy(t)) {
                new (ptr_PObjectWrapperParent()) PObjectWrapperParent*;
            }
            (*(ptr_PObjectWrapperParent())) = const_cast<PObjectWrapperParent*>((aRhs).get_PObjectWrapperParent());
            break;
        }
    case TPObjectWrapperChild:
        {
            if (MaybeDestroy(t)) {
                new (ptr_PObjectWrapperChild()) PObjectWrapperChild*;
            }
            (*(ptr_PObjectWrapperChild())) = const_cast<PObjectWrapperChild*>((aRhs).get_PObjectWrapperChild());
            break;
        }
    case TnsString:
        {
            if (MaybeDestroy(t)) {
                new (ptr_nsString()) nsString;
            }
            (*(ptr_nsString())) = (aRhs).get_nsString();
            break;
        }
    case Tint:
        {
            if (MaybeDestroy(t)) {
                new (ptr_int()) int;
            }
            (*(ptr_int())) = (aRhs).get_int();
            break;
        }
    case Tdouble:
        {
            if (MaybeDestroy(t)) {
                new (ptr_double()) double;
            }
            (*(ptr_double())) = (aRhs).get_double();
            break;
        }
    case Tbool:
        {
            if (MaybeDestroy(t)) {
                new (ptr_bool()) bool;
            }
            (*(ptr_bool())) = (aRhs).get_bool();
            break;
        }
    case T__None:
        {
            MaybeDestroy(t);
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            break;
        }
    }
    mType = t;
    return (*(this));
}

bool
JSVariant::operator==(const void_t& aRhs) const
{
    return (get_void_t()) == (aRhs);
}

bool
JSVariant::operator==(PObjectWrapperParent* aRhs) const
{
    return (get_PObjectWrapperParent()) == (aRhs);
}

bool
JSVariant::operator==(PObjectWrapperChild* aRhs) const
{
    return (get_PObjectWrapperChild()) == (aRhs);
}

bool
JSVariant::operator==(const nsString& aRhs) const
{
    return (get_nsString()) == (aRhs);
}

bool
JSVariant::operator==(const int& aRhs) const
{
    return (get_int()) == (aRhs);
}

bool
JSVariant::operator==(const double& aRhs) const
{
    return (get_double()) == (aRhs);
}

bool
JSVariant::operator==(const bool& aRhs) const
{
    return (get_bool()) == (aRhs);
}

bool
JSVariant::operator==(const JSVariant& aRhs) const
{
    if ((type()) != ((aRhs).type())) {
        return false;
    }

    switch (type()) {
    case Tvoid_t:
        {
            return (get_void_t()) == ((aRhs).get_void_t());
        }
    case TPObjectWrapperParent:
        {
            return (get_PObjectWrapperParent()) == ((aRhs).get_PObjectWrapperParent());
        }
    case TPObjectWrapperChild:
        {
            return (get_PObjectWrapperChild()) == ((aRhs).get_PObjectWrapperChild());
        }
    case TnsString:
        {
            return (get_nsString()) == ((aRhs).get_nsString());
        }
    case Tint:
        {
            return (get_int()) == ((aRhs).get_int());
        }
    case Tdouble:
        {
            return (get_double()) == ((aRhs).get_double());
        }
    case Tbool:
        {
            return (get_bool()) == ((aRhs).get_bool());
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return false;
        }
    }
}

} // namespace jsipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |union OperationStatus|
//
namespace mozilla {
namespace jsipc {
bool
OperationStatus::MaybeDestroy(Type aNewType)
{
    if ((mType) == (T__None)) {
        return true;
    }
    if ((mType) == (aNewType)) {
        return false;
    }
    switch (mType) {
    case TJSBool:
        {
            (ptr_JSBool())->~JSBool__tdef();
            break;
        }
    case TJSVariant:
        {
            (ptr_JSVariant())->~JSVariant__tdef();
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("not reached");
            break;
        }
    }
    return true;
}

OperationStatus::OperationStatus(const JSBool& aOther)
{
    new (ptr_JSBool()) JSBool(aOther);
    mType = TJSBool;
}

OperationStatus::OperationStatus(const JSVariant& aOther)
{
    new (ptr_JSVariant()) JSVariant(aOther);
    mType = TJSVariant;
}

OperationStatus::OperationStatus(const OperationStatus& aOther)
{
    (aOther).AssertSanity();
    switch ((aOther).type()) {
    case TJSBool:
        {
            new (ptr_JSBool()) JSBool((aOther).get_JSBool());
            break;
        }
    case TJSVariant:
        {
            new (ptr_JSVariant()) JSVariant((aOther).get_JSVariant());
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return;
        }
    }
    mType = (aOther).type();
}

OperationStatus::~OperationStatus()
{
    MaybeDestroy(T__None);
}

OperationStatus&
OperationStatus::operator=(const JSBool& aRhs)
{
    if (MaybeDestroy(TJSBool)) {
        new (ptr_JSBool()) JSBool;
    }
    (*(ptr_JSBool())) = aRhs;
    mType = TJSBool;
    return (*(this));
}

OperationStatus&
OperationStatus::operator=(const JSVariant& aRhs)
{
    if (MaybeDestroy(TJSVariant)) {
        new (ptr_JSVariant()) JSVariant;
    }
    (*(ptr_JSVariant())) = aRhs;
    mType = TJSVariant;
    return (*(this));
}

OperationStatus&
OperationStatus::operator=(const OperationStatus& aRhs)
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case TJSBool:
        {
            if (MaybeDestroy(t)) {
                new (ptr_JSBool()) JSBool;
            }
            (*(ptr_JSBool())) = (aRhs).get_JSBool();
            break;
        }
    case TJSVariant:
        {
            if (MaybeDestroy(t)) {
                new (ptr_JSVariant()) JSVariant;
            }
            (*(ptr_JSVariant())) = (aRhs).get_JSVariant();
            break;
        }
    case T__None:
        {
            MaybeDestroy(t);
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            break;
        }
    }
    mType = t;
    return (*(this));
}

bool
OperationStatus::operator==(const JSBool& aRhs) const
{
    return (get_JSBool()) == (aRhs);
}

bool
OperationStatus::operator==(const JSVariant& aRhs) const
{
    return (get_JSVariant()) == (aRhs);
}

bool
OperationStatus::operator==(const OperationStatus& aRhs) const
{
    if ((type()) != ((aRhs).type())) {
        return false;
    }

    switch (type()) {
    case TJSBool:
        {
            return (get_JSBool()) == ((aRhs).get_JSBool());
        }
    case TJSVariant:
        {
            return (get_JSVariant()) == ((aRhs).get_JSVariant());
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return false;
        }
    }
}

} // namespace jsipc
} // namespace mozilla
