//
// Automatically generated by ipdlc.
// Edit at your own risk
//


#include "mozilla/hal_sandbox/PHal.h"

namespace mozilla {
namespace hal_sandbox {
namespace PHal {

bool
Transition(
        State from,
        mozilla::ipc::Trigger trigger,
        State* next)
{
    switch (from) {
    case __Null:
    case __Error:
        if ((Msg___delete____ID) == ((trigger).mMsg)) {
            (*(next)) = __Dead;
            return true;
        }
        return (__Null) == (from);
    case __Dead:
        NS_RUNTIMEABORT("__delete__()d actor");
        return false;
    case __Dying:
        NS_RUNTIMEABORT("__delete__()d (and unexpectedly dying) actor");
        return false;
    default:
        NS_RUNTIMEABORT("corrupted actor state");
        return false;
    }
    (*(next)) = __Error;
    return false;
}

} // namespace PHal
} // namespace hal_sandbox
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct BatteryInformation|
//
namespace mozilla {
namespace hal {
BatteryInformation::BatteryInformation()
{
    Init();
}

BatteryInformation::~BatteryInformation()
{
}

bool
BatteryInformation::operator==(const BatteryInformation& _o) const
{
    if ((!((level()) == ((_o).level())))) {
        return false;
    }
    if ((!((charging()) == ((_o).charging())))) {
        return false;
    }
    if ((!((remainingTime()) == ((_o).remainingTime())))) {
        return false;
    }
    return true;
}

void
BatteryInformation::Init()
{
}

void
BatteryInformation::Assign(
        const double& _level,
        const bool& _charging,
        const double& _remainingTime)
{
    level_ = _level;
    charging_ = _charging;
    remainingTime_ = _remainingTime;
}

} // namespace hal
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct LightConfiguration|
//
namespace mozilla {
namespace hal {
LightConfiguration::LightConfiguration()
{
    Init();
}

LightConfiguration::~LightConfiguration()
{
}

bool
LightConfiguration::operator==(const LightConfiguration& _o) const
{
    if ((!((light()) == ((_o).light())))) {
        return false;
    }
    if ((!((mode()) == ((_o).mode())))) {
        return false;
    }
    if ((!((flash()) == ((_o).flash())))) {
        return false;
    }
    if ((!((flashOnMS()) == ((_o).flashOnMS())))) {
        return false;
    }
    if ((!((flashOffMS()) == ((_o).flashOffMS())))) {
        return false;
    }
    if ((!((color()) == ((_o).color())))) {
        return false;
    }
    return true;
}

void
LightConfiguration::Init()
{
}

void
LightConfiguration::Assign(
        const LightType& _light,
        const LightMode& _mode,
        const FlashMode& _flash,
        const uint32_t& _flashOnMS,
        const uint32_t& _flashOffMS,
        const uint32_t& _color)
{
    light_ = _light;
    mode_ = _mode;
    flash_ = _flash;
    flashOnMS_ = _flashOnMS;
    flashOffMS_ = _flashOffMS;
    color_ = _color;
}

} // namespace hal
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct SensorData|
//
namespace mozilla {
namespace hal {
SensorData::SensorData()
{
    Init();
}

SensorData::~SensorData()
{
}

bool
SensorData::operator==(const SensorData& _o) const
{
    if ((!((sensor()) == ((_o).sensor())))) {
        return false;
    }
    if ((!((timestamp()) == ((_o).timestamp())))) {
        return false;
    }
    if ((!((values()) == ((_o).values())))) {
        return false;
    }
    if ((!((accuracy()) == ((_o).accuracy())))) {
        return false;
    }
    return true;
}

void
SensorData::Init()
{
}

void
SensorData::Assign(
        const SensorType& _sensor,
        const PRTime& _timestamp,
        const InfallibleTArray<float>& _values,
        const SensorAccuracyType& _accuracy)
{
    sensor_ = _sensor;
    timestamp_ = _timestamp;
    values_ = _values;
    accuracy_ = _accuracy;
}

} // namespace hal
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct NetworkInformation|
//
namespace mozilla {
namespace hal {
NetworkInformation::NetworkInformation()
{
    Init();
}

NetworkInformation::~NetworkInformation()
{
}

bool
NetworkInformation::operator==(const NetworkInformation& _o) const
{
    if ((!((bandwidth()) == ((_o).bandwidth())))) {
        return false;
    }
    if ((!((canBeMetered()) == ((_o).canBeMetered())))) {
        return false;
    }
    return true;
}

void
NetworkInformation::Init()
{
}

void
NetworkInformation::Assign(
        const double& _bandwidth,
        const bool& _canBeMetered)
{
    bandwidth_ = _bandwidth;
    canBeMetered_ = _canBeMetered;
}

} // namespace hal
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct SwitchEvent|
//
namespace mozilla {
namespace hal {
SwitchEvent::SwitchEvent()
{
    Init();
}

SwitchEvent::~SwitchEvent()
{
}

bool
SwitchEvent::operator==(const SwitchEvent& _o) const
{
    if ((!((device()) == ((_o).device())))) {
        return false;
    }
    if ((!((status()) == ((_o).status())))) {
        return false;
    }
    return true;
}

void
SwitchEvent::Init()
{
}

void
SwitchEvent::Assign(
        const SwitchDevice& _device,
        const SwitchState& _status)
{
    device_ = _device;
    status_ = _status;
}

} // namespace hal
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct WakeLockInformation|
//
namespace mozilla {
namespace hal {
WakeLockInformation::WakeLockInformation()
{
    Init();
}

WakeLockInformation::~WakeLockInformation()
{
}

bool
WakeLockInformation::operator==(const WakeLockInformation& _o) const
{
    if ((!((numLocks()) == ((_o).numLocks())))) {
        return false;
    }
    if ((!((numHidden()) == ((_o).numHidden())))) {
        return false;
    }
    if ((!((topic()) == ((_o).topic())))) {
        return false;
    }
    return true;
}

void
WakeLockInformation::Init()
{
}

void
WakeLockInformation::Assign(
        const uint32_t& _numLocks,
        const uint32_t& _numHidden,
        const nsString& _topic)
{
    numLocks_ = _numLocks;
    numHidden_ = _numHidden;
    topic_ = _topic;
}

} // namespace hal
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct ScreenConfiguration|
//
namespace mozilla {
namespace hal {
ScreenConfiguration::ScreenConfiguration()
{
    Init();
}

ScreenConfiguration::~ScreenConfiguration()
{
}

bool
ScreenConfiguration::operator==(const ScreenConfiguration& _o) const
{
    if ((!((rect()) == ((_o).rect())))) {
        return false;
    }
    if ((!((orientation()) == ((_o).orientation())))) {
        return false;
    }
    if ((!((colorDepth()) == ((_o).colorDepth())))) {
        return false;
    }
    if ((!((pixelDepth()) == ((_o).pixelDepth())))) {
        return false;
    }
    return true;
}

void
ScreenConfiguration::Init()
{
}

void
ScreenConfiguration::Assign(
        const nsIntRect& _rect,
        const ScreenOrientation& _orientation,
        const uint32_t& _colorDepth,
        const uint32_t& _pixelDepth)
{
    rect_ = _rect;
    orientation_ = _orientation;
    colorDepth_ = _colorDepth;
    pixelDepth_ = _pixelDepth;
}

} // namespace hal
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct FMRadioOperationInformation|
//
namespace mozilla {
namespace hal {
FMRadioOperationInformation::FMRadioOperationInformation()
{
    Init();
}

FMRadioOperationInformation::~FMRadioOperationInformation()
{
}

bool
FMRadioOperationInformation::operator==(const FMRadioOperationInformation& _o) const
{
    if ((!((operation()) == ((_o).operation())))) {
        return false;
    }
    if ((!((status()) == ((_o).status())))) {
        return false;
    }
    if ((!((frequency()) == ((_o).frequency())))) {
        return false;
    }
    return true;
}

void
FMRadioOperationInformation::Init()
{
}

void
FMRadioOperationInformation::Assign(
        const FMRadioOperation& _operation,
        const FMRadioOperationStatus& _status,
        const uint32_t& _frequency)
{
    operation_ = _operation;
    status_ = _status;
    frequency_ = _frequency;
}

} // namespace hal
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct FMRadioSettings|
//
namespace mozilla {
namespace hal {
FMRadioSettings::FMRadioSettings()
{
    Init();
}

FMRadioSettings::~FMRadioSettings()
{
}

bool
FMRadioSettings::operator==(const FMRadioSettings& _o) const
{
    if ((!((country()) == ((_o).country())))) {
        return false;
    }
    if ((!((upperLimit()) == ((_o).upperLimit())))) {
        return false;
    }
    if ((!((lowerLimit()) == ((_o).lowerLimit())))) {
        return false;
    }
    if ((!((spaceType()) == ((_o).spaceType())))) {
        return false;
    }
    if ((!((preEmphasis()) == ((_o).preEmphasis())))) {
        return false;
    }
    return true;
}

void
FMRadioSettings::Init()
{
}

void
FMRadioSettings::Assign(
        const FMRadioCountry& _country,
        const uint32_t& _upperLimit,
        const uint32_t& _lowerLimit,
        const uint32_t& _spaceType,
        const uint32_t& _preEmphasis)
{
    country_ = _country;
    upperLimit_ = _upperLimit;
    lowerLimit_ = _lowerLimit;
    spaceType_ = _spaceType;
    preEmphasis_ = _preEmphasis;
}

} // namespace hal
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct SystemTimezoneChangeInformation|
//
namespace mozilla {
namespace hal {
SystemTimezoneChangeInformation::SystemTimezoneChangeInformation()
{
    Init();
}

SystemTimezoneChangeInformation::~SystemTimezoneChangeInformation()
{
}

bool
SystemTimezoneChangeInformation::operator==(const SystemTimezoneChangeInformation& _o) const
{
    if ((!((oldTimezoneOffsetMinutes()) == ((_o).oldTimezoneOffsetMinutes())))) {
        return false;
    }
    if ((!((newTimezoneOffsetMinutes()) == ((_o).newTimezoneOffsetMinutes())))) {
        return false;
    }
    return true;
}

void
SystemTimezoneChangeInformation::Init()
{
}

void
SystemTimezoneChangeInformation::Assign(
        const int32_t& _oldTimezoneOffsetMinutes,
        const int32_t& _newTimezoneOffsetMinutes)
{
    oldTimezoneOffsetMinutes_ = _oldTimezoneOffsetMinutes;
    newTimezoneOffsetMinutes_ = _newTimezoneOffsetMinutes;
}

} // namespace hal
} // namespace mozilla
