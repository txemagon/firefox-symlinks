//
// Automatically generated by ipdlc.
// Edit at your own risk
//


#include "mozilla/layers/PLayers.h"

namespace mozilla {
namespace layers {
namespace PLayers {

bool
Transition(
        State from,
        mozilla::ipc::Trigger trigger,
        State* next)
{
    switch (from) {
    case __Null:
    case __Error:
        if ((Msg___delete____ID) == ((trigger).mMsg)) {
            (*(next)) = __Dead;
            return true;
        }
        return (__Null) == (from);
    case __Dead:
        NS_RUNTIMEABORT("__delete__()d actor");
        return false;
    case __Dying:
        NS_RUNTIMEABORT("__delete__()d (and unexpectedly dying) actor");
        return false;
    default:
        NS_RUNTIMEABORT("corrupted actor state");
        return false;
    }
    (*(next)) = __Error;
    return false;
}

} // namespace PLayers
} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct TargetConfig|
//
namespace mozilla {
namespace layers {
TargetConfig::TargetConfig()
{
    Init();
}

TargetConfig::~TargetConfig()
{
}

bool
TargetConfig::operator==(const TargetConfig& _o) const
{
    if ((!((naturalBounds()) == ((_o).naturalBounds())))) {
        return false;
    }
    if ((!((rotation()) == ((_o).rotation())))) {
        return false;
    }
    if ((!((clientBounds()) == ((_o).clientBounds())))) {
        return false;
    }
    if ((!((orientation()) == ((_o).orientation())))) {
        return false;
    }
    return true;
}

void
TargetConfig::Init()
{
}

void
TargetConfig::Assign(
        const nsIntRect& _naturalBounds,
        const ScreenRotation& _rotation,
        const nsIntRect& _clientBounds,
        const ScreenOrientation& _orientation)
{
    naturalBounds_ = _naturalBounds;
    rotation_ = _rotation;
    clientBounds_ = _clientBounds;
    orientation_ = _orientation;
}

} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct OpCreateThebesLayer|
//
namespace mozilla {
namespace layers {
OpCreateThebesLayer::OpCreateThebesLayer()
{
    Init();
}

OpCreateThebesLayer::~OpCreateThebesLayer()
{
}

bool
OpCreateThebesLayer::operator==(const OpCreateThebesLayer& _o) const
{
    if ((!((layerParent()) == ((_o).layerParent())))) {
        return false;
    }
    if ((!((layerChild()) == ((_o).layerChild())))) {
        return false;
    }
    return true;
}

void
OpCreateThebesLayer::Init()
{
    layerParent_ = 0;
    layerChild_ = 0;
}

void
OpCreateThebesLayer::Assign(
        PLayerParent* _layerParent,
        PLayerChild* _layerChild)
{
    layerParent_ = _layerParent;
    layerChild_ = _layerChild;
}

} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct OpCreateContainerLayer|
//
namespace mozilla {
namespace layers {
OpCreateContainerLayer::OpCreateContainerLayer()
{
    Init();
}

OpCreateContainerLayer::~OpCreateContainerLayer()
{
}

bool
OpCreateContainerLayer::operator==(const OpCreateContainerLayer& _o) const
{
    if ((!((layerParent()) == ((_o).layerParent())))) {
        return false;
    }
    if ((!((layerChild()) == ((_o).layerChild())))) {
        return false;
    }
    return true;
}

void
OpCreateContainerLayer::Init()
{
    layerParent_ = 0;
    layerChild_ = 0;
}

void
OpCreateContainerLayer::Assign(
        PLayerParent* _layerParent,
        PLayerChild* _layerChild)
{
    layerParent_ = _layerParent;
    layerChild_ = _layerChild;
}

} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct OpCreateImageLayer|
//
namespace mozilla {
namespace layers {
OpCreateImageLayer::OpCreateImageLayer()
{
    Init();
}

OpCreateImageLayer::~OpCreateImageLayer()
{
}

bool
OpCreateImageLayer::operator==(const OpCreateImageLayer& _o) const
{
    if ((!((layerParent()) == ((_o).layerParent())))) {
        return false;
    }
    if ((!((layerChild()) == ((_o).layerChild())))) {
        return false;
    }
    return true;
}

void
OpCreateImageLayer::Init()
{
    layerParent_ = 0;
    layerChild_ = 0;
}

void
OpCreateImageLayer::Assign(
        PLayerParent* _layerParent,
        PLayerChild* _layerChild)
{
    layerParent_ = _layerParent;
    layerChild_ = _layerChild;
}

} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct OpCreateColorLayer|
//
namespace mozilla {
namespace layers {
OpCreateColorLayer::OpCreateColorLayer()
{
    Init();
}

OpCreateColorLayer::~OpCreateColorLayer()
{
}

bool
OpCreateColorLayer::operator==(const OpCreateColorLayer& _o) const
{
    if ((!((layerParent()) == ((_o).layerParent())))) {
        return false;
    }
    if ((!((layerChild()) == ((_o).layerChild())))) {
        return false;
    }
    return true;
}

void
OpCreateColorLayer::Init()
{
    layerParent_ = 0;
    layerChild_ = 0;
}

void
OpCreateColorLayer::Assign(
        PLayerParent* _layerParent,
        PLayerChild* _layerChild)
{
    layerParent_ = _layerParent;
    layerChild_ = _layerChild;
}

} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct OpCreateCanvasLayer|
//
namespace mozilla {
namespace layers {
OpCreateCanvasLayer::OpCreateCanvasLayer()
{
    Init();
}

OpCreateCanvasLayer::~OpCreateCanvasLayer()
{
}

bool
OpCreateCanvasLayer::operator==(const OpCreateCanvasLayer& _o) const
{
    if ((!((layerParent()) == ((_o).layerParent())))) {
        return false;
    }
    if ((!((layerChild()) == ((_o).layerChild())))) {
        return false;
    }
    return true;
}

void
OpCreateCanvasLayer::Init()
{
    layerParent_ = 0;
    layerChild_ = 0;
}

void
OpCreateCanvasLayer::Assign(
        PLayerParent* _layerParent,
        PLayerChild* _layerChild)
{
    layerParent_ = _layerParent;
    layerChild_ = _layerChild;
}

} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct OpCreateRefLayer|
//
namespace mozilla {
namespace layers {
OpCreateRefLayer::OpCreateRefLayer()
{
    Init();
}

OpCreateRefLayer::~OpCreateRefLayer()
{
}

bool
OpCreateRefLayer::operator==(const OpCreateRefLayer& _o) const
{
    if ((!((layerParent()) == ((_o).layerParent())))) {
        return false;
    }
    if ((!((layerChild()) == ((_o).layerChild())))) {
        return false;
    }
    return true;
}

void
OpCreateRefLayer::Init()
{
    layerParent_ = 0;
    layerChild_ = 0;
}

void
OpCreateRefLayer::Assign(
        PLayerParent* _layerParent,
        PLayerChild* _layerChild)
{
    layerParent_ = _layerParent;
    layerChild_ = _layerChild;
}

} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct ThebesBuffer|
//
namespace mozilla {
namespace layers {
ThebesBuffer::ThebesBuffer()
{
    Init();
}

ThebesBuffer::~ThebesBuffer()
{
}

bool
ThebesBuffer::operator==(const ThebesBuffer& _o) const
{
    if ((!((buffer()) == ((_o).buffer())))) {
        return false;
    }
    if ((!((rect()) == ((_o).rect())))) {
        return false;
    }
    if ((!((rotation()) == ((_o).rotation())))) {
        return false;
    }
    return true;
}

void
ThebesBuffer::Init()
{
}

void
ThebesBuffer::Assign(
        const SurfaceDescriptor& _buffer,
        const nsIntRect& _rect,
        const nsIntPoint& _rotation)
{
    buffer_ = _buffer;
    rect_ = _rect;
    rotation_ = _rotation;
}

} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |union OptionalThebesBuffer|
//
namespace mozilla {
namespace layers {
bool
OptionalThebesBuffer::MaybeDestroy(Type aNewType)
{
    if ((mType) == (T__None)) {
        return true;
    }
    if ((mType) == (aNewType)) {
        return false;
    }
    switch (mType) {
    case TThebesBuffer:
        {
            (ptr_ThebesBuffer())->~ThebesBuffer__tdef();
            break;
        }
    case Tnull_t:
        {
            (ptr_null_t())->~null_t__tdef();
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("not reached");
            break;
        }
    }
    return true;
}

OptionalThebesBuffer::OptionalThebesBuffer(const ThebesBuffer& aOther)
{
    new (ptr_ThebesBuffer()) ThebesBuffer(aOther);
    mType = TThebesBuffer;
}

OptionalThebesBuffer::OptionalThebesBuffer(const null_t& aOther)
{
    new (ptr_null_t()) null_t(aOther);
    mType = Tnull_t;
}

OptionalThebesBuffer::OptionalThebesBuffer(const OptionalThebesBuffer& aOther)
{
    (aOther).AssertSanity();
    switch ((aOther).type()) {
    case TThebesBuffer:
        {
            new (ptr_ThebesBuffer()) ThebesBuffer((aOther).get_ThebesBuffer());
            break;
        }
    case Tnull_t:
        {
            new (ptr_null_t()) null_t((aOther).get_null_t());
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return;
        }
    }
    mType = (aOther).type();
}

OptionalThebesBuffer::~OptionalThebesBuffer()
{
    MaybeDestroy(T__None);
}

OptionalThebesBuffer&
OptionalThebesBuffer::operator=(const ThebesBuffer& aRhs)
{
    if (MaybeDestroy(TThebesBuffer)) {
        new (ptr_ThebesBuffer()) ThebesBuffer;
    }
    (*(ptr_ThebesBuffer())) = aRhs;
    mType = TThebesBuffer;
    return (*(this));
}

OptionalThebesBuffer&
OptionalThebesBuffer::operator=(const null_t& aRhs)
{
    if (MaybeDestroy(Tnull_t)) {
        new (ptr_null_t()) null_t;
    }
    (*(ptr_null_t())) = aRhs;
    mType = Tnull_t;
    return (*(this));
}

OptionalThebesBuffer&
OptionalThebesBuffer::operator=(const OptionalThebesBuffer& aRhs)
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case TThebesBuffer:
        {
            if (MaybeDestroy(t)) {
                new (ptr_ThebesBuffer()) ThebesBuffer;
            }
            (*(ptr_ThebesBuffer())) = (aRhs).get_ThebesBuffer();
            break;
        }
    case Tnull_t:
        {
            if (MaybeDestroy(t)) {
                new (ptr_null_t()) null_t;
            }
            (*(ptr_null_t())) = (aRhs).get_null_t();
            break;
        }
    case T__None:
        {
            MaybeDestroy(t);
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            break;
        }
    }
    mType = t;
    return (*(this));
}

bool
OptionalThebesBuffer::operator==(const ThebesBuffer& aRhs) const
{
    return (get_ThebesBuffer()) == (aRhs);
}

bool
OptionalThebesBuffer::operator==(const null_t& aRhs) const
{
    return (get_null_t()) == (aRhs);
}

bool
OptionalThebesBuffer::operator==(const OptionalThebesBuffer& aRhs) const
{
    if ((type()) != ((aRhs).type())) {
        return false;
    }

    switch (type()) {
    case TThebesBuffer:
        {
            return (get_ThebesBuffer()) == ((aRhs).get_ThebesBuffer());
        }
    case Tnull_t:
        {
            return (get_null_t()) == ((aRhs).get_null_t());
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return false;
        }
    }
}

} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |union CanvasSurface|
//
namespace mozilla {
namespace layers {
bool
CanvasSurface::MaybeDestroy(Type aNewType)
{
    if ((mType) == (T__None)) {
        return true;
    }
    if ((mType) == (aNewType)) {
        return false;
    }
    switch (mType) {
    case TSurfaceDescriptor:
        {
            (ptr_SurfaceDescriptor())->~SurfaceDescriptor__tdef();
            break;
        }
    case Tnull_t:
        {
            (ptr_null_t())->~null_t__tdef();
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("not reached");
            break;
        }
    }
    return true;
}

CanvasSurface::CanvasSurface(const SurfaceDescriptor& aOther)
{
    new (ptr_SurfaceDescriptor()) SurfaceDescriptor(aOther);
    mType = TSurfaceDescriptor;
}

CanvasSurface::CanvasSurface(const null_t& aOther)
{
    new (ptr_null_t()) null_t(aOther);
    mType = Tnull_t;
}

CanvasSurface::CanvasSurface(const CanvasSurface& aOther)
{
    (aOther).AssertSanity();
    switch ((aOther).type()) {
    case TSurfaceDescriptor:
        {
            new (ptr_SurfaceDescriptor()) SurfaceDescriptor((aOther).get_SurfaceDescriptor());
            break;
        }
    case Tnull_t:
        {
            new (ptr_null_t()) null_t((aOther).get_null_t());
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return;
        }
    }
    mType = (aOther).type();
}

CanvasSurface::~CanvasSurface()
{
    MaybeDestroy(T__None);
}

CanvasSurface&
CanvasSurface::operator=(const SurfaceDescriptor& aRhs)
{
    if (MaybeDestroy(TSurfaceDescriptor)) {
        new (ptr_SurfaceDescriptor()) SurfaceDescriptor;
    }
    (*(ptr_SurfaceDescriptor())) = aRhs;
    mType = TSurfaceDescriptor;
    return (*(this));
}

CanvasSurface&
CanvasSurface::operator=(const null_t& aRhs)
{
    if (MaybeDestroy(Tnull_t)) {
        new (ptr_null_t()) null_t;
    }
    (*(ptr_null_t())) = aRhs;
    mType = Tnull_t;
    return (*(this));
}

CanvasSurface&
CanvasSurface::operator=(const CanvasSurface& aRhs)
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case TSurfaceDescriptor:
        {
            if (MaybeDestroy(t)) {
                new (ptr_SurfaceDescriptor()) SurfaceDescriptor;
            }
            (*(ptr_SurfaceDescriptor())) = (aRhs).get_SurfaceDescriptor();
            break;
        }
    case Tnull_t:
        {
            if (MaybeDestroy(t)) {
                new (ptr_null_t()) null_t;
            }
            (*(ptr_null_t())) = (aRhs).get_null_t();
            break;
        }
    case T__None:
        {
            MaybeDestroy(t);
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            break;
        }
    }
    mType = t;
    return (*(this));
}

bool
CanvasSurface::operator==(const SurfaceDescriptor& aRhs) const
{
    return (get_SurfaceDescriptor()) == (aRhs);
}

bool
CanvasSurface::operator==(const null_t& aRhs) const
{
    return (get_null_t()) == (aRhs);
}

bool
CanvasSurface::operator==(const CanvasSurface& aRhs) const
{
    if ((type()) != ((aRhs).type())) {
        return false;
    }

    switch (type()) {
    case TSurfaceDescriptor:
        {
            return (get_SurfaceDescriptor()) == ((aRhs).get_SurfaceDescriptor());
        }
    case Tnull_t:
        {
            return (get_null_t()) == ((aRhs).get_null_t());
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return false;
        }
    }
}

} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct CubicBezierFunction|
//
namespace mozilla {
namespace layers {
CubicBezierFunction::CubicBezierFunction()
{
    Init();
}

CubicBezierFunction::~CubicBezierFunction()
{
}

bool
CubicBezierFunction::operator==(const CubicBezierFunction& _o) const
{
    if ((!((x1()) == ((_o).x1())))) {
        return false;
    }
    if ((!((y1()) == ((_o).y1())))) {
        return false;
    }
    if ((!((x2()) == ((_o).x2())))) {
        return false;
    }
    if ((!((y2()) == ((_o).y2())))) {
        return false;
    }
    return true;
}

void
CubicBezierFunction::Init()
{
}

void
CubicBezierFunction::Assign(
        const float& _x1,
        const float& _y1,
        const float& _x2,
        const float& _y2)
{
    x1_ = _x1;
    y1_ = _y1;
    x2_ = _x2;
    y2_ = _y2;
}

} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct StepFunction|
//
namespace mozilla {
namespace layers {
StepFunction::StepFunction()
{
    Init();
}

StepFunction::~StepFunction()
{
}

bool
StepFunction::operator==(const StepFunction& _o) const
{
    if ((!((steps()) == ((_o).steps())))) {
        return false;
    }
    if ((!((type()) == ((_o).type())))) {
        return false;
    }
    return true;
}

void
StepFunction::Init()
{
}

void
StepFunction::Assign(
        const int& _steps,
        const int& _type)
{
    steps_ = _steps;
    type_ = _type;
}

} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |union TimingFunction|
//
namespace mozilla {
namespace layers {
bool
TimingFunction::MaybeDestroy(Type aNewType)
{
    if ((mType) == (T__None)) {
        return true;
    }
    if ((mType) == (aNewType)) {
        return false;
    }
    switch (mType) {
    case TCubicBezierFunction:
        {
            (ptr_CubicBezierFunction())->~CubicBezierFunction__tdef();
            break;
        }
    case TStepFunction:
        {
            (ptr_StepFunction())->~StepFunction__tdef();
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("not reached");
            break;
        }
    }
    return true;
}

TimingFunction::TimingFunction(const CubicBezierFunction& aOther)
{
    new (ptr_CubicBezierFunction()) CubicBezierFunction(aOther);
    mType = TCubicBezierFunction;
}

TimingFunction::TimingFunction(const StepFunction& aOther)
{
    new (ptr_StepFunction()) StepFunction(aOther);
    mType = TStepFunction;
}

TimingFunction::TimingFunction(const TimingFunction& aOther)
{
    (aOther).AssertSanity();
    switch ((aOther).type()) {
    case TCubicBezierFunction:
        {
            new (ptr_CubicBezierFunction()) CubicBezierFunction((aOther).get_CubicBezierFunction());
            break;
        }
    case TStepFunction:
        {
            new (ptr_StepFunction()) StepFunction((aOther).get_StepFunction());
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return;
        }
    }
    mType = (aOther).type();
}

TimingFunction::~TimingFunction()
{
    MaybeDestroy(T__None);
}

TimingFunction&
TimingFunction::operator=(const CubicBezierFunction& aRhs)
{
    if (MaybeDestroy(TCubicBezierFunction)) {
        new (ptr_CubicBezierFunction()) CubicBezierFunction;
    }
    (*(ptr_CubicBezierFunction())) = aRhs;
    mType = TCubicBezierFunction;
    return (*(this));
}

TimingFunction&
TimingFunction::operator=(const StepFunction& aRhs)
{
    if (MaybeDestroy(TStepFunction)) {
        new (ptr_StepFunction()) StepFunction;
    }
    (*(ptr_StepFunction())) = aRhs;
    mType = TStepFunction;
    return (*(this));
}

TimingFunction&
TimingFunction::operator=(const TimingFunction& aRhs)
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case TCubicBezierFunction:
        {
            if (MaybeDestroy(t)) {
                new (ptr_CubicBezierFunction()) CubicBezierFunction;
            }
            (*(ptr_CubicBezierFunction())) = (aRhs).get_CubicBezierFunction();
            break;
        }
    case TStepFunction:
        {
            if (MaybeDestroy(t)) {
                new (ptr_StepFunction()) StepFunction;
            }
            (*(ptr_StepFunction())) = (aRhs).get_StepFunction();
            break;
        }
    case T__None:
        {
            MaybeDestroy(t);
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            break;
        }
    }
    mType = t;
    return (*(this));
}

bool
TimingFunction::operator==(const CubicBezierFunction& aRhs) const
{
    return (get_CubicBezierFunction()) == (aRhs);
}

bool
TimingFunction::operator==(const StepFunction& aRhs) const
{
    return (get_StepFunction()) == (aRhs);
}

bool
TimingFunction::operator==(const TimingFunction& aRhs) const
{
    if ((type()) != ((aRhs).type())) {
        return false;
    }

    switch (type()) {
    case TCubicBezierFunction:
        {
            return (get_CubicBezierFunction()) == ((aRhs).get_CubicBezierFunction());
        }
    case TStepFunction:
        {
            return (get_StepFunction()) == ((aRhs).get_StepFunction());
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return false;
        }
    }
}

} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct Color|
//
namespace mozilla {
namespace layers {
Color::Color()
{
    Init();
}

Color::~Color()
{
}

bool
Color::operator==(const Color& _o) const
{
    if ((!((value()) == ((_o).value())))) {
        return false;
    }
    return true;
}

void
Color::Init()
{
}

void
Color::Assign(const gfxRGBA& _value)
{
    value_ = _value;
}

} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct Perspective|
//
namespace mozilla {
namespace layers {
Perspective::Perspective()
{
    Init();
}

Perspective::~Perspective()
{
}

bool
Perspective::operator==(const Perspective& _o) const
{
    if ((!((value()) == ((_o).value())))) {
        return false;
    }
    return true;
}

void
Perspective::Init()
{
}

void
Perspective::Assign(const float& _value)
{
    value_ = _value;
}

} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct RotationX|
//
namespace mozilla {
namespace layers {
RotationX::RotationX()
{
    Init();
}

RotationX::~RotationX()
{
}

bool
RotationX::operator==(const RotationX& _o) const
{
    if ((!((radians()) == ((_o).radians())))) {
        return false;
    }
    return true;
}

void
RotationX::Init()
{
}

void
RotationX::Assign(const float& _radians)
{
    radians_ = _radians;
}

} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct RotationY|
//
namespace mozilla {
namespace layers {
RotationY::RotationY()
{
    Init();
}

RotationY::~RotationY()
{
}

bool
RotationY::operator==(const RotationY& _o) const
{
    if ((!((radians()) == ((_o).radians())))) {
        return false;
    }
    return true;
}

void
RotationY::Init()
{
}

void
RotationY::Assign(const float& _radians)
{
    radians_ = _radians;
}

} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct RotationZ|
//
namespace mozilla {
namespace layers {
RotationZ::RotationZ()
{
    Init();
}

RotationZ::~RotationZ()
{
}

bool
RotationZ::operator==(const RotationZ& _o) const
{
    if ((!((radians()) == ((_o).radians())))) {
        return false;
    }
    return true;
}

void
RotationZ::Init()
{
}

void
RotationZ::Assign(const float& _radians)
{
    radians_ = _radians;
}

} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct Rotation|
//
namespace mozilla {
namespace layers {
Rotation::Rotation()
{
    Init();
}

Rotation::~Rotation()
{
}

bool
Rotation::operator==(const Rotation& _o) const
{
    if ((!((radians()) == ((_o).radians())))) {
        return false;
    }
    return true;
}

void
Rotation::Init()
{
}

void
Rotation::Assign(const float& _radians)
{
    radians_ = _radians;
}

} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct Rotation3D|
//
namespace mozilla {
namespace layers {
Rotation3D::Rotation3D()
{
    Init();
}

Rotation3D::~Rotation3D()
{
}

bool
Rotation3D::operator==(const Rotation3D& _o) const
{
    if ((!((x()) == ((_o).x())))) {
        return false;
    }
    if ((!((y()) == ((_o).y())))) {
        return false;
    }
    if ((!((z()) == ((_o).z())))) {
        return false;
    }
    if ((!((radians()) == ((_o).radians())))) {
        return false;
    }
    return true;
}

void
Rotation3D::Init()
{
}

void
Rotation3D::Assign(
        const float& _x,
        const float& _y,
        const float& _z,
        const float& _radians)
{
    x_ = _x;
    y_ = _y;
    z_ = _z;
    radians_ = _radians;
}

} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct Scale|
//
namespace mozilla {
namespace layers {
Scale::Scale()
{
    Init();
}

Scale::~Scale()
{
}

bool
Scale::operator==(const Scale& _o) const
{
    if ((!((x()) == ((_o).x())))) {
        return false;
    }
    if ((!((y()) == ((_o).y())))) {
        return false;
    }
    if ((!((z()) == ((_o).z())))) {
        return false;
    }
    return true;
}

void
Scale::Init()
{
}

void
Scale::Assign(
        const float& _x,
        const float& _y,
        const float& _z)
{
    x_ = _x;
    y_ = _y;
    z_ = _z;
}

} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct SkewX|
//
namespace mozilla {
namespace layers {
SkewX::SkewX()
{
    Init();
}

SkewX::~SkewX()
{
}

bool
SkewX::operator==(const SkewX& _o) const
{
    if ((!((x()) == ((_o).x())))) {
        return false;
    }
    return true;
}

void
SkewX::Init()
{
}

void
SkewX::Assign(const float& _x)
{
    x_ = _x;
}

} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct SkewY|
//
namespace mozilla {
namespace layers {
SkewY::SkewY()
{
    Init();
}

SkewY::~SkewY()
{
}

bool
SkewY::operator==(const SkewY& _o) const
{
    if ((!((y()) == ((_o).y())))) {
        return false;
    }
    return true;
}

void
SkewY::Init()
{
}

void
SkewY::Assign(const float& _y)
{
    y_ = _y;
}

} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct TransformMatrix|
//
namespace mozilla {
namespace layers {
TransformMatrix::TransformMatrix()
{
    Init();
}

TransformMatrix::~TransformMatrix()
{
}

bool
TransformMatrix::operator==(const TransformMatrix& _o) const
{
    if ((!((value()) == ((_o).value())))) {
        return false;
    }
    return true;
}

void
TransformMatrix::Init()
{
}

void
TransformMatrix::Assign(const gfx3DMatrix& _value)
{
    value_ = _value;
}

} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct Translation|
//
namespace mozilla {
namespace layers {
Translation::Translation()
{
    Init();
}

Translation::~Translation()
{
}

bool
Translation::operator==(const Translation& _o) const
{
    if ((!((x()) == ((_o).x())))) {
        return false;
    }
    if ((!((y()) == ((_o).y())))) {
        return false;
    }
    if ((!((z()) == ((_o).z())))) {
        return false;
    }
    return true;
}

void
Translation::Init()
{
}

void
Translation::Assign(
        const float& _x,
        const float& _y,
        const float& _z)
{
    x_ = _x;
    y_ = _y;
    z_ = _z;
}

} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |union TransformFunction|
//
namespace mozilla {
namespace layers {
bool
TransformFunction::MaybeDestroy(Type aNewType)
{
    if ((mType) == (T__None)) {
        return true;
    }
    if ((mType) == (aNewType)) {
        return false;
    }
    switch (mType) {
    case TPerspective:
        {
            (ptr_Perspective())->~Perspective__tdef();
            break;
        }
    case TRotationX:
        {
            (ptr_RotationX())->~RotationX__tdef();
            break;
        }
    case TRotationY:
        {
            (ptr_RotationY())->~RotationY__tdef();
            break;
        }
    case TRotationZ:
        {
            (ptr_RotationZ())->~RotationZ__tdef();
            break;
        }
    case TRotation:
        {
            (ptr_Rotation())->~Rotation__tdef();
            break;
        }
    case TRotation3D:
        {
            (ptr_Rotation3D())->~Rotation3D__tdef();
            break;
        }
    case TScale:
        {
            (ptr_Scale())->~Scale__tdef();
            break;
        }
    case TSkewX:
        {
            (ptr_SkewX())->~SkewX__tdef();
            break;
        }
    case TSkewY:
        {
            (ptr_SkewY())->~SkewY__tdef();
            break;
        }
    case TTranslation:
        {
            (ptr_Translation())->~Translation__tdef();
            break;
        }
    case TTransformMatrix:
        {
            (ptr_TransformMatrix())->~TransformMatrix__tdef();
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("not reached");
            break;
        }
    }
    return true;
}

TransformFunction::TransformFunction(const Perspective& aOther)
{
    new (ptr_Perspective()) Perspective(aOther);
    mType = TPerspective;
}

TransformFunction::TransformFunction(const RotationX& aOther)
{
    new (ptr_RotationX()) RotationX(aOther);
    mType = TRotationX;
}

TransformFunction::TransformFunction(const RotationY& aOther)
{
    new (ptr_RotationY()) RotationY(aOther);
    mType = TRotationY;
}

TransformFunction::TransformFunction(const RotationZ& aOther)
{
    new (ptr_RotationZ()) RotationZ(aOther);
    mType = TRotationZ;
}

TransformFunction::TransformFunction(const Rotation& aOther)
{
    new (ptr_Rotation()) Rotation(aOther);
    mType = TRotation;
}

TransformFunction::TransformFunction(const Rotation3D& aOther)
{
    new (ptr_Rotation3D()) Rotation3D(aOther);
    mType = TRotation3D;
}

TransformFunction::TransformFunction(const Scale& aOther)
{
    new (ptr_Scale()) Scale(aOther);
    mType = TScale;
}

TransformFunction::TransformFunction(const SkewX& aOther)
{
    new (ptr_SkewX()) SkewX(aOther);
    mType = TSkewX;
}

TransformFunction::TransformFunction(const SkewY& aOther)
{
    new (ptr_SkewY()) SkewY(aOther);
    mType = TSkewY;
}

TransformFunction::TransformFunction(const Translation& aOther)
{
    new (ptr_Translation()) Translation(aOther);
    mType = TTranslation;
}

TransformFunction::TransformFunction(const TransformMatrix& aOther)
{
    new (ptr_TransformMatrix()) TransformMatrix(aOther);
    mType = TTransformMatrix;
}

TransformFunction::TransformFunction(const TransformFunction& aOther)
{
    (aOther).AssertSanity();
    switch ((aOther).type()) {
    case TPerspective:
        {
            new (ptr_Perspective()) Perspective((aOther).get_Perspective());
            break;
        }
    case TRotationX:
        {
            new (ptr_RotationX()) RotationX((aOther).get_RotationX());
            break;
        }
    case TRotationY:
        {
            new (ptr_RotationY()) RotationY((aOther).get_RotationY());
            break;
        }
    case TRotationZ:
        {
            new (ptr_RotationZ()) RotationZ((aOther).get_RotationZ());
            break;
        }
    case TRotation:
        {
            new (ptr_Rotation()) Rotation((aOther).get_Rotation());
            break;
        }
    case TRotation3D:
        {
            new (ptr_Rotation3D()) Rotation3D((aOther).get_Rotation3D());
            break;
        }
    case TScale:
        {
            new (ptr_Scale()) Scale((aOther).get_Scale());
            break;
        }
    case TSkewX:
        {
            new (ptr_SkewX()) SkewX((aOther).get_SkewX());
            break;
        }
    case TSkewY:
        {
            new (ptr_SkewY()) SkewY((aOther).get_SkewY());
            break;
        }
    case TTranslation:
        {
            new (ptr_Translation()) Translation((aOther).get_Translation());
            break;
        }
    case TTransformMatrix:
        {
            new (ptr_TransformMatrix()) TransformMatrix((aOther).get_TransformMatrix());
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return;
        }
    }
    mType = (aOther).type();
}

TransformFunction::~TransformFunction()
{
    MaybeDestroy(T__None);
}

TransformFunction&
TransformFunction::operator=(const Perspective& aRhs)
{
    if (MaybeDestroy(TPerspective)) {
        new (ptr_Perspective()) Perspective;
    }
    (*(ptr_Perspective())) = aRhs;
    mType = TPerspective;
    return (*(this));
}

TransformFunction&
TransformFunction::operator=(const RotationX& aRhs)
{
    if (MaybeDestroy(TRotationX)) {
        new (ptr_RotationX()) RotationX;
    }
    (*(ptr_RotationX())) = aRhs;
    mType = TRotationX;
    return (*(this));
}

TransformFunction&
TransformFunction::operator=(const RotationY& aRhs)
{
    if (MaybeDestroy(TRotationY)) {
        new (ptr_RotationY()) RotationY;
    }
    (*(ptr_RotationY())) = aRhs;
    mType = TRotationY;
    return (*(this));
}

TransformFunction&
TransformFunction::operator=(const RotationZ& aRhs)
{
    if (MaybeDestroy(TRotationZ)) {
        new (ptr_RotationZ()) RotationZ;
    }
    (*(ptr_RotationZ())) = aRhs;
    mType = TRotationZ;
    return (*(this));
}

TransformFunction&
TransformFunction::operator=(const Rotation& aRhs)
{
    if (MaybeDestroy(TRotation)) {
        new (ptr_Rotation()) Rotation;
    }
    (*(ptr_Rotation())) = aRhs;
    mType = TRotation;
    return (*(this));
}

TransformFunction&
TransformFunction::operator=(const Rotation3D& aRhs)
{
    if (MaybeDestroy(TRotation3D)) {
        new (ptr_Rotation3D()) Rotation3D;
    }
    (*(ptr_Rotation3D())) = aRhs;
    mType = TRotation3D;
    return (*(this));
}

TransformFunction&
TransformFunction::operator=(const Scale& aRhs)
{
    if (MaybeDestroy(TScale)) {
        new (ptr_Scale()) Scale;
    }
    (*(ptr_Scale())) = aRhs;
    mType = TScale;
    return (*(this));
}

TransformFunction&
TransformFunction::operator=(const SkewX& aRhs)
{
    if (MaybeDestroy(TSkewX)) {
        new (ptr_SkewX()) SkewX;
    }
    (*(ptr_SkewX())) = aRhs;
    mType = TSkewX;
    return (*(this));
}

TransformFunction&
TransformFunction::operator=(const SkewY& aRhs)
{
    if (MaybeDestroy(TSkewY)) {
        new (ptr_SkewY()) SkewY;
    }
    (*(ptr_SkewY())) = aRhs;
    mType = TSkewY;
    return (*(this));
}

TransformFunction&
TransformFunction::operator=(const Translation& aRhs)
{
    if (MaybeDestroy(TTranslation)) {
        new (ptr_Translation()) Translation;
    }
    (*(ptr_Translation())) = aRhs;
    mType = TTranslation;
    return (*(this));
}

TransformFunction&
TransformFunction::operator=(const TransformMatrix& aRhs)
{
    if (MaybeDestroy(TTransformMatrix)) {
        new (ptr_TransformMatrix()) TransformMatrix;
    }
    (*(ptr_TransformMatrix())) = aRhs;
    mType = TTransformMatrix;
    return (*(this));
}

TransformFunction&
TransformFunction::operator=(const TransformFunction& aRhs)
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case TPerspective:
        {
            if (MaybeDestroy(t)) {
                new (ptr_Perspective()) Perspective;
            }
            (*(ptr_Perspective())) = (aRhs).get_Perspective();
            break;
        }
    case TRotationX:
        {
            if (MaybeDestroy(t)) {
                new (ptr_RotationX()) RotationX;
            }
            (*(ptr_RotationX())) = (aRhs).get_RotationX();
            break;
        }
    case TRotationY:
        {
            if (MaybeDestroy(t)) {
                new (ptr_RotationY()) RotationY;
            }
            (*(ptr_RotationY())) = (aRhs).get_RotationY();
            break;
        }
    case TRotationZ:
        {
            if (MaybeDestroy(t)) {
                new (ptr_RotationZ()) RotationZ;
            }
            (*(ptr_RotationZ())) = (aRhs).get_RotationZ();
            break;
        }
    case TRotation:
        {
            if (MaybeDestroy(t)) {
                new (ptr_Rotation()) Rotation;
            }
            (*(ptr_Rotation())) = (aRhs).get_Rotation();
            break;
        }
    case TRotation3D:
        {
            if (MaybeDestroy(t)) {
                new (ptr_Rotation3D()) Rotation3D;
            }
            (*(ptr_Rotation3D())) = (aRhs).get_Rotation3D();
            break;
        }
    case TScale:
        {
            if (MaybeDestroy(t)) {
                new (ptr_Scale()) Scale;
            }
            (*(ptr_Scale())) = (aRhs).get_Scale();
            break;
        }
    case TSkewX:
        {
            if (MaybeDestroy(t)) {
                new (ptr_SkewX()) SkewX;
            }
            (*(ptr_SkewX())) = (aRhs).get_SkewX();
            break;
        }
    case TSkewY:
        {
            if (MaybeDestroy(t)) {
                new (ptr_SkewY()) SkewY;
            }
            (*(ptr_SkewY())) = (aRhs).get_SkewY();
            break;
        }
    case TTranslation:
        {
            if (MaybeDestroy(t)) {
                new (ptr_Translation()) Translation;
            }
            (*(ptr_Translation())) = (aRhs).get_Translation();
            break;
        }
    case TTransformMatrix:
        {
            if (MaybeDestroy(t)) {
                new (ptr_TransformMatrix()) TransformMatrix;
            }
            (*(ptr_TransformMatrix())) = (aRhs).get_TransformMatrix();
            break;
        }
    case T__None:
        {
            MaybeDestroy(t);
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            break;
        }
    }
    mType = t;
    return (*(this));
}

bool
TransformFunction::operator==(const Perspective& aRhs) const
{
    return (get_Perspective()) == (aRhs);
}

bool
TransformFunction::operator==(const RotationX& aRhs) const
{
    return (get_RotationX()) == (aRhs);
}

bool
TransformFunction::operator==(const RotationY& aRhs) const
{
    return (get_RotationY()) == (aRhs);
}

bool
TransformFunction::operator==(const RotationZ& aRhs) const
{
    return (get_RotationZ()) == (aRhs);
}

bool
TransformFunction::operator==(const Rotation& aRhs) const
{
    return (get_Rotation()) == (aRhs);
}

bool
TransformFunction::operator==(const Rotation3D& aRhs) const
{
    return (get_Rotation3D()) == (aRhs);
}

bool
TransformFunction::operator==(const Scale& aRhs) const
{
    return (get_Scale()) == (aRhs);
}

bool
TransformFunction::operator==(const SkewX& aRhs) const
{
    return (get_SkewX()) == (aRhs);
}

bool
TransformFunction::operator==(const SkewY& aRhs) const
{
    return (get_SkewY()) == (aRhs);
}

bool
TransformFunction::operator==(const Translation& aRhs) const
{
    return (get_Translation()) == (aRhs);
}

bool
TransformFunction::operator==(const TransformMatrix& aRhs) const
{
    return (get_TransformMatrix()) == (aRhs);
}

bool
TransformFunction::operator==(const TransformFunction& aRhs) const
{
    if ((type()) != ((aRhs).type())) {
        return false;
    }

    switch (type()) {
    case TPerspective:
        {
            return (get_Perspective()) == ((aRhs).get_Perspective());
        }
    case TRotationX:
        {
            return (get_RotationX()) == ((aRhs).get_RotationX());
        }
    case TRotationY:
        {
            return (get_RotationY()) == ((aRhs).get_RotationY());
        }
    case TRotationZ:
        {
            return (get_RotationZ()) == ((aRhs).get_RotationZ());
        }
    case TRotation:
        {
            return (get_Rotation()) == ((aRhs).get_Rotation());
        }
    case TRotation3D:
        {
            return (get_Rotation3D()) == ((aRhs).get_Rotation3D());
        }
    case TScale:
        {
            return (get_Scale()) == ((aRhs).get_Scale());
        }
    case TSkewX:
        {
            return (get_SkewX()) == ((aRhs).get_SkewX());
        }
    case TSkewY:
        {
            return (get_SkewY()) == ((aRhs).get_SkewY());
        }
    case TTranslation:
        {
            return (get_Translation()) == ((aRhs).get_Translation());
        }
    case TTransformMatrix:
        {
            return (get_TransformMatrix()) == ((aRhs).get_TransformMatrix());
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return false;
        }
    }
}

} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |union Animatable|
//
namespace mozilla {
namespace layers {
bool
Animatable::MaybeDestroy(Type aNewType)
{
    if ((mType) == (T__None)) {
        return true;
    }
    if ((mType) == (aNewType)) {
        return false;
    }
    switch (mType) {
    case Tfloat:
        {
            (ptr_float())->~float__tdef();
            break;
        }
    case TArrayOfTransformFunction:
        {
            (ptr_ArrayOfTransformFunction())->~ArrayOfTransformFunction__tdef();
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("not reached");
            break;
        }
    }
    return true;
}

Animatable::Animatable(const float& aOther)
{
    new (ptr_float()) float(aOther);
    mType = Tfloat;
}

Animatable::Animatable(const InfallibleTArray<TransformFunction>& aOther)
{
    new (ptr_ArrayOfTransformFunction()) InfallibleTArray<TransformFunction>(aOther);
    mType = TArrayOfTransformFunction;
}

Animatable::Animatable(const Animatable& aOther)
{
    (aOther).AssertSanity();
    switch ((aOther).type()) {
    case Tfloat:
        {
            new (ptr_float()) float((aOther).get_float());
            break;
        }
    case TArrayOfTransformFunction:
        {
            new (ptr_ArrayOfTransformFunction()) InfallibleTArray<TransformFunction>((aOther).get_ArrayOfTransformFunction());
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return;
        }
    }
    mType = (aOther).type();
}

Animatable::~Animatable()
{
    MaybeDestroy(T__None);
}

Animatable&
Animatable::operator=(const float& aRhs)
{
    if (MaybeDestroy(Tfloat)) {
        new (ptr_float()) float;
    }
    (*(ptr_float())) = aRhs;
    mType = Tfloat;
    return (*(this));
}

Animatable&
Animatable::operator=(const InfallibleTArray<TransformFunction>& aRhs)
{
    if (MaybeDestroy(TArrayOfTransformFunction)) {
        new (ptr_ArrayOfTransformFunction()) InfallibleTArray<TransformFunction>;
    }
    (*(ptr_ArrayOfTransformFunction())) = aRhs;
    mType = TArrayOfTransformFunction;
    return (*(this));
}

Animatable&
Animatable::operator=(const Animatable& aRhs)
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case Tfloat:
        {
            if (MaybeDestroy(t)) {
                new (ptr_float()) float;
            }
            (*(ptr_float())) = (aRhs).get_float();
            break;
        }
    case TArrayOfTransformFunction:
        {
            if (MaybeDestroy(t)) {
                new (ptr_ArrayOfTransformFunction()) InfallibleTArray<TransformFunction>;
            }
            (*(ptr_ArrayOfTransformFunction())) = (aRhs).get_ArrayOfTransformFunction();
            break;
        }
    case T__None:
        {
            MaybeDestroy(t);
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            break;
        }
    }
    mType = t;
    return (*(this));
}

bool
Animatable::operator==(const float& aRhs) const
{
    return (get_float()) == (aRhs);
}

bool
Animatable::operator==(const InfallibleTArray<TransformFunction>& aRhs) const
{
    return (get_ArrayOfTransformFunction()) == (aRhs);
}

bool
Animatable::operator==(const Animatable& aRhs) const
{
    if ((type()) != ((aRhs).type())) {
        return false;
    }

    switch (type()) {
    case Tfloat:
        {
            return (get_float()) == ((aRhs).get_float());
        }
    case TArrayOfTransformFunction:
        {
            return (get_ArrayOfTransformFunction()) == ((aRhs).get_ArrayOfTransformFunction());
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return false;
        }
    }
}

} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct AnimationSegment|
//
namespace mozilla {
namespace layers {
AnimationSegment::AnimationSegment()
{
    Init();
}

AnimationSegment::~AnimationSegment()
{
}

bool
AnimationSegment::operator==(const AnimationSegment& _o) const
{
    if ((!((startState()) == ((_o).startState())))) {
        return false;
    }
    if ((!((endState()) == ((_o).endState())))) {
        return false;
    }
    if ((!((startPortion()) == ((_o).startPortion())))) {
        return false;
    }
    if ((!((endPortion()) == ((_o).endPortion())))) {
        return false;
    }
    if ((!((sampleFn()) == ((_o).sampleFn())))) {
        return false;
    }
    return true;
}

void
AnimationSegment::Init()
{
}

void
AnimationSegment::Assign(
        const Animatable& _startState,
        const Animatable& _endState,
        const float& _startPortion,
        const float& _endPortion,
        const TimingFunction& _sampleFn)
{
    startState_ = _startState;
    endState_ = _endState;
    startPortion_ = _startPortion;
    endPortion_ = _endPortion;
    sampleFn_ = _sampleFn;
}

} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct TransformData|
//
namespace mozilla {
namespace layers {
TransformData::TransformData()
{
    Init();
}

TransformData::~TransformData()
{
}

bool
TransformData::operator==(const TransformData& _o) const
{
    if ((!((origin()) == ((_o).origin())))) {
        return false;
    }
    if ((!((mozOrigin()) == ((_o).mozOrigin())))) {
        return false;
    }
    if ((!((perspectiveOrigin()) == ((_o).perspectiveOrigin())))) {
        return false;
    }
    if ((!((bounds()) == ((_o).bounds())))) {
        return false;
    }
    if ((!((perspective()) == ((_o).perspective())))) {
        return false;
    }
    return true;
}

void
TransformData::Init()
{
}

void
TransformData::Assign(
        const nsPoint& _origin,
        const gfxPoint3D& _mozOrigin,
        const gfxPoint3D& _perspectiveOrigin,
        const nsRect& _bounds,
        const nscoord& _perspective)
{
    origin_ = _origin;
    mozOrigin_ = _mozOrigin;
    perspectiveOrigin_ = _perspectiveOrigin;
    bounds_ = _bounds;
    perspective_ = _perspective;
}

} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |union AnimationData|
//
namespace mozilla {
namespace layers {
bool
AnimationData::MaybeDestroy(Type aNewType)
{
    if ((mType) == (T__None)) {
        return true;
    }
    if ((mType) == (aNewType)) {
        return false;
    }
    switch (mType) {
    case Tnull_t:
        {
            (ptr_null_t())->~null_t__tdef();
            break;
        }
    case TTransformData:
        {
            (ptr_TransformData())->~TransformData__tdef();
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("not reached");
            break;
        }
    }
    return true;
}

AnimationData::AnimationData(const null_t& aOther)
{
    new (ptr_null_t()) null_t(aOther);
    mType = Tnull_t;
}

AnimationData::AnimationData(const TransformData& aOther)
{
    new (ptr_TransformData()) TransformData(aOther);
    mType = TTransformData;
}

AnimationData::AnimationData(const AnimationData& aOther)
{
    (aOther).AssertSanity();
    switch ((aOther).type()) {
    case Tnull_t:
        {
            new (ptr_null_t()) null_t((aOther).get_null_t());
            break;
        }
    case TTransformData:
        {
            new (ptr_TransformData()) TransformData((aOther).get_TransformData());
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return;
        }
    }
    mType = (aOther).type();
}

AnimationData::~AnimationData()
{
    MaybeDestroy(T__None);
}

AnimationData&
AnimationData::operator=(const null_t& aRhs)
{
    if (MaybeDestroy(Tnull_t)) {
        new (ptr_null_t()) null_t;
    }
    (*(ptr_null_t())) = aRhs;
    mType = Tnull_t;
    return (*(this));
}

AnimationData&
AnimationData::operator=(const TransformData& aRhs)
{
    if (MaybeDestroy(TTransformData)) {
        new (ptr_TransformData()) TransformData;
    }
    (*(ptr_TransformData())) = aRhs;
    mType = TTransformData;
    return (*(this));
}

AnimationData&
AnimationData::operator=(const AnimationData& aRhs)
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case Tnull_t:
        {
            if (MaybeDestroy(t)) {
                new (ptr_null_t()) null_t;
            }
            (*(ptr_null_t())) = (aRhs).get_null_t();
            break;
        }
    case TTransformData:
        {
            if (MaybeDestroy(t)) {
                new (ptr_TransformData()) TransformData;
            }
            (*(ptr_TransformData())) = (aRhs).get_TransformData();
            break;
        }
    case T__None:
        {
            MaybeDestroy(t);
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            break;
        }
    }
    mType = t;
    return (*(this));
}

bool
AnimationData::operator==(const null_t& aRhs) const
{
    return (get_null_t()) == (aRhs);
}

bool
AnimationData::operator==(const TransformData& aRhs) const
{
    return (get_TransformData()) == (aRhs);
}

bool
AnimationData::operator==(const AnimationData& aRhs) const
{
    if ((type()) != ((aRhs).type())) {
        return false;
    }

    switch (type()) {
    case Tnull_t:
        {
            return (get_null_t()) == ((aRhs).get_null_t());
        }
    case TTransformData:
        {
            return (get_TransformData()) == ((aRhs).get_TransformData());
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return false;
        }
    }
}

} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct Animation|
//
namespace mozilla {
namespace layers {
Animation::Animation()
{
    Init();
}

Animation::~Animation()
{
}

bool
Animation::operator==(const Animation& _o) const
{
    if ((!((startTime()) == ((_o).startTime())))) {
        return false;
    }
    if ((!((duration()) == ((_o).duration())))) {
        return false;
    }
    if ((!((segments()) == ((_o).segments())))) {
        return false;
    }
    if ((!((numIterations()) == ((_o).numIterations())))) {
        return false;
    }
    if ((!((direction()) == ((_o).direction())))) {
        return false;
    }
    if ((!((property()) == ((_o).property())))) {
        return false;
    }
    if ((!((data()) == ((_o).data())))) {
        return false;
    }
    return true;
}

void
Animation::Init()
{
}

void
Animation::Assign(
        const TimeStamp& _startTime,
        const TimeDuration& _duration,
        const InfallibleTArray<AnimationSegment>& _segments,
        const float& _numIterations,
        const int32_t& _direction,
        const nsCSSProperty& _property,
        const AnimationData& _data)
{
    startTime_ = _startTime;
    duration_ = _duration;
    segments_ = _segments;
    numIterations_ = _numIterations;
    direction_ = _direction;
    property_ = _property;
    data_ = _data;
}

} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct CommonLayerAttributes|
//
namespace mozilla {
namespace layers {
CommonLayerAttributes::CommonLayerAttributes()
{
    Init();
}

CommonLayerAttributes::~CommonLayerAttributes()
{
}

bool
CommonLayerAttributes::operator==(const CommonLayerAttributes& _o) const
{
    if ((!((visibleRegion()) == ((_o).visibleRegion())))) {
        return false;
    }
    if ((!((transform()) == ((_o).transform())))) {
        return false;
    }
    if ((!((postXScale()) == ((_o).postXScale())))) {
        return false;
    }
    if ((!((postYScale()) == ((_o).postYScale())))) {
        return false;
    }
    if ((!((contentFlags()) == ((_o).contentFlags())))) {
        return false;
    }
    if ((!((opacity()) == ((_o).opacity())))) {
        return false;
    }
    if ((!((useClipRect()) == ((_o).useClipRect())))) {
        return false;
    }
    if ((!((clipRect()) == ((_o).clipRect())))) {
        return false;
    }
    if ((!((isFixedPosition()) == ((_o).isFixedPosition())))) {
        return false;
    }
    if ((!((fixedPositionAnchor()) == ((_o).fixedPositionAnchor())))) {
        return false;
    }
    if ((!((maskLayerParent()) == ((_o).maskLayerParent())))) {
        return false;
    }
    if ((!((maskLayerChild()) == ((_o).maskLayerChild())))) {
        return false;
    }
    if ((!((animations()) == ((_o).animations())))) {
        return false;
    }
    return true;
}

void
CommonLayerAttributes::Init()
{
    maskLayerParent_ = 0;
    maskLayerChild_ = 0;
}

void
CommonLayerAttributes::Assign(
        const nsIntRegion& _visibleRegion,
        const TransformMatrix& _transform,
        const float& _postXScale,
        const float& _postYScale,
        const uint32_t& _contentFlags,
        const float& _opacity,
        const bool& _useClipRect,
        const nsIntRect& _clipRect,
        const bool& _isFixedPosition,
        const gfxPoint& _fixedPositionAnchor,
        PLayerParent* _maskLayerParent,
        PLayerChild* _maskLayerChild,
        const InfallibleTArray<Animation>& _animations)
{
    visibleRegion_ = _visibleRegion;
    transform_ = _transform;
    postXScale_ = _postXScale;
    postYScale_ = _postYScale;
    contentFlags_ = _contentFlags;
    opacity_ = _opacity;
    useClipRect_ = _useClipRect;
    clipRect_ = _clipRect;
    isFixedPosition_ = _isFixedPosition;
    fixedPositionAnchor_ = _fixedPositionAnchor;
    maskLayerParent_ = _maskLayerParent;
    maskLayerChild_ = _maskLayerChild;
    animations_ = _animations;
}

} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct ThebesLayerAttributes|
//
namespace mozilla {
namespace layers {
ThebesLayerAttributes::ThebesLayerAttributes()
{
    Init();
}

ThebesLayerAttributes::~ThebesLayerAttributes()
{
}

bool
ThebesLayerAttributes::operator==(const ThebesLayerAttributes& _o) const
{
    if ((!((validRegion()) == ((_o).validRegion())))) {
        return false;
    }
    return true;
}

void
ThebesLayerAttributes::Init()
{
}

void
ThebesLayerAttributes::Assign(const nsIntRegion& _validRegion)
{
    validRegion_ = _validRegion;
}

} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct ContainerLayerAttributes|
//
namespace mozilla {
namespace layers {
ContainerLayerAttributes::ContainerLayerAttributes()
{
    Init();
}

ContainerLayerAttributes::~ContainerLayerAttributes()
{
}

bool
ContainerLayerAttributes::operator==(const ContainerLayerAttributes& _o) const
{
    if ((!((metrics()) == ((_o).metrics())))) {
        return false;
    }
    if ((!((preXScale()) == ((_o).preXScale())))) {
        return false;
    }
    if ((!((preYScale()) == ((_o).preYScale())))) {
        return false;
    }
    return true;
}

void
ContainerLayerAttributes::Init()
{
}

void
ContainerLayerAttributes::Assign(
        const FrameMetrics& _metrics,
        const float& _preXScale,
        const float& _preYScale)
{
    metrics_ = _metrics;
    preXScale_ = _preXScale;
    preYScale_ = _preYScale;
}

} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct ColorLayerAttributes|
//
namespace mozilla {
namespace layers {
ColorLayerAttributes::ColorLayerAttributes()
{
    Init();
}

ColorLayerAttributes::~ColorLayerAttributes()
{
}

bool
ColorLayerAttributes::operator==(const ColorLayerAttributes& _o) const
{
    if ((!((color()) == ((_o).color())))) {
        return false;
    }
    return true;
}

void
ColorLayerAttributes::Init()
{
}

void
ColorLayerAttributes::Assign(const Color& _color)
{
    color_ = _color;
}

} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct CanvasLayerAttributes|
//
namespace mozilla {
namespace layers {
CanvasLayerAttributes::CanvasLayerAttributes()
{
    Init();
}

CanvasLayerAttributes::~CanvasLayerAttributes()
{
}

bool
CanvasLayerAttributes::operator==(const CanvasLayerAttributes& _o) const
{
    if ((!((filter()) == ((_o).filter())))) {
        return false;
    }
    return true;
}

void
CanvasLayerAttributes::Init()
{
}

void
CanvasLayerAttributes::Assign(const GraphicsFilterType& _filter)
{
    filter_ = _filter;
}

} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct RefLayerAttributes|
//
namespace mozilla {
namespace layers {
RefLayerAttributes::RefLayerAttributes()
{
    Init();
}

RefLayerAttributes::~RefLayerAttributes()
{
}

bool
RefLayerAttributes::operator==(const RefLayerAttributes& _o) const
{
    if ((!((id()) == ((_o).id())))) {
        return false;
    }
    return true;
}

void
RefLayerAttributes::Init()
{
}

void
RefLayerAttributes::Assign(const int64_t& _id)
{
    id_ = _id;
}

} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct ImageLayerAttributes|
//
namespace mozilla {
namespace layers {
ImageLayerAttributes::ImageLayerAttributes()
{
    Init();
}

ImageLayerAttributes::~ImageLayerAttributes()
{
}

bool
ImageLayerAttributes::operator==(const ImageLayerAttributes& _o) const
{
    if ((!((filter()) == ((_o).filter())))) {
        return false;
    }
    if ((!((forceSingleTile()) == ((_o).forceSingleTile())))) {
        return false;
    }
    return true;
}

void
ImageLayerAttributes::Init()
{
}

void
ImageLayerAttributes::Assign(
        const GraphicsFilterType& _filter,
        const bool& _forceSingleTile)
{
    filter_ = _filter;
    forceSingleTile_ = _forceSingleTile;
}

} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |union SpecificLayerAttributes|
//
namespace mozilla {
namespace layers {
bool
SpecificLayerAttributes::MaybeDestroy(Type aNewType)
{
    if ((mType) == (T__None)) {
        return true;
    }
    if ((mType) == (aNewType)) {
        return false;
    }
    switch (mType) {
    case Tnull_t:
        {
            (ptr_null_t())->~null_t__tdef();
            break;
        }
    case TThebesLayerAttributes:
        {
            (ptr_ThebesLayerAttributes())->~ThebesLayerAttributes__tdef();
            break;
        }
    case TContainerLayerAttributes:
        {
            (ptr_ContainerLayerAttributes())->~ContainerLayerAttributes__tdef();
            break;
        }
    case TColorLayerAttributes:
        {
            (ptr_ColorLayerAttributes())->~ColorLayerAttributes__tdef();
            break;
        }
    case TCanvasLayerAttributes:
        {
            (ptr_CanvasLayerAttributes())->~CanvasLayerAttributes__tdef();
            break;
        }
    case TRefLayerAttributes:
        {
            (ptr_RefLayerAttributes())->~RefLayerAttributes__tdef();
            break;
        }
    case TImageLayerAttributes:
        {
            (ptr_ImageLayerAttributes())->~ImageLayerAttributes__tdef();
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("not reached");
            break;
        }
    }
    return true;
}

SpecificLayerAttributes::SpecificLayerAttributes(const null_t& aOther)
{
    new (ptr_null_t()) null_t(aOther);
    mType = Tnull_t;
}

SpecificLayerAttributes::SpecificLayerAttributes(const ThebesLayerAttributes& aOther)
{
    new (ptr_ThebesLayerAttributes()) ThebesLayerAttributes(aOther);
    mType = TThebesLayerAttributes;
}

SpecificLayerAttributes::SpecificLayerAttributes(const ContainerLayerAttributes& aOther)
{
    new (ptr_ContainerLayerAttributes()) ContainerLayerAttributes(aOther);
    mType = TContainerLayerAttributes;
}

SpecificLayerAttributes::SpecificLayerAttributes(const ColorLayerAttributes& aOther)
{
    new (ptr_ColorLayerAttributes()) ColorLayerAttributes(aOther);
    mType = TColorLayerAttributes;
}

SpecificLayerAttributes::SpecificLayerAttributes(const CanvasLayerAttributes& aOther)
{
    new (ptr_CanvasLayerAttributes()) CanvasLayerAttributes(aOther);
    mType = TCanvasLayerAttributes;
}

SpecificLayerAttributes::SpecificLayerAttributes(const RefLayerAttributes& aOther)
{
    new (ptr_RefLayerAttributes()) RefLayerAttributes(aOther);
    mType = TRefLayerAttributes;
}

SpecificLayerAttributes::SpecificLayerAttributes(const ImageLayerAttributes& aOther)
{
    new (ptr_ImageLayerAttributes()) ImageLayerAttributes(aOther);
    mType = TImageLayerAttributes;
}

SpecificLayerAttributes::SpecificLayerAttributes(const SpecificLayerAttributes& aOther)
{
    (aOther).AssertSanity();
    switch ((aOther).type()) {
    case Tnull_t:
        {
            new (ptr_null_t()) null_t((aOther).get_null_t());
            break;
        }
    case TThebesLayerAttributes:
        {
            new (ptr_ThebesLayerAttributes()) ThebesLayerAttributes((aOther).get_ThebesLayerAttributes());
            break;
        }
    case TContainerLayerAttributes:
        {
            new (ptr_ContainerLayerAttributes()) ContainerLayerAttributes((aOther).get_ContainerLayerAttributes());
            break;
        }
    case TColorLayerAttributes:
        {
            new (ptr_ColorLayerAttributes()) ColorLayerAttributes((aOther).get_ColorLayerAttributes());
            break;
        }
    case TCanvasLayerAttributes:
        {
            new (ptr_CanvasLayerAttributes()) CanvasLayerAttributes((aOther).get_CanvasLayerAttributes());
            break;
        }
    case TRefLayerAttributes:
        {
            new (ptr_RefLayerAttributes()) RefLayerAttributes((aOther).get_RefLayerAttributes());
            break;
        }
    case TImageLayerAttributes:
        {
            new (ptr_ImageLayerAttributes()) ImageLayerAttributes((aOther).get_ImageLayerAttributes());
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return;
        }
    }
    mType = (aOther).type();
}

SpecificLayerAttributes::~SpecificLayerAttributes()
{
    MaybeDestroy(T__None);
}

SpecificLayerAttributes&
SpecificLayerAttributes::operator=(const null_t& aRhs)
{
    if (MaybeDestroy(Tnull_t)) {
        new (ptr_null_t()) null_t;
    }
    (*(ptr_null_t())) = aRhs;
    mType = Tnull_t;
    return (*(this));
}

SpecificLayerAttributes&
SpecificLayerAttributes::operator=(const ThebesLayerAttributes& aRhs)
{
    if (MaybeDestroy(TThebesLayerAttributes)) {
        new (ptr_ThebesLayerAttributes()) ThebesLayerAttributes;
    }
    (*(ptr_ThebesLayerAttributes())) = aRhs;
    mType = TThebesLayerAttributes;
    return (*(this));
}

SpecificLayerAttributes&
SpecificLayerAttributes::operator=(const ContainerLayerAttributes& aRhs)
{
    if (MaybeDestroy(TContainerLayerAttributes)) {
        new (ptr_ContainerLayerAttributes()) ContainerLayerAttributes;
    }
    (*(ptr_ContainerLayerAttributes())) = aRhs;
    mType = TContainerLayerAttributes;
    return (*(this));
}

SpecificLayerAttributes&
SpecificLayerAttributes::operator=(const ColorLayerAttributes& aRhs)
{
    if (MaybeDestroy(TColorLayerAttributes)) {
        new (ptr_ColorLayerAttributes()) ColorLayerAttributes;
    }
    (*(ptr_ColorLayerAttributes())) = aRhs;
    mType = TColorLayerAttributes;
    return (*(this));
}

SpecificLayerAttributes&
SpecificLayerAttributes::operator=(const CanvasLayerAttributes& aRhs)
{
    if (MaybeDestroy(TCanvasLayerAttributes)) {
        new (ptr_CanvasLayerAttributes()) CanvasLayerAttributes;
    }
    (*(ptr_CanvasLayerAttributes())) = aRhs;
    mType = TCanvasLayerAttributes;
    return (*(this));
}

SpecificLayerAttributes&
SpecificLayerAttributes::operator=(const RefLayerAttributes& aRhs)
{
    if (MaybeDestroy(TRefLayerAttributes)) {
        new (ptr_RefLayerAttributes()) RefLayerAttributes;
    }
    (*(ptr_RefLayerAttributes())) = aRhs;
    mType = TRefLayerAttributes;
    return (*(this));
}

SpecificLayerAttributes&
SpecificLayerAttributes::operator=(const ImageLayerAttributes& aRhs)
{
    if (MaybeDestroy(TImageLayerAttributes)) {
        new (ptr_ImageLayerAttributes()) ImageLayerAttributes;
    }
    (*(ptr_ImageLayerAttributes())) = aRhs;
    mType = TImageLayerAttributes;
    return (*(this));
}

SpecificLayerAttributes&
SpecificLayerAttributes::operator=(const SpecificLayerAttributes& aRhs)
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case Tnull_t:
        {
            if (MaybeDestroy(t)) {
                new (ptr_null_t()) null_t;
            }
            (*(ptr_null_t())) = (aRhs).get_null_t();
            break;
        }
    case TThebesLayerAttributes:
        {
            if (MaybeDestroy(t)) {
                new (ptr_ThebesLayerAttributes()) ThebesLayerAttributes;
            }
            (*(ptr_ThebesLayerAttributes())) = (aRhs).get_ThebesLayerAttributes();
            break;
        }
    case TContainerLayerAttributes:
        {
            if (MaybeDestroy(t)) {
                new (ptr_ContainerLayerAttributes()) ContainerLayerAttributes;
            }
            (*(ptr_ContainerLayerAttributes())) = (aRhs).get_ContainerLayerAttributes();
            break;
        }
    case TColorLayerAttributes:
        {
            if (MaybeDestroy(t)) {
                new (ptr_ColorLayerAttributes()) ColorLayerAttributes;
            }
            (*(ptr_ColorLayerAttributes())) = (aRhs).get_ColorLayerAttributes();
            break;
        }
    case TCanvasLayerAttributes:
        {
            if (MaybeDestroy(t)) {
                new (ptr_CanvasLayerAttributes()) CanvasLayerAttributes;
            }
            (*(ptr_CanvasLayerAttributes())) = (aRhs).get_CanvasLayerAttributes();
            break;
        }
    case TRefLayerAttributes:
        {
            if (MaybeDestroy(t)) {
                new (ptr_RefLayerAttributes()) RefLayerAttributes;
            }
            (*(ptr_RefLayerAttributes())) = (aRhs).get_RefLayerAttributes();
            break;
        }
    case TImageLayerAttributes:
        {
            if (MaybeDestroy(t)) {
                new (ptr_ImageLayerAttributes()) ImageLayerAttributes;
            }
            (*(ptr_ImageLayerAttributes())) = (aRhs).get_ImageLayerAttributes();
            break;
        }
    case T__None:
        {
            MaybeDestroy(t);
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            break;
        }
    }
    mType = t;
    return (*(this));
}

bool
SpecificLayerAttributes::operator==(const null_t& aRhs) const
{
    return (get_null_t()) == (aRhs);
}

bool
SpecificLayerAttributes::operator==(const ThebesLayerAttributes& aRhs) const
{
    return (get_ThebesLayerAttributes()) == (aRhs);
}

bool
SpecificLayerAttributes::operator==(const ContainerLayerAttributes& aRhs) const
{
    return (get_ContainerLayerAttributes()) == (aRhs);
}

bool
SpecificLayerAttributes::operator==(const ColorLayerAttributes& aRhs) const
{
    return (get_ColorLayerAttributes()) == (aRhs);
}

bool
SpecificLayerAttributes::operator==(const CanvasLayerAttributes& aRhs) const
{
    return (get_CanvasLayerAttributes()) == (aRhs);
}

bool
SpecificLayerAttributes::operator==(const RefLayerAttributes& aRhs) const
{
    return (get_RefLayerAttributes()) == (aRhs);
}

bool
SpecificLayerAttributes::operator==(const ImageLayerAttributes& aRhs) const
{
    return (get_ImageLayerAttributes()) == (aRhs);
}

bool
SpecificLayerAttributes::operator==(const SpecificLayerAttributes& aRhs) const
{
    if ((type()) != ((aRhs).type())) {
        return false;
    }

    switch (type()) {
    case Tnull_t:
        {
            return (get_null_t()) == ((aRhs).get_null_t());
        }
    case TThebesLayerAttributes:
        {
            return (get_ThebesLayerAttributes()) == ((aRhs).get_ThebesLayerAttributes());
        }
    case TContainerLayerAttributes:
        {
            return (get_ContainerLayerAttributes()) == ((aRhs).get_ContainerLayerAttributes());
        }
    case TColorLayerAttributes:
        {
            return (get_ColorLayerAttributes()) == ((aRhs).get_ColorLayerAttributes());
        }
    case TCanvasLayerAttributes:
        {
            return (get_CanvasLayerAttributes()) == ((aRhs).get_CanvasLayerAttributes());
        }
    case TRefLayerAttributes:
        {
            return (get_RefLayerAttributes()) == ((aRhs).get_RefLayerAttributes());
        }
    case TImageLayerAttributes:
        {
            return (get_ImageLayerAttributes()) == ((aRhs).get_ImageLayerAttributes());
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return false;
        }
    }
}

} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct LayerAttributes|
//
namespace mozilla {
namespace layers {
LayerAttributes::LayerAttributes()
{
    Init();
}

LayerAttributes::~LayerAttributes()
{
}

bool
LayerAttributes::operator==(const LayerAttributes& _o) const
{
    if ((!((common()) == ((_o).common())))) {
        return false;
    }
    if ((!((specific()) == ((_o).specific())))) {
        return false;
    }
    return true;
}

void
LayerAttributes::Init()
{
}

void
LayerAttributes::Assign(
        const CommonLayerAttributes& _common,
        const SpecificLayerAttributes& _specific)
{
    common_ = _common;
    specific_ = _specific;
}

} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct OpSetLayerAttributes|
//
namespace mozilla {
namespace layers {
OpSetLayerAttributes::OpSetLayerAttributes()
{
    Init();
}

OpSetLayerAttributes::~OpSetLayerAttributes()
{
}

bool
OpSetLayerAttributes::operator==(const OpSetLayerAttributes& _o) const
{
    if ((!((layerParent()) == ((_o).layerParent())))) {
        return false;
    }
    if ((!((layerChild()) == ((_o).layerChild())))) {
        return false;
    }
    if ((!((attrs()) == ((_o).attrs())))) {
        return false;
    }
    return true;
}

void
OpSetLayerAttributes::Init()
{
    layerParent_ = 0;
    layerChild_ = 0;
}

void
OpSetLayerAttributes::Assign(
        PLayerParent* _layerParent,
        PLayerChild* _layerChild,
        const LayerAttributes& _attrs)
{
    layerParent_ = _layerParent;
    layerChild_ = _layerChild;
    attrs_ = _attrs;
}

} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct OpSetRoot|
//
namespace mozilla {
namespace layers {
OpSetRoot::OpSetRoot()
{
    Init();
}

OpSetRoot::~OpSetRoot()
{
}

bool
OpSetRoot::operator==(const OpSetRoot& _o) const
{
    if ((!((rootParent()) == ((_o).rootParent())))) {
        return false;
    }
    if ((!((rootChild()) == ((_o).rootChild())))) {
        return false;
    }
    return true;
}

void
OpSetRoot::Init()
{
    rootParent_ = 0;
    rootChild_ = 0;
}

void
OpSetRoot::Assign(
        PLayerParent* _rootParent,
        PLayerChild* _rootChild)
{
    rootParent_ = _rootParent;
    rootChild_ = _rootChild;
}

} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct OpInsertAfter|
//
namespace mozilla {
namespace layers {
OpInsertAfter::OpInsertAfter()
{
    Init();
}

OpInsertAfter::~OpInsertAfter()
{
}

bool
OpInsertAfter::operator==(const OpInsertAfter& _o) const
{
    if ((!((containerParent()) == ((_o).containerParent())))) {
        return false;
    }
    if ((!((containerChild()) == ((_o).containerChild())))) {
        return false;
    }
    if ((!((childLayerParent()) == ((_o).childLayerParent())))) {
        return false;
    }
    if ((!((childLayerChild()) == ((_o).childLayerChild())))) {
        return false;
    }
    if ((!((afterParent()) == ((_o).afterParent())))) {
        return false;
    }
    if ((!((afterChild()) == ((_o).afterChild())))) {
        return false;
    }
    return true;
}

void
OpInsertAfter::Init()
{
    containerParent_ = 0;
    containerChild_ = 0;
    childLayerParent_ = 0;
    childLayerChild_ = 0;
    afterParent_ = 0;
    afterChild_ = 0;
}

void
OpInsertAfter::Assign(
        PLayerParent* _containerParent,
        PLayerChild* _containerChild,
        PLayerParent* _childLayerParent,
        PLayerChild* _childLayerChild,
        PLayerParent* _afterParent,
        PLayerChild* _afterChild)
{
    containerParent_ = _containerParent;
    containerChild_ = _containerChild;
    childLayerParent_ = _childLayerParent;
    childLayerChild_ = _childLayerChild;
    afterParent_ = _afterParent;
    afterChild_ = _afterChild;
}

} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct OpAppendChild|
//
namespace mozilla {
namespace layers {
OpAppendChild::OpAppendChild()
{
    Init();
}

OpAppendChild::~OpAppendChild()
{
}

bool
OpAppendChild::operator==(const OpAppendChild& _o) const
{
    if ((!((containerParent()) == ((_o).containerParent())))) {
        return false;
    }
    if ((!((containerChild()) == ((_o).containerChild())))) {
        return false;
    }
    if ((!((childLayerParent()) == ((_o).childLayerParent())))) {
        return false;
    }
    if ((!((childLayerChild()) == ((_o).childLayerChild())))) {
        return false;
    }
    return true;
}

void
OpAppendChild::Init()
{
    containerParent_ = 0;
    containerChild_ = 0;
    childLayerParent_ = 0;
    childLayerChild_ = 0;
}

void
OpAppendChild::Assign(
        PLayerParent* _containerParent,
        PLayerChild* _containerChild,
        PLayerParent* _childLayerParent,
        PLayerChild* _childLayerChild)
{
    containerParent_ = _containerParent;
    containerChild_ = _containerChild;
    childLayerParent_ = _childLayerParent;
    childLayerChild_ = _childLayerChild;
}

} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct OpRemoveChild|
//
namespace mozilla {
namespace layers {
OpRemoveChild::OpRemoveChild()
{
    Init();
}

OpRemoveChild::~OpRemoveChild()
{
}

bool
OpRemoveChild::operator==(const OpRemoveChild& _o) const
{
    if ((!((containerParent()) == ((_o).containerParent())))) {
        return false;
    }
    if ((!((containerChild()) == ((_o).containerChild())))) {
        return false;
    }
    if ((!((childLayerParent()) == ((_o).childLayerParent())))) {
        return false;
    }
    if ((!((childLayerChild()) == ((_o).childLayerChild())))) {
        return false;
    }
    return true;
}

void
OpRemoveChild::Init()
{
    containerParent_ = 0;
    containerChild_ = 0;
    childLayerParent_ = 0;
    childLayerChild_ = 0;
}

void
OpRemoveChild::Assign(
        PLayerParent* _containerParent,
        PLayerChild* _containerChild,
        PLayerParent* _childLayerParent,
        PLayerChild* _childLayerChild)
{
    containerParent_ = _containerParent;
    containerChild_ = _containerChild;
    childLayerParent_ = _childLayerParent;
    childLayerChild_ = _childLayerChild;
}

} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct OpRepositionChild|
//
namespace mozilla {
namespace layers {
OpRepositionChild::OpRepositionChild()
{
    Init();
}

OpRepositionChild::~OpRepositionChild()
{
}

bool
OpRepositionChild::operator==(const OpRepositionChild& _o) const
{
    if ((!((containerParent()) == ((_o).containerParent())))) {
        return false;
    }
    if ((!((containerChild()) == ((_o).containerChild())))) {
        return false;
    }
    if ((!((childLayerParent()) == ((_o).childLayerParent())))) {
        return false;
    }
    if ((!((childLayerChild()) == ((_o).childLayerChild())))) {
        return false;
    }
    if ((!((afterParent()) == ((_o).afterParent())))) {
        return false;
    }
    if ((!((afterChild()) == ((_o).afterChild())))) {
        return false;
    }
    return true;
}

void
OpRepositionChild::Init()
{
    containerParent_ = 0;
    containerChild_ = 0;
    childLayerParent_ = 0;
    childLayerChild_ = 0;
    afterParent_ = 0;
    afterChild_ = 0;
}

void
OpRepositionChild::Assign(
        PLayerParent* _containerParent,
        PLayerChild* _containerChild,
        PLayerParent* _childLayerParent,
        PLayerChild* _childLayerChild,
        PLayerParent* _afterParent,
        PLayerChild* _afterChild)
{
    containerParent_ = _containerParent;
    containerChild_ = _containerChild;
    childLayerParent_ = _childLayerParent;
    childLayerChild_ = _childLayerChild;
    afterParent_ = _afterParent;
    afterChild_ = _afterChild;
}

} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct OpRaiseToTopChild|
//
namespace mozilla {
namespace layers {
OpRaiseToTopChild::OpRaiseToTopChild()
{
    Init();
}

OpRaiseToTopChild::~OpRaiseToTopChild()
{
}

bool
OpRaiseToTopChild::operator==(const OpRaiseToTopChild& _o) const
{
    if ((!((containerParent()) == ((_o).containerParent())))) {
        return false;
    }
    if ((!((containerChild()) == ((_o).containerChild())))) {
        return false;
    }
    if ((!((childLayerParent()) == ((_o).childLayerParent())))) {
        return false;
    }
    if ((!((childLayerChild()) == ((_o).childLayerChild())))) {
        return false;
    }
    return true;
}

void
OpRaiseToTopChild::Init()
{
    containerParent_ = 0;
    containerChild_ = 0;
    childLayerParent_ = 0;
    childLayerChild_ = 0;
}

void
OpRaiseToTopChild::Assign(
        PLayerParent* _containerParent,
        PLayerChild* _containerChild,
        PLayerParent* _childLayerParent,
        PLayerChild* _childLayerChild)
{
    containerParent_ = _containerParent;
    containerChild_ = _containerChild;
    childLayerParent_ = _childLayerParent;
    childLayerChild_ = _childLayerChild;
}

} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct OpPaintThebesBuffer|
//
namespace mozilla {
namespace layers {
OpPaintThebesBuffer::OpPaintThebesBuffer()
{
    Init();
}

OpPaintThebesBuffer::~OpPaintThebesBuffer()
{
}

bool
OpPaintThebesBuffer::operator==(const OpPaintThebesBuffer& _o) const
{
    if ((!((layerParent()) == ((_o).layerParent())))) {
        return false;
    }
    if ((!((layerChild()) == ((_o).layerChild())))) {
        return false;
    }
    if ((!((newFrontBuffer()) == ((_o).newFrontBuffer())))) {
        return false;
    }
    if ((!((updatedRegion()) == ((_o).updatedRegion())))) {
        return false;
    }
    return true;
}

void
OpPaintThebesBuffer::Init()
{
    layerParent_ = 0;
    layerChild_ = 0;
}

void
OpPaintThebesBuffer::Assign(
        PLayerParent* _layerParent,
        PLayerChild* _layerChild,
        const ThebesBuffer& _newFrontBuffer,
        const nsIntRegion& _updatedRegion)
{
    layerParent_ = _layerParent;
    layerChild_ = _layerChild;
    newFrontBuffer_ = _newFrontBuffer;
    updatedRegion_ = _updatedRegion;
}

} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct OpPaintTiledLayerBuffer|
//
namespace mozilla {
namespace layers {
OpPaintTiledLayerBuffer::OpPaintTiledLayerBuffer()
{
    Init();
}

OpPaintTiledLayerBuffer::~OpPaintTiledLayerBuffer()
{
}

bool
OpPaintTiledLayerBuffer::operator==(const OpPaintTiledLayerBuffer& _o) const
{
    if ((!((layerParent()) == ((_o).layerParent())))) {
        return false;
    }
    if ((!((layerChild()) == ((_o).layerChild())))) {
        return false;
    }
    if ((!((tiledLayerBuffer()) == ((_o).tiledLayerBuffer())))) {
        return false;
    }
    return true;
}

void
OpPaintTiledLayerBuffer::Init()
{
    layerParent_ = 0;
    layerChild_ = 0;
}

void
OpPaintTiledLayerBuffer::Assign(
        PLayerParent* _layerParent,
        PLayerChild* _layerChild,
        const uintptr_t& _tiledLayerBuffer)
{
    layerParent_ = _layerParent;
    layerChild_ = _layerChild;
    tiledLayerBuffer_ = _tiledLayerBuffer;
}

} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct OpPaintCanvas|
//
namespace mozilla {
namespace layers {
OpPaintCanvas::OpPaintCanvas()
{
    Init();
}

OpPaintCanvas::~OpPaintCanvas()
{
}

bool
OpPaintCanvas::operator==(const OpPaintCanvas& _o) const
{
    if ((!((layerParent()) == ((_o).layerParent())))) {
        return false;
    }
    if ((!((layerChild()) == ((_o).layerChild())))) {
        return false;
    }
    if ((!((newFrontBuffer()) == ((_o).newFrontBuffer())))) {
        return false;
    }
    if ((!((needYFlip()) == ((_o).needYFlip())))) {
        return false;
    }
    return true;
}

void
OpPaintCanvas::Init()
{
    layerParent_ = 0;
    layerChild_ = 0;
}

void
OpPaintCanvas::Assign(
        PLayerParent* _layerParent,
        PLayerChild* _layerChild,
        const CanvasSurface& _newFrontBuffer,
        const bool& _needYFlip)
{
    layerParent_ = _layerParent;
    layerChild_ = _layerChild;
    newFrontBuffer_ = _newFrontBuffer;
    needYFlip_ = _needYFlip;
}

} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct OpPaintImage|
//
namespace mozilla {
namespace layers {
OpPaintImage::OpPaintImage()
{
    Init();
}

OpPaintImage::~OpPaintImage()
{
}

bool
OpPaintImage::operator==(const OpPaintImage& _o) const
{
    if ((!((layerParent()) == ((_o).layerParent())))) {
        return false;
    }
    if ((!((layerChild()) == ((_o).layerChild())))) {
        return false;
    }
    if ((!((newFrontBuffer()) == ((_o).newFrontBuffer())))) {
        return false;
    }
    return true;
}

void
OpPaintImage::Init()
{
    layerParent_ = 0;
    layerChild_ = 0;
}

void
OpPaintImage::Assign(
        PLayerParent* _layerParent,
        PLayerChild* _layerChild,
        const SharedImage& _newFrontBuffer)
{
    layerParent_ = _layerParent;
    layerChild_ = _layerChild;
    newFrontBuffer_ = _newFrontBuffer;
}

} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |union Edit|
//
namespace mozilla {
namespace layers {
bool
Edit::MaybeDestroy(Type aNewType)
{
    if ((mType) == (T__None)) {
        return true;
    }
    if ((mType) == (aNewType)) {
        return false;
    }
    switch (mType) {
    case TOpCreateThebesLayer:
        {
            (ptr_OpCreateThebesLayer())->~OpCreateThebesLayer__tdef();
            break;
        }
    case TOpCreateContainerLayer:
        {
            (ptr_OpCreateContainerLayer())->~OpCreateContainerLayer__tdef();
            break;
        }
    case TOpCreateImageLayer:
        {
            (ptr_OpCreateImageLayer())->~OpCreateImageLayer__tdef();
            break;
        }
    case TOpCreateColorLayer:
        {
            (ptr_OpCreateColorLayer())->~OpCreateColorLayer__tdef();
            break;
        }
    case TOpCreateCanvasLayer:
        {
            (ptr_OpCreateCanvasLayer())->~OpCreateCanvasLayer__tdef();
            break;
        }
    case TOpCreateRefLayer:
        {
            (ptr_OpCreateRefLayer())->~OpCreateRefLayer__tdef();
            break;
        }
    case TOpSetLayerAttributes:
        {
            (ptr_OpSetLayerAttributes())->~OpSetLayerAttributes__tdef();
            break;
        }
    case TOpSetRoot:
        {
            (ptr_OpSetRoot())->~OpSetRoot__tdef();
            break;
        }
    case TOpInsertAfter:
        {
            (ptr_OpInsertAfter())->~OpInsertAfter__tdef();
            break;
        }
    case TOpAppendChild:
        {
            (ptr_OpAppendChild())->~OpAppendChild__tdef();
            break;
        }
    case TOpRemoveChild:
        {
            (ptr_OpRemoveChild())->~OpRemoveChild__tdef();
            break;
        }
    case TOpRepositionChild:
        {
            (ptr_OpRepositionChild())->~OpRepositionChild__tdef();
            break;
        }
    case TOpRaiseToTopChild:
        {
            (ptr_OpRaiseToTopChild())->~OpRaiseToTopChild__tdef();
            break;
        }
    case TOpPaintThebesBuffer:
        {
            (ptr_OpPaintThebesBuffer())->~OpPaintThebesBuffer__tdef();
            break;
        }
    case TOpPaintTiledLayerBuffer:
        {
            (ptr_OpPaintTiledLayerBuffer())->~OpPaintTiledLayerBuffer__tdef();
            break;
        }
    case TOpPaintCanvas:
        {
            (ptr_OpPaintCanvas())->~OpPaintCanvas__tdef();
            break;
        }
    case TOpPaintImage:
        {
            (ptr_OpPaintImage())->~OpPaintImage__tdef();
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("not reached");
            break;
        }
    }
    return true;
}

Edit::Edit(const OpCreateThebesLayer& aOther)
{
    new (ptr_OpCreateThebesLayer()) OpCreateThebesLayer(aOther);
    mType = TOpCreateThebesLayer;
}

Edit::Edit(const OpCreateContainerLayer& aOther)
{
    new (ptr_OpCreateContainerLayer()) OpCreateContainerLayer(aOther);
    mType = TOpCreateContainerLayer;
}

Edit::Edit(const OpCreateImageLayer& aOther)
{
    new (ptr_OpCreateImageLayer()) OpCreateImageLayer(aOther);
    mType = TOpCreateImageLayer;
}

Edit::Edit(const OpCreateColorLayer& aOther)
{
    new (ptr_OpCreateColorLayer()) OpCreateColorLayer(aOther);
    mType = TOpCreateColorLayer;
}

Edit::Edit(const OpCreateCanvasLayer& aOther)
{
    new (ptr_OpCreateCanvasLayer()) OpCreateCanvasLayer(aOther);
    mType = TOpCreateCanvasLayer;
}

Edit::Edit(const OpCreateRefLayer& aOther)
{
    new (ptr_OpCreateRefLayer()) OpCreateRefLayer(aOther);
    mType = TOpCreateRefLayer;
}

Edit::Edit(const OpSetLayerAttributes& aOther)
{
    new (ptr_OpSetLayerAttributes()) OpSetLayerAttributes(aOther);
    mType = TOpSetLayerAttributes;
}

Edit::Edit(const OpSetRoot& aOther)
{
    new (ptr_OpSetRoot()) OpSetRoot(aOther);
    mType = TOpSetRoot;
}

Edit::Edit(const OpInsertAfter& aOther)
{
    new (ptr_OpInsertAfter()) OpInsertAfter(aOther);
    mType = TOpInsertAfter;
}

Edit::Edit(const OpAppendChild& aOther)
{
    new (ptr_OpAppendChild()) OpAppendChild(aOther);
    mType = TOpAppendChild;
}

Edit::Edit(const OpRemoveChild& aOther)
{
    new (ptr_OpRemoveChild()) OpRemoveChild(aOther);
    mType = TOpRemoveChild;
}

Edit::Edit(const OpRepositionChild& aOther)
{
    new (ptr_OpRepositionChild()) OpRepositionChild(aOther);
    mType = TOpRepositionChild;
}

Edit::Edit(const OpRaiseToTopChild& aOther)
{
    new (ptr_OpRaiseToTopChild()) OpRaiseToTopChild(aOther);
    mType = TOpRaiseToTopChild;
}

Edit::Edit(const OpPaintThebesBuffer& aOther)
{
    new (ptr_OpPaintThebesBuffer()) OpPaintThebesBuffer(aOther);
    mType = TOpPaintThebesBuffer;
}

Edit::Edit(const OpPaintTiledLayerBuffer& aOther)
{
    new (ptr_OpPaintTiledLayerBuffer()) OpPaintTiledLayerBuffer(aOther);
    mType = TOpPaintTiledLayerBuffer;
}

Edit::Edit(const OpPaintCanvas& aOther)
{
    new (ptr_OpPaintCanvas()) OpPaintCanvas(aOther);
    mType = TOpPaintCanvas;
}

Edit::Edit(const OpPaintImage& aOther)
{
    new (ptr_OpPaintImage()) OpPaintImage(aOther);
    mType = TOpPaintImage;
}

Edit::Edit(const Edit& aOther)
{
    (aOther).AssertSanity();
    switch ((aOther).type()) {
    case TOpCreateThebesLayer:
        {
            new (ptr_OpCreateThebesLayer()) OpCreateThebesLayer((aOther).get_OpCreateThebesLayer());
            break;
        }
    case TOpCreateContainerLayer:
        {
            new (ptr_OpCreateContainerLayer()) OpCreateContainerLayer((aOther).get_OpCreateContainerLayer());
            break;
        }
    case TOpCreateImageLayer:
        {
            new (ptr_OpCreateImageLayer()) OpCreateImageLayer((aOther).get_OpCreateImageLayer());
            break;
        }
    case TOpCreateColorLayer:
        {
            new (ptr_OpCreateColorLayer()) OpCreateColorLayer((aOther).get_OpCreateColorLayer());
            break;
        }
    case TOpCreateCanvasLayer:
        {
            new (ptr_OpCreateCanvasLayer()) OpCreateCanvasLayer((aOther).get_OpCreateCanvasLayer());
            break;
        }
    case TOpCreateRefLayer:
        {
            new (ptr_OpCreateRefLayer()) OpCreateRefLayer((aOther).get_OpCreateRefLayer());
            break;
        }
    case TOpSetLayerAttributes:
        {
            new (ptr_OpSetLayerAttributes()) OpSetLayerAttributes((aOther).get_OpSetLayerAttributes());
            break;
        }
    case TOpSetRoot:
        {
            new (ptr_OpSetRoot()) OpSetRoot((aOther).get_OpSetRoot());
            break;
        }
    case TOpInsertAfter:
        {
            new (ptr_OpInsertAfter()) OpInsertAfter((aOther).get_OpInsertAfter());
            break;
        }
    case TOpAppendChild:
        {
            new (ptr_OpAppendChild()) OpAppendChild((aOther).get_OpAppendChild());
            break;
        }
    case TOpRemoveChild:
        {
            new (ptr_OpRemoveChild()) OpRemoveChild((aOther).get_OpRemoveChild());
            break;
        }
    case TOpRepositionChild:
        {
            new (ptr_OpRepositionChild()) OpRepositionChild((aOther).get_OpRepositionChild());
            break;
        }
    case TOpRaiseToTopChild:
        {
            new (ptr_OpRaiseToTopChild()) OpRaiseToTopChild((aOther).get_OpRaiseToTopChild());
            break;
        }
    case TOpPaintThebesBuffer:
        {
            new (ptr_OpPaintThebesBuffer()) OpPaintThebesBuffer((aOther).get_OpPaintThebesBuffer());
            break;
        }
    case TOpPaintTiledLayerBuffer:
        {
            new (ptr_OpPaintTiledLayerBuffer()) OpPaintTiledLayerBuffer((aOther).get_OpPaintTiledLayerBuffer());
            break;
        }
    case TOpPaintCanvas:
        {
            new (ptr_OpPaintCanvas()) OpPaintCanvas((aOther).get_OpPaintCanvas());
            break;
        }
    case TOpPaintImage:
        {
            new (ptr_OpPaintImage()) OpPaintImage((aOther).get_OpPaintImage());
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return;
        }
    }
    mType = (aOther).type();
}

Edit::~Edit()
{
    MaybeDestroy(T__None);
}

Edit&
Edit::operator=(const OpCreateThebesLayer& aRhs)
{
    if (MaybeDestroy(TOpCreateThebesLayer)) {
        new (ptr_OpCreateThebesLayer()) OpCreateThebesLayer;
    }
    (*(ptr_OpCreateThebesLayer())) = aRhs;
    mType = TOpCreateThebesLayer;
    return (*(this));
}

Edit&
Edit::operator=(const OpCreateContainerLayer& aRhs)
{
    if (MaybeDestroy(TOpCreateContainerLayer)) {
        new (ptr_OpCreateContainerLayer()) OpCreateContainerLayer;
    }
    (*(ptr_OpCreateContainerLayer())) = aRhs;
    mType = TOpCreateContainerLayer;
    return (*(this));
}

Edit&
Edit::operator=(const OpCreateImageLayer& aRhs)
{
    if (MaybeDestroy(TOpCreateImageLayer)) {
        new (ptr_OpCreateImageLayer()) OpCreateImageLayer;
    }
    (*(ptr_OpCreateImageLayer())) = aRhs;
    mType = TOpCreateImageLayer;
    return (*(this));
}

Edit&
Edit::operator=(const OpCreateColorLayer& aRhs)
{
    if (MaybeDestroy(TOpCreateColorLayer)) {
        new (ptr_OpCreateColorLayer()) OpCreateColorLayer;
    }
    (*(ptr_OpCreateColorLayer())) = aRhs;
    mType = TOpCreateColorLayer;
    return (*(this));
}

Edit&
Edit::operator=(const OpCreateCanvasLayer& aRhs)
{
    if (MaybeDestroy(TOpCreateCanvasLayer)) {
        new (ptr_OpCreateCanvasLayer()) OpCreateCanvasLayer;
    }
    (*(ptr_OpCreateCanvasLayer())) = aRhs;
    mType = TOpCreateCanvasLayer;
    return (*(this));
}

Edit&
Edit::operator=(const OpCreateRefLayer& aRhs)
{
    if (MaybeDestroy(TOpCreateRefLayer)) {
        new (ptr_OpCreateRefLayer()) OpCreateRefLayer;
    }
    (*(ptr_OpCreateRefLayer())) = aRhs;
    mType = TOpCreateRefLayer;
    return (*(this));
}

Edit&
Edit::operator=(const OpSetLayerAttributes& aRhs)
{
    if (MaybeDestroy(TOpSetLayerAttributes)) {
        new (ptr_OpSetLayerAttributes()) OpSetLayerAttributes;
    }
    (*(ptr_OpSetLayerAttributes())) = aRhs;
    mType = TOpSetLayerAttributes;
    return (*(this));
}

Edit&
Edit::operator=(const OpSetRoot& aRhs)
{
    if (MaybeDestroy(TOpSetRoot)) {
        new (ptr_OpSetRoot()) OpSetRoot;
    }
    (*(ptr_OpSetRoot())) = aRhs;
    mType = TOpSetRoot;
    return (*(this));
}

Edit&
Edit::operator=(const OpInsertAfter& aRhs)
{
    if (MaybeDestroy(TOpInsertAfter)) {
        new (ptr_OpInsertAfter()) OpInsertAfter;
    }
    (*(ptr_OpInsertAfter())) = aRhs;
    mType = TOpInsertAfter;
    return (*(this));
}

Edit&
Edit::operator=(const OpAppendChild& aRhs)
{
    if (MaybeDestroy(TOpAppendChild)) {
        new (ptr_OpAppendChild()) OpAppendChild;
    }
    (*(ptr_OpAppendChild())) = aRhs;
    mType = TOpAppendChild;
    return (*(this));
}

Edit&
Edit::operator=(const OpRemoveChild& aRhs)
{
    if (MaybeDestroy(TOpRemoveChild)) {
        new (ptr_OpRemoveChild()) OpRemoveChild;
    }
    (*(ptr_OpRemoveChild())) = aRhs;
    mType = TOpRemoveChild;
    return (*(this));
}

Edit&
Edit::operator=(const OpRepositionChild& aRhs)
{
    if (MaybeDestroy(TOpRepositionChild)) {
        new (ptr_OpRepositionChild()) OpRepositionChild;
    }
    (*(ptr_OpRepositionChild())) = aRhs;
    mType = TOpRepositionChild;
    return (*(this));
}

Edit&
Edit::operator=(const OpRaiseToTopChild& aRhs)
{
    if (MaybeDestroy(TOpRaiseToTopChild)) {
        new (ptr_OpRaiseToTopChild()) OpRaiseToTopChild;
    }
    (*(ptr_OpRaiseToTopChild())) = aRhs;
    mType = TOpRaiseToTopChild;
    return (*(this));
}

Edit&
Edit::operator=(const OpPaintThebesBuffer& aRhs)
{
    if (MaybeDestroy(TOpPaintThebesBuffer)) {
        new (ptr_OpPaintThebesBuffer()) OpPaintThebesBuffer;
    }
    (*(ptr_OpPaintThebesBuffer())) = aRhs;
    mType = TOpPaintThebesBuffer;
    return (*(this));
}

Edit&
Edit::operator=(const OpPaintTiledLayerBuffer& aRhs)
{
    if (MaybeDestroy(TOpPaintTiledLayerBuffer)) {
        new (ptr_OpPaintTiledLayerBuffer()) OpPaintTiledLayerBuffer;
    }
    (*(ptr_OpPaintTiledLayerBuffer())) = aRhs;
    mType = TOpPaintTiledLayerBuffer;
    return (*(this));
}

Edit&
Edit::operator=(const OpPaintCanvas& aRhs)
{
    if (MaybeDestroy(TOpPaintCanvas)) {
        new (ptr_OpPaintCanvas()) OpPaintCanvas;
    }
    (*(ptr_OpPaintCanvas())) = aRhs;
    mType = TOpPaintCanvas;
    return (*(this));
}

Edit&
Edit::operator=(const OpPaintImage& aRhs)
{
    if (MaybeDestroy(TOpPaintImage)) {
        new (ptr_OpPaintImage()) OpPaintImage;
    }
    (*(ptr_OpPaintImage())) = aRhs;
    mType = TOpPaintImage;
    return (*(this));
}

Edit&
Edit::operator=(const Edit& aRhs)
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case TOpCreateThebesLayer:
        {
            if (MaybeDestroy(t)) {
                new (ptr_OpCreateThebesLayer()) OpCreateThebesLayer;
            }
            (*(ptr_OpCreateThebesLayer())) = (aRhs).get_OpCreateThebesLayer();
            break;
        }
    case TOpCreateContainerLayer:
        {
            if (MaybeDestroy(t)) {
                new (ptr_OpCreateContainerLayer()) OpCreateContainerLayer;
            }
            (*(ptr_OpCreateContainerLayer())) = (aRhs).get_OpCreateContainerLayer();
            break;
        }
    case TOpCreateImageLayer:
        {
            if (MaybeDestroy(t)) {
                new (ptr_OpCreateImageLayer()) OpCreateImageLayer;
            }
            (*(ptr_OpCreateImageLayer())) = (aRhs).get_OpCreateImageLayer();
            break;
        }
    case TOpCreateColorLayer:
        {
            if (MaybeDestroy(t)) {
                new (ptr_OpCreateColorLayer()) OpCreateColorLayer;
            }
            (*(ptr_OpCreateColorLayer())) = (aRhs).get_OpCreateColorLayer();
            break;
        }
    case TOpCreateCanvasLayer:
        {
            if (MaybeDestroy(t)) {
                new (ptr_OpCreateCanvasLayer()) OpCreateCanvasLayer;
            }
            (*(ptr_OpCreateCanvasLayer())) = (aRhs).get_OpCreateCanvasLayer();
            break;
        }
    case TOpCreateRefLayer:
        {
            if (MaybeDestroy(t)) {
                new (ptr_OpCreateRefLayer()) OpCreateRefLayer;
            }
            (*(ptr_OpCreateRefLayer())) = (aRhs).get_OpCreateRefLayer();
            break;
        }
    case TOpSetLayerAttributes:
        {
            if (MaybeDestroy(t)) {
                new (ptr_OpSetLayerAttributes()) OpSetLayerAttributes;
            }
            (*(ptr_OpSetLayerAttributes())) = (aRhs).get_OpSetLayerAttributes();
            break;
        }
    case TOpSetRoot:
        {
            if (MaybeDestroy(t)) {
                new (ptr_OpSetRoot()) OpSetRoot;
            }
            (*(ptr_OpSetRoot())) = (aRhs).get_OpSetRoot();
            break;
        }
    case TOpInsertAfter:
        {
            if (MaybeDestroy(t)) {
                new (ptr_OpInsertAfter()) OpInsertAfter;
            }
            (*(ptr_OpInsertAfter())) = (aRhs).get_OpInsertAfter();
            break;
        }
    case TOpAppendChild:
        {
            if (MaybeDestroy(t)) {
                new (ptr_OpAppendChild()) OpAppendChild;
            }
            (*(ptr_OpAppendChild())) = (aRhs).get_OpAppendChild();
            break;
        }
    case TOpRemoveChild:
        {
            if (MaybeDestroy(t)) {
                new (ptr_OpRemoveChild()) OpRemoveChild;
            }
            (*(ptr_OpRemoveChild())) = (aRhs).get_OpRemoveChild();
            break;
        }
    case TOpRepositionChild:
        {
            if (MaybeDestroy(t)) {
                new (ptr_OpRepositionChild()) OpRepositionChild;
            }
            (*(ptr_OpRepositionChild())) = (aRhs).get_OpRepositionChild();
            break;
        }
    case TOpRaiseToTopChild:
        {
            if (MaybeDestroy(t)) {
                new (ptr_OpRaiseToTopChild()) OpRaiseToTopChild;
            }
            (*(ptr_OpRaiseToTopChild())) = (aRhs).get_OpRaiseToTopChild();
            break;
        }
    case TOpPaintThebesBuffer:
        {
            if (MaybeDestroy(t)) {
                new (ptr_OpPaintThebesBuffer()) OpPaintThebesBuffer;
            }
            (*(ptr_OpPaintThebesBuffer())) = (aRhs).get_OpPaintThebesBuffer();
            break;
        }
    case TOpPaintTiledLayerBuffer:
        {
            if (MaybeDestroy(t)) {
                new (ptr_OpPaintTiledLayerBuffer()) OpPaintTiledLayerBuffer;
            }
            (*(ptr_OpPaintTiledLayerBuffer())) = (aRhs).get_OpPaintTiledLayerBuffer();
            break;
        }
    case TOpPaintCanvas:
        {
            if (MaybeDestroy(t)) {
                new (ptr_OpPaintCanvas()) OpPaintCanvas;
            }
            (*(ptr_OpPaintCanvas())) = (aRhs).get_OpPaintCanvas();
            break;
        }
    case TOpPaintImage:
        {
            if (MaybeDestroy(t)) {
                new (ptr_OpPaintImage()) OpPaintImage;
            }
            (*(ptr_OpPaintImage())) = (aRhs).get_OpPaintImage();
            break;
        }
    case T__None:
        {
            MaybeDestroy(t);
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            break;
        }
    }
    mType = t;
    return (*(this));
}

bool
Edit::operator==(const OpCreateThebesLayer& aRhs) const
{
    return (get_OpCreateThebesLayer()) == (aRhs);
}

bool
Edit::operator==(const OpCreateContainerLayer& aRhs) const
{
    return (get_OpCreateContainerLayer()) == (aRhs);
}

bool
Edit::operator==(const OpCreateImageLayer& aRhs) const
{
    return (get_OpCreateImageLayer()) == (aRhs);
}

bool
Edit::operator==(const OpCreateColorLayer& aRhs) const
{
    return (get_OpCreateColorLayer()) == (aRhs);
}

bool
Edit::operator==(const OpCreateCanvasLayer& aRhs) const
{
    return (get_OpCreateCanvasLayer()) == (aRhs);
}

bool
Edit::operator==(const OpCreateRefLayer& aRhs) const
{
    return (get_OpCreateRefLayer()) == (aRhs);
}

bool
Edit::operator==(const OpSetLayerAttributes& aRhs) const
{
    return (get_OpSetLayerAttributes()) == (aRhs);
}

bool
Edit::operator==(const OpSetRoot& aRhs) const
{
    return (get_OpSetRoot()) == (aRhs);
}

bool
Edit::operator==(const OpInsertAfter& aRhs) const
{
    return (get_OpInsertAfter()) == (aRhs);
}

bool
Edit::operator==(const OpAppendChild& aRhs) const
{
    return (get_OpAppendChild()) == (aRhs);
}

bool
Edit::operator==(const OpRemoveChild& aRhs) const
{
    return (get_OpRemoveChild()) == (aRhs);
}

bool
Edit::operator==(const OpRepositionChild& aRhs) const
{
    return (get_OpRepositionChild()) == (aRhs);
}

bool
Edit::operator==(const OpRaiseToTopChild& aRhs) const
{
    return (get_OpRaiseToTopChild()) == (aRhs);
}

bool
Edit::operator==(const OpPaintThebesBuffer& aRhs) const
{
    return (get_OpPaintThebesBuffer()) == (aRhs);
}

bool
Edit::operator==(const OpPaintTiledLayerBuffer& aRhs) const
{
    return (get_OpPaintTiledLayerBuffer()) == (aRhs);
}

bool
Edit::operator==(const OpPaintCanvas& aRhs) const
{
    return (get_OpPaintCanvas()) == (aRhs);
}

bool
Edit::operator==(const OpPaintImage& aRhs) const
{
    return (get_OpPaintImage()) == (aRhs);
}

bool
Edit::operator==(const Edit& aRhs) const
{
    if ((type()) != ((aRhs).type())) {
        return false;
    }

    switch (type()) {
    case TOpCreateThebesLayer:
        {
            return (get_OpCreateThebesLayer()) == ((aRhs).get_OpCreateThebesLayer());
        }
    case TOpCreateContainerLayer:
        {
            return (get_OpCreateContainerLayer()) == ((aRhs).get_OpCreateContainerLayer());
        }
    case TOpCreateImageLayer:
        {
            return (get_OpCreateImageLayer()) == ((aRhs).get_OpCreateImageLayer());
        }
    case TOpCreateColorLayer:
        {
            return (get_OpCreateColorLayer()) == ((aRhs).get_OpCreateColorLayer());
        }
    case TOpCreateCanvasLayer:
        {
            return (get_OpCreateCanvasLayer()) == ((aRhs).get_OpCreateCanvasLayer());
        }
    case TOpCreateRefLayer:
        {
            return (get_OpCreateRefLayer()) == ((aRhs).get_OpCreateRefLayer());
        }
    case TOpSetLayerAttributes:
        {
            return (get_OpSetLayerAttributes()) == ((aRhs).get_OpSetLayerAttributes());
        }
    case TOpSetRoot:
        {
            return (get_OpSetRoot()) == ((aRhs).get_OpSetRoot());
        }
    case TOpInsertAfter:
        {
            return (get_OpInsertAfter()) == ((aRhs).get_OpInsertAfter());
        }
    case TOpAppendChild:
        {
            return (get_OpAppendChild()) == ((aRhs).get_OpAppendChild());
        }
    case TOpRemoveChild:
        {
            return (get_OpRemoveChild()) == ((aRhs).get_OpRemoveChild());
        }
    case TOpRepositionChild:
        {
            return (get_OpRepositionChild()) == ((aRhs).get_OpRepositionChild());
        }
    case TOpRaiseToTopChild:
        {
            return (get_OpRaiseToTopChild()) == ((aRhs).get_OpRaiseToTopChild());
        }
    case TOpPaintThebesBuffer:
        {
            return (get_OpPaintThebesBuffer()) == ((aRhs).get_OpPaintThebesBuffer());
        }
    case TOpPaintTiledLayerBuffer:
        {
            return (get_OpPaintTiledLayerBuffer()) == ((aRhs).get_OpPaintTiledLayerBuffer());
        }
    case TOpPaintCanvas:
        {
            return (get_OpPaintCanvas()) == ((aRhs).get_OpPaintCanvas());
        }
    case TOpPaintImage:
        {
            return (get_OpPaintImage()) == ((aRhs).get_OpPaintImage());
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return false;
        }
    }
}

} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct OpBufferSwap|
//
namespace mozilla {
namespace layers {
OpBufferSwap::OpBufferSwap()
{
    Init();
}

OpBufferSwap::~OpBufferSwap()
{
}

bool
OpBufferSwap::operator==(const OpBufferSwap& _o) const
{
    if ((!((layerParent()) == ((_o).layerParent())))) {
        return false;
    }
    if ((!((layerChild()) == ((_o).layerChild())))) {
        return false;
    }
    if ((!((newBackBuffer()) == ((_o).newBackBuffer())))) {
        return false;
    }
    return true;
}

void
OpBufferSwap::Init()
{
    layerParent_ = 0;
    layerChild_ = 0;
}

void
OpBufferSwap::Assign(
        PLayerParent* _layerParent,
        PLayerChild* _layerChild,
        const CanvasSurface& _newBackBuffer)
{
    layerParent_ = _layerParent;
    layerChild_ = _layerChild;
    newBackBuffer_ = _newBackBuffer;
}

} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct OpImageSwap|
//
namespace mozilla {
namespace layers {
OpImageSwap::OpImageSwap()
{
    Init();
}

OpImageSwap::~OpImageSwap()
{
}

bool
OpImageSwap::operator==(const OpImageSwap& _o) const
{
    if ((!((layerParent()) == ((_o).layerParent())))) {
        return false;
    }
    if ((!((layerChild()) == ((_o).layerChild())))) {
        return false;
    }
    if ((!((newBackImage()) == ((_o).newBackImage())))) {
        return false;
    }
    return true;
}

void
OpImageSwap::Init()
{
    layerParent_ = 0;
    layerChild_ = 0;
}

void
OpImageSwap::Assign(
        PLayerParent* _layerParent,
        PLayerChild* _layerChild,
        const SharedImage& _newBackImage)
{
    layerParent_ = _layerParent;
    layerChild_ = _layerChild;
    newBackImage_ = _newBackImage;
}

} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct OpThebesBufferSwap|
//
namespace mozilla {
namespace layers {
OpThebesBufferSwap::OpThebesBufferSwap()
{
    Init();
}

OpThebesBufferSwap::~OpThebesBufferSwap()
{
}

bool
OpThebesBufferSwap::operator==(const OpThebesBufferSwap& _o) const
{
    if ((!((layerParent()) == ((_o).layerParent())))) {
        return false;
    }
    if ((!((layerChild()) == ((_o).layerChild())))) {
        return false;
    }
    if ((!((newBackBuffer()) == ((_o).newBackBuffer())))) {
        return false;
    }
    if ((!((newValidRegion()) == ((_o).newValidRegion())))) {
        return false;
    }
    if ((!((readOnlyFrontBuffer()) == ((_o).readOnlyFrontBuffer())))) {
        return false;
    }
    if ((!((frontUpdatedRegion()) == ((_o).frontUpdatedRegion())))) {
        return false;
    }
    return true;
}

void
OpThebesBufferSwap::Init()
{
    layerParent_ = 0;
    layerChild_ = 0;
}

void
OpThebesBufferSwap::Assign(
        PLayerParent* _layerParent,
        PLayerChild* _layerChild,
        const OptionalThebesBuffer& _newBackBuffer,
        const nsIntRegion& _newValidRegion,
        const OptionalThebesBuffer& _readOnlyFrontBuffer,
        const nsIntRegion& _frontUpdatedRegion)
{
    layerParent_ = _layerParent;
    layerChild_ = _layerChild;
    newBackBuffer_ = _newBackBuffer;
    newValidRegion_ = _newValidRegion;
    readOnlyFrontBuffer_ = _readOnlyFrontBuffer;
    frontUpdatedRegion_ = _frontUpdatedRegion;
}

} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |union EditReply|
//
namespace mozilla {
namespace layers {
bool
EditReply::MaybeDestroy(Type aNewType)
{
    if ((mType) == (T__None)) {
        return true;
    }
    if ((mType) == (aNewType)) {
        return false;
    }
    switch (mType) {
    case TOpBufferSwap:
        {
            (ptr_OpBufferSwap())->~OpBufferSwap__tdef();
            break;
        }
    case TOpThebesBufferSwap:
        {
            (ptr_OpThebesBufferSwap())->~OpThebesBufferSwap__tdef();
            break;
        }
    case TOpImageSwap:
        {
            (ptr_OpImageSwap())->~OpImageSwap__tdef();
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("not reached");
            break;
        }
    }
    return true;
}

EditReply::EditReply(const OpBufferSwap& aOther)
{
    new (ptr_OpBufferSwap()) OpBufferSwap(aOther);
    mType = TOpBufferSwap;
}

EditReply::EditReply(const OpThebesBufferSwap& aOther)
{
    new (ptr_OpThebesBufferSwap()) OpThebesBufferSwap(aOther);
    mType = TOpThebesBufferSwap;
}

EditReply::EditReply(const OpImageSwap& aOther)
{
    new (ptr_OpImageSwap()) OpImageSwap(aOther);
    mType = TOpImageSwap;
}

EditReply::EditReply(const EditReply& aOther)
{
    (aOther).AssertSanity();
    switch ((aOther).type()) {
    case TOpBufferSwap:
        {
            new (ptr_OpBufferSwap()) OpBufferSwap((aOther).get_OpBufferSwap());
            break;
        }
    case TOpThebesBufferSwap:
        {
            new (ptr_OpThebesBufferSwap()) OpThebesBufferSwap((aOther).get_OpThebesBufferSwap());
            break;
        }
    case TOpImageSwap:
        {
            new (ptr_OpImageSwap()) OpImageSwap((aOther).get_OpImageSwap());
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return;
        }
    }
    mType = (aOther).type();
}

EditReply::~EditReply()
{
    MaybeDestroy(T__None);
}

EditReply&
EditReply::operator=(const OpBufferSwap& aRhs)
{
    if (MaybeDestroy(TOpBufferSwap)) {
        new (ptr_OpBufferSwap()) OpBufferSwap;
    }
    (*(ptr_OpBufferSwap())) = aRhs;
    mType = TOpBufferSwap;
    return (*(this));
}

EditReply&
EditReply::operator=(const OpThebesBufferSwap& aRhs)
{
    if (MaybeDestroy(TOpThebesBufferSwap)) {
        new (ptr_OpThebesBufferSwap()) OpThebesBufferSwap;
    }
    (*(ptr_OpThebesBufferSwap())) = aRhs;
    mType = TOpThebesBufferSwap;
    return (*(this));
}

EditReply&
EditReply::operator=(const OpImageSwap& aRhs)
{
    if (MaybeDestroy(TOpImageSwap)) {
        new (ptr_OpImageSwap()) OpImageSwap;
    }
    (*(ptr_OpImageSwap())) = aRhs;
    mType = TOpImageSwap;
    return (*(this));
}

EditReply&
EditReply::operator=(const EditReply& aRhs)
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case TOpBufferSwap:
        {
            if (MaybeDestroy(t)) {
                new (ptr_OpBufferSwap()) OpBufferSwap;
            }
            (*(ptr_OpBufferSwap())) = (aRhs).get_OpBufferSwap();
            break;
        }
    case TOpThebesBufferSwap:
        {
            if (MaybeDestroy(t)) {
                new (ptr_OpThebesBufferSwap()) OpThebesBufferSwap;
            }
            (*(ptr_OpThebesBufferSwap())) = (aRhs).get_OpThebesBufferSwap();
            break;
        }
    case TOpImageSwap:
        {
            if (MaybeDestroy(t)) {
                new (ptr_OpImageSwap()) OpImageSwap;
            }
            (*(ptr_OpImageSwap())) = (aRhs).get_OpImageSwap();
            break;
        }
    case T__None:
        {
            MaybeDestroy(t);
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            break;
        }
    }
    mType = t;
    return (*(this));
}

bool
EditReply::operator==(const OpBufferSwap& aRhs) const
{
    return (get_OpBufferSwap()) == (aRhs);
}

bool
EditReply::operator==(const OpThebesBufferSwap& aRhs) const
{
    return (get_OpThebesBufferSwap()) == (aRhs);
}

bool
EditReply::operator==(const OpImageSwap& aRhs) const
{
    return (get_OpImageSwap()) == (aRhs);
}

bool
EditReply::operator==(const EditReply& aRhs) const
{
    if ((type()) != ((aRhs).type())) {
        return false;
    }

    switch (type()) {
    case TOpBufferSwap:
        {
            return (get_OpBufferSwap()) == ((aRhs).get_OpBufferSwap());
        }
    case TOpThebesBufferSwap:
        {
            return (get_OpThebesBufferSwap()) == ((aRhs).get_OpThebesBufferSwap());
        }
    case TOpImageSwap:
        {
            return (get_OpImageSwap()) == ((aRhs).get_OpImageSwap());
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return false;
        }
    }
}

} // namespace layers
} // namespace mozilla
