//
// Automatically generated by ipdlc.
// Edit at your own risk
//


#include "mozilla/dom/sms/PSmsRequest.h"

namespace mozilla {
namespace dom {
namespace sms {
namespace PSmsRequest {

bool
Transition(
        State from,
        mozilla::ipc::Trigger trigger,
        State* next)
{
    switch (from) {
    case __Null:
    case __Error:
        if ((Msg___delete____ID) == ((trigger).mMsg)) {
            (*(next)) = __Dead;
            return true;
        }
        return (__Null) == (from);
    case __Dead:
        NS_RUNTIMEABORT("__delete__()d actor");
        return false;
    case __Dying:
        NS_RUNTIMEABORT("__delete__()d (and unexpectedly dying) actor");
        return false;
    default:
        NS_RUNTIMEABORT("corrupted actor state");
        return false;
    }
    (*(next)) = __Error;
    return false;
}

} // namespace PSmsRequest
} // namespace sms
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct ReplyMessageSend|
//
namespace mozilla {
namespace dom {
namespace sms {
ReplyMessageSend::ReplyMessageSend()
{
    Init();
}

ReplyMessageSend::~ReplyMessageSend()
{
}

bool
ReplyMessageSend::operator==(const ReplyMessageSend& _o) const
{
    if ((!((messageData()) == ((_o).messageData())))) {
        return false;
    }
    return true;
}

void
ReplyMessageSend::Init()
{
}

void
ReplyMessageSend::Assign(const SmsMessageData& _messageData)
{
    messageData_ = _messageData;
}

} // namespace sms
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct ReplyMessageSendFail|
//
namespace mozilla {
namespace dom {
namespace sms {
ReplyMessageSendFail::ReplyMessageSendFail()
{
    Init();
}

ReplyMessageSendFail::~ReplyMessageSendFail()
{
}

bool
ReplyMessageSendFail::operator==(const ReplyMessageSendFail& _o) const
{
    if ((!((error()) == ((_o).error())))) {
        return false;
    }
    return true;
}

void
ReplyMessageSendFail::Init()
{
}

void
ReplyMessageSendFail::Assign(const int32_t& _error)
{
    error_ = _error;
}

} // namespace sms
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct ReplyGetMessage|
//
namespace mozilla {
namespace dom {
namespace sms {
ReplyGetMessage::ReplyGetMessage()
{
    Init();
}

ReplyGetMessage::~ReplyGetMessage()
{
}

bool
ReplyGetMessage::operator==(const ReplyGetMessage& _o) const
{
    if ((!((messageData()) == ((_o).messageData())))) {
        return false;
    }
    return true;
}

void
ReplyGetMessage::Init()
{
}

void
ReplyGetMessage::Assign(const SmsMessageData& _messageData)
{
    messageData_ = _messageData;
}

} // namespace sms
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct ReplyGetMessageFail|
//
namespace mozilla {
namespace dom {
namespace sms {
ReplyGetMessageFail::ReplyGetMessageFail()
{
    Init();
}

ReplyGetMessageFail::~ReplyGetMessageFail()
{
}

bool
ReplyGetMessageFail::operator==(const ReplyGetMessageFail& _o) const
{
    if ((!((error()) == ((_o).error())))) {
        return false;
    }
    return true;
}

void
ReplyGetMessageFail::Init()
{
}

void
ReplyGetMessageFail::Assign(const int32_t& _error)
{
    error_ = _error;
}

} // namespace sms
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct ReplyMessageDelete|
//
namespace mozilla {
namespace dom {
namespace sms {
ReplyMessageDelete::ReplyMessageDelete()
{
    Init();
}

ReplyMessageDelete::~ReplyMessageDelete()
{
}

bool
ReplyMessageDelete::operator==(const ReplyMessageDelete& _o) const
{
    if ((!((deleted()) == ((_o).deleted())))) {
        return false;
    }
    return true;
}

void
ReplyMessageDelete::Init()
{
}

void
ReplyMessageDelete::Assign(const bool& _deleted)
{
    deleted_ = _deleted;
}

} // namespace sms
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct ReplyMessageDeleteFail|
//
namespace mozilla {
namespace dom {
namespace sms {
ReplyMessageDeleteFail::ReplyMessageDeleteFail()
{
    Init();
}

ReplyMessageDeleteFail::~ReplyMessageDeleteFail()
{
}

bool
ReplyMessageDeleteFail::operator==(const ReplyMessageDeleteFail& _o) const
{
    if ((!((error()) == ((_o).error())))) {
        return false;
    }
    return true;
}

void
ReplyMessageDeleteFail::Init()
{
}

void
ReplyMessageDeleteFail::Assign(const int32_t& _error)
{
    error_ = _error;
}

} // namespace sms
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct ReplyCreateMessageList|
//
namespace mozilla {
namespace dom {
namespace sms {
ReplyCreateMessageList::ReplyCreateMessageList()
{
    Init();
}

ReplyCreateMessageList::~ReplyCreateMessageList()
{
}

bool
ReplyCreateMessageList::operator==(const ReplyCreateMessageList& _o) const
{
    if ((!((listId()) == ((_o).listId())))) {
        return false;
    }
    if ((!((messageData()) == ((_o).messageData())))) {
        return false;
    }
    return true;
}

void
ReplyCreateMessageList::Init()
{
}

void
ReplyCreateMessageList::Assign(
        const int32_t& _listId,
        const SmsMessageData& _messageData)
{
    listId_ = _listId;
    messageData_ = _messageData;
}

} // namespace sms
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct ReplyCreateMessageListFail|
//
namespace mozilla {
namespace dom {
namespace sms {
ReplyCreateMessageListFail::ReplyCreateMessageListFail()
{
    Init();
}

ReplyCreateMessageListFail::~ReplyCreateMessageListFail()
{
}

bool
ReplyCreateMessageListFail::operator==(const ReplyCreateMessageListFail& _o) const
{
    if ((!((error()) == ((_o).error())))) {
        return false;
    }
    return true;
}

void
ReplyCreateMessageListFail::Init()
{
}

void
ReplyCreateMessageListFail::Assign(const int32_t& _error)
{
    error_ = _error;
}

} // namespace sms
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct ReplyGetNextMessage|
//
namespace mozilla {
namespace dom {
namespace sms {
ReplyGetNextMessage::ReplyGetNextMessage()
{
    Init();
}

ReplyGetNextMessage::~ReplyGetNextMessage()
{
}

bool
ReplyGetNextMessage::operator==(const ReplyGetNextMessage& _o) const
{
    if ((!((messageData()) == ((_o).messageData())))) {
        return false;
    }
    return true;
}

void
ReplyGetNextMessage::Init()
{
}

void
ReplyGetNextMessage::Assign(const SmsMessageData& _messageData)
{
    messageData_ = _messageData;
}

} // namespace sms
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct ReplyMarkeMessageRead|
//
namespace mozilla {
namespace dom {
namespace sms {
ReplyMarkeMessageRead::ReplyMarkeMessageRead()
{
    Init();
}

ReplyMarkeMessageRead::~ReplyMarkeMessageRead()
{
}

bool
ReplyMarkeMessageRead::operator==(const ReplyMarkeMessageRead& _o) const
{
    if ((!((read()) == ((_o).read())))) {
        return false;
    }
    return true;
}

void
ReplyMarkeMessageRead::Init()
{
}

void
ReplyMarkeMessageRead::Assign(const bool& _read)
{
    read_ = _read;
}

} // namespace sms
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct ReplyMarkeMessageReadFail|
//
namespace mozilla {
namespace dom {
namespace sms {
ReplyMarkeMessageReadFail::ReplyMarkeMessageReadFail()
{
    Init();
}

ReplyMarkeMessageReadFail::~ReplyMarkeMessageReadFail()
{
}

bool
ReplyMarkeMessageReadFail::operator==(const ReplyMarkeMessageReadFail& _o) const
{
    if ((!((error()) == ((_o).error())))) {
        return false;
    }
    return true;
}

void
ReplyMarkeMessageReadFail::Init()
{
}

void
ReplyMarkeMessageReadFail::Assign(const int32_t& _error)
{
    error_ = _error;
}

} // namespace sms
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct ReplyNoMessageInList|
//
namespace mozilla {
namespace dom {
namespace sms {
ReplyNoMessageInList::~ReplyNoMessageInList()
{
}

bool
ReplyNoMessageInList::operator==(const ReplyNoMessageInList& _o) const
{
    return true;
}

void
ReplyNoMessageInList::Init()
{
}

void
ReplyNoMessageInList::Assign()
{
}

} // namespace sms
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct ThreadListItem|
//
namespace mozilla {
namespace dom {
namespace sms {
ThreadListItem::ThreadListItem()
{
    Init();
}

ThreadListItem::~ThreadListItem()
{
}

bool
ThreadListItem::operator==(const ThreadListItem& _o) const
{
    if ((!((senderOrReceiver()) == ((_o).senderOrReceiver())))) {
        return false;
    }
    if ((!((timestamp()) == ((_o).timestamp())))) {
        return false;
    }
    if ((!((body()) == ((_o).body())))) {
        return false;
    }
    if ((!((unreadCount()) == ((_o).unreadCount())))) {
        return false;
    }
    return true;
}

void
ThreadListItem::Init()
{
}

void
ThreadListItem::Assign(
        const nsString& _senderOrReceiver,
        const uint64_t& _timestamp,
        const nsString& _body,
        const uint64_t& _unreadCount)
{
    senderOrReceiver_ = _senderOrReceiver;
    timestamp_ = _timestamp;
    body_ = _body;
    unreadCount_ = _unreadCount;
}

} // namespace sms
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct ReplyThreadList|
//
namespace mozilla {
namespace dom {
namespace sms {
ReplyThreadList::ReplyThreadList()
{
    Init();
}

ReplyThreadList::~ReplyThreadList()
{
}

bool
ReplyThreadList::operator==(const ReplyThreadList& _o) const
{
    if ((!((items()) == ((_o).items())))) {
        return false;
    }
    return true;
}

void
ReplyThreadList::Init()
{
}

void
ReplyThreadList::Assign(const InfallibleTArray<ThreadListItem>& _items)
{
    items_ = _items;
}

} // namespace sms
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct ReplyThreadListFail|
//
namespace mozilla {
namespace dom {
namespace sms {
ReplyThreadListFail::ReplyThreadListFail()
{
    Init();
}

ReplyThreadListFail::~ReplyThreadListFail()
{
}

bool
ReplyThreadListFail::operator==(const ReplyThreadListFail& _o) const
{
    if ((!((error()) == ((_o).error())))) {
        return false;
    }
    return true;
}

void
ReplyThreadListFail::Init()
{
}

void
ReplyThreadListFail::Assign(const int32_t& _error)
{
    error_ = _error;
}

} // namespace sms
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |union MessageReply|
//
namespace mozilla {
namespace dom {
namespace sms {
bool
MessageReply::MaybeDestroy(Type aNewType)
{
    if ((mType) == (T__None)) {
        return true;
    }
    if ((mType) == (aNewType)) {
        return false;
    }
    switch (mType) {
    case TReplyMessageSend:
        {
            (ptr_ReplyMessageSend())->~ReplyMessageSend__tdef();
            break;
        }
    case TReplyMessageSendFail:
        {
            (ptr_ReplyMessageSendFail())->~ReplyMessageSendFail__tdef();
            break;
        }
    case TReplyGetMessage:
        {
            (ptr_ReplyGetMessage())->~ReplyGetMessage__tdef();
            break;
        }
    case TReplyGetMessageFail:
        {
            (ptr_ReplyGetMessageFail())->~ReplyGetMessageFail__tdef();
            break;
        }
    case TReplyMessageDelete:
        {
            (ptr_ReplyMessageDelete())->~ReplyMessageDelete__tdef();
            break;
        }
    case TReplyMessageDeleteFail:
        {
            (ptr_ReplyMessageDeleteFail())->~ReplyMessageDeleteFail__tdef();
            break;
        }
    case TReplyNoMessageInList:
        {
            (ptr_ReplyNoMessageInList())->~ReplyNoMessageInList__tdef();
            break;
        }
    case TReplyCreateMessageList:
        {
            (ptr_ReplyCreateMessageList())->~ReplyCreateMessageList__tdef();
            break;
        }
    case TReplyCreateMessageListFail:
        {
            (ptr_ReplyCreateMessageListFail())->~ReplyCreateMessageListFail__tdef();
            break;
        }
    case TReplyGetNextMessage:
        {
            (ptr_ReplyGetNextMessage())->~ReplyGetNextMessage__tdef();
            break;
        }
    case TReplyMarkeMessageRead:
        {
            (ptr_ReplyMarkeMessageRead())->~ReplyMarkeMessageRead__tdef();
            break;
        }
    case TReplyMarkeMessageReadFail:
        {
            (ptr_ReplyMarkeMessageReadFail())->~ReplyMarkeMessageReadFail__tdef();
            break;
        }
    case TReplyThreadList:
        {
            (ptr_ReplyThreadList())->~ReplyThreadList__tdef();
            break;
        }
    case TReplyThreadListFail:
        {
            (ptr_ReplyThreadListFail())->~ReplyThreadListFail__tdef();
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("not reached");
            break;
        }
    }
    return true;
}

MessageReply::MessageReply(const ReplyMessageSend& aOther)
{
    new (ptr_ReplyMessageSend()) ReplyMessageSend(aOther);
    mType = TReplyMessageSend;
}

MessageReply::MessageReply(const ReplyMessageSendFail& aOther)
{
    new (ptr_ReplyMessageSendFail()) ReplyMessageSendFail(aOther);
    mType = TReplyMessageSendFail;
}

MessageReply::MessageReply(const ReplyGetMessage& aOther)
{
    new (ptr_ReplyGetMessage()) ReplyGetMessage(aOther);
    mType = TReplyGetMessage;
}

MessageReply::MessageReply(const ReplyGetMessageFail& aOther)
{
    new (ptr_ReplyGetMessageFail()) ReplyGetMessageFail(aOther);
    mType = TReplyGetMessageFail;
}

MessageReply::MessageReply(const ReplyMessageDelete& aOther)
{
    new (ptr_ReplyMessageDelete()) ReplyMessageDelete(aOther);
    mType = TReplyMessageDelete;
}

MessageReply::MessageReply(const ReplyMessageDeleteFail& aOther)
{
    new (ptr_ReplyMessageDeleteFail()) ReplyMessageDeleteFail(aOther);
    mType = TReplyMessageDeleteFail;
}

MessageReply::MessageReply(const ReplyNoMessageInList& aOther)
{
    new (ptr_ReplyNoMessageInList()) ReplyNoMessageInList(aOther);
    mType = TReplyNoMessageInList;
}

MessageReply::MessageReply(const ReplyCreateMessageList& aOther)
{
    new (ptr_ReplyCreateMessageList()) ReplyCreateMessageList(aOther);
    mType = TReplyCreateMessageList;
}

MessageReply::MessageReply(const ReplyCreateMessageListFail& aOther)
{
    new (ptr_ReplyCreateMessageListFail()) ReplyCreateMessageListFail(aOther);
    mType = TReplyCreateMessageListFail;
}

MessageReply::MessageReply(const ReplyGetNextMessage& aOther)
{
    new (ptr_ReplyGetNextMessage()) ReplyGetNextMessage(aOther);
    mType = TReplyGetNextMessage;
}

MessageReply::MessageReply(const ReplyMarkeMessageRead& aOther)
{
    new (ptr_ReplyMarkeMessageRead()) ReplyMarkeMessageRead(aOther);
    mType = TReplyMarkeMessageRead;
}

MessageReply::MessageReply(const ReplyMarkeMessageReadFail& aOther)
{
    new (ptr_ReplyMarkeMessageReadFail()) ReplyMarkeMessageReadFail(aOther);
    mType = TReplyMarkeMessageReadFail;
}

MessageReply::MessageReply(const ReplyThreadList& aOther)
{
    new (ptr_ReplyThreadList()) ReplyThreadList(aOther);
    mType = TReplyThreadList;
}

MessageReply::MessageReply(const ReplyThreadListFail& aOther)
{
    new (ptr_ReplyThreadListFail()) ReplyThreadListFail(aOther);
    mType = TReplyThreadListFail;
}

MessageReply::MessageReply(const MessageReply& aOther)
{
    (aOther).AssertSanity();
    switch ((aOther).type()) {
    case TReplyMessageSend:
        {
            new (ptr_ReplyMessageSend()) ReplyMessageSend((aOther).get_ReplyMessageSend());
            break;
        }
    case TReplyMessageSendFail:
        {
            new (ptr_ReplyMessageSendFail()) ReplyMessageSendFail((aOther).get_ReplyMessageSendFail());
            break;
        }
    case TReplyGetMessage:
        {
            new (ptr_ReplyGetMessage()) ReplyGetMessage((aOther).get_ReplyGetMessage());
            break;
        }
    case TReplyGetMessageFail:
        {
            new (ptr_ReplyGetMessageFail()) ReplyGetMessageFail((aOther).get_ReplyGetMessageFail());
            break;
        }
    case TReplyMessageDelete:
        {
            new (ptr_ReplyMessageDelete()) ReplyMessageDelete((aOther).get_ReplyMessageDelete());
            break;
        }
    case TReplyMessageDeleteFail:
        {
            new (ptr_ReplyMessageDeleteFail()) ReplyMessageDeleteFail((aOther).get_ReplyMessageDeleteFail());
            break;
        }
    case TReplyNoMessageInList:
        {
            new (ptr_ReplyNoMessageInList()) ReplyNoMessageInList((aOther).get_ReplyNoMessageInList());
            break;
        }
    case TReplyCreateMessageList:
        {
            new (ptr_ReplyCreateMessageList()) ReplyCreateMessageList((aOther).get_ReplyCreateMessageList());
            break;
        }
    case TReplyCreateMessageListFail:
        {
            new (ptr_ReplyCreateMessageListFail()) ReplyCreateMessageListFail((aOther).get_ReplyCreateMessageListFail());
            break;
        }
    case TReplyGetNextMessage:
        {
            new (ptr_ReplyGetNextMessage()) ReplyGetNextMessage((aOther).get_ReplyGetNextMessage());
            break;
        }
    case TReplyMarkeMessageRead:
        {
            new (ptr_ReplyMarkeMessageRead()) ReplyMarkeMessageRead((aOther).get_ReplyMarkeMessageRead());
            break;
        }
    case TReplyMarkeMessageReadFail:
        {
            new (ptr_ReplyMarkeMessageReadFail()) ReplyMarkeMessageReadFail((aOther).get_ReplyMarkeMessageReadFail());
            break;
        }
    case TReplyThreadList:
        {
            new (ptr_ReplyThreadList()) ReplyThreadList((aOther).get_ReplyThreadList());
            break;
        }
    case TReplyThreadListFail:
        {
            new (ptr_ReplyThreadListFail()) ReplyThreadListFail((aOther).get_ReplyThreadListFail());
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return;
        }
    }
    mType = (aOther).type();
}

MessageReply::~MessageReply()
{
    MaybeDestroy(T__None);
}

MessageReply&
MessageReply::operator=(const ReplyMessageSend& aRhs)
{
    if (MaybeDestroy(TReplyMessageSend)) {
        new (ptr_ReplyMessageSend()) ReplyMessageSend;
    }
    (*(ptr_ReplyMessageSend())) = aRhs;
    mType = TReplyMessageSend;
    return (*(this));
}

MessageReply&
MessageReply::operator=(const ReplyMessageSendFail& aRhs)
{
    if (MaybeDestroy(TReplyMessageSendFail)) {
        new (ptr_ReplyMessageSendFail()) ReplyMessageSendFail;
    }
    (*(ptr_ReplyMessageSendFail())) = aRhs;
    mType = TReplyMessageSendFail;
    return (*(this));
}

MessageReply&
MessageReply::operator=(const ReplyGetMessage& aRhs)
{
    if (MaybeDestroy(TReplyGetMessage)) {
        new (ptr_ReplyGetMessage()) ReplyGetMessage;
    }
    (*(ptr_ReplyGetMessage())) = aRhs;
    mType = TReplyGetMessage;
    return (*(this));
}

MessageReply&
MessageReply::operator=(const ReplyGetMessageFail& aRhs)
{
    if (MaybeDestroy(TReplyGetMessageFail)) {
        new (ptr_ReplyGetMessageFail()) ReplyGetMessageFail;
    }
    (*(ptr_ReplyGetMessageFail())) = aRhs;
    mType = TReplyGetMessageFail;
    return (*(this));
}

MessageReply&
MessageReply::operator=(const ReplyMessageDelete& aRhs)
{
    if (MaybeDestroy(TReplyMessageDelete)) {
        new (ptr_ReplyMessageDelete()) ReplyMessageDelete;
    }
    (*(ptr_ReplyMessageDelete())) = aRhs;
    mType = TReplyMessageDelete;
    return (*(this));
}

MessageReply&
MessageReply::operator=(const ReplyMessageDeleteFail& aRhs)
{
    if (MaybeDestroy(TReplyMessageDeleteFail)) {
        new (ptr_ReplyMessageDeleteFail()) ReplyMessageDeleteFail;
    }
    (*(ptr_ReplyMessageDeleteFail())) = aRhs;
    mType = TReplyMessageDeleteFail;
    return (*(this));
}

MessageReply&
MessageReply::operator=(const ReplyNoMessageInList& aRhs)
{
    if (MaybeDestroy(TReplyNoMessageInList)) {
        new (ptr_ReplyNoMessageInList()) ReplyNoMessageInList;
    }
    (*(ptr_ReplyNoMessageInList())) = aRhs;
    mType = TReplyNoMessageInList;
    return (*(this));
}

MessageReply&
MessageReply::operator=(const ReplyCreateMessageList& aRhs)
{
    if (MaybeDestroy(TReplyCreateMessageList)) {
        new (ptr_ReplyCreateMessageList()) ReplyCreateMessageList;
    }
    (*(ptr_ReplyCreateMessageList())) = aRhs;
    mType = TReplyCreateMessageList;
    return (*(this));
}

MessageReply&
MessageReply::operator=(const ReplyCreateMessageListFail& aRhs)
{
    if (MaybeDestroy(TReplyCreateMessageListFail)) {
        new (ptr_ReplyCreateMessageListFail()) ReplyCreateMessageListFail;
    }
    (*(ptr_ReplyCreateMessageListFail())) = aRhs;
    mType = TReplyCreateMessageListFail;
    return (*(this));
}

MessageReply&
MessageReply::operator=(const ReplyGetNextMessage& aRhs)
{
    if (MaybeDestroy(TReplyGetNextMessage)) {
        new (ptr_ReplyGetNextMessage()) ReplyGetNextMessage;
    }
    (*(ptr_ReplyGetNextMessage())) = aRhs;
    mType = TReplyGetNextMessage;
    return (*(this));
}

MessageReply&
MessageReply::operator=(const ReplyMarkeMessageRead& aRhs)
{
    if (MaybeDestroy(TReplyMarkeMessageRead)) {
        new (ptr_ReplyMarkeMessageRead()) ReplyMarkeMessageRead;
    }
    (*(ptr_ReplyMarkeMessageRead())) = aRhs;
    mType = TReplyMarkeMessageRead;
    return (*(this));
}

MessageReply&
MessageReply::operator=(const ReplyMarkeMessageReadFail& aRhs)
{
    if (MaybeDestroy(TReplyMarkeMessageReadFail)) {
        new (ptr_ReplyMarkeMessageReadFail()) ReplyMarkeMessageReadFail;
    }
    (*(ptr_ReplyMarkeMessageReadFail())) = aRhs;
    mType = TReplyMarkeMessageReadFail;
    return (*(this));
}

MessageReply&
MessageReply::operator=(const ReplyThreadList& aRhs)
{
    if (MaybeDestroy(TReplyThreadList)) {
        new (ptr_ReplyThreadList()) ReplyThreadList;
    }
    (*(ptr_ReplyThreadList())) = aRhs;
    mType = TReplyThreadList;
    return (*(this));
}

MessageReply&
MessageReply::operator=(const ReplyThreadListFail& aRhs)
{
    if (MaybeDestroy(TReplyThreadListFail)) {
        new (ptr_ReplyThreadListFail()) ReplyThreadListFail;
    }
    (*(ptr_ReplyThreadListFail())) = aRhs;
    mType = TReplyThreadListFail;
    return (*(this));
}

MessageReply&
MessageReply::operator=(const MessageReply& aRhs)
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case TReplyMessageSend:
        {
            if (MaybeDestroy(t)) {
                new (ptr_ReplyMessageSend()) ReplyMessageSend;
            }
            (*(ptr_ReplyMessageSend())) = (aRhs).get_ReplyMessageSend();
            break;
        }
    case TReplyMessageSendFail:
        {
            if (MaybeDestroy(t)) {
                new (ptr_ReplyMessageSendFail()) ReplyMessageSendFail;
            }
            (*(ptr_ReplyMessageSendFail())) = (aRhs).get_ReplyMessageSendFail();
            break;
        }
    case TReplyGetMessage:
        {
            if (MaybeDestroy(t)) {
                new (ptr_ReplyGetMessage()) ReplyGetMessage;
            }
            (*(ptr_ReplyGetMessage())) = (aRhs).get_ReplyGetMessage();
            break;
        }
    case TReplyGetMessageFail:
        {
            if (MaybeDestroy(t)) {
                new (ptr_ReplyGetMessageFail()) ReplyGetMessageFail;
            }
            (*(ptr_ReplyGetMessageFail())) = (aRhs).get_ReplyGetMessageFail();
            break;
        }
    case TReplyMessageDelete:
        {
            if (MaybeDestroy(t)) {
                new (ptr_ReplyMessageDelete()) ReplyMessageDelete;
            }
            (*(ptr_ReplyMessageDelete())) = (aRhs).get_ReplyMessageDelete();
            break;
        }
    case TReplyMessageDeleteFail:
        {
            if (MaybeDestroy(t)) {
                new (ptr_ReplyMessageDeleteFail()) ReplyMessageDeleteFail;
            }
            (*(ptr_ReplyMessageDeleteFail())) = (aRhs).get_ReplyMessageDeleteFail();
            break;
        }
    case TReplyNoMessageInList:
        {
            if (MaybeDestroy(t)) {
                new (ptr_ReplyNoMessageInList()) ReplyNoMessageInList;
            }
            (*(ptr_ReplyNoMessageInList())) = (aRhs).get_ReplyNoMessageInList();
            break;
        }
    case TReplyCreateMessageList:
        {
            if (MaybeDestroy(t)) {
                new (ptr_ReplyCreateMessageList()) ReplyCreateMessageList;
            }
            (*(ptr_ReplyCreateMessageList())) = (aRhs).get_ReplyCreateMessageList();
            break;
        }
    case TReplyCreateMessageListFail:
        {
            if (MaybeDestroy(t)) {
                new (ptr_ReplyCreateMessageListFail()) ReplyCreateMessageListFail;
            }
            (*(ptr_ReplyCreateMessageListFail())) = (aRhs).get_ReplyCreateMessageListFail();
            break;
        }
    case TReplyGetNextMessage:
        {
            if (MaybeDestroy(t)) {
                new (ptr_ReplyGetNextMessage()) ReplyGetNextMessage;
            }
            (*(ptr_ReplyGetNextMessage())) = (aRhs).get_ReplyGetNextMessage();
            break;
        }
    case TReplyMarkeMessageRead:
        {
            if (MaybeDestroy(t)) {
                new (ptr_ReplyMarkeMessageRead()) ReplyMarkeMessageRead;
            }
            (*(ptr_ReplyMarkeMessageRead())) = (aRhs).get_ReplyMarkeMessageRead();
            break;
        }
    case TReplyMarkeMessageReadFail:
        {
            if (MaybeDestroy(t)) {
                new (ptr_ReplyMarkeMessageReadFail()) ReplyMarkeMessageReadFail;
            }
            (*(ptr_ReplyMarkeMessageReadFail())) = (aRhs).get_ReplyMarkeMessageReadFail();
            break;
        }
    case TReplyThreadList:
        {
            if (MaybeDestroy(t)) {
                new (ptr_ReplyThreadList()) ReplyThreadList;
            }
            (*(ptr_ReplyThreadList())) = (aRhs).get_ReplyThreadList();
            break;
        }
    case TReplyThreadListFail:
        {
            if (MaybeDestroy(t)) {
                new (ptr_ReplyThreadListFail()) ReplyThreadListFail;
            }
            (*(ptr_ReplyThreadListFail())) = (aRhs).get_ReplyThreadListFail();
            break;
        }
    case T__None:
        {
            MaybeDestroy(t);
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            break;
        }
    }
    mType = t;
    return (*(this));
}

bool
MessageReply::operator==(const ReplyMessageSend& aRhs) const
{
    return (get_ReplyMessageSend()) == (aRhs);
}

bool
MessageReply::operator==(const ReplyMessageSendFail& aRhs) const
{
    return (get_ReplyMessageSendFail()) == (aRhs);
}

bool
MessageReply::operator==(const ReplyGetMessage& aRhs) const
{
    return (get_ReplyGetMessage()) == (aRhs);
}

bool
MessageReply::operator==(const ReplyGetMessageFail& aRhs) const
{
    return (get_ReplyGetMessageFail()) == (aRhs);
}

bool
MessageReply::operator==(const ReplyMessageDelete& aRhs) const
{
    return (get_ReplyMessageDelete()) == (aRhs);
}

bool
MessageReply::operator==(const ReplyMessageDeleteFail& aRhs) const
{
    return (get_ReplyMessageDeleteFail()) == (aRhs);
}

bool
MessageReply::operator==(const ReplyNoMessageInList& aRhs) const
{
    return (get_ReplyNoMessageInList()) == (aRhs);
}

bool
MessageReply::operator==(const ReplyCreateMessageList& aRhs) const
{
    return (get_ReplyCreateMessageList()) == (aRhs);
}

bool
MessageReply::operator==(const ReplyCreateMessageListFail& aRhs) const
{
    return (get_ReplyCreateMessageListFail()) == (aRhs);
}

bool
MessageReply::operator==(const ReplyGetNextMessage& aRhs) const
{
    return (get_ReplyGetNextMessage()) == (aRhs);
}

bool
MessageReply::operator==(const ReplyMarkeMessageRead& aRhs) const
{
    return (get_ReplyMarkeMessageRead()) == (aRhs);
}

bool
MessageReply::operator==(const ReplyMarkeMessageReadFail& aRhs) const
{
    return (get_ReplyMarkeMessageReadFail()) == (aRhs);
}

bool
MessageReply::operator==(const ReplyThreadList& aRhs) const
{
    return (get_ReplyThreadList()) == (aRhs);
}

bool
MessageReply::operator==(const ReplyThreadListFail& aRhs) const
{
    return (get_ReplyThreadListFail()) == (aRhs);
}

bool
MessageReply::operator==(const MessageReply& aRhs) const
{
    if ((type()) != ((aRhs).type())) {
        return false;
    }

    switch (type()) {
    case TReplyMessageSend:
        {
            return (get_ReplyMessageSend()) == ((aRhs).get_ReplyMessageSend());
        }
    case TReplyMessageSendFail:
        {
            return (get_ReplyMessageSendFail()) == ((aRhs).get_ReplyMessageSendFail());
        }
    case TReplyGetMessage:
        {
            return (get_ReplyGetMessage()) == ((aRhs).get_ReplyGetMessage());
        }
    case TReplyGetMessageFail:
        {
            return (get_ReplyGetMessageFail()) == ((aRhs).get_ReplyGetMessageFail());
        }
    case TReplyMessageDelete:
        {
            return (get_ReplyMessageDelete()) == ((aRhs).get_ReplyMessageDelete());
        }
    case TReplyMessageDeleteFail:
        {
            return (get_ReplyMessageDeleteFail()) == ((aRhs).get_ReplyMessageDeleteFail());
        }
    case TReplyNoMessageInList:
        {
            return (get_ReplyNoMessageInList()) == ((aRhs).get_ReplyNoMessageInList());
        }
    case TReplyCreateMessageList:
        {
            return (get_ReplyCreateMessageList()) == ((aRhs).get_ReplyCreateMessageList());
        }
    case TReplyCreateMessageListFail:
        {
            return (get_ReplyCreateMessageListFail()) == ((aRhs).get_ReplyCreateMessageListFail());
        }
    case TReplyGetNextMessage:
        {
            return (get_ReplyGetNextMessage()) == ((aRhs).get_ReplyGetNextMessage());
        }
    case TReplyMarkeMessageRead:
        {
            return (get_ReplyMarkeMessageRead()) == ((aRhs).get_ReplyMarkeMessageRead());
        }
    case TReplyMarkeMessageReadFail:
        {
            return (get_ReplyMarkeMessageReadFail()) == ((aRhs).get_ReplyMarkeMessageReadFail());
        }
    case TReplyThreadList:
        {
            return (get_ReplyThreadList()) == ((aRhs).get_ReplyThreadList());
        }
    case TReplyThreadListFail:
        {
            return (get_ReplyThreadListFail()) == ((aRhs).get_ReplyThreadListFail());
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return false;
        }
    }
}

} // namespace sms
} // namespace dom
} // namespace mozilla
