//
// Automatically generated by ipdlc.
// Edit at your own risk
//


#include "mozilla/plugins/PPluginModuleParent.h"
#ifdef MOZ_CRASHREPORTER
#  include "nsXULAppAPI.h"
#endif 

#include "mozilla/plugins/PPluginIdentifierParent.h"
#include "mozilla/plugins/PPluginInstanceParent.h"
#include "mozilla/plugins/PPluginScriptableObjectParent.h"
#include "mozilla/dom/PCrashReporterParent.h"

typedef IPC::Message Message;
typedef mozilla::ipc::RPCChannel Channel;
typedef mozilla::ipc::RPCChannel::RPCListener ChannelListener;
typedef base::ProcessHandle ProcessHandle;
typedef mozilla::ipc::AsyncChannel AsyncChannel;
typedef mozilla::ipc::SharedMemory SharedMemory;
typedef mozilla::ipc::Trigger Trigger;
typedef mozilla::ipc::ActorHandle ActorHandle;
typedef mozilla::ipc::FileDescriptor FileDescriptor;
typedef mac_plugin_interposing::NSCursorInfo NSCursorInfo;
typedef mozilla::dom::NativeThreadId NativeThreadId;
typedef mozilla::ipc::Shmem Shmem;
using mozilla::plugins::PPluginIdentifierParent;
using mozilla::plugins::PPluginInstanceParent;
using mozilla::plugins::PPluginScriptableObjectParent;
using mozilla::dom::PCrashReporterParent;

namespace mozilla {
namespace plugins {


bool
PPluginModuleParent::RecvPPluginIdentifierConstructor(
        PPluginIdentifierParent* actor,
        const nsCString& aString,
        const int32_t& aInt,
        const bool& temporary)
{
    return true;
}

void
PPluginModuleParent::ActorDestroy(ActorDestroyReason why)
{
}

void
PPluginModuleParent::ProcessingError(Result code)
{
}

bool
PPluginModuleParent::ShouldContinueFromReplyTimeout()
{
    return true;
}

void
PPluginModuleParent::EnteredCxxStack()
{
}

void
PPluginModuleParent::ExitedCxxStack()
{
}

void
PPluginModuleParent::EnteredCall()
{
}

void
PPluginModuleParent::ExitedCall()
{
}

PPluginModuleParent::PPluginModuleParent() :
    mChannel(ALLOW_THIS_IN_INITIALIZER_LIST(this)),
    mLastRouteId(1),
    mLastShmemId(1),
    mState(PPluginModule::__Start)
{
    MOZ_COUNT_CTOR(PPluginModuleParent);
}

PPluginModuleParent::~PPluginModuleParent()
{
    MOZ_COUNT_DTOR(PPluginModuleParent);
}

bool
PPluginModuleParent::Open(
        Channel::Transport* aTransport,
        ProcessHandle aOtherProcess,
        MessageLoop* aThread,
        AsyncChannel::Side aSide)
{
    mOtherProcess = aOtherProcess;
    return (mChannel).Open(aTransport, aThread, aSide);
}

bool
PPluginModuleParent::Open(
        AsyncChannel* aChannel,
        MessageLoop* aMessageLoop,
        AsyncChannel::Side aSide)
{
    mOtherProcess = 0;
    return (mChannel).Open(aChannel, aMessageLoop, aSide);
}

void
PPluginModuleParent::Close()
{
    (mChannel).Close();
}

void
PPluginModuleParent::SetReplyTimeoutMs(int32_t aTimeoutMs)
{
    (mChannel).SetReplyTimeoutMs(aTimeoutMs);
}

void
PPluginModuleParent::ManagedPPluginInstanceParent(InfallibleTArray<PPluginInstanceParent*>& aArr) const
{
    aArr = mManagedPPluginInstanceParent;
}

const InfallibleTArray<PPluginInstanceParent*>&
PPluginModuleParent::ManagedPPluginInstanceParent() const
{
    return mManagedPPluginInstanceParent;
}

void
PPluginModuleParent::ManagedPPluginIdentifierParent(InfallibleTArray<PPluginIdentifierParent*>& aArr) const
{
    aArr = mManagedPPluginIdentifierParent;
}

const InfallibleTArray<PPluginIdentifierParent*>&
PPluginModuleParent::ManagedPPluginIdentifierParent() const
{
    return mManagedPPluginIdentifierParent;
}

void
PPluginModuleParent::ManagedPCrashReporterParent(InfallibleTArray<PCrashReporterParent*>& aArr) const
{
    aArr = mManagedPCrashReporterParent;
}

const InfallibleTArray<PCrashReporterParent*>&
PPluginModuleParent::ManagedPCrashReporterParent() const
{
    return mManagedPCrashReporterParent;
}

PPluginModule::State
PPluginModuleParent::state()
{
    return mState;
}

PPluginIdentifierParent*
PPluginModuleParent::SendPPluginIdentifierConstructor(
        const nsCString& aString,
        const int32_t& aInt,
        const bool& temporary)
{
    return SendPPluginIdentifierConstructor(AllocPPluginIdentifier(aString, aInt, temporary), aString, aInt, temporary);
}

PPluginIdentifierParent*
PPluginModuleParent::SendPPluginIdentifierConstructor(
        PPluginIdentifierParent* actor,
        const nsCString& aString,
        const int32_t& aInt,
        const bool& temporary)
{
    if ((!(actor))) {
        return 0;
    }
    (actor)->mId = Register(actor);
    (actor)->mManager = this;
    (actor)->mChannel = (&(mChannel));
    (mManagedPPluginIdentifierParent).InsertElementSorted(actor);
    (actor)->mState = mozilla::plugins::PPluginIdentifier::__Start;

    PPluginModule::Msg_PPluginIdentifierConstructor* __msg = new PPluginModule::Msg_PPluginIdentifierConstructor();

    Write(actor, __msg, false);
    Write(aString, __msg);
    Write(aInt, __msg);
    Write(temporary, __msg);

    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);


    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginModuleParent] Sending ", stderr);
    }
    if ((!(PPluginModule::Transition(mState, Trigger(Trigger::Send, PPluginModule::Msg_PPluginIdentifierConstructor__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg);
    if ((!(__sendok))) {
        (actor)->DestroySubtree(FailedConstructor);
        (actor)->DeallocSubtree();
        ((actor)->mManager)->RemoveManagee(PPluginIdentifierMsgStart, actor);
        return 0;
    }
    return actor;
}

bool
PPluginModuleParent::SendProcessNativeEventsInRPCCall()
{
    PPluginModule::Msg_ProcessNativeEventsInRPCCall* __msg = new PPluginModule::Msg_ProcessNativeEventsInRPCCall();


    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginModuleParent] Sending ", stderr);
    }
    if ((!(PPluginModule::Transition(mState, Trigger(Trigger::Send, PPluginModule::Msg_ProcessNativeEventsInRPCCall__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg);
    return __sendok;
}

bool
PPluginModuleParent::CallNP_GetEntryPoints(NPError* rv)
{
    PPluginModule::Msg_NP_GetEntryPoints* __msg = new PPluginModule::Msg_NP_GetEntryPoints();


    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);
    (__msg)->set_rpc();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginModuleParent] Sending ", stderr);
    }
    if ((!(PPluginModule::Transition(mState, Trigger(Trigger::Send, PPluginModule::Msg_NP_GetEntryPoints__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Call(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PPluginModule::Reply_NP_GetEntryPoints*>((&(__reply))))->Log("[PPluginModuleParent] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(rv, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    (__reply).EndRead(__iter);

    return true;
}

bool
PPluginModuleParent::CallNP_Initialize(
        const uint32_t& aFlags,
        NPError* rv)
{
    PPluginModule::Msg_NP_Initialize* __msg = new PPluginModule::Msg_NP_Initialize();

    Write(aFlags, __msg);

    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);
    (__msg)->set_rpc();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginModuleParent] Sending ", stderr);
    }
    if ((!(PPluginModule::Transition(mState, Trigger(Trigger::Send, PPluginModule::Msg_NP_Initialize__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Call(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PPluginModule::Reply_NP_Initialize*>((&(__reply))))->Log("[PPluginModuleParent] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(rv, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    (__reply).EndRead(__iter);

    return true;
}

PPluginInstanceParent*
PPluginModuleParent::CallPPluginInstanceConstructor(
        const nsCString& aMimeType,
        const uint16_t& aMode,
        const InfallibleTArray<nsCString>& aNames,
        const InfallibleTArray<nsCString>& aValues,
        NPError* rv)
{
    return CallPPluginInstanceConstructor(AllocPPluginInstance(aMimeType, aMode, aNames, aValues, rv), aMimeType, aMode, aNames, aValues, rv);
}

PPluginInstanceParent*
PPluginModuleParent::CallPPluginInstanceConstructor(
        PPluginInstanceParent* actor,
        const nsCString& aMimeType,
        const uint16_t& aMode,
        const InfallibleTArray<nsCString>& aNames,
        const InfallibleTArray<nsCString>& aValues,
        NPError* rv)
{
    if ((!(actor))) {
        return 0;
    }
    (actor)->mId = Register(actor);
    (actor)->mManager = this;
    (actor)->mChannel = (&(mChannel));
    (mManagedPPluginInstanceParent).InsertElementSorted(actor);
    (actor)->mState = mozilla::plugins::PPluginInstance::__Start;

    PPluginModule::Msg_PPluginInstanceConstructor* __msg = new PPluginModule::Msg_PPluginInstanceConstructor();

    Write(actor, __msg, false);
    Write(aMimeType, __msg);
    Write(aMode, __msg);
    Write(aNames, __msg);
    Write(aValues, __msg);

    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);
    (__msg)->set_rpc();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginModuleParent] Sending ", stderr);
    }
    if ((!(PPluginModule::Transition(mState, Trigger(Trigger::Send, PPluginModule::Msg_PPluginInstanceConstructor__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Call(__msg, (&(__reply)));
    if ((!(__sendok))) {
        (actor)->DestroySubtree(FailedConstructor);
        (actor)->DeallocSubtree();
        ((actor)->mManager)->RemoveManagee(PPluginInstanceMsgStart, actor);
        return 0;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PPluginModule::Reply_PPluginInstanceConstructor*>((&(__reply))))->Log("[PPluginModuleParent] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(rv, (&(__reply)), (&(__iter)))))) {
        if (true) {
            (actor)->DestroySubtree(FailedConstructor);
            (actor)->DeallocSubtree();
            ((actor)->mManager)->RemoveManagee(PPluginInstanceMsgStart, actor);
            return 0;
        }
    }
    (__reply).EndRead(__iter);
    return actor;
}

bool
PPluginModuleParent::CallNP_Shutdown(NPError* rv)
{
    PPluginModule::Msg_NP_Shutdown* __msg = new PPluginModule::Msg_NP_Shutdown();


    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);
    (__msg)->set_rpc();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginModuleParent] Sending ", stderr);
    }
    if ((!(PPluginModule::Transition(mState, Trigger(Trigger::Send, PPluginModule::Msg_NP_Shutdown__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Call(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PPluginModule::Reply_NP_Shutdown*>((&(__reply))))->Log("[PPluginModuleParent] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(rv, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    (__reply).EndRead(__iter);

    return true;
}

bool
PPluginModuleParent::CallOptionalFunctionsSupported(
        bool* aURLRedirectNotify,
        bool* aClearSiteData,
        bool* aGetSitesWithData)
{
    PPluginModule::Msg_OptionalFunctionsSupported* __msg = new PPluginModule::Msg_OptionalFunctionsSupported();


    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);
    (__msg)->set_rpc();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginModuleParent] Sending ", stderr);
    }
    if ((!(PPluginModule::Transition(mState, Trigger(Trigger::Send, PPluginModule::Msg_OptionalFunctionsSupported__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Call(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PPluginModule::Reply_OptionalFunctionsSupported*>((&(__reply))))->Log("[PPluginModuleParent] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(aURLRedirectNotify, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read(aClearSiteData, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read(aGetSitesWithData, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    (__reply).EndRead(__iter);

    return true;
}

bool
PPluginModuleParent::CallNPP_ClearSiteData(
        const nsCString& site,
        const uint64_t& flags,
        const uint64_t& maxAge,
        NPError* rv)
{
    PPluginModule::Msg_NPP_ClearSiteData* __msg = new PPluginModule::Msg_NPP_ClearSiteData();

    Write(site, __msg);
    Write(flags, __msg);
    Write(maxAge, __msg);

    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);
    (__msg)->set_rpc();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginModuleParent] Sending ", stderr);
    }
    if ((!(PPluginModule::Transition(mState, Trigger(Trigger::Send, PPluginModule::Msg_NPP_ClearSiteData__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Call(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PPluginModule::Reply_NPP_ClearSiteData*>((&(__reply))))->Log("[PPluginModuleParent] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(rv, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    (__reply).EndRead(__iter);

    return true;
}

bool
PPluginModuleParent::CallNPP_GetSitesWithData(InfallibleTArray<nsCString>* sites)
{
    PPluginModule::Msg_NPP_GetSitesWithData* __msg = new PPluginModule::Msg_NPP_GetSitesWithData();


    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);
    (__msg)->set_rpc();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginModuleParent] Sending ", stderr);
    }
    if ((!(PPluginModule::Transition(mState, Trigger(Trigger::Send, PPluginModule::Msg_NPP_GetSitesWithData__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Call(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PPluginModule::Reply_NPP_GetSitesWithData*>((&(__reply))))->Log("[PPluginModuleParent] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(sites, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    (__reply).EndRead(__iter);

    return true;
}

bool
PPluginModuleParent::SendSetAudioSessionData(
        const nsID& aID,
        const nsString& aDisplayName,
        const nsString& aIconPath)
{
    PPluginModule::Msg_SetAudioSessionData* __msg = new PPluginModule::Msg_SetAudioSessionData();

    Write(aID, __msg);
    Write(aDisplayName, __msg);
    Write(aIconPath, __msg);

    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginModuleParent] Sending ", stderr);
    }
    if ((!(PPluginModule::Transition(mState, Trigger(Trigger::Send, PPluginModule::Msg_SetAudioSessionData__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg);
    return __sendok;
}

bool
PPluginModuleParent::SendSetParentHangTimeout(const uint32_t& seconds)
{
    PPluginModule::Msg_SetParentHangTimeout* __msg = new PPluginModule::Msg_SetParentHangTimeout();

    Write(seconds, __msg);

    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginModuleParent] Sending ", stderr);
    }
    if ((!(PPluginModule::Transition(mState, Trigger(Trigger::Send, PPluginModule::Msg_SetParentHangTimeout__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg);
    return __sendok;
}

PCrashReporterParent*
PPluginModuleParent::CallPCrashReporterConstructor(
        NativeThreadId* tid,
        uint32_t* processType)
{
    return CallPCrashReporterConstructor(AllocPCrashReporter(tid, processType), tid, processType);
}

PCrashReporterParent*
PPluginModuleParent::CallPCrashReporterConstructor(
        PCrashReporterParent* actor,
        NativeThreadId* tid,
        uint32_t* processType)
{
    if ((!(actor))) {
        return 0;
    }
    (actor)->mId = Register(actor);
    (actor)->mManager = this;
    (actor)->mChannel = (&(mChannel));
    (mManagedPCrashReporterParent).InsertElementSorted(actor);
    (actor)->mState = mozilla::dom::PCrashReporter::__Start;

    PPluginModule::Msg_PCrashReporterConstructor* __msg = new PPluginModule::Msg_PCrashReporterConstructor();

    Write(actor, __msg, false);

    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);
    (__msg)->set_rpc();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginModuleParent] Sending ", stderr);
    }
    if ((!(PPluginModule::Transition(mState, Trigger(Trigger::Send, PPluginModule::Msg_PCrashReporterConstructor__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Call(__msg, (&(__reply)));
    if ((!(__sendok))) {
        (actor)->DestroySubtree(FailedConstructor);
        (actor)->DeallocSubtree();
        ((actor)->mManager)->RemoveManagee(PCrashReporterMsgStart, actor);
        return 0;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PPluginModule::Reply_PCrashReporterConstructor*>((&(__reply))))->Log("[PPluginModuleParent] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(tid, (&(__reply)), (&(__iter)))))) {
        if (true) {
            (actor)->DestroySubtree(FailedConstructor);
            (actor)->DeallocSubtree();
            ((actor)->mManager)->RemoveManagee(PCrashReporterMsgStart, actor);
            return 0;
        }
    }
    if ((!(Read(processType, (&(__reply)), (&(__iter)))))) {
        if (true) {
            (actor)->DestroySubtree(FailedConstructor);
            (actor)->DeallocSubtree();
            ((actor)->mManager)->RemoveManagee(PCrashReporterMsgStart, actor);
            return 0;
        }
    }
    (__reply).EndRead(__iter);
    return actor;
}

int32_t
PPluginModuleParent::Register(ChannelListener* aRouted)
{
    int32_t tmp = (++(mLastRouteId));
    (mActorMap).AddWithID(aRouted, tmp);
    return tmp;
}

int32_t
PPluginModuleParent::RegisterID(
        ChannelListener* aRouted,
        int32_t aId)
{
    (mActorMap).AddWithID(aRouted, aId);
    return aId;
}

ChannelListener*
PPluginModuleParent::Lookup(int32_t aId)
{
    return (mActorMap).Lookup(aId);
}

void
PPluginModuleParent::Unregister(int32_t aId)
{
    return (mActorMap).Remove(aId);
}

void
PPluginModuleParent::RemoveManagee(
        int32_t aProtocolId,
        ChannelListener* aListener)
{
    switch (aProtocolId) {
    case PPluginInstanceMsgStart:
        {
            PPluginInstanceParent* actor = static_cast<PPluginInstanceParent*>(aListener);
            NS_ABORT_IF_FALSE(((mManagedPPluginInstanceParent).NoIndex) != ((mManagedPPluginInstanceParent).BinaryIndexOf(actor)), "actor not managed by this!");

            (mManagedPPluginInstanceParent).RemoveElementSorted(actor);
            DeallocPPluginInstance(actor);
            return;
        }
    case PPluginIdentifierMsgStart:
        {
            PPluginIdentifierParent* actor = static_cast<PPluginIdentifierParent*>(aListener);
            NS_ABORT_IF_FALSE(((mManagedPPluginIdentifierParent).NoIndex) != ((mManagedPPluginIdentifierParent).BinaryIndexOf(actor)), "actor not managed by this!");

            (mManagedPPluginIdentifierParent).RemoveElementSorted(actor);
            DeallocPPluginIdentifier(actor);
            return;
        }
    case PCrashReporterMsgStart:
        {
            PCrashReporterParent* actor = static_cast<PCrashReporterParent*>(aListener);
            NS_ABORT_IF_FALSE(((mManagedPCrashReporterParent).NoIndex) != ((mManagedPCrashReporterParent).BinaryIndexOf(actor)), "actor not managed by this!");

            (mManagedPCrashReporterParent).RemoveElementSorted(actor);
            DeallocPCrashReporter(actor);
            return;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return;
        }
    }
}

Shmem::SharedMemory*
PPluginModuleParent::CreateSharedMemory(
        size_t aSize,
        Shmem::SharedMemory::SharedMemoryType aType,
        bool aUnsafe,
        Shmem::id_t* aId)
{
    nsAutoPtr<Shmem::SharedMemory> segment(Shmem::Alloc(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(), aSize, aType, aUnsafe));
    if ((!(segment))) {
        return 0;
    }
    Shmem shmem(
            Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(),
            (segment).get(),
            (++(mLastShmemId)));
    Message* descriptor = (shmem).ShareTo(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(), OtherProcess(), MSG_ROUTING_CONTROL);
    if ((!(descriptor))) {
        return 0;
    }
    if ((!((mChannel).Send(descriptor)))) {
    }
    (*(aId)) = (shmem).Id(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead());
    (mShmemMap).AddWithID(segment, (*(aId)));
    return (segment).forget();
}

bool
PPluginModuleParent::AdoptSharedMemory(
        Shmem::SharedMemory* segment,
        Shmem::id_t* aId)
{
    Shmem shmem(
            Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(),
            segment,
            (++(mLastShmemId)));
    Message* descriptor = (shmem).ShareTo(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(), OtherProcess(), MSG_ROUTING_CONTROL);
    if ((!(descriptor))) {
        return false;
    }
    if ((!((mChannel).Send(descriptor)))) {
    }
    (*(aId)) = (shmem).Id(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead());
    (mShmemMap).AddWithID(segment, (*(aId)));
    (segment)->AddRef();
    return true;
}

Shmem::SharedMemory*
PPluginModuleParent::LookupSharedMemory(Shmem::id_t aId)
{
    return (mShmemMap).Lookup(aId);
}

bool
PPluginModuleParent::IsTrackingSharedMemory(Shmem::SharedMemory* segment)
{
    return (mShmemMap).HasData(segment);
}

bool
PPluginModuleParent::DestroySharedMemory(Shmem& shmem)
{
    Shmem::id_t aId = (shmem).Id(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead());
    Shmem::SharedMemory* segment = LookupSharedMemory(aId);
    if ((!(segment))) {
        return false;
    }
    Message* descriptor = (shmem).UnshareFrom(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(), OtherProcess(), MSG_ROUTING_CONTROL);

    (mShmemMap).Remove(aId);
    Shmem::Dealloc(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(), segment);

    return (descriptor) && ((mChannel).Send(descriptor));
}

ProcessHandle
PPluginModuleParent::OtherProcess() const
{
    return mOtherProcess;
}

AsyncChannel*
PPluginModuleParent::GetIPCChannel()
{
    return (&(mChannel));
}

PPluginModuleParent::Result
PPluginModuleParent::OnMessageReceived(const Message& __msg)
{
    int32_t __route = (__msg).routing_id();
    if ((MSG_ROUTING_CONTROL) != (__route)) {
        ChannelListener* __routed = Lookup(__route);
        if ((!(__routed))) {
            return MsgRouteError;
        }
        return (__routed)->OnMessageReceived(__msg);
    }

    switch ((__msg).type()) {
    case PPluginModule::Reply_PPluginIdentifierConstructor__ID:
        {
            return MsgProcessed;
        }
    case PPluginModule::Msg_PPluginIdentifierConstructor__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginModule::Msg_PPluginIdentifierConstructor");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginModule::Msg_PPluginIdentifierConstructor*>((&(__msg))))->Log("[PPluginModuleParent] Received ", stderr);
            }

            void* __iter = 0;
            ActorHandle __handle;
            PPluginIdentifierParent* actor;
            nsCString aString;
            int32_t aInt;
            bool temporary;

            if ((!(Read((&(__handle)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(aString)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(aInt)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(temporary)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PPluginModule::Transition(mState, Trigger(Trigger::Recv, PPluginModule::Msg_PPluginIdentifierConstructor__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            actor = AllocPPluginIdentifier(aString, aInt, temporary);
            if ((!(actor))) {
                return MsgValueError;
            }
            (actor)->mId = RegisterID(actor, (__handle).mId);
            (actor)->mManager = this;
            (actor)->mChannel = (&(mChannel));
            (mManagedPPluginIdentifierParent).InsertElementSorted(actor);
            (actor)->mState = mozilla::plugins::PPluginIdentifier::__Start;

            if ((!(RecvPPluginIdentifierConstructor(actor, aString, aInt, temporary)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for PPluginIdentifier returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PPluginModule::Msg_ProcessNativeEventsInRPCCall__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginModule::Msg_ProcessNativeEventsInRPCCall");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginModule::Msg_ProcessNativeEventsInRPCCall*>((&(__msg))))->Log("[PPluginModuleParent] Received ", stderr);
            }

            if ((!(PPluginModule::Transition(mState, Trigger(Trigger::Recv, PPluginModule::Msg_ProcessNativeEventsInRPCCall__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvProcessNativeEventsInRPCCall()))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for ProcessNativeEventsInRPCCall returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PPluginModule::Msg_BackUpXResources__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginModule::Msg_BackUpXResources");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginModule::Msg_BackUpXResources*>((&(__msg))))->Log("[PPluginModuleParent] Received ", stderr);
            }

            void* __iter = 0;
            FileDescriptor aXSocketFd;

            if ((!(Read((&(aXSocketFd)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PPluginModule::Transition(mState, Trigger(Trigger::Recv, PPluginModule::Msg_BackUpXResources__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvBackUpXResources(aXSocketFd)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for BackUpXResources returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PPluginModule::Msg_PluginShowWindow__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginModule::Msg_PluginShowWindow");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginModule::Msg_PluginShowWindow*>((&(__msg))))->Log("[PPluginModuleParent] Received ", stderr);
            }

            void* __iter = 0;
            uint32_t aWindowId;
            bool aModal;
            int32_t aX;
            int32_t aY;
            size_t aWidth;
            size_t aHeight;

            if ((!(Read((&(aWindowId)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(aModal)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(aX)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(aY)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(aWidth)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(aHeight)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PPluginModule::Transition(mState, Trigger(Trigger::Recv, PPluginModule::Msg_PluginShowWindow__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvPluginShowWindow(aWindowId, aModal, aX, aY, aWidth, aHeight)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for PluginShowWindow returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PPluginModule::Msg_PluginHideWindow__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginModule::Msg_PluginHideWindow");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginModule::Msg_PluginHideWindow*>((&(__msg))))->Log("[PPluginModuleParent] Received ", stderr);
            }

            void* __iter = 0;
            uint32_t aWindowId;

            if ((!(Read((&(aWindowId)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PPluginModule::Transition(mState, Trigger(Trigger::Recv, PPluginModule::Msg_PluginHideWindow__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvPluginHideWindow(aWindowId)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for PluginHideWindow returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PPluginModule::Msg_SetCursor__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginModule::Msg_SetCursor");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginModule::Msg_SetCursor*>((&(__msg))))->Log("[PPluginModuleParent] Received ", stderr);
            }

            void* __iter = 0;
            NSCursorInfo cursorInfo;

            if ((!(Read((&(cursorInfo)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PPluginModule::Transition(mState, Trigger(Trigger::Recv, PPluginModule::Msg_SetCursor__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvSetCursor(cursorInfo)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for SetCursor returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PPluginModule::Msg_ShowCursor__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginModule::Msg_ShowCursor");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginModule::Msg_ShowCursor*>((&(__msg))))->Log("[PPluginModuleParent] Received ", stderr);
            }

            void* __iter = 0;
            bool show;

            if ((!(Read((&(show)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PPluginModule::Transition(mState, Trigger(Trigger::Recv, PPluginModule::Msg_ShowCursor__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvShowCursor(show)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for ShowCursor returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PPluginModule::Msg_PushCursor__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginModule::Msg_PushCursor");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginModule::Msg_PushCursor*>((&(__msg))))->Log("[PPluginModuleParent] Received ", stderr);
            }

            void* __iter = 0;
            NSCursorInfo cursorInfo;

            if ((!(Read((&(cursorInfo)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PPluginModule::Transition(mState, Trigger(Trigger::Recv, PPluginModule::Msg_PushCursor__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvPushCursor(cursorInfo)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for PushCursor returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PPluginModule::Msg_PopCursor__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginModule::Msg_PopCursor");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginModule::Msg_PopCursor*>((&(__msg))))->Log("[PPluginModuleParent] Received ", stderr);
            }

            if ((!(PPluginModule::Transition(mState, Trigger(Trigger::Recv, PPluginModule::Msg_PopCursor__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvPopCursor()))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for PopCursor returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PPluginModule::Msg_NPN_ReloadPlugins__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginModule::Msg_NPN_ReloadPlugins");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginModule::Msg_NPN_ReloadPlugins*>((&(__msg))))->Log("[PPluginModuleParent] Received ", stderr);
            }

            void* __iter = 0;
            bool aReloadPages;

            if ((!(Read((&(aReloadPages)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PPluginModule::Transition(mState, Trigger(Trigger::Recv, PPluginModule::Msg_NPN_ReloadPlugins__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvNPN_ReloadPlugins(aReloadPages)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for NPN_ReloadPlugins returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    default:
        {
            return MsgNotKnown;
        }
    case SHMEM_CREATED_MESSAGE_TYPE:
        {
            Shmem::id_t id;
            nsAutoPtr<Shmem::SharedMemory> rawmem(Shmem::OpenExisting(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(), __msg, (&(id)), true));
            if ((!(rawmem))) {
                return MsgPayloadError;
            }
            (mShmemMap).AddWithID((rawmem).forget(), id);

            return MsgProcessed;
        }
    case SHMEM_DESTROYED_MESSAGE_TYPE:
        {
            Shmem::id_t id;
            void* iter = 0;
            if ((!(IPC::ReadParam((&(__msg)), (&(iter)), (&(id)))))) {
                return MsgPayloadError;
            }
            (__msg).EndRead(iter);

            Shmem::SharedMemory* rawmem = LookupSharedMemory(id);
            if ((!(rawmem))) {
                return MsgValueError;
            }
            (mShmemMap).Remove(id);
            Shmem::Dealloc(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(), rawmem);
            return MsgProcessed;
        }
    }
}

PPluginModuleParent::Result
PPluginModuleParent::OnMessageReceived(
        const Message& __msg,
        Message*& __reply)
{
    int32_t __route = (__msg).routing_id();
    if ((MSG_ROUTING_CONTROL) != (__route)) {
        ChannelListener* __routed = Lookup(__route);
        if ((!(__routed))) {
            return MsgRouteError;
        }
        return (__routed)->OnMessageReceived(__msg, __reply);
    }

    switch ((__msg).type()) {
    case PPluginModule::Msg_GetNativeCursorsSupported__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginModule::Msg_GetNativeCursorsSupported");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginModule::Msg_GetNativeCursorsSupported*>((&(__msg))))->Log("[PPluginModuleParent] Received ", stderr);
            }

            if ((!(PPluginModule::Transition(mState, Trigger(Trigger::Recv, PPluginModule::Msg_GetNativeCursorsSupported__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            bool supported;
            int32_t __id = MSG_ROUTING_CONTROL;
            if ((!(RecvGetNativeCursorsSupported((&(supported)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for GetNativeCursorsSupported returned error code");
                return MsgProcessingError;
            }

            __reply = new PPluginModule::Reply_GetNativeCursorsSupported();

            Write(supported, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_sync();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginModule::Reply_GetNativeCursorsSupported*>(__reply))->Log("[PPluginModuleParent] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    case PPluginModule::Msg_NPN_SetException__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginModule::Msg_NPN_SetException");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginModule::Msg_NPN_SetException*>((&(__msg))))->Log("[PPluginModuleParent] Received ", stderr);
            }

            void* __iter = 0;
            PPluginScriptableObjectParent* actor;
            nsCString message;

            if ((!(Read((&(actor)), (&(__msg)), (&(__iter)), true)))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(message)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PPluginModule::Transition(mState, Trigger(Trigger::Recv, PPluginModule::Msg_NPN_SetException__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            int32_t __id = MSG_ROUTING_CONTROL;
            if ((!(RecvNPN_SetException(actor, message)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for NPN_SetException returned error code");
                return MsgProcessingError;
            }

            __reply = new PPluginModule::Reply_NPN_SetException();

            (__reply)->set_routing_id(__id);
            (__reply)->set_sync();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginModule::Reply_NPN_SetException*>(__reply))->Log("[PPluginModuleParent] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    default:
        {
            return MsgNotKnown;
        }
    }
}

PPluginModuleParent::Result
PPluginModuleParent::OnCallReceived(
        const Message& __msg,
        Message*& __reply)
{
    int32_t __route = (__msg).routing_id();
    if ((MSG_ROUTING_CONTROL) != (__route)) {
        ChannelListener* __routed = Lookup(__route);
        if ((!(__routed))) {
            return MsgRouteError;
        }
        return (__routed)->OnCallReceived(__msg, __reply);
    }

    switch ((__msg).type()) {
    case PPluginModule::Msg_NPN_UserAgent__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginModule::Msg_NPN_UserAgent");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginModule::Msg_NPN_UserAgent*>((&(__msg))))->Log("[PPluginModuleParent] Received ", stderr);
            }

            if ((!(PPluginModule::Transition(mState, Trigger(Trigger::Recv, PPluginModule::Msg_NPN_UserAgent__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            nsCString userAgent;
            int32_t __id = MSG_ROUTING_CONTROL;
            if ((!(AnswerNPN_UserAgent((&(userAgent)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for NPN_UserAgent returned error code");
                return MsgProcessingError;
            }

            __reply = new PPluginModule::Reply_NPN_UserAgent();

            Write(userAgent, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_rpc();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginModule::Reply_NPN_UserAgent*>(__reply))->Log("[PPluginModuleParent] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    case PPluginModule::Msg_NPN_GetValue_WithBoolReturn__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginModule::Msg_NPN_GetValue_WithBoolReturn");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginModule::Msg_NPN_GetValue_WithBoolReturn*>((&(__msg))))->Log("[PPluginModuleParent] Received ", stderr);
            }

            void* __iter = 0;
            NPNVariable aVariable;

            if ((!(Read((&(aVariable)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PPluginModule::Transition(mState, Trigger(Trigger::Recv, PPluginModule::Msg_NPN_GetValue_WithBoolReturn__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            NPError aError;
            bool aBoolVal;
            int32_t __id = MSG_ROUTING_CONTROL;
            if ((!(AnswerNPN_GetValue_WithBoolReturn(aVariable, (&(aError)), (&(aBoolVal)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for NPN_GetValue_WithBoolReturn returned error code");
                return MsgProcessingError;
            }

            __reply = new PPluginModule::Reply_NPN_GetValue_WithBoolReturn();

            Write(aError, __reply);
            Write(aBoolVal, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_rpc();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginModule::Reply_NPN_GetValue_WithBoolReturn*>(__reply))->Log("[PPluginModuleParent] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    case PPluginModule::Msg_ProcessSomeEvents__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginModule::Msg_ProcessSomeEvents");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginModule::Msg_ProcessSomeEvents*>((&(__msg))))->Log("[PPluginModuleParent] Received ", stderr);
            }

            if ((!(PPluginModule::Transition(mState, Trigger(Trigger::Recv, PPluginModule::Msg_ProcessSomeEvents__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            int32_t __id = MSG_ROUTING_CONTROL;
            if ((!(AnswerProcessSomeEvents()))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for ProcessSomeEvents returned error code");
                return MsgProcessingError;
            }

            __reply = new PPluginModule::Reply_ProcessSomeEvents();

            (__reply)->set_routing_id(__id);
            (__reply)->set_rpc();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginModule::Reply_ProcessSomeEvents*>(__reply))->Log("[PPluginModuleParent] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    default:
        {
            return MsgNotKnown;
        }
    }
}

void
PPluginModuleParent::OnProcessingError(Result code)
{
    return ProcessingError(code);
}

int32_t
PPluginModuleParent::GetProtocolTypeId()
{
    return PPluginModuleMsgStart;
}

bool
PPluginModuleParent::OnReplyTimeout()
{
    return ShouldContinueFromReplyTimeout();
}

void
PPluginModuleParent::OnEnteredCxxStack()
{
    return EnteredCxxStack();
}

void
PPluginModuleParent::OnExitedCxxStack()
{
    return ExitedCxxStack();
}

void
PPluginModuleParent::OnEnteredCall()
{
    return EnteredCall();
}

void
PPluginModuleParent::OnExitedCall()
{
    return ExitedCall();
}

bool
PPluginModuleParent::IsOnCxxStack() const
{
    return (mChannel).IsOnCxxStack();
}

void
PPluginModuleParent::FlushPendingRPCQueue()
{
    ((this)->mChannel).FlushPendingRPCQueue();
}

void
PPluginModuleParent::OnChannelClose()
{
    DestroySubtree(NormalShutdown);
    DeallocSubtree();
    DeallocShmems();
}

void
PPluginModuleParent::OnChannelError()
{
    DestroySubtree(AbnormalShutdown);
    DeallocSubtree();
    DeallocShmems();
}

void
PPluginModuleParent::OnChannelConnected(int32_t pid)
{
}

bool
PPluginModuleParent::AllocShmem(
        size_t aSize,
        Shmem::SharedMemory::SharedMemoryType aType,
        Shmem* aMem)
{
    Shmem::id_t aId;
    nsAutoPtr<Shmem::SharedMemory> rawmem(CreateSharedMemory(aSize, aType, false, (&(aId))));
    if ((!(rawmem))) {
        return false;
    }

    (*(aMem)) = Shmem(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(), (rawmem).forget(), aId);
    return true;
}

bool
PPluginModuleParent::AllocUnsafeShmem(
        size_t aSize,
        Shmem::SharedMemory::SharedMemoryType aType,
        Shmem* aMem)
{
    Shmem::id_t aId;
    nsAutoPtr<Shmem::SharedMemory> rawmem(CreateSharedMemory(aSize, aType, true, (&(aId))));
    if ((!(rawmem))) {
        return false;
    }

    (*(aMem)) = Shmem(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(), (rawmem).forget(), aId);
    return true;
}

bool
PPluginModuleParent::AdoptShmem(
        Shmem& aMem,
        Shmem* aOutMem)
{
    Shmem::SharedMemory* rawmem = (aMem).Segment(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead());
    if (((!(rawmem))) || (IsTrackingSharedMemory(rawmem))) {
        NS_RUNTIMEABORT("bad Shmem");
    }

    Shmem::id_t aId;
    if ((!(AdoptSharedMemory(rawmem, (&(aId)))))) {
        return false;
    }

    (*(aOutMem)) = Shmem(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(), rawmem, aId);
    return true;
}

bool
PPluginModuleParent::DeallocShmem(Shmem& aMem)
{
    bool ok = DestroySharedMemory(aMem);
    (aMem).forget(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead());
    return ok;
}

void
PPluginModuleParent::ProcessNativeEventsInRPCCall()
{
#ifdef OS_WIN
    (mChannel).ProcessNativeEventsInRPCCall();
#else 
    NS_RUNTIMEABORT("This method is Windows-only");
#endif 
}

void
PPluginModuleParent::SetOtherProcess(ProcessHandle aOtherProcess)
{
    mOtherProcess = aOtherProcess;
}

base::ProcessId
PPluginModuleParent::OtherSidePID() const
{
    return base::GetProcId(mOtherProcess);
}

bool
PPluginModuleParent::TakeMinidump(
        nsIFile** aDump,
        uint32_t* aSequence) const
{
#ifdef MOZ_CRASHREPORTER
    return XRE_TakeMinidumpForChild(OtherSidePID(), aDump, aSequence);
#else 
    return false;
#endif 
}

bool
PPluginModuleParent::BlockChild()
{
    return (mChannel).BlockChild();
}

bool
PPluginModuleParent::UnblockChild()
{
    return (mChannel).UnblockChild();
}

void
PPluginModuleParent::FatalError(const char* const msg) const
{
    // Virtual method to prevent inlining.
    // This give us better error reporting.
    // See bug 589371

    NS_ERROR("IPDL error:");
    NS_ERROR(msg);
    mozilla::ipc::ProtocolErrorBreakpoint(msg);

    NS_ERROR("[PPluginModuleParent] killing child side as a result");

    if ((!(base::KillProcess(OtherProcess(), base::PROCESS_END_KILLED_BY_USER, false)))) {
        NS_ERROR("  may have failed to kill child!");
    }
}

void
PPluginModuleParent::DestroySubtree(ActorDestroyReason why)
{
    ActorDestroyReason subtreewhy = (((why) == (Deletion)) || ((why) == (FailedConstructor)) ? AncestorDeletion : why);

    {
        // Recursively shutting down PPluginInstance kids
        InfallibleTArray<PPluginInstanceParent*> kids(mManagedPPluginInstanceParent);
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DestroySubtree(subtreewhy);
        }
    }
    {
        // Recursively shutting down PPluginIdentifier kids
        InfallibleTArray<PPluginIdentifierParent*> kids(mManagedPPluginIdentifierParent);
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DestroySubtree(subtreewhy);
        }
    }
    {
        // Recursively shutting down PCrashReporter kids
        InfallibleTArray<PCrashReporterParent*> kids(mManagedPCrashReporterParent);
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DestroySubtree(subtreewhy);
        }
    }

    // Finally, destroy "us".
    ActorDestroy(why);
}

void
PPluginModuleParent::DeallocSubtree()
{
    {
        // Recursively deleting PPluginInstance kids
        InfallibleTArray<PPluginInstanceParent*>& kids = mManagedPPluginInstanceParent;
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DeallocSubtree();
        }

        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            DeallocPPluginInstance(kids[i]);
        }
        (mManagedPPluginInstanceParent).Clear();
    }
    {
        // Recursively deleting PPluginIdentifier kids
        InfallibleTArray<PPluginIdentifierParent*>& kids = mManagedPPluginIdentifierParent;
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DeallocSubtree();
        }

        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            DeallocPPluginIdentifier(kids[i]);
        }
        (mManagedPPluginIdentifierParent).Clear();
    }
    {
        // Recursively deleting PCrashReporter kids
        InfallibleTArray<PCrashReporterParent*>& kids = mManagedPCrashReporterParent;
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DeallocSubtree();
        }

        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            DeallocPCrashReporter(kids[i]);
        }
        (mManagedPCrashReporterParent).Clear();
    }
}

void
PPluginModuleParent::DeallocShmems()
{
    for (IDMap<SharedMemory>::const_iterator cit = (mShmemMap).begin(); (cit) != ((mShmemMap).end()); (++(cit))) {
        Shmem::Dealloc(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(), (cit)->second);
    }
    (mShmemMap).Clear();
}

void
PPluginModuleParent::Write(
        const FileDescriptor& __v,
        Message* __msg)
{
    FileDescriptor::PickleType pfd = (__v).ShareTo(FileDescriptor::IPDLPrivate(), OtherProcess());
    IPC::WriteParam(__msg, pfd);
}

bool
PPluginModuleParent::Read(
        FileDescriptor* __v,
        const Message* __msg,
        void** __iter)
{
    FileDescriptor::PickleType pfd;
    if ((!(IPC::ReadParam(__msg, __iter, (&(pfd)))))) {
        return false;
    }

    FileDescriptor fd = FileDescriptor(FileDescriptor::IPDLPrivate(), pfd);
    if ((!((fd).IsValid()))) {
        return false;
    }

    (*(__v)) = fd;
    return true;
}

void
PPluginModuleParent::Write(
        PPluginScriptableObjectParent* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PPluginModuleParent::Read(
        PPluginScriptableObjectParent** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PPluginModule");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PPluginScriptableObject");
        return false;
    }

    if ((PPluginScriptableObjectMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PPluginScriptableObject has different type");
        return false;
    }

    (*(__v)) = static_cast<PPluginScriptableObjectParent*>(listener);
    return true;
}

void
PPluginModuleParent::Write(
        PPluginInstanceParent* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PPluginModuleParent::Read(
        PPluginInstanceParent** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PPluginModule");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PPluginInstance");
        return false;
    }

    if ((PPluginInstanceMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PPluginInstance has different type");
        return false;
    }

    (*(__v)) = static_cast<PPluginInstanceParent*>(listener);
    return true;
}

void
PPluginModuleParent::Write(
        PCrashReporterParent* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PPluginModuleParent::Read(
        PCrashReporterParent** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PPluginModule");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PCrashReporter");
        return false;
    }

    if ((PCrashReporterMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PCrashReporter has different type");
        return false;
    }

    (*(__v)) = static_cast<PCrashReporterParent*>(listener);
    return true;
}

void
PPluginModuleParent::Write(
        PPluginIdentifierParent* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PPluginModuleParent::Read(
        PPluginIdentifierParent** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PPluginModule");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PPluginIdentifier");
        return false;
    }

    if ((PPluginIdentifierMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PPluginIdentifier has different type");
        return false;
    }

    (*(__v)) = static_cast<PPluginIdentifierParent*>(listener);
    return true;
}



} // namespace plugins
} // namespace mozilla
