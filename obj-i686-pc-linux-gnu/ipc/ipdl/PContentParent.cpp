//
// Automatically generated by ipdlc.
// Edit at your own risk
//


#include "mozilla/dom/PContentParent.h"
#ifdef MOZ_CRASHREPORTER
#  include "nsXULAppAPI.h"
#endif 

#include "mozilla/dom/PBlobParent.h"
#include "mozilla/dom/bluetooth/PBluetoothParent.h"
#include "mozilla/dom/PBrowserParent.h"
#include "mozilla/layers/PCompositorParent.h"
#include "mozilla/dom/PCrashReporterParent.h"
#include "mozilla/dom/PExternalHelperAppParent.h"
#include "mozilla/dom/devicestorage/PDeviceStorageRequestParent.h"
#include "mozilla/hal_sandbox/PHalParent.h"
#include "mozilla/layers/PImageBridgeParent.h"
#include "mozilla/dom/indexedDB/PIndexedDBParent.h"
#include "mozilla/dom/PMemoryReportRequestParent.h"
#include "mozilla/net/PNeckoParent.h"
#include "mozilla/dom/sms/PSmsParent.h"
#include "mozilla/dom/PStorageParent.h"
#include "mozilla/ipc/PTestShellParent.h"

typedef IPC::Message Message;
typedef mozilla::ipc::RPCChannel Channel;
typedef mozilla::ipc::RPCChannel::RPCListener ChannelListener;
typedef base::ProcessHandle ProcessHandle;
typedef mozilla::ipc::AsyncChannel AsyncChannel;
typedef mozilla::ipc::SharedMemory SharedMemory;
typedef mozilla::ipc::Trigger Trigger;
typedef mozilla::ipc::ActorHandle ActorHandle;
typedef mozilla::dom::AppFrameIPCTabContext AppFrameIPCTabContext;
typedef mozilla::dom::AudioChannelType AudioChannelType;
typedef mozilla::dom::BlobConstructorParams BlobConstructorParams;
typedef mozilla::dom::BrowserFrameIPCTabContext BrowserFrameIPCTabContext;
typedef mozilla::dom::ClonedMessageData ClonedMessageData;
typedef mozilla::dom::DeviceStorageAddParams DeviceStorageAddParams;
typedef mozilla::dom::DeviceStorageDeleteParams DeviceStorageDeleteParams;
typedef mozilla::dom::DeviceStorageEnumerationParams DeviceStorageEnumerationParams;
typedef mozilla::dom::DeviceStorageGetParams DeviceStorageGetParams;
typedef mozilla::dom::DeviceStorageParams DeviceStorageParams;
typedef mozilla::dom::DeviceStorageStatParams DeviceStorageStatParams;
typedef mozilla::dom::FileBlobConstructorParams FileBlobConstructorParams;
typedef mozilla::ipc::FileDescriptor FileDescriptor;
typedef mozilla::dom::FontListEntry FontListEntry;
typedef mozilla::ipc::GenericURIParams GenericURIParams;
typedef mozilla::dom::IPCTabAppBrowserContext IPCTabAppBrowserContext;
typedef mozilla::dom::IPCTabContext IPCTabContext;
typedef mozilla::ipc::JARURIParams JARURIParams;
typedef mozilla::dom::MaybePrefValue MaybePrefValue;
typedef mozilla::dom::MysteryBlobConstructorParams MysteryBlobConstructorParams;
typedef mozilla::dom::NativeThreadId NativeThreadId;
typedef mozilla::dom::NormalBlobConstructorParams NormalBlobConstructorParams;
typedef mozilla::ipc::OptionalURIParams OptionalURIParams;
typedef IPC::Permission Permission;
typedef mozilla::dom::PopupIPCTabContext PopupIPCTabContext;
typedef mozilla::dom::PrefSetting PrefSetting;
typedef mozilla::dom::PrefValue PrefValue;
typedef IPC::Principal Principal;
typedef mozilla::layout::ScrollingBehavior ScrollingBehavior;
typedef mozilla::SerializedStructuredCloneBuffer SerializedStructuredCloneBuffer;
typedef mozilla::ipc::Shmem Shmem;
typedef mozilla::ipc::SimpleURIParams SimpleURIParams;
typedef mozilla::dom::SlicedBlobConstructorParams SlicedBlobConstructorParams;
typedef mozilla::ipc::StandardURLParams StandardURLParams;
typedef mozilla::ipc::StandardURLSegment StandardURLSegment;
typedef mozilla::dom::StorageClone StorageClone;
typedef mozilla::dom::StorageConstructData StorageConstructData;
typedef mozilla::ipc::URIParams URIParams;
typedef mozilla::dom::VanillaFrameIPCTabContext VanillaFrameIPCTabContext;
typedef mozilla::null_t null_t;
typedef mozilla::void_t void_t;
using mozilla::dom::PBlobParent;
using mozilla::dom::bluetooth::PBluetoothParent;
using mozilla::dom::PBrowserParent;
using mozilla::layers::PCompositorParent;
using mozilla::dom::PCrashReporterParent;
using mozilla::dom::PExternalHelperAppParent;
using mozilla::dom::devicestorage::PDeviceStorageRequestParent;
using mozilla::hal_sandbox::PHalParent;
using mozilla::layers::PImageBridgeParent;
using mozilla::dom::indexedDB::PIndexedDBParent;
using mozilla::dom::PMemoryReportRequestParent;
using mozilla::net::PNeckoParent;
using mozilla::dom::sms::PSmsParent;
using mozilla::dom::PStorageParent;
using mozilla::ipc::PTestShellParent;

namespace mozilla {
namespace dom {


bool
PContentParent::RecvPBrowserConstructor(
        PBrowserParent* actor,
        const IPCTabContext& context,
        const uint32_t& chromeFlags)
{
    return true;
}

bool
PContentParent::RecvPBlobConstructor(
        PBlobParent* actor,
        const BlobConstructorParams& params)
{
    return true;
}

bool
PContentParent::RecvPDeviceStorageRequestConstructor(
        PDeviceStorageRequestParent* actor,
        const DeviceStorageParams& params)
{
    return true;
}

bool
PContentParent::RecvPCrashReporterConstructor(
        PCrashReporterParent* actor,
        const NativeThreadId& tid,
        const uint32_t& processType)
{
    return true;
}

bool
PContentParent::RecvPHalConstructor(PHalParent* actor)
{
    return true;
}

bool
PContentParent::RecvPIndexedDBConstructor(PIndexedDBParent* actor)
{
    return true;
}

bool
PContentParent::RecvPNeckoConstructor(PNeckoParent* actor)
{
    return true;
}

bool
PContentParent::RecvPSmsConstructor(PSmsParent* actor)
{
    return true;
}

bool
PContentParent::RecvPStorageConstructor(
        PStorageParent* actor,
        const StorageConstructData& data)
{
    return true;
}

bool
PContentParent::RecvPBluetoothConstructor(PBluetoothParent* actor)
{
    return true;
}

bool
PContentParent::RecvPExternalHelperAppConstructor(
        PExternalHelperAppParent* actor,
        const OptionalURIParams& uri,
        const nsCString& aMimeContentType,
        const nsCString& aContentDisposition,
        const bool& aForceSave,
        const int64_t& aContentLength,
        const OptionalURIParams& aReferrer)
{
    return true;
}

void
PContentParent::ActorDestroy(ActorDestroyReason why)
{
}

void
PContentParent::ProcessingError(Result code)
{
}

bool
PContentParent::ShouldContinueFromReplyTimeout()
{
    return true;
}

void
PContentParent::EnteredCxxStack()
{
}

void
PContentParent::ExitedCxxStack()
{
}

void
PContentParent::EnteredCall()
{
}

void
PContentParent::ExitedCall()
{
}

PContentParent::PContentParent() :
    mChannel(ALLOW_THIS_IN_INITIALIZER_LIST(this)),
    mLastRouteId(1),
    mLastShmemId(1),
    mState(PContent::__Start)
{
    MOZ_COUNT_CTOR(PContentParent);
}

PContentParent::~PContentParent()
{
    MOZ_COUNT_DTOR(PContentParent);
}

bool
PContentParent::Open(
        Channel::Transport* aTransport,
        ProcessHandle aOtherProcess,
        MessageLoop* aThread,
        AsyncChannel::Side aSide)
{
    mOtherProcess = aOtherProcess;
    return (mChannel).Open(aTransport, aThread, aSide);
}

bool
PContentParent::Open(
        AsyncChannel* aChannel,
        MessageLoop* aMessageLoop,
        AsyncChannel::Side aSide)
{
    mOtherProcess = 0;
    return (mChannel).Open(aChannel, aMessageLoop, aSide);
}

void
PContentParent::Close()
{
    (mChannel).Close();
}

void
PContentParent::SetReplyTimeoutMs(int32_t aTimeoutMs)
{
    (mChannel).SetReplyTimeoutMs(aTimeoutMs);
}

void
PContentParent::ManagedPBlobParent(InfallibleTArray<PBlobParent*>& aArr) const
{
    aArr = mManagedPBlobParent;
}

const InfallibleTArray<PBlobParent*>&
PContentParent::ManagedPBlobParent() const
{
    return mManagedPBlobParent;
}

void
PContentParent::ManagedPBluetoothParent(InfallibleTArray<PBluetoothParent*>& aArr) const
{
    aArr = mManagedPBluetoothParent;
}

const InfallibleTArray<PBluetoothParent*>&
PContentParent::ManagedPBluetoothParent() const
{
    return mManagedPBluetoothParent;
}

void
PContentParent::ManagedPBrowserParent(InfallibleTArray<PBrowserParent*>& aArr) const
{
    aArr = mManagedPBrowserParent;
}

const InfallibleTArray<PBrowserParent*>&
PContentParent::ManagedPBrowserParent() const
{
    return mManagedPBrowserParent;
}

void
PContentParent::ManagedPCrashReporterParent(InfallibleTArray<PCrashReporterParent*>& aArr) const
{
    aArr = mManagedPCrashReporterParent;
}

const InfallibleTArray<PCrashReporterParent*>&
PContentParent::ManagedPCrashReporterParent() const
{
    return mManagedPCrashReporterParent;
}

void
PContentParent::ManagedPDeviceStorageRequestParent(InfallibleTArray<PDeviceStorageRequestParent*>& aArr) const
{
    aArr = mManagedPDeviceStorageRequestParent;
}

const InfallibleTArray<PDeviceStorageRequestParent*>&
PContentParent::ManagedPDeviceStorageRequestParent() const
{
    return mManagedPDeviceStorageRequestParent;
}

void
PContentParent::ManagedPExternalHelperAppParent(InfallibleTArray<PExternalHelperAppParent*>& aArr) const
{
    aArr = mManagedPExternalHelperAppParent;
}

const InfallibleTArray<PExternalHelperAppParent*>&
PContentParent::ManagedPExternalHelperAppParent() const
{
    return mManagedPExternalHelperAppParent;
}

void
PContentParent::ManagedPHalParent(InfallibleTArray<PHalParent*>& aArr) const
{
    aArr = mManagedPHalParent;
}

const InfallibleTArray<PHalParent*>&
PContentParent::ManagedPHalParent() const
{
    return mManagedPHalParent;
}

void
PContentParent::ManagedPIndexedDBParent(InfallibleTArray<PIndexedDBParent*>& aArr) const
{
    aArr = mManagedPIndexedDBParent;
}

const InfallibleTArray<PIndexedDBParent*>&
PContentParent::ManagedPIndexedDBParent() const
{
    return mManagedPIndexedDBParent;
}

void
PContentParent::ManagedPMemoryReportRequestParent(InfallibleTArray<PMemoryReportRequestParent*>& aArr) const
{
    aArr = mManagedPMemoryReportRequestParent;
}

const InfallibleTArray<PMemoryReportRequestParent*>&
PContentParent::ManagedPMemoryReportRequestParent() const
{
    return mManagedPMemoryReportRequestParent;
}

void
PContentParent::ManagedPNeckoParent(InfallibleTArray<PNeckoParent*>& aArr) const
{
    aArr = mManagedPNeckoParent;
}

const InfallibleTArray<PNeckoParent*>&
PContentParent::ManagedPNeckoParent() const
{
    return mManagedPNeckoParent;
}

void
PContentParent::ManagedPSmsParent(InfallibleTArray<PSmsParent*>& aArr) const
{
    aArr = mManagedPSmsParent;
}

const InfallibleTArray<PSmsParent*>&
PContentParent::ManagedPSmsParent() const
{
    return mManagedPSmsParent;
}

void
PContentParent::ManagedPStorageParent(InfallibleTArray<PStorageParent*>& aArr) const
{
    aArr = mManagedPStorageParent;
}

const InfallibleTArray<PStorageParent*>&
PContentParent::ManagedPStorageParent() const
{
    return mManagedPStorageParent;
}

void
PContentParent::ManagedPTestShellParent(InfallibleTArray<PTestShellParent*>& aArr) const
{
    aArr = mManagedPTestShellParent;
}

const InfallibleTArray<PTestShellParent*>&
PContentParent::ManagedPTestShellParent() const
{
    return mManagedPTestShellParent;
}

PContent::State
PContentParent::state()
{
    return mState;
}

PBrowserParent*
PContentParent::SendPBrowserConstructor(
        const IPCTabContext& context,
        const uint32_t& chromeFlags)
{
    return SendPBrowserConstructor(AllocPBrowser(context, chromeFlags), context, chromeFlags);
}

PBrowserParent*
PContentParent::SendPBrowserConstructor(
        PBrowserParent* actor,
        const IPCTabContext& context,
        const uint32_t& chromeFlags)
{
    if ((!(actor))) {
        return 0;
    }
    (actor)->mId = Register(actor);
    (actor)->mManager = this;
    (actor)->mChannel = (&(mChannel));
    (mManagedPBrowserParent).InsertElementSorted(actor);
    (actor)->mState = mozilla::dom::PBrowser::__Start;

    PContent::Msg_PBrowserConstructor* __msg = new PContent::Msg_PBrowserConstructor();

    Write(actor, __msg, false);
    Write(context, __msg);
    Write(chromeFlags, __msg);

    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);


    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PContentParent] Sending ", stderr);
    }
    if ((!(PContent::Transition(mState, Trigger(Trigger::Send, PContent::Msg_PBrowserConstructor__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg);
    if ((!(__sendok))) {
        (actor)->DestroySubtree(FailedConstructor);
        (actor)->DeallocSubtree();
        ((actor)->mManager)->RemoveManagee(PBrowserMsgStart, actor);
        return 0;
    }
    return actor;
}

PBlobParent*
PContentParent::SendPBlobConstructor(const BlobConstructorParams& params)
{
    return SendPBlobConstructor(AllocPBlob(params), params);
}

PBlobParent*
PContentParent::SendPBlobConstructor(
        PBlobParent* actor,
        const BlobConstructorParams& params)
{
    if ((!(actor))) {
        return 0;
    }
    (actor)->mId = Register(actor);
    (actor)->mManager = this;
    (actor)->mChannel = (&(mChannel));
    (mManagedPBlobParent).InsertElementSorted(actor);
    (actor)->mState = mozilla::dom::PBlob::__Start;

    PContent::Msg_PBlobConstructor* __msg = new PContent::Msg_PBlobConstructor();

    Write(actor, __msg, false);
    Write(params, __msg);

    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);


    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PContentParent] Sending ", stderr);
    }
    if ((!(PContent::Transition(mState, Trigger(Trigger::Send, PContent::Msg_PBlobConstructor__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg);
    if ((!(__sendok))) {
        (actor)->DestroySubtree(FailedConstructor);
        (actor)->DeallocSubtree();
        ((actor)->mManager)->RemoveManagee(PBlobMsgStart, actor);
        return 0;
    }
    return actor;
}

PMemoryReportRequestParent*
PContentParent::SendPMemoryReportRequestConstructor()
{
    return SendPMemoryReportRequestConstructor(AllocPMemoryReportRequest());
}

PMemoryReportRequestParent*
PContentParent::SendPMemoryReportRequestConstructor(PMemoryReportRequestParent* actor)
{
    if ((!(actor))) {
        return 0;
    }
    (actor)->mId = Register(actor);
    (actor)->mManager = this;
    (actor)->mChannel = (&(mChannel));
    (mManagedPMemoryReportRequestParent).InsertElementSorted(actor);
    (actor)->mState = mozilla::dom::PMemoryReportRequest::__Start;

    PContent::Msg_PMemoryReportRequestConstructor* __msg = new PContent::Msg_PMemoryReportRequestConstructor();

    Write(actor, __msg, false);

    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);


    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PContentParent] Sending ", stderr);
    }
    if ((!(PContent::Transition(mState, Trigger(Trigger::Send, PContent::Msg_PMemoryReportRequestConstructor__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg);
    if ((!(__sendok))) {
        (actor)->DestroySubtree(FailedConstructor);
        (actor)->DeallocSubtree();
        ((actor)->mManager)->RemoveManagee(PMemoryReportRequestMsgStart, actor);
        return 0;
    }
    return actor;
}

bool
PContentParent::SendAudioChannelNotify()
{
    PContent::Msg_AudioChannelNotify* __msg = new PContent::Msg_AudioChannelNotify();


    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PContentParent] Sending ", stderr);
    }
    if ((!(PContent::Transition(mState, Trigger(Trigger::Send, PContent::Msg_AudioChannelNotify__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg);
    return __sendok;
}

bool
PContentParent::SendDumpMemoryReportsToFile(
        const nsString& identifier,
        const bool& minimizeMemoryUsage,
        const bool& dumpChildProcesses)
{
    PContent::Msg_DumpMemoryReportsToFile* __msg = new PContent::Msg_DumpMemoryReportsToFile();

    Write(identifier, __msg);
    Write(minimizeMemoryUsage, __msg);
    Write(dumpChildProcesses, __msg);

    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PContentParent] Sending ", stderr);
    }
    if ((!(PContent::Transition(mState, Trigger(Trigger::Send, PContent::Msg_DumpMemoryReportsToFile__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg);
    return __sendok;
}

bool
PContentParent::SendDumpGCAndCCLogsToFile(
        const nsString& identifier,
        const bool& dumpChildProcesses)
{
    PContent::Msg_DumpGCAndCCLogsToFile* __msg = new PContent::Msg_DumpGCAndCCLogsToFile();

    Write(identifier, __msg);
    Write(dumpChildProcesses, __msg);

    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PContentParent] Sending ", stderr);
    }
    if ((!(PContent::Transition(mState, Trigger(Trigger::Send, PContent::Msg_DumpGCAndCCLogsToFile__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg);
    return __sendok;
}

PTestShellParent*
PContentParent::SendPTestShellConstructor()
{
    return SendPTestShellConstructor(AllocPTestShell());
}

PTestShellParent*
PContentParent::SendPTestShellConstructor(PTestShellParent* actor)
{
    if ((!(actor))) {
        return 0;
    }
    (actor)->mId = Register(actor);
    (actor)->mManager = this;
    (actor)->mChannel = (&(mChannel));
    (mManagedPTestShellParent).InsertElementSorted(actor);
    (actor)->mState = mozilla::ipc::PTestShell::__Start;

    PContent::Msg_PTestShellConstructor* __msg = new PContent::Msg_PTestShellConstructor();

    Write(actor, __msg, false);

    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);


    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PContentParent] Sending ", stderr);
    }
    if ((!(PContent::Transition(mState, Trigger(Trigger::Send, PContent::Msg_PTestShellConstructor__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg);
    if ((!(__sendok))) {
        (actor)->DestroySubtree(FailedConstructor);
        (actor)->DeallocSubtree();
        ((actor)->mManager)->RemoveManagee(PTestShellMsgStart, actor);
        return 0;
    }
    return actor;
}

bool
PContentParent::SendRegisterChrome(
        const InfallibleTArray<ChromePackage>& packages,
        const InfallibleTArray<ResourceMapping>& resources,
        const InfallibleTArray<OverrideMapping>& overrides,
        const nsCString& locale)
{
    PContent::Msg_RegisterChrome* __msg = new PContent::Msg_RegisterChrome();

    Write(packages, __msg);
    Write(resources, __msg);
    Write(overrides, __msg);
    Write(locale, __msg);

    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PContentParent] Sending ", stderr);
    }
    if ((!(PContent::Transition(mState, Trigger(Trigger::Send, PContent::Msg_RegisterChrome__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg);
    return __sendok;
}

bool
PContentParent::SendSetOffline(const bool& offline)
{
    PContent::Msg_SetOffline* __msg = new PContent::Msg_SetOffline();

    Write(offline, __msg);

    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PContentParent] Sending ", stderr);
    }
    if ((!(PContent::Transition(mState, Trigger(Trigger::Send, PContent::Msg_SetOffline__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg);
    return __sendok;
}

bool
PContentParent::SendNotifyVisited(const URIParams& uri)
{
    PContent::Msg_NotifyVisited* __msg = new PContent::Msg_NotifyVisited();

    Write(uri, __msg);

    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PContentParent] Sending ", stderr);
    }
    if ((!(PContent::Transition(mState, Trigger(Trigger::Send, PContent::Msg_NotifyVisited__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg);
    return __sendok;
}

bool
PContentParent::SendPreferenceUpdate(const PrefSetting& pref)
{
    PContent::Msg_PreferenceUpdate* __msg = new PContent::Msg_PreferenceUpdate();

    Write(pref, __msg);

    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PContentParent] Sending ", stderr);
    }
    if ((!(PContent::Transition(mState, Trigger(Trigger::Send, PContent::Msg_PreferenceUpdate__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg);
    return __sendok;
}

bool
PContentParent::SendNotifyAlertsObserver(
        const nsCString& topic,
        const nsString& data)
{
    PContent::Msg_NotifyAlertsObserver* __msg = new PContent::Msg_NotifyAlertsObserver();

    Write(topic, __msg);
    Write(data, __msg);

    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PContentParent] Sending ", stderr);
    }
    if ((!(PContent::Transition(mState, Trigger(Trigger::Send, PContent::Msg_NotifyAlertsObserver__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg);
    return __sendok;
}

bool
PContentParent::SendGeolocationUpdate(const GeoPosition& somewhere)
{
    PContent::Msg_GeolocationUpdate* __msg = new PContent::Msg_GeolocationUpdate();

    Write(somewhere, __msg);

    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PContentParent] Sending ", stderr);
    }
    if ((!(PContent::Transition(mState, Trigger(Trigger::Send, PContent::Msg_GeolocationUpdate__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg);
    return __sendok;
}

bool
PContentParent::SendAddPermission(const Permission& permission)
{
    PContent::Msg_AddPermission* __msg = new PContent::Msg_AddPermission();

    Write(permission, __msg);

    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PContentParent] Sending ", stderr);
    }
    if ((!(PContent::Transition(mState, Trigger(Trigger::Send, PContent::Msg_AddPermission__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg);
    return __sendok;
}

bool
PContentParent::SendScreenSizeChanged(const gfxIntSize& size)
{
    PContent::Msg_ScreenSizeChanged* __msg = new PContent::Msg_ScreenSizeChanged();

    Write(size, __msg);

    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PContentParent] Sending ", stderr);
    }
    if ((!(PContent::Transition(mState, Trigger(Trigger::Send, PContent::Msg_ScreenSizeChanged__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg);
    return __sendok;
}

bool
PContentParent::SendFlushMemory(const nsString& reason)
{
    PContent::Msg_FlushMemory* __msg = new PContent::Msg_FlushMemory();

    Write(reason, __msg);

    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PContentParent] Sending ", stderr);
    }
    if ((!(PContent::Transition(mState, Trigger(Trigger::Send, PContent::Msg_FlushMemory__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg);
    return __sendok;
}

bool
PContentParent::SendGarbageCollect()
{
    PContent::Msg_GarbageCollect* __msg = new PContent::Msg_GarbageCollect();


    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PContentParent] Sending ", stderr);
    }
    if ((!(PContent::Transition(mState, Trigger(Trigger::Send, PContent::Msg_GarbageCollect__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg);
    return __sendok;
}

bool
PContentParent::SendCycleCollect()
{
    PContent::Msg_CycleCollect* __msg = new PContent::Msg_CycleCollect();


    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PContentParent] Sending ", stderr);
    }
    if ((!(PContent::Transition(mState, Trigger(Trigger::Send, PContent::Msg_CycleCollect__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg);
    return __sendok;
}

bool
PContentParent::SendActivateA11y()
{
    PContent::Msg_ActivateA11y* __msg = new PContent::Msg_ActivateA11y();


    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PContentParent] Sending ", stderr);
    }
    if ((!(PContent::Transition(mState, Trigger(Trigger::Send, PContent::Msg_ActivateA11y__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg);
    return __sendok;
}

bool
PContentParent::SendAppInfo(
        const nsCString& version,
        const nsCString& buildID)
{
    PContent::Msg_AppInfo* __msg = new PContent::Msg_AppInfo();

    Write(version, __msg);
    Write(buildID, __msg);

    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PContentParent] Sending ", stderr);
    }
    if ((!(PContent::Transition(mState, Trigger(Trigger::Send, PContent::Msg_AppInfo__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg);
    return __sendok;
}

bool
PContentParent::SendLastPrivateDocShellDestroyed()
{
    PContent::Msg_LastPrivateDocShellDestroyed* __msg = new PContent::Msg_LastPrivateDocShellDestroyed();


    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PContentParent] Sending ", stderr);
    }
    if ((!(PContent::Transition(mState, Trigger(Trigger::Send, PContent::Msg_LastPrivateDocShellDestroyed__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg);
    return __sendok;
}

bool
PContentParent::SendFilePathUpdate(
        const nsString& type,
        const nsString& filepath,
        const nsCString& reasons)
{
    PContent::Msg_FilePathUpdate* __msg = new PContent::Msg_FilePathUpdate();

    Write(type, __msg);
    Write(filepath, __msg);
    Write(reasons, __msg);

    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PContentParent] Sending ", stderr);
    }
    if ((!(PContent::Transition(mState, Trigger(Trigger::Send, PContent::Msg_FilePathUpdate__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg);
    return __sendok;
}

bool
PContentParent::SendFileSystemUpdate(
        const nsString& fsName,
        const nsString& mountPoint,
        const int32_t& fsState)
{
    PContent::Msg_FileSystemUpdate* __msg = new PContent::Msg_FileSystemUpdate();

    Write(fsName, __msg);
    Write(mountPoint, __msg);
    Write(fsState, __msg);

    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PContentParent] Sending ", stderr);
    }
    if ((!(PContent::Transition(mState, Trigger(Trigger::Send, PContent::Msg_FileSystemUpdate__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg);
    return __sendok;
}

bool
PContentParent::SendAsyncMessage(
        const nsString& aMessage,
        const ClonedMessageData& aData)
{
    PContent::Msg_AsyncMessage* __msg = new PContent::Msg_AsyncMessage();

    Write(aMessage, __msg);
    Write(aData, __msg);

    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PContentParent] Sending ", stderr);
    }
    if ((!(PContent::Transition(mState, Trigger(Trigger::Send, PContent::Msg_AsyncMessage__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg);
    return __sendok;
}

int32_t
PContentParent::Register(ChannelListener* aRouted)
{
    int32_t tmp = (++(mLastRouteId));
    (mActorMap).AddWithID(aRouted, tmp);
    return tmp;
}

int32_t
PContentParent::RegisterID(
        ChannelListener* aRouted,
        int32_t aId)
{
    (mActorMap).AddWithID(aRouted, aId);
    return aId;
}

ChannelListener*
PContentParent::Lookup(int32_t aId)
{
    return (mActorMap).Lookup(aId);
}

void
PContentParent::Unregister(int32_t aId)
{
    return (mActorMap).Remove(aId);
}

void
PContentParent::RemoveManagee(
        int32_t aProtocolId,
        ChannelListener* aListener)
{
    switch (aProtocolId) {
    case PBlobMsgStart:
        {
            PBlobParent* actor = static_cast<PBlobParent*>(aListener);
            NS_ABORT_IF_FALSE(((mManagedPBlobParent).NoIndex) != ((mManagedPBlobParent).BinaryIndexOf(actor)), "actor not managed by this!");

            (mManagedPBlobParent).RemoveElementSorted(actor);
            DeallocPBlob(actor);
            return;
        }
    case PBluetoothMsgStart:
        {
            PBluetoothParent* actor = static_cast<PBluetoothParent*>(aListener);
            NS_ABORT_IF_FALSE(((mManagedPBluetoothParent).NoIndex) != ((mManagedPBluetoothParent).BinaryIndexOf(actor)), "actor not managed by this!");

            (mManagedPBluetoothParent).RemoveElementSorted(actor);
            DeallocPBluetooth(actor);
            return;
        }
    case PBrowserMsgStart:
        {
            PBrowserParent* actor = static_cast<PBrowserParent*>(aListener);
            NS_ABORT_IF_FALSE(((mManagedPBrowserParent).NoIndex) != ((mManagedPBrowserParent).BinaryIndexOf(actor)), "actor not managed by this!");

            (mManagedPBrowserParent).RemoveElementSorted(actor);
            DeallocPBrowser(actor);
            return;
        }
    case PCrashReporterMsgStart:
        {
            PCrashReporterParent* actor = static_cast<PCrashReporterParent*>(aListener);
            NS_ABORT_IF_FALSE(((mManagedPCrashReporterParent).NoIndex) != ((mManagedPCrashReporterParent).BinaryIndexOf(actor)), "actor not managed by this!");

            (mManagedPCrashReporterParent).RemoveElementSorted(actor);
            DeallocPCrashReporter(actor);
            return;
        }
    case PDeviceStorageRequestMsgStart:
        {
            PDeviceStorageRequestParent* actor = static_cast<PDeviceStorageRequestParent*>(aListener);
            NS_ABORT_IF_FALSE(((mManagedPDeviceStorageRequestParent).NoIndex) != ((mManagedPDeviceStorageRequestParent).BinaryIndexOf(actor)), "actor not managed by this!");

            (mManagedPDeviceStorageRequestParent).RemoveElementSorted(actor);
            DeallocPDeviceStorageRequest(actor);
            return;
        }
    case PExternalHelperAppMsgStart:
        {
            PExternalHelperAppParent* actor = static_cast<PExternalHelperAppParent*>(aListener);
            NS_ABORT_IF_FALSE(((mManagedPExternalHelperAppParent).NoIndex) != ((mManagedPExternalHelperAppParent).BinaryIndexOf(actor)), "actor not managed by this!");

            (mManagedPExternalHelperAppParent).RemoveElementSorted(actor);
            DeallocPExternalHelperApp(actor);
            return;
        }
    case PHalMsgStart:
        {
            PHalParent* actor = static_cast<PHalParent*>(aListener);
            NS_ABORT_IF_FALSE(((mManagedPHalParent).NoIndex) != ((mManagedPHalParent).BinaryIndexOf(actor)), "actor not managed by this!");

            (mManagedPHalParent).RemoveElementSorted(actor);
            DeallocPHal(actor);
            return;
        }
    case PIndexedDBMsgStart:
        {
            PIndexedDBParent* actor = static_cast<PIndexedDBParent*>(aListener);
            NS_ABORT_IF_FALSE(((mManagedPIndexedDBParent).NoIndex) != ((mManagedPIndexedDBParent).BinaryIndexOf(actor)), "actor not managed by this!");

            (mManagedPIndexedDBParent).RemoveElementSorted(actor);
            DeallocPIndexedDB(actor);
            return;
        }
    case PMemoryReportRequestMsgStart:
        {
            PMemoryReportRequestParent* actor = static_cast<PMemoryReportRequestParent*>(aListener);
            NS_ABORT_IF_FALSE(((mManagedPMemoryReportRequestParent).NoIndex) != ((mManagedPMemoryReportRequestParent).BinaryIndexOf(actor)), "actor not managed by this!");

            (mManagedPMemoryReportRequestParent).RemoveElementSorted(actor);
            DeallocPMemoryReportRequest(actor);
            return;
        }
    case PNeckoMsgStart:
        {
            PNeckoParent* actor = static_cast<PNeckoParent*>(aListener);
            NS_ABORT_IF_FALSE(((mManagedPNeckoParent).NoIndex) != ((mManagedPNeckoParent).BinaryIndexOf(actor)), "actor not managed by this!");

            (mManagedPNeckoParent).RemoveElementSorted(actor);
            DeallocPNecko(actor);
            return;
        }
    case PSmsMsgStart:
        {
            PSmsParent* actor = static_cast<PSmsParent*>(aListener);
            NS_ABORT_IF_FALSE(((mManagedPSmsParent).NoIndex) != ((mManagedPSmsParent).BinaryIndexOf(actor)), "actor not managed by this!");

            (mManagedPSmsParent).RemoveElementSorted(actor);
            DeallocPSms(actor);
            return;
        }
    case PStorageMsgStart:
        {
            PStorageParent* actor = static_cast<PStorageParent*>(aListener);
            NS_ABORT_IF_FALSE(((mManagedPStorageParent).NoIndex) != ((mManagedPStorageParent).BinaryIndexOf(actor)), "actor not managed by this!");

            (mManagedPStorageParent).RemoveElementSorted(actor);
            DeallocPStorage(actor);
            return;
        }
    case PTestShellMsgStart:
        {
            PTestShellParent* actor = static_cast<PTestShellParent*>(aListener);
            NS_ABORT_IF_FALSE(((mManagedPTestShellParent).NoIndex) != ((mManagedPTestShellParent).BinaryIndexOf(actor)), "actor not managed by this!");

            (mManagedPTestShellParent).RemoveElementSorted(actor);
            DeallocPTestShell(actor);
            return;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return;
        }
    }
}

Shmem::SharedMemory*
PContentParent::CreateSharedMemory(
        size_t aSize,
        Shmem::SharedMemory::SharedMemoryType aType,
        bool aUnsafe,
        Shmem::id_t* aId)
{
    nsAutoPtr<Shmem::SharedMemory> segment(Shmem::Alloc(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(), aSize, aType, aUnsafe));
    if ((!(segment))) {
        return 0;
    }
    Shmem shmem(
            Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(),
            (segment).get(),
            (++(mLastShmemId)));
    Message* descriptor = (shmem).ShareTo(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(), OtherProcess(), MSG_ROUTING_CONTROL);
    if ((!(descriptor))) {
        return 0;
    }
    if ((!((mChannel).Send(descriptor)))) {
    }
    (*(aId)) = (shmem).Id(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead());
    (mShmemMap).AddWithID(segment, (*(aId)));
    return (segment).forget();
}

bool
PContentParent::AdoptSharedMemory(
        Shmem::SharedMemory* segment,
        Shmem::id_t* aId)
{
    Shmem shmem(
            Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(),
            segment,
            (++(mLastShmemId)));
    Message* descriptor = (shmem).ShareTo(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(), OtherProcess(), MSG_ROUTING_CONTROL);
    if ((!(descriptor))) {
        return false;
    }
    if ((!((mChannel).Send(descriptor)))) {
    }
    (*(aId)) = (shmem).Id(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead());
    (mShmemMap).AddWithID(segment, (*(aId)));
    (segment)->AddRef();
    return true;
}

Shmem::SharedMemory*
PContentParent::LookupSharedMemory(Shmem::id_t aId)
{
    return (mShmemMap).Lookup(aId);
}

bool
PContentParent::IsTrackingSharedMemory(Shmem::SharedMemory* segment)
{
    return (mShmemMap).HasData(segment);
}

bool
PContentParent::DestroySharedMemory(Shmem& shmem)
{
    Shmem::id_t aId = (shmem).Id(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead());
    Shmem::SharedMemory* segment = LookupSharedMemory(aId);
    if ((!(segment))) {
        return false;
    }
    Message* descriptor = (shmem).UnshareFrom(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(), OtherProcess(), MSG_ROUTING_CONTROL);

    (mShmemMap).Remove(aId);
    Shmem::Dealloc(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(), segment);

    return (descriptor) && ((mChannel).Send(descriptor));
}

ProcessHandle
PContentParent::OtherProcess() const
{
    return mOtherProcess;
}

AsyncChannel*
PContentParent::GetIPCChannel()
{
    return (&(mChannel));
}

PContentParent::Result
PContentParent::OnMessageReceived(const Message& __msg)
{
    int32_t __route = (__msg).routing_id();
    if ((MSG_ROUTING_CONTROL) != (__route)) {
        ChannelListener* __routed = Lookup(__route);
        if ((!(__routed))) {
            return MsgRouteError;
        }
        return (__routed)->OnMessageReceived(__msg);
    }

    switch ((__msg).type()) {
    case PContent::Reply_PBrowserConstructor__ID:
        {
            return MsgProcessed;
        }
    case PContent::Msg_PBrowserConstructor__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PContent::Msg_PBrowserConstructor");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Msg_PBrowserConstructor*>((&(__msg))))->Log("[PContentParent] Received ", stderr);
            }

            void* __iter = 0;
            ActorHandle __handle;
            PBrowserParent* actor;
            IPCTabContext context;
            uint32_t chromeFlags;

            if ((!(Read((&(__handle)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(context)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(chromeFlags)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_PBrowserConstructor__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            actor = AllocPBrowser(context, chromeFlags);
            if ((!(actor))) {
                return MsgValueError;
            }
            (actor)->mId = RegisterID(actor, (__handle).mId);
            (actor)->mManager = this;
            (actor)->mChannel = (&(mChannel));
            (mManagedPBrowserParent).InsertElementSorted(actor);
            (actor)->mState = mozilla::dom::PBrowser::__Start;

            if ((!(RecvPBrowserConstructor(actor, context, chromeFlags)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for PBrowser returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PContent::Reply_PBlobConstructor__ID:
        {
            return MsgProcessed;
        }
    case PContent::Msg_PBlobConstructor__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PContent::Msg_PBlobConstructor");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Msg_PBlobConstructor*>((&(__msg))))->Log("[PContentParent] Received ", stderr);
            }

            void* __iter = 0;
            ActorHandle __handle;
            PBlobParent* actor;
            BlobConstructorParams params;

            if ((!(Read((&(__handle)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(params)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_PBlobConstructor__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            actor = AllocPBlob(params);
            if ((!(actor))) {
                return MsgValueError;
            }
            (actor)->mId = RegisterID(actor, (__handle).mId);
            (actor)->mManager = this;
            (actor)->mChannel = (&(mChannel));
            (mManagedPBlobParent).InsertElementSorted(actor);
            (actor)->mState = mozilla::dom::PBlob::__Start;

            if ((!(RecvPBlobConstructor(actor, params)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for PBlob returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PContent::Reply_PMemoryReportRequestConstructor__ID:
        {
            return MsgProcessed;
        }
    case PContent::Reply_PTestShellConstructor__ID:
        {
            return MsgProcessed;
        }
    case PContent::Msg_PDeviceStorageRequestConstructor__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PContent::Msg_PDeviceStorageRequestConstructor");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Msg_PDeviceStorageRequestConstructor*>((&(__msg))))->Log("[PContentParent] Received ", stderr);
            }

            void* __iter = 0;
            ActorHandle __handle;
            PDeviceStorageRequestParent* actor;
            DeviceStorageParams params;

            if ((!(Read((&(__handle)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(params)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_PDeviceStorageRequestConstructor__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            actor = AllocPDeviceStorageRequest(params);
            if ((!(actor))) {
                return MsgValueError;
            }
            (actor)->mId = RegisterID(actor, (__handle).mId);
            (actor)->mManager = this;
            (actor)->mChannel = (&(mChannel));
            (mManagedPDeviceStorageRequestParent).InsertElementSorted(actor);
            (actor)->mState = mozilla::dom::devicestorage::PDeviceStorageRequest::__Start;

            if ((!(RecvPDeviceStorageRequestConstructor(actor, params)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for PDeviceStorageRequest returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PContent::Msg_PHalConstructor__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PContent::Msg_PHalConstructor");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Msg_PHalConstructor*>((&(__msg))))->Log("[PContentParent] Received ", stderr);
            }

            void* __iter = 0;
            ActorHandle __handle;
            PHalParent* actor;

            if ((!(Read((&(__handle)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_PHalConstructor__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            actor = AllocPHal();
            if ((!(actor))) {
                return MsgValueError;
            }
            (actor)->mId = RegisterID(actor, (__handle).mId);
            (actor)->mManager = this;
            (actor)->mChannel = (&(mChannel));
            (mManagedPHalParent).InsertElementSorted(actor);
            (actor)->mState = mozilla::hal_sandbox::PHal::__Start;

            if ((!(RecvPHalConstructor(actor)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for PHal returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PContent::Msg_PIndexedDBConstructor__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PContent::Msg_PIndexedDBConstructor");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Msg_PIndexedDBConstructor*>((&(__msg))))->Log("[PContentParent] Received ", stderr);
            }

            void* __iter = 0;
            ActorHandle __handle;
            PIndexedDBParent* actor;

            if ((!(Read((&(__handle)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_PIndexedDBConstructor__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            actor = AllocPIndexedDB();
            if ((!(actor))) {
                return MsgValueError;
            }
            (actor)->mId = RegisterID(actor, (__handle).mId);
            (actor)->mManager = this;
            (actor)->mChannel = (&(mChannel));
            (mManagedPIndexedDBParent).InsertElementSorted(actor);
            (actor)->mState = mozilla::dom::indexedDB::PIndexedDB::__Start;

            if ((!(RecvPIndexedDBConstructor(actor)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for PIndexedDB returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PContent::Msg_PNeckoConstructor__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PContent::Msg_PNeckoConstructor");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Msg_PNeckoConstructor*>((&(__msg))))->Log("[PContentParent] Received ", stderr);
            }

            void* __iter = 0;
            ActorHandle __handle;
            PNeckoParent* actor;

            if ((!(Read((&(__handle)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_PNeckoConstructor__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            actor = AllocPNecko();
            if ((!(actor))) {
                return MsgValueError;
            }
            (actor)->mId = RegisterID(actor, (__handle).mId);
            (actor)->mManager = this;
            (actor)->mChannel = (&(mChannel));
            (mManagedPNeckoParent).InsertElementSorted(actor);
            (actor)->mState = mozilla::net::PNecko::__Start;

            if ((!(RecvPNeckoConstructor(actor)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for PNecko returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PContent::Msg_PSmsConstructor__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PContent::Msg_PSmsConstructor");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Msg_PSmsConstructor*>((&(__msg))))->Log("[PContentParent] Received ", stderr);
            }

            void* __iter = 0;
            ActorHandle __handle;
            PSmsParent* actor;

            if ((!(Read((&(__handle)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_PSmsConstructor__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            actor = AllocPSms();
            if ((!(actor))) {
                return MsgValueError;
            }
            (actor)->mId = RegisterID(actor, (__handle).mId);
            (actor)->mManager = this;
            (actor)->mChannel = (&(mChannel));
            (mManagedPSmsParent).InsertElementSorted(actor);
            (actor)->mState = mozilla::dom::sms::PSms::__Start;

            if ((!(RecvPSmsConstructor(actor)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for PSms returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PContent::Msg_PStorageConstructor__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PContent::Msg_PStorageConstructor");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Msg_PStorageConstructor*>((&(__msg))))->Log("[PContentParent] Received ", stderr);
            }

            void* __iter = 0;
            ActorHandle __handle;
            PStorageParent* actor;
            StorageConstructData data;

            if ((!(Read((&(__handle)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(data)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_PStorageConstructor__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            actor = AllocPStorage(data);
            if ((!(actor))) {
                return MsgValueError;
            }
            (actor)->mId = RegisterID(actor, (__handle).mId);
            (actor)->mManager = this;
            (actor)->mChannel = (&(mChannel));
            (mManagedPStorageParent).InsertElementSorted(actor);
            (actor)->mState = mozilla::dom::PStorage::__Start;

            if ((!(RecvPStorageConstructor(actor, data)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for PStorage returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PContent::Msg_PBluetoothConstructor__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PContent::Msg_PBluetoothConstructor");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Msg_PBluetoothConstructor*>((&(__msg))))->Log("[PContentParent] Received ", stderr);
            }

            void* __iter = 0;
            ActorHandle __handle;
            PBluetoothParent* actor;

            if ((!(Read((&(__handle)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_PBluetoothConstructor__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            actor = AllocPBluetooth();
            if ((!(actor))) {
                return MsgValueError;
            }
            (actor)->mId = RegisterID(actor, (__handle).mId);
            (actor)->mManager = this;
            (actor)->mChannel = (&(mChannel));
            (mManagedPBluetoothParent).InsertElementSorted(actor);
            (actor)->mState = mozilla::dom::bluetooth::PBluetooth::__Start;

            if ((!(RecvPBluetoothConstructor(actor)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for PBluetooth returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PContent::Msg_StartVisitedQuery__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PContent::Msg_StartVisitedQuery");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Msg_StartVisitedQuery*>((&(__msg))))->Log("[PContentParent] Received ", stderr);
            }

            void* __iter = 0;
            URIParams uri;

            if ((!(Read((&(uri)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_StartVisitedQuery__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvStartVisitedQuery(uri)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for StartVisitedQuery returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PContent::Msg_VisitURI__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PContent::Msg_VisitURI");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Msg_VisitURI*>((&(__msg))))->Log("[PContentParent] Received ", stderr);
            }

            void* __iter = 0;
            URIParams uri;
            OptionalURIParams referrer;
            uint32_t flags;

            if ((!(Read((&(uri)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(referrer)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(flags)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_VisitURI__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvVisitURI(uri, referrer, flags)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for VisitURI returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PContent::Msg_SetURITitle__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PContent::Msg_SetURITitle");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Msg_SetURITitle*>((&(__msg))))->Log("[PContentParent] Received ", stderr);
            }

            void* __iter = 0;
            URIParams uri;
            nsString title;

            if ((!(Read((&(uri)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(title)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_SetURITitle__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvSetURITitle(uri, title)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for SetURITitle returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PContent::Msg_LoadURIExternal__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PContent::Msg_LoadURIExternal");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Msg_LoadURIExternal*>((&(__msg))))->Log("[PContentParent] Received ", stderr);
            }

            void* __iter = 0;
            URIParams uri;

            if ((!(Read((&(uri)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_LoadURIExternal__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvLoadURIExternal(uri)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for LoadURIExternal returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PContent::Msg_ShowAlertNotification__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PContent::Msg_ShowAlertNotification");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Msg_ShowAlertNotification*>((&(__msg))))->Log("[PContentParent] Received ", stderr);
            }

            void* __iter = 0;
            nsString imageUrl;
            nsString title;
            nsString text;
            bool textClickable;
            nsString cookie;
            nsString name;

            if ((!(Read((&(imageUrl)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(title)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(text)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(textClickable)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(cookie)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(name)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_ShowAlertNotification__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvShowAlertNotification(imageUrl, title, text, textClickable, cookie, name)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for ShowAlertNotification returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PContent::Msg_PExternalHelperAppConstructor__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PContent::Msg_PExternalHelperAppConstructor");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Msg_PExternalHelperAppConstructor*>((&(__msg))))->Log("[PContentParent] Received ", stderr);
            }

            void* __iter = 0;
            ActorHandle __handle;
            PExternalHelperAppParent* actor;
            OptionalURIParams uri;
            nsCString aMimeContentType;
            nsCString aContentDisposition;
            bool aForceSave;
            int64_t aContentLength;
            OptionalURIParams aReferrer;

            if ((!(Read((&(__handle)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(uri)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(aMimeContentType)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(aContentDisposition)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(aForceSave)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(aContentLength)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(aReferrer)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_PExternalHelperAppConstructor__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            actor = AllocPExternalHelperApp(uri, aMimeContentType, aContentDisposition, aForceSave, aContentLength, aReferrer);
            if ((!(actor))) {
                return MsgValueError;
            }
            (actor)->mId = RegisterID(actor, (__handle).mId);
            (actor)->mManager = this;
            (actor)->mChannel = (&(mChannel));
            (mManagedPExternalHelperAppParent).InsertElementSorted(actor);
            (actor)->mState = mozilla::dom::PExternalHelperApp::__Start;

            if ((!(RecvPExternalHelperAppConstructor(actor, uri, aMimeContentType, aContentDisposition, aForceSave, aContentLength, aReferrer)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for PExternalHelperApp returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PContent::Msg_AddGeolocationListener__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PContent::Msg_AddGeolocationListener");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Msg_AddGeolocationListener*>((&(__msg))))->Log("[PContentParent] Received ", stderr);
            }

            void* __iter = 0;
            Principal principal;

            if ((!(Read((&(principal)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_AddGeolocationListener__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvAddGeolocationListener(principal)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for AddGeolocationListener returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PContent::Msg_RemoveGeolocationListener__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PContent::Msg_RemoveGeolocationListener");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Msg_RemoveGeolocationListener*>((&(__msg))))->Log("[PContentParent] Received ", stderr);
            }

            if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_RemoveGeolocationListener__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvRemoveGeolocationListener()))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for RemoveGeolocationListener returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PContent::Msg_SetGeolocationHigherAccuracy__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PContent::Msg_SetGeolocationHigherAccuracy");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Msg_SetGeolocationHigherAccuracy*>((&(__msg))))->Log("[PContentParent] Received ", stderr);
            }

            void* __iter = 0;
            bool enable;

            if ((!(Read((&(enable)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_SetGeolocationHigherAccuracy__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvSetGeolocationHigherAccuracy(enable)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for SetGeolocationHigherAccuracy returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PContent::Msg_ConsoleMessage__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PContent::Msg_ConsoleMessage");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Msg_ConsoleMessage*>((&(__msg))))->Log("[PContentParent] Received ", stderr);
            }

            void* __iter = 0;
            nsString message;

            if ((!(Read((&(message)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_ConsoleMessage__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvConsoleMessage(message)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for ConsoleMessage returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PContent::Msg_ScriptError__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PContent::Msg_ScriptError");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Msg_ScriptError*>((&(__msg))))->Log("[PContentParent] Received ", stderr);
            }

            void* __iter = 0;
            nsString message;
            nsString sourceName;
            nsString sourceLine;
            uint32_t lineNumber;
            uint32_t colNumber;
            uint32_t flags;
            nsCString category;

            if ((!(Read((&(message)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(sourceName)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(sourceLine)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(lineNumber)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(colNumber)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(flags)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(category)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_ScriptError__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvScriptError(message, sourceName, sourceLine, lineNumber, colNumber, flags, category)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for ScriptError returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PContent::Msg_SetClipboardText__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PContent::Msg_SetClipboardText");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Msg_SetClipboardText*>((&(__msg))))->Log("[PContentParent] Received ", stderr);
            }

            void* __iter = 0;
            nsString text;
            bool isPrivateData;
            int32_t whichClipboard;

            if ((!(Read((&(text)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(isPrivateData)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(whichClipboard)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_SetClipboardText__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvSetClipboardText(text, isPrivateData, whichClipboard)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for SetClipboardText returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PContent::Msg_EmptyClipboard__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PContent::Msg_EmptyClipboard");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Msg_EmptyClipboard*>((&(__msg))))->Log("[PContentParent] Received ", stderr);
            }

            if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_EmptyClipboard__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvEmptyClipboard()))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for EmptyClipboard returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PContent::Msg_PrivateDocShellsExist__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PContent::Msg_PrivateDocShellsExist");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Msg_PrivateDocShellsExist*>((&(__msg))))->Log("[PContentParent] Received ", stderr);
            }

            void* __iter = 0;
            bool aExist;

            if ((!(Read((&(aExist)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_PrivateDocShellsExist__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvPrivateDocShellsExist(aExist)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for PrivateDocShellsExist returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PContent::Msg_FirstIdle__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PContent::Msg_FirstIdle");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Msg_FirstIdle*>((&(__msg))))->Log("[PContentParent] Received ", stderr);
            }

            if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_FirstIdle__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvFirstIdle()))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for FirstIdle returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PContent::Msg_AudioChannelRegisterType__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PContent::Msg_AudioChannelRegisterType");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Msg_AudioChannelRegisterType*>((&(__msg))))->Log("[PContentParent] Received ", stderr);
            }

            void* __iter = 0;
            AudioChannelType aType;

            if ((!(Read((&(aType)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_AudioChannelRegisterType__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvAudioChannelRegisterType(aType)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for AudioChannelRegisterType returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PContent::Msg_AudioChannelUnregisterType__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PContent::Msg_AudioChannelUnregisterType");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Msg_AudioChannelUnregisterType*>((&(__msg))))->Log("[PContentParent] Received ", stderr);
            }

            void* __iter = 0;
            AudioChannelType aType;

            if ((!(Read((&(aType)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_AudioChannelUnregisterType__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvAudioChannelUnregisterType(aType)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for AudioChannelUnregisterType returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PContent::Msg_AsyncMessage__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PContent::Msg_AsyncMessage");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Msg_AsyncMessage*>((&(__msg))))->Log("[PContentParent] Received ", stderr);
            }

            void* __iter = 0;
            nsString aMessage;
            ClonedMessageData aData;

            if ((!(Read((&(aMessage)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(aData)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_AsyncMessage__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvAsyncMessage(aMessage, aData)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for AsyncMessage returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case CHANNEL_OPENED_MESSAGE_TYPE:
        {
            TransportDescriptor td;
            ProcessId pid;
            ProtocolId p;
            if ((!(mozilla::ipc::UnpackChannelOpened(mozilla::ipc::PrivateIPDLInterface(), __msg, (&(td)), (&(pid)), (&(p)))))) {
                return MsgPayloadError;
            }

            switch (p) {
            case PCompositorMsgStart:
                {
                    Transport* t;
                    if ((!(t = mozilla::ipc::OpenDescriptor(td, mozilla::ipc::Transport::MODE_SERVER)))) {
                        return MsgValueError;
                    }
                    if ((!(AllocPCompositor(t, pid)))) {
                        return MsgProcessingError;
                    }
                    break;
                }
            case PImageBridgeMsgStart:
                {
                    Transport* t;
                    if ((!(t = mozilla::ipc::OpenDescriptor(td, mozilla::ipc::Transport::MODE_SERVER)))) {
                        return MsgValueError;
                    }
                    if ((!(AllocPImageBridge(t, pid)))) {
                        return MsgProcessingError;
                    }
                    break;
                }
            default:
                NS_RUNTIMEABORT("Invalid protocol");
                return MsgValueError;
            }
            return MsgProcessed;
        }
    default:
        {
            return MsgNotKnown;
        }
    case SHMEM_CREATED_MESSAGE_TYPE:
        {
            Shmem::id_t id;
            nsAutoPtr<Shmem::SharedMemory> rawmem(Shmem::OpenExisting(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(), __msg, (&(id)), true));
            if ((!(rawmem))) {
                return MsgPayloadError;
            }
            (mShmemMap).AddWithID((rawmem).forget(), id);

            return MsgProcessed;
        }
    case SHMEM_DESTROYED_MESSAGE_TYPE:
        {
            Shmem::id_t id;
            void* iter = 0;
            if ((!(IPC::ReadParam((&(__msg)), (&(iter)), (&(id)))))) {
                return MsgPayloadError;
            }
            (__msg).EndRead(iter);

            Shmem::SharedMemory* rawmem = LookupSharedMemory(id);
            if ((!(rawmem))) {
                return MsgValueError;
            }
            (mShmemMap).Remove(id);
            Shmem::Dealloc(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(), rawmem);
            return MsgProcessed;
        }
    }
}

PContentParent::Result
PContentParent::OnMessageReceived(
        const Message& __msg,
        Message*& __reply)
{
    int32_t __route = (__msg).routing_id();
    if ((MSG_ROUTING_CONTROL) != (__route)) {
        ChannelListener* __routed = Lookup(__route);
        if ((!(__routed))) {
            return MsgRouteError;
        }
        return (__routed)->OnMessageReceived(__msg, __reply);
    }

    switch ((__msg).type()) {
    case PContent::Msg_GetProcessAttributes__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PContent::Msg_GetProcessAttributes");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Msg_GetProcessAttributes*>((&(__msg))))->Log("[PContentParent] Received ", stderr);
            }

            if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_GetProcessAttributes__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            uint64_t id;
            bool startBackground;
            bool isForApp;
            bool isForBrowser;
            int32_t __id = MSG_ROUTING_CONTROL;
            if ((!(RecvGetProcessAttributes((&(id)), (&(startBackground)), (&(isForApp)), (&(isForBrowser)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for GetProcessAttributes returned error code");
                return MsgProcessingError;
            }

            __reply = new PContent::Reply_GetProcessAttributes();

            Write(id, __reply);
            Write(startBackground, __reply);
            Write(isForApp, __reply);
            Write(isForBrowser, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_sync();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Reply_GetProcessAttributes*>(__reply))->Log("[PContentParent] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    case PContent::Msg_GetXPCOMProcessAttributes__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PContent::Msg_GetXPCOMProcessAttributes");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Msg_GetXPCOMProcessAttributes*>((&(__msg))))->Log("[PContentParent] Received ", stderr);
            }

            if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_GetXPCOMProcessAttributes__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            bool isOffline;
            int32_t __id = MSG_ROUTING_CONTROL;
            if ((!(RecvGetXPCOMProcessAttributes((&(isOffline)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for GetXPCOMProcessAttributes returned error code");
                return MsgProcessingError;
            }

            __reply = new PContent::Reply_GetXPCOMProcessAttributes();

            Write(isOffline, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_sync();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Reply_GetXPCOMProcessAttributes*>(__reply))->Log("[PContentParent] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    case PContent::Msg_PCrashReporterConstructor__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PContent::Msg_PCrashReporterConstructor");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Msg_PCrashReporterConstructor*>((&(__msg))))->Log("[PContentParent] Received ", stderr);
            }

            void* __iter = 0;
            ActorHandle __handle;
            PCrashReporterParent* actor;
            NativeThreadId tid;
            uint32_t processType;

            if ((!(Read((&(__handle)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(tid)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(processType)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_PCrashReporterConstructor__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            actor = AllocPCrashReporter(tid, processType);
            if ((!(actor))) {
                return MsgValueError;
            }
            (actor)->mId = RegisterID(actor, (__handle).mId);
            (actor)->mManager = this;
            (actor)->mChannel = (&(mChannel));
            (mManagedPCrashReporterParent).InsertElementSorted(actor);
            (actor)->mState = mozilla::dom::PCrashReporter::__Start;

            int32_t __id = MSG_ROUTING_CONTROL;
            if ((!(RecvPCrashReporterConstructor(actor, tid, processType)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for PCrashReporter returned error code");
                return MsgProcessingError;
            }
            __reply = new PContent::Reply_PCrashReporterConstructor();

            (__reply)->set_routing_id(__id);
            (__reply)->set_sync();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Reply_PCrashReporterConstructor*>(__reply))->Log("[PContentParent] Sending reply ", stderr);
            }

            return MsgProcessed;
        }
    case PContent::Msg_ShowFilePicker__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PContent::Msg_ShowFilePicker");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Msg_ShowFilePicker*>((&(__msg))))->Log("[PContentParent] Received ", stderr);
            }

            void* __iter = 0;
            int16_t mode;
            int16_t selectedType;
            bool addToRecentDocs;
            nsString title;
            nsString defaultFile;
            nsString defaultExtension;
            InfallibleTArray<nsString> filters;
            InfallibleTArray<nsString> filterNames;

            if ((!(Read((&(mode)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(selectedType)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(addToRecentDocs)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(title)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(defaultFile)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(defaultExtension)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(filters)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(filterNames)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_ShowFilePicker__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            InfallibleTArray<nsString> files;
            int16_t retValue;
            nsresult result;
            int32_t __id = MSG_ROUTING_CONTROL;
            if ((!(RecvShowFilePicker(mode, selectedType, addToRecentDocs, title, defaultFile, defaultExtension, filters, filterNames, (&(files)), (&(retValue)), (&(result)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for ShowFilePicker returned error code");
                return MsgProcessingError;
            }

            __reply = new PContent::Reply_ShowFilePicker();

            Write(files, __reply);
            Write(retValue, __reply);
            Write(result, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_sync();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Reply_ShowFilePicker*>(__reply))->Log("[PContentParent] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    case PContent::Msg_ReadPrefsArray__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PContent::Msg_ReadPrefsArray");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Msg_ReadPrefsArray*>((&(__msg))))->Log("[PContentParent] Received ", stderr);
            }

            if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_ReadPrefsArray__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            InfallibleTArray<PrefSetting> prefs;
            int32_t __id = MSG_ROUTING_CONTROL;
            if ((!(RecvReadPrefsArray((&(prefs)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for ReadPrefsArray returned error code");
                return MsgProcessingError;
            }

            __reply = new PContent::Reply_ReadPrefsArray();

            Write(prefs, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_sync();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Reply_ReadPrefsArray*>(__reply))->Log("[PContentParent] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    case PContent::Msg_ReadFontList__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PContent::Msg_ReadFontList");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Msg_ReadFontList*>((&(__msg))))->Log("[PContentParent] Received ", stderr);
            }

            if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_ReadFontList__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            InfallibleTArray<FontListEntry> retValue;
            int32_t __id = MSG_ROUTING_CONTROL;
            if ((!(RecvReadFontList((&(retValue)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for ReadFontList returned error code");
                return MsgProcessingError;
            }

            __reply = new PContent::Reply_ReadFontList();

            Write(retValue, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_sync();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Reply_ReadFontList*>(__reply))->Log("[PContentParent] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    case PContent::Msg_SyncMessage__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PContent::Msg_SyncMessage");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Msg_SyncMessage*>((&(__msg))))->Log("[PContentParent] Received ", stderr);
            }

            void* __iter = 0;
            nsString aMessage;
            ClonedMessageData aData;

            if ((!(Read((&(aMessage)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(aData)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_SyncMessage__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            InfallibleTArray<nsString> retval;
            int32_t __id = MSG_ROUTING_CONTROL;
            if ((!(RecvSyncMessage(aMessage, aData, (&(retval)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for SyncMessage returned error code");
                return MsgProcessingError;
            }

            __reply = new PContent::Reply_SyncMessage();

            Write(retval, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_sync();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Reply_SyncMessage*>(__reply))->Log("[PContentParent] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    case PContent::Msg_ReadPermissions__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PContent::Msg_ReadPermissions");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Msg_ReadPermissions*>((&(__msg))))->Log("[PContentParent] Received ", stderr);
            }

            if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_ReadPermissions__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            InfallibleTArray<Permission> permissions;
            int32_t __id = MSG_ROUTING_CONTROL;
            if ((!(RecvReadPermissions((&(permissions)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for ReadPermissions returned error code");
                return MsgProcessingError;
            }

            __reply = new PContent::Reply_ReadPermissions();

            Write(permissions, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_sync();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Reply_ReadPermissions*>(__reply))->Log("[PContentParent] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    case PContent::Msg_GetClipboardText__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PContent::Msg_GetClipboardText");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Msg_GetClipboardText*>((&(__msg))))->Log("[PContentParent] Received ", stderr);
            }

            void* __iter = 0;
            int32_t whichClipboard;

            if ((!(Read((&(whichClipboard)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_GetClipboardText__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            nsString text;
            int32_t __id = MSG_ROUTING_CONTROL;
            if ((!(RecvGetClipboardText(whichClipboard, (&(text)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for GetClipboardText returned error code");
                return MsgProcessingError;
            }

            __reply = new PContent::Reply_GetClipboardText();

            Write(text, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_sync();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Reply_GetClipboardText*>(__reply))->Log("[PContentParent] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    case PContent::Msg_ClipboardHasText__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PContent::Msg_ClipboardHasText");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Msg_ClipboardHasText*>((&(__msg))))->Log("[PContentParent] Received ", stderr);
            }

            if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_ClipboardHasText__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            bool hasText;
            int32_t __id = MSG_ROUTING_CONTROL;
            if ((!(RecvClipboardHasText((&(hasText)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for ClipboardHasText returned error code");
                return MsgProcessingError;
            }

            __reply = new PContent::Reply_ClipboardHasText();

            Write(hasText, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_sync();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Reply_ClipboardHasText*>(__reply))->Log("[PContentParent] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    case PContent::Msg_GetSystemColors__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PContent::Msg_GetSystemColors");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Msg_GetSystemColors*>((&(__msg))))->Log("[PContentParent] Received ", stderr);
            }

            void* __iter = 0;
            uint32_t colorsCount;

            if ((!(Read((&(colorsCount)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_GetSystemColors__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            InfallibleTArray<uint32_t> colors;
            int32_t __id = MSG_ROUTING_CONTROL;
            if ((!(RecvGetSystemColors(colorsCount, (&(colors)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for GetSystemColors returned error code");
                return MsgProcessingError;
            }

            __reply = new PContent::Reply_GetSystemColors();

            Write(colors, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_sync();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Reply_GetSystemColors*>(__reply))->Log("[PContentParent] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    case PContent::Msg_GetIconForExtension__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PContent::Msg_GetIconForExtension");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Msg_GetIconForExtension*>((&(__msg))))->Log("[PContentParent] Received ", stderr);
            }

            void* __iter = 0;
            nsCString aFileExt;
            uint32_t aIconSize;

            if ((!(Read((&(aFileExt)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(aIconSize)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_GetIconForExtension__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            InfallibleTArray<uint8_t> bits;
            int32_t __id = MSG_ROUTING_CONTROL;
            if ((!(RecvGetIconForExtension(aFileExt, aIconSize, (&(bits)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for GetIconForExtension returned error code");
                return MsgProcessingError;
            }

            __reply = new PContent::Reply_GetIconForExtension();

            Write(bits, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_sync();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Reply_GetIconForExtension*>(__reply))->Log("[PContentParent] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    case PContent::Msg_GetShowPasswordSetting__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PContent::Msg_GetShowPasswordSetting");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Msg_GetShowPasswordSetting*>((&(__msg))))->Log("[PContentParent] Received ", stderr);
            }

            if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_GetShowPasswordSetting__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            bool showPassword;
            int32_t __id = MSG_ROUTING_CONTROL;
            if ((!(RecvGetShowPasswordSetting((&(showPassword)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for GetShowPasswordSetting returned error code");
                return MsgProcessingError;
            }

            __reply = new PContent::Reply_GetShowPasswordSetting();

            Write(showPassword, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_sync();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Reply_GetShowPasswordSetting*>(__reply))->Log("[PContentParent] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    case PContent::Msg_AudioChannelGetMuted__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PContent::Msg_AudioChannelGetMuted");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Msg_AudioChannelGetMuted*>((&(__msg))))->Log("[PContentParent] Received ", stderr);
            }

            void* __iter = 0;
            AudioChannelType aType;
            bool aMozHidden;

            if ((!(Read((&(aType)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(aMozHidden)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_AudioChannelGetMuted__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            bool value;
            int32_t __id = MSG_ROUTING_CONTROL;
            if ((!(RecvAudioChannelGetMuted(aType, aMozHidden, (&(value)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for AudioChannelGetMuted returned error code");
                return MsgProcessingError;
            }

            __reply = new PContent::Reply_AudioChannelGetMuted();

            Write(value, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_sync();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Reply_AudioChannelGetMuted*>(__reply))->Log("[PContentParent] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    default:
        {
            return MsgNotKnown;
        }
    }
}

PContentParent::Result
PContentParent::OnCallReceived(
        const Message& __msg,
        Message*& __reply)
{
    int32_t __route = (__msg).routing_id();
    if ((MSG_ROUTING_CONTROL) != (__route)) {
        ChannelListener* __routed = Lookup(__route);
        if ((!(__routed))) {
            return MsgRouteError;
        }
        return (__routed)->OnCallReceived(__msg, __reply);
    }

    return MsgNotKnown;
}

void
PContentParent::OnProcessingError(Result code)
{
    return ProcessingError(code);
}

int32_t
PContentParent::GetProtocolTypeId()
{
    return PContentMsgStart;
}

bool
PContentParent::OnReplyTimeout()
{
    return ShouldContinueFromReplyTimeout();
}

void
PContentParent::OnEnteredCxxStack()
{
    return EnteredCxxStack();
}

void
PContentParent::OnExitedCxxStack()
{
    return ExitedCxxStack();
}

void
PContentParent::OnEnteredCall()
{
    return EnteredCall();
}

void
PContentParent::OnExitedCall()
{
    return ExitedCall();
}

bool
PContentParent::IsOnCxxStack() const
{
    return (mChannel).IsOnCxxStack();
}

void
PContentParent::FlushPendingRPCQueue()
{
    ((this)->mChannel).FlushPendingRPCQueue();
}

void
PContentParent::OnChannelClose()
{
    DestroySubtree(NormalShutdown);
    DeallocSubtree();
    DeallocShmems();
}

void
PContentParent::OnChannelError()
{
    DestroySubtree(AbnormalShutdown);
    DeallocSubtree();
    DeallocShmems();
}

void
PContentParent::OnChannelConnected(int32_t pid)
{
}

bool
PContentParent::AllocShmem(
        size_t aSize,
        Shmem::SharedMemory::SharedMemoryType aType,
        Shmem* aMem)
{
    Shmem::id_t aId;
    nsAutoPtr<Shmem::SharedMemory> rawmem(CreateSharedMemory(aSize, aType, false, (&(aId))));
    if ((!(rawmem))) {
        return false;
    }

    (*(aMem)) = Shmem(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(), (rawmem).forget(), aId);
    return true;
}

bool
PContentParent::AllocUnsafeShmem(
        size_t aSize,
        Shmem::SharedMemory::SharedMemoryType aType,
        Shmem* aMem)
{
    Shmem::id_t aId;
    nsAutoPtr<Shmem::SharedMemory> rawmem(CreateSharedMemory(aSize, aType, true, (&(aId))));
    if ((!(rawmem))) {
        return false;
    }

    (*(aMem)) = Shmem(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(), (rawmem).forget(), aId);
    return true;
}

bool
PContentParent::AdoptShmem(
        Shmem& aMem,
        Shmem* aOutMem)
{
    Shmem::SharedMemory* rawmem = (aMem).Segment(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead());
    if (((!(rawmem))) || (IsTrackingSharedMemory(rawmem))) {
        NS_RUNTIMEABORT("bad Shmem");
    }

    Shmem::id_t aId;
    if ((!(AdoptSharedMemory(rawmem, (&(aId)))))) {
        return false;
    }

    (*(aOutMem)) = Shmem(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(), rawmem, aId);
    return true;
}

bool
PContentParent::DeallocShmem(Shmem& aMem)
{
    bool ok = DestroySharedMemory(aMem);
    (aMem).forget(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead());
    return ok;
}

void
PContentParent::ProcessNativeEventsInRPCCall()
{
#ifdef OS_WIN
    (mChannel).ProcessNativeEventsInRPCCall();
#else 
    NS_RUNTIMEABORT("This method is Windows-only");
#endif 
}

void
PContentParent::SetOtherProcess(ProcessHandle aOtherProcess)
{
    mOtherProcess = aOtherProcess;
}

base::ProcessId
PContentParent::OtherSidePID() const
{
    return base::GetProcId(mOtherProcess);
}

bool
PContentParent::TakeMinidump(
        nsIFile** aDump,
        uint32_t* aSequence) const
{
#ifdef MOZ_CRASHREPORTER
    return XRE_TakeMinidumpForChild(OtherSidePID(), aDump, aSequence);
#else 
    return false;
#endif 
}

bool
PContentParent::BlockChild()
{
    return (mChannel).BlockChild();
}

bool
PContentParent::UnblockChild()
{
    return (mChannel).UnblockChild();
}

void
PContentParent::FatalError(const char* const msg) const
{
    // Virtual method to prevent inlining.
    // This give us better error reporting.
    // See bug 589371

    NS_ERROR("IPDL error:");
    NS_ERROR(msg);
    mozilla::ipc::ProtocolErrorBreakpoint(msg);

    NS_ERROR("[PContentParent] killing child side as a result");

    if ((!(base::KillProcess(OtherProcess(), base::PROCESS_END_KILLED_BY_USER, false)))) {
        NS_ERROR("  may have failed to kill child!");
    }
}

void
PContentParent::DestroySubtree(ActorDestroyReason why)
{
    ActorDestroyReason subtreewhy = (((why) == (Deletion)) || ((why) == (FailedConstructor)) ? AncestorDeletion : why);

    {
        // Recursively shutting down PBlob kids
        InfallibleTArray<PBlobParent*> kids(mManagedPBlobParent);
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DestroySubtree(subtreewhy);
        }
    }
    {
        // Recursively shutting down PBluetooth kids
        InfallibleTArray<PBluetoothParent*> kids(mManagedPBluetoothParent);
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DestroySubtree(subtreewhy);
        }
    }
    {
        // Recursively shutting down PBrowser kids
        InfallibleTArray<PBrowserParent*> kids(mManagedPBrowserParent);
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DestroySubtree(subtreewhy);
        }
    }
    {
        // Recursively shutting down PCrashReporter kids
        InfallibleTArray<PCrashReporterParent*> kids(mManagedPCrashReporterParent);
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DestroySubtree(subtreewhy);
        }
    }
    {
        // Recursively shutting down PDeviceStorageRequest kids
        InfallibleTArray<PDeviceStorageRequestParent*> kids(mManagedPDeviceStorageRequestParent);
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DestroySubtree(subtreewhy);
        }
    }
    {
        // Recursively shutting down PExternalHelperApp kids
        InfallibleTArray<PExternalHelperAppParent*> kids(mManagedPExternalHelperAppParent);
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DestroySubtree(subtreewhy);
        }
    }
    {
        // Recursively shutting down PHal kids
        InfallibleTArray<PHalParent*> kids(mManagedPHalParent);
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DestroySubtree(subtreewhy);
        }
    }
    {
        // Recursively shutting down PIndexedDB kids
        InfallibleTArray<PIndexedDBParent*> kids(mManagedPIndexedDBParent);
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DestroySubtree(subtreewhy);
        }
    }
    {
        // Recursively shutting down PMemoryReportRequest kids
        InfallibleTArray<PMemoryReportRequestParent*> kids(mManagedPMemoryReportRequestParent);
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DestroySubtree(subtreewhy);
        }
    }
    {
        // Recursively shutting down PNecko kids
        InfallibleTArray<PNeckoParent*> kids(mManagedPNeckoParent);
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DestroySubtree(subtreewhy);
        }
    }
    {
        // Recursively shutting down PSms kids
        InfallibleTArray<PSmsParent*> kids(mManagedPSmsParent);
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DestroySubtree(subtreewhy);
        }
    }
    {
        // Recursively shutting down PStorage kids
        InfallibleTArray<PStorageParent*> kids(mManagedPStorageParent);
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DestroySubtree(subtreewhy);
        }
    }
    {
        // Recursively shutting down PTestShell kids
        InfallibleTArray<PTestShellParent*> kids(mManagedPTestShellParent);
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DestroySubtree(subtreewhy);
        }
    }

    // Finally, destroy "us".
    ActorDestroy(why);
}

void
PContentParent::DeallocSubtree()
{
    {
        // Recursively deleting PBlob kids
        InfallibleTArray<PBlobParent*>& kids = mManagedPBlobParent;
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DeallocSubtree();
        }

        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            DeallocPBlob(kids[i]);
        }
        (mManagedPBlobParent).Clear();
    }
    {
        // Recursively deleting PBluetooth kids
        InfallibleTArray<PBluetoothParent*>& kids = mManagedPBluetoothParent;
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DeallocSubtree();
        }

        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            DeallocPBluetooth(kids[i]);
        }
        (mManagedPBluetoothParent).Clear();
    }
    {
        // Recursively deleting PBrowser kids
        InfallibleTArray<PBrowserParent*>& kids = mManagedPBrowserParent;
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DeallocSubtree();
        }

        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            DeallocPBrowser(kids[i]);
        }
        (mManagedPBrowserParent).Clear();
    }
    {
        // Recursively deleting PCrashReporter kids
        InfallibleTArray<PCrashReporterParent*>& kids = mManagedPCrashReporterParent;
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DeallocSubtree();
        }

        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            DeallocPCrashReporter(kids[i]);
        }
        (mManagedPCrashReporterParent).Clear();
    }
    {
        // Recursively deleting PDeviceStorageRequest kids
        InfallibleTArray<PDeviceStorageRequestParent*>& kids = mManagedPDeviceStorageRequestParent;
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DeallocSubtree();
        }

        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            DeallocPDeviceStorageRequest(kids[i]);
        }
        (mManagedPDeviceStorageRequestParent).Clear();
    }
    {
        // Recursively deleting PExternalHelperApp kids
        InfallibleTArray<PExternalHelperAppParent*>& kids = mManagedPExternalHelperAppParent;
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DeallocSubtree();
        }

        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            DeallocPExternalHelperApp(kids[i]);
        }
        (mManagedPExternalHelperAppParent).Clear();
    }
    {
        // Recursively deleting PHal kids
        InfallibleTArray<PHalParent*>& kids = mManagedPHalParent;
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DeallocSubtree();
        }

        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            DeallocPHal(kids[i]);
        }
        (mManagedPHalParent).Clear();
    }
    {
        // Recursively deleting PIndexedDB kids
        InfallibleTArray<PIndexedDBParent*>& kids = mManagedPIndexedDBParent;
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DeallocSubtree();
        }

        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            DeallocPIndexedDB(kids[i]);
        }
        (mManagedPIndexedDBParent).Clear();
    }
    {
        // Recursively deleting PMemoryReportRequest kids
        InfallibleTArray<PMemoryReportRequestParent*>& kids = mManagedPMemoryReportRequestParent;
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DeallocSubtree();
        }

        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            DeallocPMemoryReportRequest(kids[i]);
        }
        (mManagedPMemoryReportRequestParent).Clear();
    }
    {
        // Recursively deleting PNecko kids
        InfallibleTArray<PNeckoParent*>& kids = mManagedPNeckoParent;
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DeallocSubtree();
        }

        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            DeallocPNecko(kids[i]);
        }
        (mManagedPNeckoParent).Clear();
    }
    {
        // Recursively deleting PSms kids
        InfallibleTArray<PSmsParent*>& kids = mManagedPSmsParent;
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DeallocSubtree();
        }

        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            DeallocPSms(kids[i]);
        }
        (mManagedPSmsParent).Clear();
    }
    {
        // Recursively deleting PStorage kids
        InfallibleTArray<PStorageParent*>& kids = mManagedPStorageParent;
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DeallocSubtree();
        }

        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            DeallocPStorage(kids[i]);
        }
        (mManagedPStorageParent).Clear();
    }
    {
        // Recursively deleting PTestShell kids
        InfallibleTArray<PTestShellParent*>& kids = mManagedPTestShellParent;
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DeallocSubtree();
        }

        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            DeallocPTestShell(kids[i]);
        }
        (mManagedPTestShellParent).Clear();
    }
}

void
PContentParent::DeallocShmems()
{
    for (IDMap<SharedMemory>::const_iterator cit = (mShmemMap).begin(); (cit) != ((mShmemMap).end()); (++(cit))) {
        Shmem::Dealloc(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(), (cit)->second);
    }
    (mShmemMap).Clear();
}

void
PContentParent::Write(
        const BlobConstructorParams& __v,
        Message* __msg)
{
    typedef BlobConstructorParams __type;
    Write(int((__v).type()), __msg);

    switch ((__v).type()) {
    case __type::TNormalBlobConstructorParams:
        {
            Write((__v).get_NormalBlobConstructorParams(), __msg);
            return;
        }
    case __type::TFileBlobConstructorParams:
        {
            Write((__v).get_FileBlobConstructorParams(), __msg);
            return;
        }
    case __type::TSlicedBlobConstructorParams:
        {
            Write((__v).get_SlicedBlobConstructorParams(), __msg);
            return;
        }
    case __type::TMysteryBlobConstructorParams:
        {
            Write((__v).get_MysteryBlobConstructorParams(), __msg);
            return;
        }
    default:
        {
            NS_RUNTIMEABORT("unknown union type");
            return;
        }
    }
}

bool
PContentParent::Read(
        BlobConstructorParams* __v,
        const Message* __msg,
        void** __iter)
{
    typedef BlobConstructorParams __type;
    int type;
    if ((!(Read((&(type)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }

    switch (type) {
    case __type::TNormalBlobConstructorParams:
        {
            NormalBlobConstructorParams tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_NormalBlobConstructorParams())), __msg, __iter);
        }
    case __type::TFileBlobConstructorParams:
        {
            FileBlobConstructorParams tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_FileBlobConstructorParams())), __msg, __iter);
        }
    case __type::TSlicedBlobConstructorParams:
        {
            SlicedBlobConstructorParams tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_SlicedBlobConstructorParams())), __msg, __iter);
        }
    case __type::TMysteryBlobConstructorParams:
        {
            MysteryBlobConstructorParams tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_MysteryBlobConstructorParams())), __msg, __iter);
        }
    default:
        {
            mozilla::ipc::ProtocolErrorBreakpoint("unknown union type");
            return false;
        }
    }
}

void
PContentParent::Write(
        const IPCTabContext& __v,
        Message* __msg)
{
    Write((__v).appBrowserContext(), __msg);
    Write((__v).scrollingBehavior(), __msg);
}

bool
PContentParent::Read(
        IPCTabContext* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->appBrowserContext())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->scrollingBehavior())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PContentParent::Write(
        const OptionalURIParams& __v,
        Message* __msg)
{
    typedef OptionalURIParams __type;
    Write(int((__v).type()), __msg);

    switch ((__v).type()) {
    case __type::Tvoid_t:
        {
            Write((__v).get_void_t(), __msg);
            return;
        }
    case __type::TURIParams:
        {
            Write((__v).get_URIParams(), __msg);
            return;
        }
    default:
        {
            NS_RUNTIMEABORT("unknown union type");
            return;
        }
    }
}

bool
PContentParent::Read(
        OptionalURIParams* __v,
        const Message* __msg,
        void** __iter)
{
    typedef OptionalURIParams __type;
    int type;
    if ((!(Read((&(type)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }

    switch (type) {
    case __type::Tvoid_t:
        {
            void_t tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_void_t())), __msg, __iter);
        }
    case __type::TURIParams:
        {
            URIParams tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_URIParams())), __msg, __iter);
        }
    default:
        {
            mozilla::ipc::ProtocolErrorBreakpoint("unknown union type");
            return false;
        }
    }
}

void
PContentParent::Write(
        PIndexedDBParent* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PContentParent::Read(
        PIndexedDBParent** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PContent");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PIndexedDB");
        return false;
    }

    if ((PIndexedDBMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PIndexedDB has different type");
        return false;
    }

    (*(__v)) = static_cast<PIndexedDBParent*>(listener);
    return true;
}

void
PContentParent::Write(
        const StandardURLParams& __v,
        Message* __msg)
{
    Write((__v).urlType(), __msg);
    Write((__v).port(), __msg);
    Write((__v).defaultPort(), __msg);
    Write((__v).spec(), __msg);
    Write((__v).scheme(), __msg);
    Write((__v).authority(), __msg);
    Write((__v).username(), __msg);
    Write((__v).password(), __msg);
    Write((__v).host(), __msg);
    Write((__v).path(), __msg);
    Write((__v).filePath(), __msg);
    Write((__v).directory(), __msg);
    Write((__v).baseName(), __msg);
    Write((__v).extension(), __msg);
    Write((__v).query(), __msg);
    Write((__v).ref(), __msg);
    Write((__v).originCharset(), __msg);
    Write((__v).isMutable(), __msg);
    Write((__v).supportsFileURL(), __msg);
    Write((__v).hostEncoding(), __msg);
}

bool
PContentParent::Read(
        StandardURLParams* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->urlType())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->port())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->defaultPort())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->spec())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->scheme())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->authority())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->username())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->password())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->host())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->path())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->filePath())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->directory())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->baseName())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->extension())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->query())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->ref())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->originCharset())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->isMutable())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->supportsFileURL())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->hostEncoding())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PContentParent::Write(
        const URIParams& __v,
        Message* __msg)
{
    typedef URIParams __type;
    Write(int((__v).type()), __msg);

    switch ((__v).type()) {
    case __type::TSimpleURIParams:
        {
            Write((__v).get_SimpleURIParams(), __msg);
            return;
        }
    case __type::TStandardURLParams:
        {
            Write((__v).get_StandardURLParams(), __msg);
            return;
        }
    case __type::TJARURIParams:
        {
            Write((__v).get_JARURIParams(), __msg);
            return;
        }
    case __type::TGenericURIParams:
        {
            Write((__v).get_GenericURIParams(), __msg);
            return;
        }
    default:
        {
            NS_RUNTIMEABORT("unknown union type");
            return;
        }
    }
}

bool
PContentParent::Read(
        URIParams* __v,
        const Message* __msg,
        void** __iter)
{
    typedef URIParams __type;
    int type;
    if ((!(Read((&(type)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }

    switch (type) {
    case __type::TSimpleURIParams:
        {
            SimpleURIParams tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_SimpleURIParams())), __msg, __iter);
        }
    case __type::TStandardURLParams:
        {
            StandardURLParams tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_StandardURLParams())), __msg, __iter);
        }
    case __type::TJARURIParams:
        {
            JARURIParams tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_JARURIParams())), __msg, __iter);
        }
    case __type::TGenericURIParams:
        {
            GenericURIParams tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_GenericURIParams())), __msg, __iter);
        }
    default:
        {
            mozilla::ipc::ProtocolErrorBreakpoint("unknown union type");
            return false;
        }
    }
}

void
PContentParent::Write(
        PBlobParent* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PContentParent::Read(
        PBlobParent** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PContent");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PBlob");
        return false;
    }

    if ((PBlobMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PBlob has different type");
        return false;
    }

    (*(__v)) = static_cast<PBlobParent*>(listener);
    return true;
}

void
PContentParent::Write(
        const InfallibleTArray<FontListEntry>& __v,
        Message* __msg)
{
    uint32_t length = (__v).Length();
    Write(length, __msg);

    for (uint32_t i = 0; (i) < (length); (++(i))) {
        Write(__v[i], __msg);
    }
}

bool
PContentParent::Read(
        InfallibleTArray<FontListEntry>* __v,
        const Message* __msg,
        void** __iter)
{
    InfallibleTArray<FontListEntry>& a = (*(__v));
    uint32_t length;
    if ((!(Read((&(length)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }

    (__v)->SetLength(length);
    for (uint32_t i = 0; (i) < (length); (++(i))) {
        if ((!(Read((&(a[i])), __msg, __iter)))) {
            mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
            return false;
        }
    }
    return true;
}

void
PContentParent::Write(
        PCrashReporterParent* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PContentParent::Read(
        PCrashReporterParent** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PContent");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PCrashReporter");
        return false;
    }

    if ((PCrashReporterMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PCrashReporter has different type");
        return false;
    }

    (*(__v)) = static_cast<PCrashReporterParent*>(listener);
    return true;
}

void
PContentParent::Write(
        PSmsParent* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PContentParent::Read(
        PSmsParent** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PContent");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PSms");
        return false;
    }

    if ((PSmsMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PSms has different type");
        return false;
    }

    (*(__v)) = static_cast<PSmsParent*>(listener);
    return true;
}

void
PContentParent::Write(
        const IPCTabAppBrowserContext& __v,
        Message* __msg)
{
    typedef IPCTabAppBrowserContext __type;
    Write(int((__v).type()), __msg);

    switch ((__v).type()) {
    case __type::TPopupIPCTabContext:
        {
            Write((__v).get_PopupIPCTabContext(), __msg);
            return;
        }
    case __type::TAppFrameIPCTabContext:
        {
            Write((__v).get_AppFrameIPCTabContext(), __msg);
            return;
        }
    case __type::TBrowserFrameIPCTabContext:
        {
            Write((__v).get_BrowserFrameIPCTabContext(), __msg);
            return;
        }
    case __type::TVanillaFrameIPCTabContext:
        {
            Write((__v).get_VanillaFrameIPCTabContext(), __msg);
            return;
        }
    default:
        {
            NS_RUNTIMEABORT("unknown union type");
            return;
        }
    }
}

bool
PContentParent::Read(
        IPCTabAppBrowserContext* __v,
        const Message* __msg,
        void** __iter)
{
    typedef IPCTabAppBrowserContext __type;
    int type;
    if ((!(Read((&(type)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }

    switch (type) {
    case __type::TPopupIPCTabContext:
        {
            PopupIPCTabContext tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_PopupIPCTabContext())), __msg, __iter);
        }
    case __type::TAppFrameIPCTabContext:
        {
            AppFrameIPCTabContext tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_AppFrameIPCTabContext())), __msg, __iter);
        }
    case __type::TBrowserFrameIPCTabContext:
        {
            BrowserFrameIPCTabContext tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_BrowserFrameIPCTabContext())), __msg, __iter);
        }
    case __type::TVanillaFrameIPCTabContext:
        {
            VanillaFrameIPCTabContext tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_VanillaFrameIPCTabContext())), __msg, __iter);
        }
    default:
        {
            mozilla::ipc::ProtocolErrorBreakpoint("unknown union type");
            return false;
        }
    }
}

void
PContentParent::Write(
        const BrowserFrameIPCTabContext& __v,
        Message* __msg)
{
    Write((__v).browserFrameOwnerAppId(), __msg);
}

bool
PContentParent::Read(
        BrowserFrameIPCTabContext* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->browserFrameOwnerAppId())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PContentParent::Write(
        const InfallibleTArray<PrefSetting>& __v,
        Message* __msg)
{
    uint32_t length = (__v).Length();
    Write(length, __msg);

    for (uint32_t i = 0; (i) < (length); (++(i))) {
        Write(__v[i], __msg);
    }
}

bool
PContentParent::Read(
        InfallibleTArray<PrefSetting>* __v,
        const Message* __msg,
        void** __iter)
{
    InfallibleTArray<PrefSetting>& a = (*(__v));
    uint32_t length;
    if ((!(Read((&(length)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }

    (__v)->SetLength(length);
    for (uint32_t i = 0; (i) < (length); (++(i))) {
        if ((!(Read((&(a[i])), __msg, __iter)))) {
            mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
            return false;
        }
    }
    return true;
}

void
PContentParent::Write(
        const PrefValue& __v,
        Message* __msg)
{
    typedef PrefValue __type;
    Write(int((__v).type()), __msg);

    switch ((__v).type()) {
    case __type::TnsCString:
        {
            Write((__v).get_nsCString(), __msg);
            return;
        }
    case __type::Tint32_t:
        {
            Write((__v).get_int32_t(), __msg);
            return;
        }
    case __type::Tbool:
        {
            Write((__v).get_bool(), __msg);
            return;
        }
    default:
        {
            NS_RUNTIMEABORT("unknown union type");
            return;
        }
    }
}

bool
PContentParent::Read(
        PrefValue* __v,
        const Message* __msg,
        void** __iter)
{
    typedef PrefValue __type;
    int type;
    if ((!(Read((&(type)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }

    switch (type) {
    case __type::TnsCString:
        {
            nsCString tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_nsCString())), __msg, __iter);
        }
    case __type::Tint32_t:
        {
            int32_t tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_int32_t())), __msg, __iter);
        }
    case __type::Tbool:
        {
            bool tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_bool())), __msg, __iter);
        }
    default:
        {
            mozilla::ipc::ProtocolErrorBreakpoint("unknown union type");
            return false;
        }
    }
}

void
PContentParent::Write(
        PExternalHelperAppParent* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PContentParent::Read(
        PExternalHelperAppParent** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PContent");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PExternalHelperApp");
        return false;
    }

    if ((PExternalHelperAppMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PExternalHelperApp has different type");
        return false;
    }

    (*(__v)) = static_cast<PExternalHelperAppParent*>(listener);
    return true;
}

void
PContentParent::Write(
        const FontListEntry& __v,
        Message* __msg)
{
    Write((__v).familyName(), __msg);
    Write((__v).faceName(), __msg);
    Write((__v).filepath(), __msg);
    Write((__v).weight(), __msg);
    Write((__v).stretch(), __msg);
    Write((__v).italic(), __msg);
    Write((__v).index(), __msg);
}

bool
PContentParent::Read(
        FontListEntry* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->familyName())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->faceName())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->filepath())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->weight())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->stretch())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->italic())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->index())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PContentParent::Write(
        const DeviceStorageEnumerationParams& __v,
        Message* __msg)
{
    Write((__v).type(), __msg);
    Write((__v).fullpath(), __msg);
    Write((__v).since(), __msg);
}

bool
PContentParent::Read(
        DeviceStorageEnumerationParams* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->type())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->fullpath())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->since())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PContentParent::Write(
        const VanillaFrameIPCTabContext& __v,
        Message* __msg)
{
}

bool
PContentParent::Read(
        VanillaFrameIPCTabContext* __v,
        const Message* __msg,
        void** __iter)
{
    return true;
}

void
PContentParent::Write(
        PTestShellParent* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PContentParent::Read(
        PTestShellParent** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PContent");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PTestShell");
        return false;
    }

    if ((PTestShellMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PTestShell has different type");
        return false;
    }

    (*(__v)) = static_cast<PTestShellParent*>(listener);
    return true;
}

void
PContentParent::Write(
        PMemoryReportRequestParent* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PContentParent::Read(
        PMemoryReportRequestParent** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PContent");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PMemoryReportRequest");
        return false;
    }

    if ((PMemoryReportRequestMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PMemoryReportRequest has different type");
        return false;
    }

    (*(__v)) = static_cast<PMemoryReportRequestParent*>(listener);
    return true;
}

void
PContentParent::Write(
        const GenericURIParams& __v,
        Message* __msg)
{
    Write((__v).spec(), __msg);
    Write((__v).charset(), __msg);
}

bool
PContentParent::Read(
        GenericURIParams* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->spec())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->charset())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PContentParent::Write(
        const DeviceStorageGetParams& __v,
        Message* __msg)
{
    Write((__v).type(), __msg);
    Write((__v).name(), __msg);
    Write((__v).fullpath(), __msg);
}

bool
PContentParent::Read(
        DeviceStorageGetParams* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->type())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->name())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->fullpath())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PContentParent::Write(
        const DeviceStorageAddParams& __v,
        Message* __msg)
{
    Write((__v).type(), __msg);
    Write((__v).blobParent(), __msg, false);
    // skipping actor field that's meaningless on this side
    Write((__v).name(), __msg);
    Write((__v).fullpath(), __msg);
}

bool
PContentParent::Read(
        DeviceStorageAddParams* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->type())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->blobParent())), __msg, __iter, false)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    // skipping actor field that's meaningless on this side
    if ((!(Read((&((__v)->name())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->fullpath())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PContentParent::Write(
        const SlicedBlobConstructorParams& __v,
        Message* __msg)
{
    Write((__v).sourceParent(), __msg, false);
    // skipping actor field that's meaningless on this side
    Write((__v).begin(), __msg);
    Write((__v).end(), __msg);
    Write((__v).contentType(), __msg);
}

bool
PContentParent::Read(
        SlicedBlobConstructorParams* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->sourceParent())), __msg, __iter, false)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    // skipping actor field that's meaningless on this side
    if ((!(Read((&((__v)->begin())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->end())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->contentType())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PContentParent::Write(
        const MaybePrefValue& __v,
        Message* __msg)
{
    typedef MaybePrefValue __type;
    Write(int((__v).type()), __msg);

    switch ((__v).type()) {
    case __type::TPrefValue:
        {
            Write((__v).get_PrefValue(), __msg);
            return;
        }
    case __type::Tnull_t:
        {
            Write((__v).get_null_t(), __msg);
            return;
        }
    default:
        {
            NS_RUNTIMEABORT("unknown union type");
            return;
        }
    }
}

bool
PContentParent::Read(
        MaybePrefValue* __v,
        const Message* __msg,
        void** __iter)
{
    typedef MaybePrefValue __type;
    int type;
    if ((!(Read((&(type)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }

    switch (type) {
    case __type::TPrefValue:
        {
            PrefValue tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_PrefValue())), __msg, __iter);
        }
    case __type::Tnull_t:
        {
            null_t tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_null_t())), __msg, __iter);
        }
    default:
        {
            mozilla::ipc::ProtocolErrorBreakpoint("unknown union type");
            return false;
        }
    }
}

void
PContentParent::Write(
        PNeckoParent* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PContentParent::Read(
        PNeckoParent** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PContent");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PNecko");
        return false;
    }

    if ((PNeckoMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PNecko has different type");
        return false;
    }

    (*(__v)) = static_cast<PNeckoParent*>(listener);
    return true;
}

void
PContentParent::Write(
        const ClonedMessageData& __v,
        Message* __msg)
{
    Write((__v).data(), __msg);
    Write((__v).blobsParent(), __msg);
    // skipping actor field that's meaningless on this side
}

bool
PContentParent::Read(
        ClonedMessageData* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->data())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->blobsParent())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    // skipping actor field that's meaningless on this side
    return true;
}

void
PContentParent::Write(
        const InfallibleTArray<PBlobParent*>& __v,
        Message* __msg)
{
    uint32_t length = (__v).Length();
    Write(length, __msg);

    for (uint32_t i = 0; (i) < (length); (++(i))) {
        Write(__v[i], __msg, false);
    }
}

bool
PContentParent::Read(
        InfallibleTArray<PBlobParent*>* __v,
        const Message* __msg,
        void** __iter)
{
    InfallibleTArray<PBlobParent*>& a = (*(__v));
    uint32_t length;
    if ((!(Read((&(length)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }

    (__v)->SetLength(length);
    for (uint32_t i = 0; (i) < (length); (++(i))) {
        if ((!(Read((&(a[i])), __msg, __iter, false)))) {
            mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
            return false;
        }
    }
    return true;
}

void
PContentParent::Write(
        PDeviceStorageRequestParent* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PContentParent::Read(
        PDeviceStorageRequestParent** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PContent");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PDeviceStorageRequest");
        return false;
    }

    if ((PDeviceStorageRequestMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PDeviceStorageRequest has different type");
        return false;
    }

    (*(__v)) = static_cast<PDeviceStorageRequestParent*>(listener);
    return true;
}

void
PContentParent::Write(
        const NormalBlobConstructorParams& __v,
        Message* __msg)
{
    Write((__v).contentType(), __msg);
    Write((__v).length(), __msg);
}

bool
PContentParent::Read(
        NormalBlobConstructorParams* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->contentType())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->length())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PContentParent::Write(
        const DeviceStorageStatParams& __v,
        Message* __msg)
{
    Write((__v).type(), __msg);
    Write((__v).fullpath(), __msg);
}

bool
PContentParent::Read(
        DeviceStorageStatParams* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->type())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->fullpath())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PContentParent::Write(
        const StorageClone& __v,
        Message* __msg)
{
    Write((__v).actorParent(), __msg, false);
    // skipping actor field that's meaningless on this side
    Write((__v).callerSecure(), __msg);
}

bool
PContentParent::Read(
        StorageClone* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->actorParent())), __msg, __iter, false)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    // skipping actor field that's meaningless on this side
    if ((!(Read((&((__v)->callerSecure())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PContentParent::Write(
        const JARURIParams& __v,
        Message* __msg)
{
    Write((__v).jarFile(), __msg);
    Write((__v).jarEntry(), __msg);
    Write((__v).charset(), __msg);
}

bool
PContentParent::Read(
        JARURIParams* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->jarFile())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->jarEntry())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->charset())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PContentParent::Write(
        const MysteryBlobConstructorParams& __v,
        Message* __msg)
{
}

bool
PContentParent::Read(
        MysteryBlobConstructorParams* __v,
        const Message* __msg,
        void** __iter)
{
    return true;
}

void
PContentParent::Write(
        const DeviceStorageParams& __v,
        Message* __msg)
{
    typedef DeviceStorageParams __type;
    Write(int((__v).type()), __msg);

    switch ((__v).type()) {
    case __type::TDeviceStorageAddParams:
        {
            Write((__v).get_DeviceStorageAddParams(), __msg);
            return;
        }
    case __type::TDeviceStorageGetParams:
        {
            Write((__v).get_DeviceStorageGetParams(), __msg);
            return;
        }
    case __type::TDeviceStorageDeleteParams:
        {
            Write((__v).get_DeviceStorageDeleteParams(), __msg);
            return;
        }
    case __type::TDeviceStorageEnumerationParams:
        {
            Write((__v).get_DeviceStorageEnumerationParams(), __msg);
            return;
        }
    case __type::TDeviceStorageStatParams:
        {
            Write((__v).get_DeviceStorageStatParams(), __msg);
            return;
        }
    default:
        {
            NS_RUNTIMEABORT("unknown union type");
            return;
        }
    }
}

bool
PContentParent::Read(
        DeviceStorageParams* __v,
        const Message* __msg,
        void** __iter)
{
    typedef DeviceStorageParams __type;
    int type;
    if ((!(Read((&(type)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }

    switch (type) {
    case __type::TDeviceStorageAddParams:
        {
            DeviceStorageAddParams tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_DeviceStorageAddParams())), __msg, __iter);
        }
    case __type::TDeviceStorageGetParams:
        {
            DeviceStorageGetParams tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_DeviceStorageGetParams())), __msg, __iter);
        }
    case __type::TDeviceStorageDeleteParams:
        {
            DeviceStorageDeleteParams tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_DeviceStorageDeleteParams())), __msg, __iter);
        }
    case __type::TDeviceStorageEnumerationParams:
        {
            DeviceStorageEnumerationParams tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_DeviceStorageEnumerationParams())), __msg, __iter);
        }
    case __type::TDeviceStorageStatParams:
        {
            DeviceStorageStatParams tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_DeviceStorageStatParams())), __msg, __iter);
        }
    default:
        {
            mozilla::ipc::ProtocolErrorBreakpoint("unknown union type");
            return false;
        }
    }
}

void
PContentParent::Write(
        PBluetoothParent* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PContentParent::Read(
        PBluetoothParent** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PContent");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PBluetooth");
        return false;
    }

    if ((PBluetoothMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PBluetooth has different type");
        return false;
    }

    (*(__v)) = static_cast<PBluetoothParent*>(listener);
    return true;
}

void
PContentParent::Write(
        const PopupIPCTabContext& __v,
        Message* __msg)
{
    Write((__v).openerParent(), __msg, false);
    // skipping actor field that's meaningless on this side
    Write((__v).isBrowserElement(), __msg);
}

bool
PContentParent::Read(
        PopupIPCTabContext* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->openerParent())), __msg, __iter, false)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    // skipping actor field that's meaningless on this side
    if ((!(Read((&((__v)->isBrowserElement())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PContentParent::Write(
        const SimpleURIParams& __v,
        Message* __msg)
{
    Write((__v).scheme(), __msg);
    Write((__v).path(), __msg);
    Write((__v).ref(), __msg);
    Write((__v).isMutable(), __msg);
}

bool
PContentParent::Read(
        SimpleURIParams* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->scheme())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->path())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->ref())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->isMutable())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PContentParent::Write(
        const StorageConstructData& __v,
        Message* __msg)
{
    typedef StorageConstructData __type;
    Write(int((__v).type()), __msg);

    switch ((__v).type()) {
    case __type::Tnull_t:
        {
            Write((__v).get_null_t(), __msg);
            return;
        }
    case __type::TStorageClone:
        {
            Write((__v).get_StorageClone(), __msg);
            return;
        }
    default:
        {
            NS_RUNTIMEABORT("unknown union type");
            return;
        }
    }
}

bool
PContentParent::Read(
        StorageConstructData* __v,
        const Message* __msg,
        void** __iter)
{
    typedef StorageConstructData __type;
    int type;
    if ((!(Read((&(type)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }

    switch (type) {
    case __type::Tnull_t:
        {
            null_t tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_null_t())), __msg, __iter);
        }
    case __type::TStorageClone:
        {
            StorageClone tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_StorageClone())), __msg, __iter);
        }
    default:
        {
            mozilla::ipc::ProtocolErrorBreakpoint("unknown union type");
            return false;
        }
    }
}

void
PContentParent::Write(
        PStorageParent* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PContentParent::Read(
        PStorageParent** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PContent");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PStorage");
        return false;
    }

    if ((PStorageMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PStorage has different type");
        return false;
    }

    (*(__v)) = static_cast<PStorageParent*>(listener);
    return true;
}

void
PContentParent::Write(
        PBrowserParent* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PContentParent::Read(
        PBrowserParent** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PContent");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PBrowser");
        return false;
    }

    if ((PBrowserMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PBrowser has different type");
        return false;
    }

    (*(__v)) = static_cast<PBrowserParent*>(listener);
    return true;
}

void
PContentParent::Write(
        const DeviceStorageDeleteParams& __v,
        Message* __msg)
{
    Write((__v).type(), __msg);
    Write((__v).fullpath(), __msg);
}

bool
PContentParent::Read(
        DeviceStorageDeleteParams* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->type())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->fullpath())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PContentParent::Write(
        const PrefSetting& __v,
        Message* __msg)
{
    Write((__v).name(), __msg);
    Write((__v).defaultValue(), __msg);
    Write((__v).userValue(), __msg);
}

bool
PContentParent::Read(
        PrefSetting* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->name())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->defaultValue())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->userValue())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PContentParent::Write(
        PHalParent* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PContentParent::Read(
        PHalParent** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PContent");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PHal");
        return false;
    }

    if ((PHalMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PHal has different type");
        return false;
    }

    (*(__v)) = static_cast<PHalParent*>(listener);
    return true;
}

void
PContentParent::Write(
        const StandardURLSegment& __v,
        Message* __msg)
{
    Write((__v).position(), __msg);
    Write((__v).length(), __msg);
}

bool
PContentParent::Read(
        StandardURLSegment* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->position())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->length())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PContentParent::Write(
        const FileBlobConstructorParams& __v,
        Message* __msg)
{
    Write((__v).name(), __msg);
    Write((__v).contentType(), __msg);
    Write((__v).length(), __msg);
    Write((__v).modDate(), __msg);
}

bool
PContentParent::Read(
        FileBlobConstructorParams* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->name())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->contentType())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->length())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->modDate())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PContentParent::Write(
        const AppFrameIPCTabContext& __v,
        Message* __msg)
{
    Write((__v).ownAppId(), __msg);
    Write((__v).appFrameOwnerAppId(), __msg);
}

bool
PContentParent::Read(
        AppFrameIPCTabContext* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->ownAppId())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->appFrameOwnerAppId())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}



} // namespace dom
} // namespace mozilla
