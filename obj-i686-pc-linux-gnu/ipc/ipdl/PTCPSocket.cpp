//
// Automatically generated by ipdlc.
// Edit at your own risk
//


#include "mozilla/net/PTCPSocket.h"

namespace mozilla {
namespace net {
namespace PTCPSocket {

bool
Transition(
        State from,
        mozilla::ipc::Trigger trigger,
        State* next)
{
    switch (from) {
    case __Null:
    case __Error:
        if ((Msg___delete____ID) == ((trigger).mMsg)) {
            (*(next)) = __Dead;
            return true;
        }
        return (__Null) == (from);
    case __Dead:
        NS_RUNTIMEABORT("__delete__()d actor");
        return false;
    case __Dying:
        NS_RUNTIMEABORT("__delete__()d (and unexpectedly dying) actor");
        return false;
    default:
        NS_RUNTIMEABORT("corrupted actor state");
        return false;
    }
    (*(next)) = __Error;
    return false;
}

} // namespace PTCPSocket
} // namespace net
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct JSError|
//
JSError::JSError()
{
    Init();
}

JSError::~JSError()
{
}

bool
JSError::operator==(const JSError& _o) const
{
    if ((!((message()) == ((_o).message())))) {
        return false;
    }
    if ((!((filename()) == ((_o).filename())))) {
        return false;
    }
    if ((!((lineNumber()) == ((_o).lineNumber())))) {
        return false;
    }
    if ((!((columnNumber()) == ((_o).columnNumber())))) {
        return false;
    }
    return true;
}

void
JSError::Init()
{
}

void
JSError::Assign(
        const nsString& _message,
        const nsString& _filename,
        const uint32_t& _lineNumber,
        const uint32_t& _columnNumber)
{
    message_ = _message;
    filename_ = _filename;
    lineNumber_ = _lineNumber;
    columnNumber_ = _columnNumber;
}


//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |union SendableData|
//
bool
SendableData::MaybeDestroy(Type aNewType)
{
    if ((mType) == (T__None)) {
        return true;
    }
    if ((mType) == (aNewType)) {
        return false;
    }
    switch (mType) {
    case TArrayOfuint8_t:
        {
            (ptr_ArrayOfuint8_t())->~ArrayOfuint8_t__tdef();
            break;
        }
    case TnsString:
        {
            (ptr_nsString())->~nsString__tdef();
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("not reached");
            break;
        }
    }
    return true;
}

SendableData::SendableData(const InfallibleTArray<uint8_t>& aOther)
{
    new (ptr_ArrayOfuint8_t()) InfallibleTArray<uint8_t>(aOther);
    mType = TArrayOfuint8_t;
}

SendableData::SendableData(const nsString& aOther)
{
    new (ptr_nsString()) nsString(aOther);
    mType = TnsString;
}

SendableData::SendableData(const SendableData& aOther)
{
    (aOther).AssertSanity();
    switch ((aOther).type()) {
    case TArrayOfuint8_t:
        {
            new (ptr_ArrayOfuint8_t()) InfallibleTArray<uint8_t>((aOther).get_ArrayOfuint8_t());
            break;
        }
    case TnsString:
        {
            new (ptr_nsString()) nsString((aOther).get_nsString());
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return;
        }
    }
    mType = (aOther).type();
}

SendableData::~SendableData()
{
    MaybeDestroy(T__None);
}

SendableData&
SendableData::operator=(const InfallibleTArray<uint8_t>& aRhs)
{
    if (MaybeDestroy(TArrayOfuint8_t)) {
        new (ptr_ArrayOfuint8_t()) InfallibleTArray<uint8_t>;
    }
    (*(ptr_ArrayOfuint8_t())) = aRhs;
    mType = TArrayOfuint8_t;
    return (*(this));
}

SendableData&
SendableData::operator=(const nsString& aRhs)
{
    if (MaybeDestroy(TnsString)) {
        new (ptr_nsString()) nsString;
    }
    (*(ptr_nsString())) = aRhs;
    mType = TnsString;
    return (*(this));
}

SendableData&
SendableData::operator=(const SendableData& aRhs)
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case TArrayOfuint8_t:
        {
            if (MaybeDestroy(t)) {
                new (ptr_ArrayOfuint8_t()) InfallibleTArray<uint8_t>;
            }
            (*(ptr_ArrayOfuint8_t())) = (aRhs).get_ArrayOfuint8_t();
            break;
        }
    case TnsString:
        {
            if (MaybeDestroy(t)) {
                new (ptr_nsString()) nsString;
            }
            (*(ptr_nsString())) = (aRhs).get_nsString();
            break;
        }
    case T__None:
        {
            MaybeDestroy(t);
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            break;
        }
    }
    mType = t;
    return (*(this));
}

bool
SendableData::operator==(const InfallibleTArray<uint8_t>& aRhs) const
{
    return (get_ArrayOfuint8_t()) == (aRhs);
}

bool
SendableData::operator==(const nsString& aRhs) const
{
    return (get_nsString()) == (aRhs);
}

bool
SendableData::operator==(const SendableData& aRhs) const
{
    if ((type()) != ((aRhs).type())) {
        return false;
    }

    switch (type()) {
    case TArrayOfuint8_t:
        {
            return (get_ArrayOfuint8_t()) == ((aRhs).get_ArrayOfuint8_t());
        }
    case TnsString:
        {
            return (get_nsString()) == ((aRhs).get_nsString());
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return false;
        }
    }
}


//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |union CallbackData|
//
bool
CallbackData::MaybeDestroy(Type aNewType)
{
    if ((mType) == (T__None)) {
        return true;
    }
    if ((mType) == (aNewType)) {
        return false;
    }
    switch (mType) {
    case Tvoid_t:
        {
            (ptr_void_t())->~void_t__tdef();
            break;
        }
    case TSendableData:
        {
            (ptr_SendableData())->~SendableData__tdef();
            break;
        }
    case TJSError:
        {
            (ptr_JSError())->~JSError__tdef();
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("not reached");
            break;
        }
    }
    return true;
}

CallbackData::CallbackData(const void_t& aOther)
{
    new (ptr_void_t()) void_t(aOther);
    mType = Tvoid_t;
}

CallbackData::CallbackData(const SendableData& aOther)
{
    new (ptr_SendableData()) SendableData(aOther);
    mType = TSendableData;
}

CallbackData::CallbackData(const JSError& aOther)
{
    new (ptr_JSError()) JSError(aOther);
    mType = TJSError;
}

CallbackData::CallbackData(const CallbackData& aOther)
{
    (aOther).AssertSanity();
    switch ((aOther).type()) {
    case Tvoid_t:
        {
            new (ptr_void_t()) void_t((aOther).get_void_t());
            break;
        }
    case TSendableData:
        {
            new (ptr_SendableData()) SendableData((aOther).get_SendableData());
            break;
        }
    case TJSError:
        {
            new (ptr_JSError()) JSError((aOther).get_JSError());
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return;
        }
    }
    mType = (aOther).type();
}

CallbackData::~CallbackData()
{
    MaybeDestroy(T__None);
}

CallbackData&
CallbackData::operator=(const void_t& aRhs)
{
    if (MaybeDestroy(Tvoid_t)) {
        new (ptr_void_t()) void_t;
    }
    (*(ptr_void_t())) = aRhs;
    mType = Tvoid_t;
    return (*(this));
}

CallbackData&
CallbackData::operator=(const SendableData& aRhs)
{
    if (MaybeDestroy(TSendableData)) {
        new (ptr_SendableData()) SendableData;
    }
    (*(ptr_SendableData())) = aRhs;
    mType = TSendableData;
    return (*(this));
}

CallbackData&
CallbackData::operator=(const JSError& aRhs)
{
    if (MaybeDestroy(TJSError)) {
        new (ptr_JSError()) JSError;
    }
    (*(ptr_JSError())) = aRhs;
    mType = TJSError;
    return (*(this));
}

CallbackData&
CallbackData::operator=(const CallbackData& aRhs)
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case Tvoid_t:
        {
            if (MaybeDestroy(t)) {
                new (ptr_void_t()) void_t;
            }
            (*(ptr_void_t())) = (aRhs).get_void_t();
            break;
        }
    case TSendableData:
        {
            if (MaybeDestroy(t)) {
                new (ptr_SendableData()) SendableData;
            }
            (*(ptr_SendableData())) = (aRhs).get_SendableData();
            break;
        }
    case TJSError:
        {
            if (MaybeDestroy(t)) {
                new (ptr_JSError()) JSError;
            }
            (*(ptr_JSError())) = (aRhs).get_JSError();
            break;
        }
    case T__None:
        {
            MaybeDestroy(t);
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            break;
        }
    }
    mType = t;
    return (*(this));
}

bool
CallbackData::operator==(const void_t& aRhs) const
{
    return (get_void_t()) == (aRhs);
}

bool
CallbackData::operator==(const SendableData& aRhs) const
{
    return (get_SendableData()) == (aRhs);
}

bool
CallbackData::operator==(const JSError& aRhs) const
{
    return (get_JSError()) == (aRhs);
}

bool
CallbackData::operator==(const CallbackData& aRhs) const
{
    if ((type()) != ((aRhs).type())) {
        return false;
    }

    switch (type()) {
    case Tvoid_t:
        {
            return (get_void_t()) == ((aRhs).get_void_t());
        }
    case TSendableData:
        {
            return (get_SendableData()) == ((aRhs).get_SendableData());
        }
    case TJSError:
        {
            return (get_JSError()) == ((aRhs).get_JSError());
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return false;
        }
    }
}

