//
// Automatically generated by ipdlc.
// Edit at your own risk
//


#include "mozilla/plugins/PPluginInstance.h"

namespace mozilla {
namespace plugins {
namespace PPluginInstance {

bool
Transition(
        State from,
        mozilla::ipc::Trigger trigger,
        State* next)
{
    switch (from) {
    case __Null:
    case __Error:
        if ((Msg___delete____ID) == ((trigger).mMsg)) {
            (*(next)) = __Dying;
            return true;
        }
        return (__Null) == (from);
    case __Dead:
        NS_RUNTIMEABORT("__delete__()d actor");
        return false;
    case __Dying:
        if ((Reply___delete____ID) == ((trigger).mMsg)) {
            (*(next)) = __Dead;
        }
        return true;
    default:
        NS_RUNTIMEABORT("corrupted actor state");
        return false;
    }
    (*(next)) = __Error;
    return false;
}

} // namespace PPluginInstance
} // namespace plugins
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct IOSurfaceDescriptor|
//
namespace mozilla {
namespace plugins {
IOSurfaceDescriptor::IOSurfaceDescriptor()
{
    Init();
}

IOSurfaceDescriptor::~IOSurfaceDescriptor()
{
}

bool
IOSurfaceDescriptor::operator==(const IOSurfaceDescriptor& _o) const
{
    if ((!((surfaceId()) == ((_o).surfaceId())))) {
        return false;
    }
    if ((!((contentsScaleFactor()) == ((_o).contentsScaleFactor())))) {
        return false;
    }
    return true;
}

void
IOSurfaceDescriptor::Init()
{
}

void
IOSurfaceDescriptor::Assign(
        const uint32_t& _surfaceId,
        const double& _contentsScaleFactor)
{
    surfaceId_ = _surfaceId;
    contentsScaleFactor_ = _contentsScaleFactor;
}

} // namespace plugins
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |union SurfaceDescriptor|
//
namespace mozilla {
namespace plugins {
bool
SurfaceDescriptor::MaybeDestroy(Type aNewType)
{
    if ((mType) == (T__None)) {
        return true;
    }
    if ((mType) == (aNewType)) {
        return false;
    }
    switch (mType) {
    case TShmem:
        {
            (ptr_Shmem())->~Shmem__tdef();
            break;
        }
    case TSurfaceDescriptorX11:
        {
            (ptr_SurfaceDescriptorX11())->~SurfaceDescriptorX11__tdef();
            break;
        }
    case TPPluginSurfaceParent:
        {
            (ptr_PPluginSurfaceParent())->~PPluginSurfaceParent__tdef();
            break;
        }
    case TPPluginSurfaceChild:
        {
            (ptr_PPluginSurfaceChild())->~PPluginSurfaceChild__tdef();
            break;
        }
    case TIOSurfaceDescriptor:
        {
            (ptr_IOSurfaceDescriptor())->~IOSurfaceDescriptor__tdef();
            break;
        }
    case Tnull_t:
        {
            (ptr_null_t())->~null_t__tdef();
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("not reached");
            break;
        }
    }
    return true;
}

SurfaceDescriptor::SurfaceDescriptor(Shmem& aOther)
{
    new (ptr_Shmem()) Shmem(aOther);
    mType = TShmem;
}

SurfaceDescriptor::SurfaceDescriptor(const SurfaceDescriptorX11& aOther)
{
    new (ptr_SurfaceDescriptorX11()) SurfaceDescriptorX11(aOther);
    mType = TSurfaceDescriptorX11;
}

SurfaceDescriptor::SurfaceDescriptor(PPluginSurfaceParent* aOther)
{
    new (ptr_PPluginSurfaceParent()) PPluginSurfaceParent*(const_cast<PPluginSurfaceParent*>(aOther));
    mType = TPPluginSurfaceParent;
}

SurfaceDescriptor::SurfaceDescriptor(PPluginSurfaceChild* aOther)
{
    new (ptr_PPluginSurfaceChild()) PPluginSurfaceChild*(const_cast<PPluginSurfaceChild*>(aOther));
    mType = TPPluginSurfaceChild;
}

SurfaceDescriptor::SurfaceDescriptor(const IOSurfaceDescriptor& aOther)
{
    new (ptr_IOSurfaceDescriptor()) IOSurfaceDescriptor(aOther);
    mType = TIOSurfaceDescriptor;
}

SurfaceDescriptor::SurfaceDescriptor(const null_t& aOther)
{
    new (ptr_null_t()) null_t(aOther);
    mType = Tnull_t;
}

SurfaceDescriptor::SurfaceDescriptor(const SurfaceDescriptor& aOther)
{
    (aOther).AssertSanity();
    switch ((aOther).type()) {
    case TShmem:
        {
            new (ptr_Shmem()) Shmem((aOther).get_Shmem());
            break;
        }
    case TSurfaceDescriptorX11:
        {
            new (ptr_SurfaceDescriptorX11()) SurfaceDescriptorX11((aOther).get_SurfaceDescriptorX11());
            break;
        }
    case TPPluginSurfaceParent:
        {
            new (ptr_PPluginSurfaceParent()) PPluginSurfaceParent*(const_cast<PPluginSurfaceParent*>((aOther).get_PPluginSurfaceParent()));
            break;
        }
    case TPPluginSurfaceChild:
        {
            new (ptr_PPluginSurfaceChild()) PPluginSurfaceChild*(const_cast<PPluginSurfaceChild*>((aOther).get_PPluginSurfaceChild()));
            break;
        }
    case TIOSurfaceDescriptor:
        {
            new (ptr_IOSurfaceDescriptor()) IOSurfaceDescriptor((aOther).get_IOSurfaceDescriptor());
            break;
        }
    case Tnull_t:
        {
            new (ptr_null_t()) null_t((aOther).get_null_t());
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return;
        }
    }
    mType = (aOther).type();
}

SurfaceDescriptor::~SurfaceDescriptor()
{
    MaybeDestroy(T__None);
}

SurfaceDescriptor&
SurfaceDescriptor::operator=(Shmem& aRhs)
{
    if (MaybeDestroy(TShmem)) {
        new (ptr_Shmem()) Shmem;
    }
    (*(ptr_Shmem())) = aRhs;
    mType = TShmem;
    return (*(this));
}

SurfaceDescriptor&
SurfaceDescriptor::operator=(const SurfaceDescriptorX11& aRhs)
{
    if (MaybeDestroy(TSurfaceDescriptorX11)) {
        new (ptr_SurfaceDescriptorX11()) SurfaceDescriptorX11;
    }
    (*(ptr_SurfaceDescriptorX11())) = aRhs;
    mType = TSurfaceDescriptorX11;
    return (*(this));
}

SurfaceDescriptor&
SurfaceDescriptor::operator=(PPluginSurfaceParent* aRhs)
{
    if (MaybeDestroy(TPPluginSurfaceParent)) {
        new (ptr_PPluginSurfaceParent()) PPluginSurfaceParent*;
    }
    (*(ptr_PPluginSurfaceParent())) = const_cast<PPluginSurfaceParent*>(aRhs);
    mType = TPPluginSurfaceParent;
    return (*(this));
}

SurfaceDescriptor&
SurfaceDescriptor::operator=(PPluginSurfaceChild* aRhs)
{
    if (MaybeDestroy(TPPluginSurfaceChild)) {
        new (ptr_PPluginSurfaceChild()) PPluginSurfaceChild*;
    }
    (*(ptr_PPluginSurfaceChild())) = const_cast<PPluginSurfaceChild*>(aRhs);
    mType = TPPluginSurfaceChild;
    return (*(this));
}

SurfaceDescriptor&
SurfaceDescriptor::operator=(const IOSurfaceDescriptor& aRhs)
{
    if (MaybeDestroy(TIOSurfaceDescriptor)) {
        new (ptr_IOSurfaceDescriptor()) IOSurfaceDescriptor;
    }
    (*(ptr_IOSurfaceDescriptor())) = aRhs;
    mType = TIOSurfaceDescriptor;
    return (*(this));
}

SurfaceDescriptor&
SurfaceDescriptor::operator=(const null_t& aRhs)
{
    if (MaybeDestroy(Tnull_t)) {
        new (ptr_null_t()) null_t;
    }
    (*(ptr_null_t())) = aRhs;
    mType = Tnull_t;
    return (*(this));
}

SurfaceDescriptor&
SurfaceDescriptor::operator=(const SurfaceDescriptor& aRhs)
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case TShmem:
        {
            if (MaybeDestroy(t)) {
                new (ptr_Shmem()) Shmem;
            }
            (*(ptr_Shmem())) = (aRhs).get_Shmem();
            break;
        }
    case TSurfaceDescriptorX11:
        {
            if (MaybeDestroy(t)) {
                new (ptr_SurfaceDescriptorX11()) SurfaceDescriptorX11;
            }
            (*(ptr_SurfaceDescriptorX11())) = (aRhs).get_SurfaceDescriptorX11();
            break;
        }
    case TPPluginSurfaceParent:
        {
            if (MaybeDestroy(t)) {
                new (ptr_PPluginSurfaceParent()) PPluginSurfaceParent*;
            }
            (*(ptr_PPluginSurfaceParent())) = const_cast<PPluginSurfaceParent*>((aRhs).get_PPluginSurfaceParent());
            break;
        }
    case TPPluginSurfaceChild:
        {
            if (MaybeDestroy(t)) {
                new (ptr_PPluginSurfaceChild()) PPluginSurfaceChild*;
            }
            (*(ptr_PPluginSurfaceChild())) = const_cast<PPluginSurfaceChild*>((aRhs).get_PPluginSurfaceChild());
            break;
        }
    case TIOSurfaceDescriptor:
        {
            if (MaybeDestroy(t)) {
                new (ptr_IOSurfaceDescriptor()) IOSurfaceDescriptor;
            }
            (*(ptr_IOSurfaceDescriptor())) = (aRhs).get_IOSurfaceDescriptor();
            break;
        }
    case Tnull_t:
        {
            if (MaybeDestroy(t)) {
                new (ptr_null_t()) null_t;
            }
            (*(ptr_null_t())) = (aRhs).get_null_t();
            break;
        }
    case T__None:
        {
            MaybeDestroy(t);
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            break;
        }
    }
    mType = t;
    return (*(this));
}

bool
SurfaceDescriptor::operator==(Shmem& aRhs) const
{
    return (get_Shmem()) == (aRhs);
}

bool
SurfaceDescriptor::operator==(const SurfaceDescriptorX11& aRhs) const
{
    return (get_SurfaceDescriptorX11()) == (aRhs);
}

bool
SurfaceDescriptor::operator==(PPluginSurfaceParent* aRhs) const
{
    return (get_PPluginSurfaceParent()) == (aRhs);
}

bool
SurfaceDescriptor::operator==(PPluginSurfaceChild* aRhs) const
{
    return (get_PPluginSurfaceChild()) == (aRhs);
}

bool
SurfaceDescriptor::operator==(const IOSurfaceDescriptor& aRhs) const
{
    return (get_IOSurfaceDescriptor()) == (aRhs);
}

bool
SurfaceDescriptor::operator==(const null_t& aRhs) const
{
    return (get_null_t()) == (aRhs);
}

bool
SurfaceDescriptor::operator==(const SurfaceDescriptor& aRhs) const
{
    if ((type()) != ((aRhs).type())) {
        return false;
    }

    switch (type()) {
    case TShmem:
        {
            return (get_Shmem()) == ((aRhs).get_Shmem());
        }
    case TSurfaceDescriptorX11:
        {
            return (get_SurfaceDescriptorX11()) == ((aRhs).get_SurfaceDescriptorX11());
        }
    case TPPluginSurfaceParent:
        {
            return (get_PPluginSurfaceParent()) == ((aRhs).get_PPluginSurfaceParent());
        }
    case TPPluginSurfaceChild:
        {
            return (get_PPluginSurfaceChild()) == ((aRhs).get_PPluginSurfaceChild());
        }
    case TIOSurfaceDescriptor:
        {
            return (get_IOSurfaceDescriptor()) == ((aRhs).get_IOSurfaceDescriptor());
        }
    case Tnull_t:
        {
            return (get_null_t()) == ((aRhs).get_null_t());
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return false;
        }
    }
}

} // namespace plugins
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |union OptionalShmem|
//
namespace mozilla {
namespace plugins {
bool
OptionalShmem::MaybeDestroy(Type aNewType)
{
    if ((mType) == (T__None)) {
        return true;
    }
    if ((mType) == (aNewType)) {
        return false;
    }
    switch (mType) {
    case TShmem:
        {
            (ptr_Shmem())->~Shmem__tdef();
            break;
        }
    case Tnull_t:
        {
            (ptr_null_t())->~null_t__tdef();
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("not reached");
            break;
        }
    }
    return true;
}

OptionalShmem::OptionalShmem(Shmem& aOther)
{
    new (ptr_Shmem()) Shmem(aOther);
    mType = TShmem;
}

OptionalShmem::OptionalShmem(const null_t& aOther)
{
    new (ptr_null_t()) null_t(aOther);
    mType = Tnull_t;
}

OptionalShmem::OptionalShmem(const OptionalShmem& aOther)
{
    (aOther).AssertSanity();
    switch ((aOther).type()) {
    case TShmem:
        {
            new (ptr_Shmem()) Shmem((aOther).get_Shmem());
            break;
        }
    case Tnull_t:
        {
            new (ptr_null_t()) null_t((aOther).get_null_t());
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return;
        }
    }
    mType = (aOther).type();
}

OptionalShmem::~OptionalShmem()
{
    MaybeDestroy(T__None);
}

OptionalShmem&
OptionalShmem::operator=(Shmem& aRhs)
{
    if (MaybeDestroy(TShmem)) {
        new (ptr_Shmem()) Shmem;
    }
    (*(ptr_Shmem())) = aRhs;
    mType = TShmem;
    return (*(this));
}

OptionalShmem&
OptionalShmem::operator=(const null_t& aRhs)
{
    if (MaybeDestroy(Tnull_t)) {
        new (ptr_null_t()) null_t;
    }
    (*(ptr_null_t())) = aRhs;
    mType = Tnull_t;
    return (*(this));
}

OptionalShmem&
OptionalShmem::operator=(const OptionalShmem& aRhs)
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case TShmem:
        {
            if (MaybeDestroy(t)) {
                new (ptr_Shmem()) Shmem;
            }
            (*(ptr_Shmem())) = (aRhs).get_Shmem();
            break;
        }
    case Tnull_t:
        {
            if (MaybeDestroy(t)) {
                new (ptr_null_t()) null_t;
            }
            (*(ptr_null_t())) = (aRhs).get_null_t();
            break;
        }
    case T__None:
        {
            MaybeDestroy(t);
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            break;
        }
    }
    mType = t;
    return (*(this));
}

bool
OptionalShmem::operator==(Shmem& aRhs) const
{
    return (get_Shmem()) == (aRhs);
}

bool
OptionalShmem::operator==(const null_t& aRhs) const
{
    return (get_null_t()) == (aRhs);
}

bool
OptionalShmem::operator==(const OptionalShmem& aRhs) const
{
    if ((type()) != ((aRhs).type())) {
        return false;
    }

    switch (type()) {
    case TShmem:
        {
            return (get_Shmem()) == ((aRhs).get_Shmem());
        }
    case Tnull_t:
        {
            return (get_null_t()) == ((aRhs).get_null_t());
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return false;
        }
    }
}

} // namespace plugins
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |union AsyncSurfaceDescriptor|
//
namespace mozilla {
namespace plugins {
bool
AsyncSurfaceDescriptor::MaybeDestroy(Type aNewType)
{
    if ((mType) == (T__None)) {
        return true;
    }
    if ((mType) == (aNewType)) {
        return false;
    }
    switch (mType) {
    case TShmem:
        {
            (ptr_Shmem())->~Shmem__tdef();
            break;
        }
    case TDXGISharedSurfaceHandle:
        {
            (ptr_DXGISharedSurfaceHandle())->~DXGISharedSurfaceHandle__tdef();
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("not reached");
            break;
        }
    }
    return true;
}

AsyncSurfaceDescriptor::AsyncSurfaceDescriptor(Shmem& aOther)
{
    new (ptr_Shmem()) Shmem(aOther);
    mType = TShmem;
}

AsyncSurfaceDescriptor::AsyncSurfaceDescriptor(const DXGISharedSurfaceHandle& aOther)
{
    new (ptr_DXGISharedSurfaceHandle()) DXGISharedSurfaceHandle(aOther);
    mType = TDXGISharedSurfaceHandle;
}

AsyncSurfaceDescriptor::AsyncSurfaceDescriptor(const AsyncSurfaceDescriptor& aOther)
{
    (aOther).AssertSanity();
    switch ((aOther).type()) {
    case TShmem:
        {
            new (ptr_Shmem()) Shmem((aOther).get_Shmem());
            break;
        }
    case TDXGISharedSurfaceHandle:
        {
            new (ptr_DXGISharedSurfaceHandle()) DXGISharedSurfaceHandle((aOther).get_DXGISharedSurfaceHandle());
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return;
        }
    }
    mType = (aOther).type();
}

AsyncSurfaceDescriptor::~AsyncSurfaceDescriptor()
{
    MaybeDestroy(T__None);
}

AsyncSurfaceDescriptor&
AsyncSurfaceDescriptor::operator=(Shmem& aRhs)
{
    if (MaybeDestroy(TShmem)) {
        new (ptr_Shmem()) Shmem;
    }
    (*(ptr_Shmem())) = aRhs;
    mType = TShmem;
    return (*(this));
}

AsyncSurfaceDescriptor&
AsyncSurfaceDescriptor::operator=(const DXGISharedSurfaceHandle& aRhs)
{
    if (MaybeDestroy(TDXGISharedSurfaceHandle)) {
        new (ptr_DXGISharedSurfaceHandle()) DXGISharedSurfaceHandle;
    }
    (*(ptr_DXGISharedSurfaceHandle())) = aRhs;
    mType = TDXGISharedSurfaceHandle;
    return (*(this));
}

AsyncSurfaceDescriptor&
AsyncSurfaceDescriptor::operator=(const AsyncSurfaceDescriptor& aRhs)
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case TShmem:
        {
            if (MaybeDestroy(t)) {
                new (ptr_Shmem()) Shmem;
            }
            (*(ptr_Shmem())) = (aRhs).get_Shmem();
            break;
        }
    case TDXGISharedSurfaceHandle:
        {
            if (MaybeDestroy(t)) {
                new (ptr_DXGISharedSurfaceHandle()) DXGISharedSurfaceHandle;
            }
            (*(ptr_DXGISharedSurfaceHandle())) = (aRhs).get_DXGISharedSurfaceHandle();
            break;
        }
    case T__None:
        {
            MaybeDestroy(t);
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            break;
        }
    }
    mType = t;
    return (*(this));
}

bool
AsyncSurfaceDescriptor::operator==(Shmem& aRhs) const
{
    return (get_Shmem()) == (aRhs);
}

bool
AsyncSurfaceDescriptor::operator==(const DXGISharedSurfaceHandle& aRhs) const
{
    return (get_DXGISharedSurfaceHandle()) == (aRhs);
}

bool
AsyncSurfaceDescriptor::operator==(const AsyncSurfaceDescriptor& aRhs) const
{
    if ((type()) != ((aRhs).type())) {
        return false;
    }

    switch (type()) {
    case TShmem:
        {
            return (get_Shmem()) == ((aRhs).get_Shmem());
        }
    case TDXGISharedSurfaceHandle:
        {
            return (get_DXGISharedSurfaceHandle()) == ((aRhs).get_DXGISharedSurfaceHandle());
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return false;
        }
    }
}

} // namespace plugins
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct NPRemoteAsyncSurface|
//
namespace mozilla {
namespace plugins {
NPRemoteAsyncSurface::NPRemoteAsyncSurface()
{
    Init();
}

NPRemoteAsyncSurface::~NPRemoteAsyncSurface()
{
}

bool
NPRemoteAsyncSurface::operator==(const NPRemoteAsyncSurface& _o) const
{
    if ((!((version()) == ((_o).version())))) {
        return false;
    }
    if ((!((size()) == ((_o).size())))) {
        return false;
    }
    if ((!((format()) == ((_o).format())))) {
        return false;
    }
    if ((!((stride()) == ((_o).stride())))) {
        return false;
    }
    if ((!((data()) == ((_o).data())))) {
        return false;
    }
    if ((!((hostPtr()) == ((_o).hostPtr())))) {
        return false;
    }
    return true;
}

void
NPRemoteAsyncSurface::Init()
{
}

void
NPRemoteAsyncSurface::Assign(
        const uint32_t& _version,
        const gfxIntSize& _size,
        const NPImageFormat& _format,
        const uint32_t& _stride,
        const AsyncSurfaceDescriptor& _data,
        const uintptr_t& _hostPtr)
{
    version_ = _version;
    size_ = _size;
    format_ = _format;
    stride_ = _stride;
    data_ = _data;
    hostPtr_ = _hostPtr;
}

} // namespace plugins
} // namespace mozilla
