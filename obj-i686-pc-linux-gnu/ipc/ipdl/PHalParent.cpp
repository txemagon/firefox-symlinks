//
// Automatically generated by ipdlc.
// Edit at your own risk
//


#include "mozilla/hal_sandbox/PHalParent.h"

#include "mozilla/dom/PContentParent.h"
#include "mozilla/dom/PBrowserParent.h"

typedef IPC::Message Message;
typedef mozilla::ipc::RPCChannel Channel;
typedef mozilla::ipc::RPCChannel::RPCListener ChannelListener;
typedef base::ProcessHandle ProcessHandle;
typedef mozilla::ipc::AsyncChannel AsyncChannel;
typedef mozilla::ipc::SharedMemory SharedMemory;
typedef mozilla::ipc::Trigger Trigger;
typedef mozilla::ipc::ActorHandle ActorHandle;
typedef mozilla::hal::BatteryInformation BatteryInformation;
typedef mozilla::hal::FMRadioCountry FMRadioCountry;
typedef mozilla::hal::FMRadioOperation FMRadioOperation;
typedef mozilla::hal::FMRadioOperationInformation FMRadioOperationInformation;
typedef mozilla::hal::FMRadioOperationStatus FMRadioOperationStatus;
typedef mozilla::hal::FMRadioSettings FMRadioSettings;
typedef mozilla::ipc::FileDescriptor FileDescriptor;
typedef mozilla::hal::FlashMode FlashMode;
typedef mozilla::hal::LightConfiguration LightConfiguration;
typedef mozilla::hal::LightMode LightMode;
typedef mozilla::hal::LightType LightType;
typedef mozilla::hal::NetworkInformation NetworkInformation;
typedef mozilla::hal::ProcessPriority ProcessPriority;
typedef mozilla::hal::ScreenConfiguration ScreenConfiguration;
typedef mozilla::dom::ScreenOrientation ScreenOrientation;
typedef mozilla::hal::SensorAccuracyType SensorAccuracyType;
typedef mozilla::hal::SensorData SensorData;
typedef mozilla::hal::SensorType SensorType;
typedef mozilla::ipc::Shmem Shmem;
typedef mozilla::hal::SwitchDevice SwitchDevice;
typedef mozilla::hal::SwitchEvent SwitchEvent;
typedef mozilla::hal::SwitchState SwitchState;
typedef mozilla::hal::SystemTimezoneChangeInformation SystemTimezoneChangeInformation;
typedef mozilla::hal::WakeLockControl WakeLockControl;
typedef mozilla::hal::WakeLockInformation WakeLockInformation;
using mozilla::dom::PContentParent;
using mozilla::dom::PBrowserParent;

namespace mozilla {
namespace hal_sandbox {


bool
PHalParent::Recv__delete__()
{
    return true;
}

void
PHalParent::ActorDestroy(ActorDestroyReason why)
{
}

PHalParent::PHalParent() :
    mId(0),
    mState(PHal::__Dead)
{
    MOZ_COUNT_CTOR(PHalParent);
}

PHalParent::~PHalParent()
{
    MOZ_COUNT_DTOR(PHalParent);
}

PContentParent*
PHalParent::Manager() const
{
    return static_cast<PContentParent*>(mManager);
}

PHal::State
PHalParent::state()
{
    return mState;
}

bool
PHalParent::SendNotifyBatteryChange(const BatteryInformation& aBatteryInfo)
{
    PHal::Msg_NotifyBatteryChange* __msg = new PHal::Msg_NotifyBatteryChange();

    Write(aBatteryInfo, __msg);

    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PHalParent] Sending ", stderr);
    }
    if ((!(PHal::Transition(mState, Trigger(Trigger::Send, PHal::Msg_NotifyBatteryChange__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

bool
PHalParent::SendNotifyNetworkChange(const NetworkInformation& aNetworkInfo)
{
    PHal::Msg_NotifyNetworkChange* __msg = new PHal::Msg_NotifyNetworkChange();

    Write(aNetworkInfo, __msg);

    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PHalParent] Sending ", stderr);
    }
    if ((!(PHal::Transition(mState, Trigger(Trigger::Send, PHal::Msg_NotifyNetworkChange__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

bool
PHalParent::SendNotifyWakeLockChange(const WakeLockInformation& aWakeLockInfo)
{
    PHal::Msg_NotifyWakeLockChange* __msg = new PHal::Msg_NotifyWakeLockChange();

    Write(aWakeLockInfo, __msg);

    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PHalParent] Sending ", stderr);
    }
    if ((!(PHal::Transition(mState, Trigger(Trigger::Send, PHal::Msg_NotifyWakeLockChange__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

bool
PHalParent::SendNotifyScreenConfigurationChange(const ScreenConfiguration& aScreenOrientation)
{
    PHal::Msg_NotifyScreenConfigurationChange* __msg = new PHal::Msg_NotifyScreenConfigurationChange();

    Write(aScreenOrientation, __msg);

    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PHalParent] Sending ", stderr);
    }
    if ((!(PHal::Transition(mState, Trigger(Trigger::Send, PHal::Msg_NotifyScreenConfigurationChange__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

bool
PHalParent::SendNotifySwitchChange(const SwitchEvent& aEvent)
{
    PHal::Msg_NotifySwitchChange* __msg = new PHal::Msg_NotifySwitchChange();

    Write(aEvent, __msg);

    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PHalParent] Sending ", stderr);
    }
    if ((!(PHal::Transition(mState, Trigger(Trigger::Send, PHal::Msg_NotifySwitchChange__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

bool
PHalParent::SendNotifySystemClockChange(const int64_t& aClockDeltaMS)
{
    PHal::Msg_NotifySystemClockChange* __msg = new PHal::Msg_NotifySystemClockChange();

    Write(aClockDeltaMS, __msg);

    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PHalParent] Sending ", stderr);
    }
    if ((!(PHal::Transition(mState, Trigger(Trigger::Send, PHal::Msg_NotifySystemClockChange__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

bool
PHalParent::SendNotifySystemTimezoneChange(const SystemTimezoneChangeInformation& aSystemTimezoneChangeInfo)
{
    PHal::Msg_NotifySystemTimezoneChange* __msg = new PHal::Msg_NotifySystemTimezoneChange();

    Write(aSystemTimezoneChangeInfo, __msg);

    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PHalParent] Sending ", stderr);
    }
    if ((!(PHal::Transition(mState, Trigger(Trigger::Send, PHal::Msg_NotifySystemTimezoneChange__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

bool
PHalParent::SendNotifySensorChange(const SensorData& aSensorData)
{
    PHal::Msg_NotifySensorChange* __msg = new PHal::Msg_NotifySensorChange();

    Write(aSensorData, __msg);

    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PHalParent] Sending ", stderr);
    }
    if ((!(PHal::Transition(mState, Trigger(Trigger::Send, PHal::Msg_NotifySensorChange__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

int32_t
PHalParent::Register(ChannelListener* aRouted)
{
    return (mManager)->Register(aRouted);
}

int32_t
PHalParent::RegisterID(
        ChannelListener* aRouted,
        int32_t aId)
{
    return (mManager)->RegisterID(aRouted, aId);
}

ChannelListener*
PHalParent::Lookup(int32_t aId)
{
    return (mManager)->Lookup(aId);
}

void
PHalParent::Unregister(int32_t aId)
{
    return (mManager)->Unregister(aId);
}

void
PHalParent::RemoveManagee(
        int32_t aProtocolId,
        ChannelListener* aListener)
{
    NS_RUNTIMEABORT("unreached");
    return;
}

Shmem::SharedMemory*
PHalParent::CreateSharedMemory(
        size_t aSize,
        Shmem::SharedMemory::SharedMemoryType aType,
        bool aUnsafe,
        Shmem::id_t* aId)
{
    return (mManager)->CreateSharedMemory(aSize, aType, aUnsafe, aId);
}

bool
PHalParent::AdoptSharedMemory(
        Shmem::SharedMemory* segment,
        Shmem::id_t* aId)
{
    return (mManager)->AdoptSharedMemory(segment, aId);
}

Shmem::SharedMemory*
PHalParent::LookupSharedMemory(Shmem::id_t aId)
{
    return (mManager)->LookupSharedMemory(aId);
}

bool
PHalParent::IsTrackingSharedMemory(Shmem::SharedMemory* segment)
{
    return (mManager)->IsTrackingSharedMemory(segment);
}

bool
PHalParent::DestroySharedMemory(Shmem& shmem)
{
    return (mManager)->DestroySharedMemory(shmem);
}

ProcessHandle
PHalParent::OtherProcess() const
{
    return (mManager)->OtherProcess();
}

AsyncChannel*
PHalParent::GetIPCChannel()
{
    return mChannel;
}

PHalParent::Result
PHalParent::OnMessageReceived(const Message& __msg)
{
    switch ((__msg).type()) {
    case PHal::Msg_Vibrate__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PHal::Msg_Vibrate");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PHal::Msg_Vibrate*>((&(__msg))))->Log("[PHalParent] Received ", stderr);
            }

            void* __iter = 0;
            InfallibleTArray<uint32_t> pattern;
            InfallibleTArray<uint64_t> id;
            PBrowserParent* browser;

            if ((!(Read((&(pattern)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(id)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(browser)), (&(__msg)), (&(__iter)), false)))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_Vibrate__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvVibrate(pattern, id, browser)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for Vibrate returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PHal::Msg_CancelVibrate__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PHal::Msg_CancelVibrate");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PHal::Msg_CancelVibrate*>((&(__msg))))->Log("[PHalParent] Received ", stderr);
            }

            void* __iter = 0;
            InfallibleTArray<uint64_t> id;
            PBrowserParent* browser;

            if ((!(Read((&(id)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(browser)), (&(__msg)), (&(__iter)), false)))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_CancelVibrate__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvCancelVibrate(id, browser)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for CancelVibrate returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PHal::Msg_EnableBatteryNotifications__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PHal::Msg_EnableBatteryNotifications");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PHal::Msg_EnableBatteryNotifications*>((&(__msg))))->Log("[PHalParent] Received ", stderr);
            }

            if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_EnableBatteryNotifications__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvEnableBatteryNotifications()))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for EnableBatteryNotifications returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PHal::Msg_DisableBatteryNotifications__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PHal::Msg_DisableBatteryNotifications");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PHal::Msg_DisableBatteryNotifications*>((&(__msg))))->Log("[PHalParent] Received ", stderr);
            }

            if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_DisableBatteryNotifications__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvDisableBatteryNotifications()))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for DisableBatteryNotifications returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PHal::Msg_EnableNetworkNotifications__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PHal::Msg_EnableNetworkNotifications");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PHal::Msg_EnableNetworkNotifications*>((&(__msg))))->Log("[PHalParent] Received ", stderr);
            }

            if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_EnableNetworkNotifications__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvEnableNetworkNotifications()))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for EnableNetworkNotifications returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PHal::Msg_DisableNetworkNotifications__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PHal::Msg_DisableNetworkNotifications");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PHal::Msg_DisableNetworkNotifications*>((&(__msg))))->Log("[PHalParent] Received ", stderr);
            }

            if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_DisableNetworkNotifications__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvDisableNetworkNotifications()))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for DisableNetworkNotifications returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PHal::Msg_SetScreenEnabled__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PHal::Msg_SetScreenEnabled");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PHal::Msg_SetScreenEnabled*>((&(__msg))))->Log("[PHalParent] Received ", stderr);
            }

            void* __iter = 0;
            bool enabled;

            if ((!(Read((&(enabled)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_SetScreenEnabled__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvSetScreenEnabled(enabled)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for SetScreenEnabled returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PHal::Msg_SetCpuSleepAllowed__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PHal::Msg_SetCpuSleepAllowed");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PHal::Msg_SetCpuSleepAllowed*>((&(__msg))))->Log("[PHalParent] Received ", stderr);
            }

            void* __iter = 0;
            bool allowed;

            if ((!(Read((&(allowed)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_SetCpuSleepAllowed__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvSetCpuSleepAllowed(allowed)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for SetCpuSleepAllowed returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PHal::Msg_SetScreenBrightness__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PHal::Msg_SetScreenBrightness");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PHal::Msg_SetScreenBrightness*>((&(__msg))))->Log("[PHalParent] Received ", stderr);
            }

            void* __iter = 0;
            double brightness;

            if ((!(Read((&(brightness)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_SetScreenBrightness__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvSetScreenBrightness(brightness)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for SetScreenBrightness returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PHal::Msg_AdjustSystemClock__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PHal::Msg_AdjustSystemClock");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PHal::Msg_AdjustSystemClock*>((&(__msg))))->Log("[PHalParent] Received ", stderr);
            }

            void* __iter = 0;
            int64_t aDeltaMilliseconds;

            if ((!(Read((&(aDeltaMilliseconds)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_AdjustSystemClock__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvAdjustSystemClock(aDeltaMilliseconds)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for AdjustSystemClock returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PHal::Msg_SetTimezone__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PHal::Msg_SetTimezone");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PHal::Msg_SetTimezone*>((&(__msg))))->Log("[PHalParent] Received ", stderr);
            }

            void* __iter = 0;
            nsCString aTimezoneSpec;

            if ((!(Read((&(aTimezoneSpec)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_SetTimezone__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvSetTimezone(aTimezoneSpec)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for SetTimezone returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PHal::Msg_EnableSystemClockChangeNotifications__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PHal::Msg_EnableSystemClockChangeNotifications");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PHal::Msg_EnableSystemClockChangeNotifications*>((&(__msg))))->Log("[PHalParent] Received ", stderr);
            }

            if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_EnableSystemClockChangeNotifications__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvEnableSystemClockChangeNotifications()))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for EnableSystemClockChangeNotifications returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PHal::Msg_DisableSystemClockChangeNotifications__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PHal::Msg_DisableSystemClockChangeNotifications");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PHal::Msg_DisableSystemClockChangeNotifications*>((&(__msg))))->Log("[PHalParent] Received ", stderr);
            }

            if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_DisableSystemClockChangeNotifications__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvDisableSystemClockChangeNotifications()))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for DisableSystemClockChangeNotifications returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PHal::Msg_EnableSystemTimezoneChangeNotifications__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PHal::Msg_EnableSystemTimezoneChangeNotifications");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PHal::Msg_EnableSystemTimezoneChangeNotifications*>((&(__msg))))->Log("[PHalParent] Received ", stderr);
            }

            if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_EnableSystemTimezoneChangeNotifications__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvEnableSystemTimezoneChangeNotifications()))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for EnableSystemTimezoneChangeNotifications returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PHal::Msg_DisableSystemTimezoneChangeNotifications__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PHal::Msg_DisableSystemTimezoneChangeNotifications");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PHal::Msg_DisableSystemTimezoneChangeNotifications*>((&(__msg))))->Log("[PHalParent] Received ", stderr);
            }

            if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_DisableSystemTimezoneChangeNotifications__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvDisableSystemTimezoneChangeNotifications()))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for DisableSystemTimezoneChangeNotifications returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PHal::Msg_ModifyWakeLock__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PHal::Msg_ModifyWakeLock");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PHal::Msg_ModifyWakeLock*>((&(__msg))))->Log("[PHalParent] Received ", stderr);
            }

            void* __iter = 0;
            nsString aTopic;
            WakeLockControl aLockAdjust;
            WakeLockControl aHiddenAdjust;
            uint64_t aProcessID;

            if ((!(Read((&(aTopic)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(aLockAdjust)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(aHiddenAdjust)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(aProcessID)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_ModifyWakeLock__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvModifyWakeLock(aTopic, aLockAdjust, aHiddenAdjust, aProcessID)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for ModifyWakeLock returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PHal::Msg_EnableWakeLockNotifications__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PHal::Msg_EnableWakeLockNotifications");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PHal::Msg_EnableWakeLockNotifications*>((&(__msg))))->Log("[PHalParent] Received ", stderr);
            }

            if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_EnableWakeLockNotifications__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvEnableWakeLockNotifications()))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for EnableWakeLockNotifications returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PHal::Msg_DisableWakeLockNotifications__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PHal::Msg_DisableWakeLockNotifications");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PHal::Msg_DisableWakeLockNotifications*>((&(__msg))))->Log("[PHalParent] Received ", stderr);
            }

            if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_DisableWakeLockNotifications__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvDisableWakeLockNotifications()))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for DisableWakeLockNotifications returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PHal::Msg_EnableScreenConfigurationNotifications__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PHal::Msg_EnableScreenConfigurationNotifications");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PHal::Msg_EnableScreenConfigurationNotifications*>((&(__msg))))->Log("[PHalParent] Received ", stderr);
            }

            if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_EnableScreenConfigurationNotifications__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvEnableScreenConfigurationNotifications()))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for EnableScreenConfigurationNotifications returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PHal::Msg_DisableScreenConfigurationNotifications__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PHal::Msg_DisableScreenConfigurationNotifications");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PHal::Msg_DisableScreenConfigurationNotifications*>((&(__msg))))->Log("[PHalParent] Received ", stderr);
            }

            if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_DisableScreenConfigurationNotifications__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvDisableScreenConfigurationNotifications()))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for DisableScreenConfigurationNotifications returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PHal::Msg_UnlockScreenOrientation__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PHal::Msg_UnlockScreenOrientation");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PHal::Msg_UnlockScreenOrientation*>((&(__msg))))->Log("[PHalParent] Received ", stderr);
            }

            if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_UnlockScreenOrientation__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvUnlockScreenOrientation()))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for UnlockScreenOrientation returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PHal::Msg_EnableSwitchNotifications__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PHal::Msg_EnableSwitchNotifications");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PHal::Msg_EnableSwitchNotifications*>((&(__msg))))->Log("[PHalParent] Received ", stderr);
            }

            void* __iter = 0;
            SwitchDevice aDevice;

            if ((!(Read((&(aDevice)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_EnableSwitchNotifications__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvEnableSwitchNotifications(aDevice)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for EnableSwitchNotifications returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PHal::Msg_DisableSwitchNotifications__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PHal::Msg_DisableSwitchNotifications");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PHal::Msg_DisableSwitchNotifications*>((&(__msg))))->Log("[PHalParent] Received ", stderr);
            }

            void* __iter = 0;
            SwitchDevice aDevice;

            if ((!(Read((&(aDevice)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_DisableSwitchNotifications__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvDisableSwitchNotifications(aDevice)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for DisableSwitchNotifications returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PHal::Msg_SetProcessPriority__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PHal::Msg_SetProcessPriority");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PHal::Msg_SetProcessPriority*>((&(__msg))))->Log("[PHalParent] Received ", stderr);
            }

            void* __iter = 0;
            int aPid;
            ProcessPriority aPriority;

            if ((!(Read((&(aPid)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(aPriority)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_SetProcessPriority__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvSetProcessPriority(aPid, aPriority)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for SetProcessPriority returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PHal::Msg_FactoryReset__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PHal::Msg_FactoryReset");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PHal::Msg_FactoryReset*>((&(__msg))))->Log("[PHalParent] Received ", stderr);
            }

            if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_FactoryReset__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvFactoryReset()))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for FactoryReset returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PHal::Msg_EnableSensorNotifications__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PHal::Msg_EnableSensorNotifications");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PHal::Msg_EnableSensorNotifications*>((&(__msg))))->Log("[PHalParent] Received ", stderr);
            }

            void* __iter = 0;
            SensorType aSensor;

            if ((!(Read((&(aSensor)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_EnableSensorNotifications__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvEnableSensorNotifications(aSensor)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for EnableSensorNotifications returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PHal::Msg_DisableSensorNotifications__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PHal::Msg_DisableSensorNotifications");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PHal::Msg_DisableSensorNotifications*>((&(__msg))))->Log("[PHalParent] Received ", stderr);
            }

            void* __iter = 0;
            SensorType aSensor;

            if ((!(Read((&(aSensor)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_DisableSensorNotifications__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvDisableSensorNotifications(aSensor)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for DisableSensorNotifications returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PHal::Msg___delete____ID:
        {
            (const_cast<Message&>(__msg)).set_name("PHal::Msg___delete__");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PHal::Msg___delete__*>((&(__msg))))->Log("[PHalParent] Received ", stderr);
            }

            void* __iter = 0;
            PHalParent* actor;

            if ((!(Read((&(actor)), (&(__msg)), (&(__iter)), false)))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg___delete____ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(Recv__delete__()))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for __delete__ returned error code");
                return MsgProcessingError;
            }

            (actor)->DestroySubtree(Deletion);
            (actor)->DeallocSubtree();
            ((actor)->mManager)->RemoveManagee(PHalMsgStart, actor);


            return MsgProcessed;
        }
    default:
        {
            return MsgNotKnown;
        }
    }
}

PHalParent::Result
PHalParent::OnMessageReceived(
        const Message& __msg,
        Message*& __reply)
{
    switch ((__msg).type()) {
    case PHal::Msg_GetCurrentBatteryInformation__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PHal::Msg_GetCurrentBatteryInformation");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PHal::Msg_GetCurrentBatteryInformation*>((&(__msg))))->Log("[PHalParent] Received ", stderr);
            }

            if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_GetCurrentBatteryInformation__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            BatteryInformation aBatteryInfo;
            int32_t __id = mId;
            if ((!(RecvGetCurrentBatteryInformation((&(aBatteryInfo)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for GetCurrentBatteryInformation returned error code");
                return MsgProcessingError;
            }

            __reply = new PHal::Reply_GetCurrentBatteryInformation();

            Write(aBatteryInfo, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_sync();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PHal::Reply_GetCurrentBatteryInformation*>(__reply))->Log("[PHalParent] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    case PHal::Msg_GetCurrentNetworkInformation__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PHal::Msg_GetCurrentNetworkInformation");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PHal::Msg_GetCurrentNetworkInformation*>((&(__msg))))->Log("[PHalParent] Received ", stderr);
            }

            if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_GetCurrentNetworkInformation__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            NetworkInformation aNetworkInfo;
            int32_t __id = mId;
            if ((!(RecvGetCurrentNetworkInformation((&(aNetworkInfo)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for GetCurrentNetworkInformation returned error code");
                return MsgProcessingError;
            }

            __reply = new PHal::Reply_GetCurrentNetworkInformation();

            Write(aNetworkInfo, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_sync();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PHal::Reply_GetCurrentNetworkInformation*>(__reply))->Log("[PHalParent] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    case PHal::Msg_GetScreenEnabled__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PHal::Msg_GetScreenEnabled");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PHal::Msg_GetScreenEnabled*>((&(__msg))))->Log("[PHalParent] Received ", stderr);
            }

            if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_GetScreenEnabled__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            bool enabled;
            int32_t __id = mId;
            if ((!(RecvGetScreenEnabled((&(enabled)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for GetScreenEnabled returned error code");
                return MsgProcessingError;
            }

            __reply = new PHal::Reply_GetScreenEnabled();

            Write(enabled, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_sync();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PHal::Reply_GetScreenEnabled*>(__reply))->Log("[PHalParent] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    case PHal::Msg_GetCpuSleepAllowed__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PHal::Msg_GetCpuSleepAllowed");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PHal::Msg_GetCpuSleepAllowed*>((&(__msg))))->Log("[PHalParent] Received ", stderr);
            }

            if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_GetCpuSleepAllowed__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            bool allowed;
            int32_t __id = mId;
            if ((!(RecvGetCpuSleepAllowed((&(allowed)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for GetCpuSleepAllowed returned error code");
                return MsgProcessingError;
            }

            __reply = new PHal::Reply_GetCpuSleepAllowed();

            Write(allowed, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_sync();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PHal::Reply_GetCpuSleepAllowed*>(__reply))->Log("[PHalParent] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    case PHal::Msg_GetScreenBrightness__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PHal::Msg_GetScreenBrightness");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PHal::Msg_GetScreenBrightness*>((&(__msg))))->Log("[PHalParent] Received ", stderr);
            }

            if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_GetScreenBrightness__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            double brightness;
            int32_t __id = mId;
            if ((!(RecvGetScreenBrightness((&(brightness)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for GetScreenBrightness returned error code");
                return MsgProcessingError;
            }

            __reply = new PHal::Reply_GetScreenBrightness();

            Write(brightness, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_sync();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PHal::Reply_GetScreenBrightness*>(__reply))->Log("[PHalParent] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    case PHal::Msg_GetTimezone__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PHal::Msg_GetTimezone");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PHal::Msg_GetTimezone*>((&(__msg))))->Log("[PHalParent] Received ", stderr);
            }

            if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_GetTimezone__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            nsCString aTimezoneSpec;
            int32_t __id = mId;
            if ((!(RecvGetTimezone((&(aTimezoneSpec)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for GetTimezone returned error code");
                return MsgProcessingError;
            }

            __reply = new PHal::Reply_GetTimezone();

            Write(aTimezoneSpec, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_sync();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PHal::Reply_GetTimezone*>(__reply))->Log("[PHalParent] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    case PHal::Msg_SetLight__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PHal::Msg_SetLight");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PHal::Msg_SetLight*>((&(__msg))))->Log("[PHalParent] Received ", stderr);
            }

            void* __iter = 0;
            LightType light;
            LightConfiguration aConfig;

            if ((!(Read((&(light)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(aConfig)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_SetLight__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            bool status;
            int32_t __id = mId;
            if ((!(RecvSetLight(light, aConfig, (&(status)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for SetLight returned error code");
                return MsgProcessingError;
            }

            __reply = new PHal::Reply_SetLight();

            Write(status, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_sync();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PHal::Reply_SetLight*>(__reply))->Log("[PHalParent] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    case PHal::Msg_GetLight__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PHal::Msg_GetLight");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PHal::Msg_GetLight*>((&(__msg))))->Log("[PHalParent] Received ", stderr);
            }

            void* __iter = 0;
            LightType light;

            if ((!(Read((&(light)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_GetLight__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            LightConfiguration aConfig;
            bool status;
            int32_t __id = mId;
            if ((!(RecvGetLight(light, (&(aConfig)), (&(status)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for GetLight returned error code");
                return MsgProcessingError;
            }

            __reply = new PHal::Reply_GetLight();

            Write(aConfig, __reply);
            Write(status, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_sync();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PHal::Reply_GetLight*>(__reply))->Log("[PHalParent] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    case PHal::Msg_GetWakeLockInfo__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PHal::Msg_GetWakeLockInfo");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PHal::Msg_GetWakeLockInfo*>((&(__msg))))->Log("[PHalParent] Received ", stderr);
            }

            void* __iter = 0;
            nsString aTopic;

            if ((!(Read((&(aTopic)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_GetWakeLockInfo__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            WakeLockInformation aWakeLockInfo;
            int32_t __id = mId;
            if ((!(RecvGetWakeLockInfo(aTopic, (&(aWakeLockInfo)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for GetWakeLockInfo returned error code");
                return MsgProcessingError;
            }

            __reply = new PHal::Reply_GetWakeLockInfo();

            Write(aWakeLockInfo, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_sync();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PHal::Reply_GetWakeLockInfo*>(__reply))->Log("[PHalParent] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    case PHal::Msg_GetCurrentScreenConfiguration__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PHal::Msg_GetCurrentScreenConfiguration");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PHal::Msg_GetCurrentScreenConfiguration*>((&(__msg))))->Log("[PHalParent] Received ", stderr);
            }

            if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_GetCurrentScreenConfiguration__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            ScreenConfiguration aScreenConfiguration;
            int32_t __id = mId;
            if ((!(RecvGetCurrentScreenConfiguration((&(aScreenConfiguration)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for GetCurrentScreenConfiguration returned error code");
                return MsgProcessingError;
            }

            __reply = new PHal::Reply_GetCurrentScreenConfiguration();

            Write(aScreenConfiguration, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_sync();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PHal::Reply_GetCurrentScreenConfiguration*>(__reply))->Log("[PHalParent] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    case PHal::Msg_LockScreenOrientation__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PHal::Msg_LockScreenOrientation");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PHal::Msg_LockScreenOrientation*>((&(__msg))))->Log("[PHalParent] Received ", stderr);
            }

            void* __iter = 0;
            ScreenOrientation aOrientation;

            if ((!(Read((&(aOrientation)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_LockScreenOrientation__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            bool allowed;
            int32_t __id = mId;
            if ((!(RecvLockScreenOrientation(aOrientation, (&(allowed)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for LockScreenOrientation returned error code");
                return MsgProcessingError;
            }

            __reply = new PHal::Reply_LockScreenOrientation();

            Write(allowed, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_sync();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PHal::Reply_LockScreenOrientation*>(__reply))->Log("[PHalParent] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    case PHal::Msg_GetCurrentSwitchState__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PHal::Msg_GetCurrentSwitchState");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PHal::Msg_GetCurrentSwitchState*>((&(__msg))))->Log("[PHalParent] Received ", stderr);
            }

            void* __iter = 0;
            SwitchDevice aDevice;

            if ((!(Read((&(aDevice)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_GetCurrentSwitchState__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            SwitchState aState;
            int32_t __id = mId;
            if ((!(RecvGetCurrentSwitchState(aDevice, (&(aState)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for GetCurrentSwitchState returned error code");
                return MsgProcessingError;
            }

            __reply = new PHal::Reply_GetCurrentSwitchState();

            Write(aState, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_sync();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PHal::Reply_GetCurrentSwitchState*>(__reply))->Log("[PHalParent] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    default:
        {
            return MsgNotKnown;
        }
    }
}

PHalParent::Result
PHalParent::OnCallReceived(
        const Message& __msg,
        Message*& __reply)
{
    return MsgNotKnown;
}

void
PHalParent::OnProcessingError(Result code)
{
    NS_RUNTIMEABORT("`OnProcessingError' called on non-toplevel actor");
}

int32_t
PHalParent::GetProtocolTypeId()
{
    return PHalMsgStart;
}

bool
PHalParent::OnReplyTimeout()
{
    NS_RUNTIMEABORT("`OnReplyTimeout' called on non-toplevel actor");
    return false;
}

void
PHalParent::OnChannelClose()
{
    NS_RUNTIMEABORT("`OnClose' called on non-toplevel actor");
}

void
PHalParent::OnChannelError()
{
    NS_RUNTIMEABORT("`OnError' called on non-toplevel actor");
}

void
PHalParent::OnChannelConnected(int32_t pid)
{
    NS_RUNTIMEABORT("'OnConnected' called on non-toplevel actor");
}

bool
PHalParent::AllocShmem(
        size_t aSize,
        Shmem::SharedMemory::SharedMemoryType aType,
        Shmem* aMem)
{
    Shmem::id_t aId;
    nsAutoPtr<Shmem::SharedMemory> rawmem(CreateSharedMemory(aSize, aType, false, (&(aId))));
    if ((!(rawmem))) {
        return false;
    }

    (*(aMem)) = Shmem(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(), (rawmem).forget(), aId);
    return true;
}

bool
PHalParent::AllocUnsafeShmem(
        size_t aSize,
        Shmem::SharedMemory::SharedMemoryType aType,
        Shmem* aMem)
{
    Shmem::id_t aId;
    nsAutoPtr<Shmem::SharedMemory> rawmem(CreateSharedMemory(aSize, aType, true, (&(aId))));
    if ((!(rawmem))) {
        return false;
    }

    (*(aMem)) = Shmem(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(), (rawmem).forget(), aId);
    return true;
}

bool
PHalParent::AdoptShmem(
        Shmem& aMem,
        Shmem* aOutMem)
{
    Shmem::SharedMemory* rawmem = (aMem).Segment(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead());
    if (((!(rawmem))) || (IsTrackingSharedMemory(rawmem))) {
        NS_RUNTIMEABORT("bad Shmem");
    }

    Shmem::id_t aId;
    if ((!(AdoptSharedMemory(rawmem, (&(aId)))))) {
        return false;
    }

    (*(aOutMem)) = Shmem(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(), rawmem, aId);
    return true;
}

bool
PHalParent::DeallocShmem(Shmem& aMem)
{
    bool ok = DestroySharedMemory(aMem);
    (aMem).forget(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead());
    return ok;
}

void
PHalParent::FatalError(const char* const msg) const
{
    // Virtual method to prevent inlining.
    // This give us better error reporting.
    // See bug 589371

    NS_ERROR("IPDL error:");
    NS_ERROR(msg);
    mozilla::ipc::ProtocolErrorBreakpoint(msg);

    NS_ERROR("[PHalParent] killing child side as a result");

    if ((!(base::KillProcess(OtherProcess(), base::PROCESS_END_KILLED_BY_USER, false)))) {
        NS_ERROR("  may have failed to kill child!");
    }
}

void
PHalParent::DestroySubtree(ActorDestroyReason why)
{
    // Unregister from our manager.
    Unregister(mId);
    mId = 1;

    // Finally, destroy "us".
    ActorDestroy(why);
}

void
PHalParent::DeallocSubtree()
{
}

void
PHalParent::Write(
        const SwitchEvent& __v,
        Message* __msg)
{
    Write((__v).device(), __msg);
    Write((__v).status(), __msg);
}

bool
PHalParent::Read(
        SwitchEvent* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->device())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->status())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PHalParent::Write(
        const LightConfiguration& __v,
        Message* __msg)
{
    Write((__v).light(), __msg);
    Write((__v).mode(), __msg);
    Write((__v).flash(), __msg);
    Write((__v).flashOnMS(), __msg);
    Write((__v).flashOffMS(), __msg);
    Write((__v).color(), __msg);
}

bool
PHalParent::Read(
        LightConfiguration* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->light())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->mode())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->flash())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->flashOnMS())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->flashOffMS())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->color())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PHalParent::Write(
        PBrowserParent* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PHalParent::Read(
        PBrowserParent** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PHal");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PBrowser");
        return false;
    }

    if ((PBrowserMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PBrowser has different type");
        return false;
    }

    (*(__v)) = static_cast<PBrowserParent*>(listener);
    return true;
}

void
PHalParent::Write(
        const ScreenConfiguration& __v,
        Message* __msg)
{
    Write((__v).rect(), __msg);
    Write((__v).orientation(), __msg);
    Write((__v).colorDepth(), __msg);
    Write((__v).pixelDepth(), __msg);
}

bool
PHalParent::Read(
        ScreenConfiguration* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->rect())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->orientation())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->colorDepth())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->pixelDepth())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PHalParent::Write(
        const BatteryInformation& __v,
        Message* __msg)
{
    Write((__v).level(), __msg);
    Write((__v).charging(), __msg);
    Write((__v).remainingTime(), __msg);
}

bool
PHalParent::Read(
        BatteryInformation* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->level())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->charging())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->remainingTime())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PHalParent::Write(
        const WakeLockInformation& __v,
        Message* __msg)
{
    Write((__v).numLocks(), __msg);
    Write((__v).numHidden(), __msg);
    Write((__v).topic(), __msg);
}

bool
PHalParent::Read(
        WakeLockInformation* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->numLocks())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->numHidden())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->topic())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PHalParent::Write(
        const NetworkInformation& __v,
        Message* __msg)
{
    Write((__v).bandwidth(), __msg);
    Write((__v).canBeMetered(), __msg);
}

bool
PHalParent::Read(
        NetworkInformation* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->bandwidth())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->canBeMetered())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PHalParent::Write(
        const SystemTimezoneChangeInformation& __v,
        Message* __msg)
{
    Write((__v).oldTimezoneOffsetMinutes(), __msg);
    Write((__v).newTimezoneOffsetMinutes(), __msg);
}

bool
PHalParent::Read(
        SystemTimezoneChangeInformation* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->oldTimezoneOffsetMinutes())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->newTimezoneOffsetMinutes())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PHalParent::Write(
        const SensorData& __v,
        Message* __msg)
{
    Write((__v).sensor(), __msg);
    Write((__v).timestamp(), __msg);
    Write((__v).values(), __msg);
    Write((__v).accuracy(), __msg);
}

bool
PHalParent::Read(
        SensorData* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->sensor())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->timestamp())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->values())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->accuracy())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PHalParent::Write(
        PHalParent* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PHalParent::Read(
        PHalParent** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PHal");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PHal");
        return false;
    }

    if ((PHalMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PHal has different type");
        return false;
    }

    (*(__v)) = static_cast<PHalParent*>(listener);
    return true;
}



} // namespace hal_sandbox
} // namespace mozilla
