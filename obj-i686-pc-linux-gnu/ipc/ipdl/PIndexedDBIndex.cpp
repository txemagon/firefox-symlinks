//
// Automatically generated by ipdlc.
// Edit at your own risk
//


#include "mozilla/dom/indexedDB/PIndexedDBIndex.h"

namespace mozilla {
namespace dom {
namespace indexedDB {
namespace PIndexedDBIndex {

bool
Transition(
        State from,
        mozilla::ipc::Trigger trigger,
        State* next)
{
    switch (from) {
    case __Null:
    case __Error:
        if ((Msg___delete____ID) == ((trigger).mMsg)) {
            (*(next)) = __Dead;
            return true;
        }
        return (__Null) == (from);
    case __Dead:
        NS_RUNTIMEABORT("__delete__()d actor");
        return false;
    case __Dying:
        NS_RUNTIMEABORT("__delete__()d (and unexpectedly dying) actor");
        return false;
    default:
        NS_RUNTIMEABORT("corrupted actor state");
        return false;
    }
    (*(next)) = __Error;
    return false;
}

} // namespace PIndexedDBIndex
} // namespace indexedDB
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct KeyRange|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
namespace ipc {
namespace FIXME_Bug_521898_index {
KeyRange::KeyRange()
{
    Init();
}

KeyRange::~KeyRange()
{
}

bool
KeyRange::operator==(const KeyRange& _o) const
{
    if ((!((lower()) == ((_o).lower())))) {
        return false;
    }
    if ((!((upper()) == ((_o).upper())))) {
        return false;
    }
    if ((!((lowerOpen()) == ((_o).lowerOpen())))) {
        return false;
    }
    if ((!((upperOpen()) == ((_o).upperOpen())))) {
        return false;
    }
    if ((!((isOnly()) == ((_o).isOnly())))) {
        return false;
    }
    return true;
}

void
KeyRange::Init()
{
}

void
KeyRange::Assign(
        const Key& _lower,
        const Key& _upper,
        const bool& _lowerOpen,
        const bool& _upperOpen,
        const bool& _isOnly)
{
    lower_ = _lower;
    upper_ = _upper;
    lowerOpen_ = _lowerOpen;
    upperOpen_ = _upperOpen;
    isOnly_ = _isOnly;
}

} // namespace FIXME_Bug_521898_index
} // namespace ipc
} // namespace indexedDB
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |union OptionalKeyRange|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
namespace ipc {
namespace FIXME_Bug_521898_index {
bool
OptionalKeyRange::MaybeDestroy(Type aNewType)
{
    if ((mType) == (T__None)) {
        return true;
    }
    if ((mType) == (aNewType)) {
        return false;
    }
    switch (mType) {
    case TKeyRange:
        {
            (ptr_KeyRange())->~KeyRange__tdef();
            break;
        }
    case Tvoid_t:
        {
            (ptr_void_t())->~void_t__tdef();
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("not reached");
            break;
        }
    }
    return true;
}

OptionalKeyRange::OptionalKeyRange(const KeyRange& aOther)
{
    new (ptr_KeyRange()) KeyRange(aOther);
    mType = TKeyRange;
}

OptionalKeyRange::OptionalKeyRange(const void_t& aOther)
{
    new (ptr_void_t()) void_t(aOther);
    mType = Tvoid_t;
}

OptionalKeyRange::OptionalKeyRange(const OptionalKeyRange& aOther)
{
    (aOther).AssertSanity();
    switch ((aOther).type()) {
    case TKeyRange:
        {
            new (ptr_KeyRange()) KeyRange((aOther).get_KeyRange());
            break;
        }
    case Tvoid_t:
        {
            new (ptr_void_t()) void_t((aOther).get_void_t());
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return;
        }
    }
    mType = (aOther).type();
}

OptionalKeyRange::~OptionalKeyRange()
{
    MaybeDestroy(T__None);
}

OptionalKeyRange&
OptionalKeyRange::operator=(const KeyRange& aRhs)
{
    if (MaybeDestroy(TKeyRange)) {
        new (ptr_KeyRange()) KeyRange;
    }
    (*(ptr_KeyRange())) = aRhs;
    mType = TKeyRange;
    return (*(this));
}

OptionalKeyRange&
OptionalKeyRange::operator=(const void_t& aRhs)
{
    if (MaybeDestroy(Tvoid_t)) {
        new (ptr_void_t()) void_t;
    }
    (*(ptr_void_t())) = aRhs;
    mType = Tvoid_t;
    return (*(this));
}

OptionalKeyRange&
OptionalKeyRange::operator=(const OptionalKeyRange& aRhs)
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case TKeyRange:
        {
            if (MaybeDestroy(t)) {
                new (ptr_KeyRange()) KeyRange;
            }
            (*(ptr_KeyRange())) = (aRhs).get_KeyRange();
            break;
        }
    case Tvoid_t:
        {
            if (MaybeDestroy(t)) {
                new (ptr_void_t()) void_t;
            }
            (*(ptr_void_t())) = (aRhs).get_void_t();
            break;
        }
    case T__None:
        {
            MaybeDestroy(t);
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            break;
        }
    }
    mType = t;
    return (*(this));
}

bool
OptionalKeyRange::operator==(const KeyRange& aRhs) const
{
    return (get_KeyRange()) == (aRhs);
}

bool
OptionalKeyRange::operator==(const void_t& aRhs) const
{
    return (get_void_t()) == (aRhs);
}

bool
OptionalKeyRange::operator==(const OptionalKeyRange& aRhs) const
{
    if ((type()) != ((aRhs).type())) {
        return false;
    }

    switch (type()) {
    case TKeyRange:
        {
            return (get_KeyRange()) == ((aRhs).get_KeyRange());
        }
    case Tvoid_t:
        {
            return (get_void_t()) == ((aRhs).get_void_t());
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return false;
        }
    }
}

} // namespace FIXME_Bug_521898_index
} // namespace ipc
} // namespace indexedDB
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct GetParams|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
namespace ipc {
namespace FIXME_Bug_521898_index {
GetParams::GetParams()
{
    Init();
}

GetParams::~GetParams()
{
}

bool
GetParams::operator==(const GetParams& _o) const
{
    if ((!((keyRange()) == ((_o).keyRange())))) {
        return false;
    }
    return true;
}

void
GetParams::Init()
{
}

void
GetParams::Assign(const KeyRange& _keyRange)
{
    keyRange_ = _keyRange;
}

} // namespace FIXME_Bug_521898_index
} // namespace ipc
} // namespace indexedDB
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct GetAllParams|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
namespace ipc {
namespace FIXME_Bug_521898_index {
GetAllParams::GetAllParams()
{
    Init();
}

GetAllParams::~GetAllParams()
{
}

bool
GetAllParams::operator==(const GetAllParams& _o) const
{
    if ((!((optionalKeyRange()) == ((_o).optionalKeyRange())))) {
        return false;
    }
    if ((!((limit()) == ((_o).limit())))) {
        return false;
    }
    return true;
}

void
GetAllParams::Init()
{
}

void
GetAllParams::Assign(
        const OptionalKeyRange& _optionalKeyRange,
        const uint32_t& _limit)
{
    optionalKeyRange_ = _optionalKeyRange;
    limit_ = _limit;
}

} // namespace FIXME_Bug_521898_index
} // namespace ipc
} // namespace indexedDB
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct CountParams|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
namespace ipc {
namespace FIXME_Bug_521898_index {
CountParams::CountParams()
{
    Init();
}

CountParams::~CountParams()
{
}

bool
CountParams::operator==(const CountParams& _o) const
{
    if ((!((optionalKeyRange()) == ((_o).optionalKeyRange())))) {
        return false;
    }
    return true;
}

void
CountParams::Init()
{
}

void
CountParams::Assign(const OptionalKeyRange& _optionalKeyRange)
{
    optionalKeyRange_ = _optionalKeyRange;
}

} // namespace FIXME_Bug_521898_index
} // namespace ipc
} // namespace indexedDB
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct OpenCursorParams|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
namespace ipc {
namespace FIXME_Bug_521898_index {
OpenCursorParams::OpenCursorParams()
{
    Init();
}

OpenCursorParams::~OpenCursorParams()
{
}

bool
OpenCursorParams::operator==(const OpenCursorParams& _o) const
{
    if ((!((optionalKeyRange()) == ((_o).optionalKeyRange())))) {
        return false;
    }
    if ((!((direction()) == ((_o).direction())))) {
        return false;
    }
    return true;
}

void
OpenCursorParams::Init()
{
}

void
OpenCursorParams::Assign(
        const OptionalKeyRange& _optionalKeyRange,
        const Direction& _direction)
{
    optionalKeyRange_ = _optionalKeyRange;
    direction_ = _direction;
}

} // namespace FIXME_Bug_521898_index
} // namespace ipc
} // namespace indexedDB
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct GetKeyParams|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
namespace ipc {
GetKeyParams::GetKeyParams()
{
    Init();
}

GetKeyParams::~GetKeyParams()
{
}

bool
GetKeyParams::operator==(const GetKeyParams& _o) const
{
    if ((!((keyRange()) == ((_o).keyRange())))) {
        return false;
    }
    return true;
}

void
GetKeyParams::Init()
{
}

void
GetKeyParams::Assign(const KeyRange& _keyRange)
{
    keyRange_ = _keyRange;
}

} // namespace ipc
} // namespace indexedDB
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct GetAllKeysParams|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
namespace ipc {
GetAllKeysParams::GetAllKeysParams()
{
    Init();
}

GetAllKeysParams::~GetAllKeysParams()
{
}

bool
GetAllKeysParams::operator==(const GetAllKeysParams& _o) const
{
    if ((!((optionalKeyRange()) == ((_o).optionalKeyRange())))) {
        return false;
    }
    if ((!((limit()) == ((_o).limit())))) {
        return false;
    }
    return true;
}

void
GetAllKeysParams::Init()
{
}

void
GetAllKeysParams::Assign(
        const OptionalKeyRange& _optionalKeyRange,
        const uint32_t& _limit)
{
    optionalKeyRange_ = _optionalKeyRange;
    limit_ = _limit;
}

} // namespace ipc
} // namespace indexedDB
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct OpenKeyCursorParams|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
namespace ipc {
OpenKeyCursorParams::OpenKeyCursorParams()
{
    Init();
}

OpenKeyCursorParams::~OpenKeyCursorParams()
{
}

bool
OpenKeyCursorParams::operator==(const OpenKeyCursorParams& _o) const
{
    if ((!((optionalKeyRange()) == ((_o).optionalKeyRange())))) {
        return false;
    }
    if ((!((direction()) == ((_o).direction())))) {
        return false;
    }
    return true;
}

void
OpenKeyCursorParams::Init()
{
}

void
OpenKeyCursorParams::Assign(
        const OptionalKeyRange& _optionalKeyRange,
        const Direction& _direction)
{
    optionalKeyRange_ = _optionalKeyRange;
    direction_ = _direction;
}

} // namespace ipc
} // namespace indexedDB
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |union IndexRequestParams|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
namespace ipc {
bool
IndexRequestParams::MaybeDestroy(Type aNewType)
{
    if ((mType) == (T__None)) {
        return true;
    }
    if ((mType) == (aNewType)) {
        return false;
    }
    switch (mType) {
    case TGetParams:
        {
            (ptr_GetParams())->~GetParams__tdef();
            break;
        }
    case TGetKeyParams:
        {
            (ptr_GetKeyParams())->~GetKeyParams__tdef();
            break;
        }
    case TGetAllParams:
        {
            (ptr_GetAllParams())->~GetAllParams__tdef();
            break;
        }
    case TGetAllKeysParams:
        {
            (ptr_GetAllKeysParams())->~GetAllKeysParams__tdef();
            break;
        }
    case TCountParams:
        {
            (ptr_CountParams())->~CountParams__tdef();
            break;
        }
    case TOpenCursorParams:
        {
            (ptr_OpenCursorParams())->~OpenCursorParams__tdef();
            break;
        }
    case TOpenKeyCursorParams:
        {
            (ptr_OpenKeyCursorParams())->~OpenKeyCursorParams__tdef();
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("not reached");
            break;
        }
    }
    return true;
}

IndexRequestParams::IndexRequestParams(const GetParams& aOther)
{
    new (ptr_GetParams()) GetParams(aOther);
    mType = TGetParams;
}

IndexRequestParams::IndexRequestParams(const GetKeyParams& aOther)
{
    new (ptr_GetKeyParams()) GetKeyParams(aOther);
    mType = TGetKeyParams;
}

IndexRequestParams::IndexRequestParams(const GetAllParams& aOther)
{
    new (ptr_GetAllParams()) GetAllParams(aOther);
    mType = TGetAllParams;
}

IndexRequestParams::IndexRequestParams(const GetAllKeysParams& aOther)
{
    new (ptr_GetAllKeysParams()) GetAllKeysParams(aOther);
    mType = TGetAllKeysParams;
}

IndexRequestParams::IndexRequestParams(const CountParams& aOther)
{
    new (ptr_CountParams()) CountParams(aOther);
    mType = TCountParams;
}

IndexRequestParams::IndexRequestParams(const OpenCursorParams& aOther)
{
    new (ptr_OpenCursorParams()) OpenCursorParams(aOther);
    mType = TOpenCursorParams;
}

IndexRequestParams::IndexRequestParams(const OpenKeyCursorParams& aOther)
{
    new (ptr_OpenKeyCursorParams()) OpenKeyCursorParams(aOther);
    mType = TOpenKeyCursorParams;
}

IndexRequestParams::IndexRequestParams(const IndexRequestParams& aOther)
{
    (aOther).AssertSanity();
    switch ((aOther).type()) {
    case TGetParams:
        {
            new (ptr_GetParams()) GetParams((aOther).get_GetParams());
            break;
        }
    case TGetKeyParams:
        {
            new (ptr_GetKeyParams()) GetKeyParams((aOther).get_GetKeyParams());
            break;
        }
    case TGetAllParams:
        {
            new (ptr_GetAllParams()) GetAllParams((aOther).get_GetAllParams());
            break;
        }
    case TGetAllKeysParams:
        {
            new (ptr_GetAllKeysParams()) GetAllKeysParams((aOther).get_GetAllKeysParams());
            break;
        }
    case TCountParams:
        {
            new (ptr_CountParams()) CountParams((aOther).get_CountParams());
            break;
        }
    case TOpenCursorParams:
        {
            new (ptr_OpenCursorParams()) OpenCursorParams((aOther).get_OpenCursorParams());
            break;
        }
    case TOpenKeyCursorParams:
        {
            new (ptr_OpenKeyCursorParams()) OpenKeyCursorParams((aOther).get_OpenKeyCursorParams());
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return;
        }
    }
    mType = (aOther).type();
}

IndexRequestParams::~IndexRequestParams()
{
    MaybeDestroy(T__None);
}

IndexRequestParams&
IndexRequestParams::operator=(const GetParams& aRhs)
{
    if (MaybeDestroy(TGetParams)) {
        new (ptr_GetParams()) GetParams;
    }
    (*(ptr_GetParams())) = aRhs;
    mType = TGetParams;
    return (*(this));
}

IndexRequestParams&
IndexRequestParams::operator=(const GetKeyParams& aRhs)
{
    if (MaybeDestroy(TGetKeyParams)) {
        new (ptr_GetKeyParams()) GetKeyParams;
    }
    (*(ptr_GetKeyParams())) = aRhs;
    mType = TGetKeyParams;
    return (*(this));
}

IndexRequestParams&
IndexRequestParams::operator=(const GetAllParams& aRhs)
{
    if (MaybeDestroy(TGetAllParams)) {
        new (ptr_GetAllParams()) GetAllParams;
    }
    (*(ptr_GetAllParams())) = aRhs;
    mType = TGetAllParams;
    return (*(this));
}

IndexRequestParams&
IndexRequestParams::operator=(const GetAllKeysParams& aRhs)
{
    if (MaybeDestroy(TGetAllKeysParams)) {
        new (ptr_GetAllKeysParams()) GetAllKeysParams;
    }
    (*(ptr_GetAllKeysParams())) = aRhs;
    mType = TGetAllKeysParams;
    return (*(this));
}

IndexRequestParams&
IndexRequestParams::operator=(const CountParams& aRhs)
{
    if (MaybeDestroy(TCountParams)) {
        new (ptr_CountParams()) CountParams;
    }
    (*(ptr_CountParams())) = aRhs;
    mType = TCountParams;
    return (*(this));
}

IndexRequestParams&
IndexRequestParams::operator=(const OpenCursorParams& aRhs)
{
    if (MaybeDestroy(TOpenCursorParams)) {
        new (ptr_OpenCursorParams()) OpenCursorParams;
    }
    (*(ptr_OpenCursorParams())) = aRhs;
    mType = TOpenCursorParams;
    return (*(this));
}

IndexRequestParams&
IndexRequestParams::operator=(const OpenKeyCursorParams& aRhs)
{
    if (MaybeDestroy(TOpenKeyCursorParams)) {
        new (ptr_OpenKeyCursorParams()) OpenKeyCursorParams;
    }
    (*(ptr_OpenKeyCursorParams())) = aRhs;
    mType = TOpenKeyCursorParams;
    return (*(this));
}

IndexRequestParams&
IndexRequestParams::operator=(const IndexRequestParams& aRhs)
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case TGetParams:
        {
            if (MaybeDestroy(t)) {
                new (ptr_GetParams()) GetParams;
            }
            (*(ptr_GetParams())) = (aRhs).get_GetParams();
            break;
        }
    case TGetKeyParams:
        {
            if (MaybeDestroy(t)) {
                new (ptr_GetKeyParams()) GetKeyParams;
            }
            (*(ptr_GetKeyParams())) = (aRhs).get_GetKeyParams();
            break;
        }
    case TGetAllParams:
        {
            if (MaybeDestroy(t)) {
                new (ptr_GetAllParams()) GetAllParams;
            }
            (*(ptr_GetAllParams())) = (aRhs).get_GetAllParams();
            break;
        }
    case TGetAllKeysParams:
        {
            if (MaybeDestroy(t)) {
                new (ptr_GetAllKeysParams()) GetAllKeysParams;
            }
            (*(ptr_GetAllKeysParams())) = (aRhs).get_GetAllKeysParams();
            break;
        }
    case TCountParams:
        {
            if (MaybeDestroy(t)) {
                new (ptr_CountParams()) CountParams;
            }
            (*(ptr_CountParams())) = (aRhs).get_CountParams();
            break;
        }
    case TOpenCursorParams:
        {
            if (MaybeDestroy(t)) {
                new (ptr_OpenCursorParams()) OpenCursorParams;
            }
            (*(ptr_OpenCursorParams())) = (aRhs).get_OpenCursorParams();
            break;
        }
    case TOpenKeyCursorParams:
        {
            if (MaybeDestroy(t)) {
                new (ptr_OpenKeyCursorParams()) OpenKeyCursorParams;
            }
            (*(ptr_OpenKeyCursorParams())) = (aRhs).get_OpenKeyCursorParams();
            break;
        }
    case T__None:
        {
            MaybeDestroy(t);
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            break;
        }
    }
    mType = t;
    return (*(this));
}

bool
IndexRequestParams::operator==(const GetParams& aRhs) const
{
    return (get_GetParams()) == (aRhs);
}

bool
IndexRequestParams::operator==(const GetKeyParams& aRhs) const
{
    return (get_GetKeyParams()) == (aRhs);
}

bool
IndexRequestParams::operator==(const GetAllParams& aRhs) const
{
    return (get_GetAllParams()) == (aRhs);
}

bool
IndexRequestParams::operator==(const GetAllKeysParams& aRhs) const
{
    return (get_GetAllKeysParams()) == (aRhs);
}

bool
IndexRequestParams::operator==(const CountParams& aRhs) const
{
    return (get_CountParams()) == (aRhs);
}

bool
IndexRequestParams::operator==(const OpenCursorParams& aRhs) const
{
    return (get_OpenCursorParams()) == (aRhs);
}

bool
IndexRequestParams::operator==(const OpenKeyCursorParams& aRhs) const
{
    return (get_OpenKeyCursorParams()) == (aRhs);
}

bool
IndexRequestParams::operator==(const IndexRequestParams& aRhs) const
{
    if ((type()) != ((aRhs).type())) {
        return false;
    }

    switch (type()) {
    case TGetParams:
        {
            return (get_GetParams()) == ((aRhs).get_GetParams());
        }
    case TGetKeyParams:
        {
            return (get_GetKeyParams()) == ((aRhs).get_GetKeyParams());
        }
    case TGetAllParams:
        {
            return (get_GetAllParams()) == ((aRhs).get_GetAllParams());
        }
    case TGetAllKeysParams:
        {
            return (get_GetAllKeysParams()) == ((aRhs).get_GetAllKeysParams());
        }
    case TCountParams:
        {
            return (get_CountParams()) == ((aRhs).get_CountParams());
        }
    case TOpenCursorParams:
        {
            return (get_OpenCursorParams()) == ((aRhs).get_OpenCursorParams());
        }
    case TOpenKeyCursorParams:
        {
            return (get_OpenKeyCursorParams()) == ((aRhs).get_OpenKeyCursorParams());
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return false;
        }
    }
}

} // namespace ipc
} // namespace indexedDB
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |union OptionalStructuredCloneReadInfo|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
namespace ipc {
bool
OptionalStructuredCloneReadInfo::MaybeDestroy(Type aNewType)
{
    if ((mType) == (T__None)) {
        return true;
    }
    if ((mType) == (aNewType)) {
        return false;
    }
    switch (mType) {
    case TSerializedStructuredCloneReadInfo:
        {
            (ptr_SerializedStructuredCloneReadInfo())->~SerializedStructuredCloneReadInfo__tdef();
            break;
        }
    case Tvoid_t:
        {
            (ptr_void_t())->~void_t__tdef();
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("not reached");
            break;
        }
    }
    return true;
}

OptionalStructuredCloneReadInfo::OptionalStructuredCloneReadInfo(const SerializedStructuredCloneReadInfo& aOther)
{
    new (ptr_SerializedStructuredCloneReadInfo()) SerializedStructuredCloneReadInfo(aOther);
    mType = TSerializedStructuredCloneReadInfo;
}

OptionalStructuredCloneReadInfo::OptionalStructuredCloneReadInfo(const void_t& aOther)
{
    new (ptr_void_t()) void_t(aOther);
    mType = Tvoid_t;
}

OptionalStructuredCloneReadInfo::OptionalStructuredCloneReadInfo(const OptionalStructuredCloneReadInfo& aOther)
{
    (aOther).AssertSanity();
    switch ((aOther).type()) {
    case TSerializedStructuredCloneReadInfo:
        {
            new (ptr_SerializedStructuredCloneReadInfo()) SerializedStructuredCloneReadInfo((aOther).get_SerializedStructuredCloneReadInfo());
            break;
        }
    case Tvoid_t:
        {
            new (ptr_void_t()) void_t((aOther).get_void_t());
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return;
        }
    }
    mType = (aOther).type();
}

OptionalStructuredCloneReadInfo::~OptionalStructuredCloneReadInfo()
{
    MaybeDestroy(T__None);
}

OptionalStructuredCloneReadInfo&
OptionalStructuredCloneReadInfo::operator=(const SerializedStructuredCloneReadInfo& aRhs)
{
    if (MaybeDestroy(TSerializedStructuredCloneReadInfo)) {
        new (ptr_SerializedStructuredCloneReadInfo()) SerializedStructuredCloneReadInfo;
    }
    (*(ptr_SerializedStructuredCloneReadInfo())) = aRhs;
    mType = TSerializedStructuredCloneReadInfo;
    return (*(this));
}

OptionalStructuredCloneReadInfo&
OptionalStructuredCloneReadInfo::operator=(const void_t& aRhs)
{
    if (MaybeDestroy(Tvoid_t)) {
        new (ptr_void_t()) void_t;
    }
    (*(ptr_void_t())) = aRhs;
    mType = Tvoid_t;
    return (*(this));
}

OptionalStructuredCloneReadInfo&
OptionalStructuredCloneReadInfo::operator=(const OptionalStructuredCloneReadInfo& aRhs)
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case TSerializedStructuredCloneReadInfo:
        {
            if (MaybeDestroy(t)) {
                new (ptr_SerializedStructuredCloneReadInfo()) SerializedStructuredCloneReadInfo;
            }
            (*(ptr_SerializedStructuredCloneReadInfo())) = (aRhs).get_SerializedStructuredCloneReadInfo();
            break;
        }
    case Tvoid_t:
        {
            if (MaybeDestroy(t)) {
                new (ptr_void_t()) void_t;
            }
            (*(ptr_void_t())) = (aRhs).get_void_t();
            break;
        }
    case T__None:
        {
            MaybeDestroy(t);
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            break;
        }
    }
    mType = t;
    return (*(this));
}

bool
OptionalStructuredCloneReadInfo::operator==(const SerializedStructuredCloneReadInfo& aRhs) const
{
    return (get_SerializedStructuredCloneReadInfo()) == (aRhs);
}

bool
OptionalStructuredCloneReadInfo::operator==(const void_t& aRhs) const
{
    return (get_void_t()) == (aRhs);
}

bool
OptionalStructuredCloneReadInfo::operator==(const OptionalStructuredCloneReadInfo& aRhs) const
{
    if ((type()) != ((aRhs).type())) {
        return false;
    }

    switch (type()) {
    case TSerializedStructuredCloneReadInfo:
        {
            return (get_SerializedStructuredCloneReadInfo()) == ((aRhs).get_SerializedStructuredCloneReadInfo());
        }
    case Tvoid_t:
        {
            return (get_void_t()) == ((aRhs).get_void_t());
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return false;
        }
    }
}

} // namespace ipc
} // namespace indexedDB
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct IndexCursorConstructorParams|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
namespace ipc {
IndexCursorConstructorParams::IndexCursorConstructorParams()
{
    Init();
}

IndexCursorConstructorParams::~IndexCursorConstructorParams()
{
}

bool
IndexCursorConstructorParams::operator==(const IndexCursorConstructorParams& _o) const
{
    if ((!((requestParent()) == ((_o).requestParent())))) {
        return false;
    }
    if ((!((requestChild()) == ((_o).requestChild())))) {
        return false;
    }
    if ((!((direction()) == ((_o).direction())))) {
        return false;
    }
    if ((!((key()) == ((_o).key())))) {
        return false;
    }
    if ((!((objectKey()) == ((_o).objectKey())))) {
        return false;
    }
    if ((!((optionalCloneInfo()) == ((_o).optionalCloneInfo())))) {
        return false;
    }
    if ((!((blobsParent()) == ((_o).blobsParent())))) {
        return false;
    }
    if ((!((blobsChild()) == ((_o).blobsChild())))) {
        return false;
    }
    return true;
}

void
IndexCursorConstructorParams::Init()
{
    requestParent_ = 0;
    requestChild_ = 0;
}

void
IndexCursorConstructorParams::Assign(
        PIndexedDBRequestParent* _requestParent,
        PIndexedDBRequestChild* _requestChild,
        const Direction& _direction,
        const Key& _key,
        const Key& _objectKey,
        const OptionalStructuredCloneReadInfo& _optionalCloneInfo,
        const InfallibleTArray<PBlobParent*>& _blobsParent,
        const InfallibleTArray<PBlobChild*>& _blobsChild)
{
    requestParent_ = _requestParent;
    requestChild_ = _requestChild;
    direction_ = _direction;
    key_ = _key;
    objectKey_ = _objectKey;
    optionalCloneInfo_ = _optionalCloneInfo;
    blobsParent_ = _blobsParent;
    blobsChild_ = _blobsChild;
}

} // namespace ipc
} // namespace indexedDB
} // namespace dom
} // namespace mozilla
