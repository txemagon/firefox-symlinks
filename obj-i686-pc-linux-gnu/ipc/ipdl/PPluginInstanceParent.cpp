//
// Automatically generated by ipdlc.
// Edit at your own risk
//


#include "mozilla/plugins/PPluginInstanceParent.h"

#include "mozilla/plugins/PPluginBackgroundDestroyerParent.h"
#include "mozilla/plugins/PPluginModuleParent.h"
#include "mozilla/plugins/PPluginScriptableObjectParent.h"
#include "mozilla/plugins/PBrowserStreamParent.h"
#include "mozilla/plugins/PPluginStreamParent.h"
#include "mozilla/plugins/PStreamNotifyParent.h"
#include "mozilla/plugins/PPluginSurfaceParent.h"

typedef IPC::Message Message;
typedef mozilla::ipc::RPCChannel Channel;
typedef mozilla::ipc::RPCChannel::RPCListener ChannelListener;
typedef base::ProcessHandle ProcessHandle;
typedef mozilla::ipc::AsyncChannel AsyncChannel;
typedef mozilla::ipc::SharedMemory SharedMemory;
typedef mozilla::ipc::Trigger Trigger;
typedef mozilla::ipc::ActorHandle ActorHandle;
typedef mozilla::plugins::AsyncSurfaceDescriptor AsyncSurfaceDescriptor;
typedef mozilla::CrossProcessMutexHandle CrossProcessMutexHandle;
typedef mozilla::plugins::DXGISharedSurfaceHandle DXGISharedSurfaceHandle;
typedef mozilla::ipc::FileDescriptor FileDescriptor;
typedef mozilla::plugins::IOSurfaceDescriptor IOSurfaceDescriptor;
typedef mozilla::plugins::NPRemoteAsyncSurface NPRemoteAsyncSurface;
typedef mozilla::plugins::NativeWindowHandle NativeWindowHandle;
typedef mozilla::plugins::OptionalShmem OptionalShmem;
typedef mozilla::ipc::Shmem Shmem;
typedef mozilla::plugins::SurfaceDescriptor SurfaceDescriptor;
typedef mozilla::plugins::WindowsSharedMemoryHandle WindowsSharedMemoryHandle;
typedef mozilla::gfxSurfaceType gfxSurfaceType;
typedef mozilla::null_t null_t;
using mozilla::plugins::PPluginBackgroundDestroyerParent;
using mozilla::plugins::PPluginModuleParent;
using mozilla::plugins::PPluginScriptableObjectParent;
using mozilla::plugins::PBrowserStreamParent;
using mozilla::plugins::PPluginStreamParent;
using mozilla::plugins::PStreamNotifyParent;
using mozilla::plugins::PPluginSurfaceParent;

namespace mozilla {
namespace plugins {


bool
PPluginInstanceParent::AnswerPStreamNotifyConstructor(
        PStreamNotifyParent* actor,
        const nsCString& url,
        const nsCString& target,
        const bool& post,
        const nsCString& buffer,
        const bool& file,
        NPError* result)
{
    return true;
}

bool
PPluginInstanceParent::RecvPPluginSurfaceConstructor(
        PPluginSurfaceParent* actor,
        const WindowsSharedMemoryHandle& handle,
        const gfxIntSize& size,
        const bool& transparent)
{
    return true;
}

bool
PPluginInstanceParent::RecvPPluginScriptableObjectConstructor(PPluginScriptableObjectParent* actor)
{
    return true;
}

bool
PPluginInstanceParent::AnswerPPluginStreamConstructor(
        PPluginStreamParent* actor,
        const nsCString& mimeType,
        const nsCString& target,
        NPError* result)
{
    return true;
}

void
PPluginInstanceParent::ActorDestroy(ActorDestroyReason why)
{
}

PPluginInstanceParent::PPluginInstanceParent() :
    mId(0),
    mState(PPluginInstance::__Dead)
{
    MOZ_COUNT_CTOR(PPluginInstanceParent);
}

PPluginInstanceParent::~PPluginInstanceParent()
{
    MOZ_COUNT_DTOR(PPluginInstanceParent);
}

PPluginModuleParent*
PPluginInstanceParent::Manager() const
{
    return static_cast<PPluginModuleParent*>(mManager);
}

void
PPluginInstanceParent::ManagedPPluginBackgroundDestroyerParent(InfallibleTArray<PPluginBackgroundDestroyerParent*>& aArr) const
{
    aArr = mManagedPPluginBackgroundDestroyerParent;
}

const InfallibleTArray<PPluginBackgroundDestroyerParent*>&
PPluginInstanceParent::ManagedPPluginBackgroundDestroyerParent() const
{
    return mManagedPPluginBackgroundDestroyerParent;
}

void
PPluginInstanceParent::ManagedPPluginScriptableObjectParent(InfallibleTArray<PPluginScriptableObjectParent*>& aArr) const
{
    aArr = mManagedPPluginScriptableObjectParent;
}

const InfallibleTArray<PPluginScriptableObjectParent*>&
PPluginInstanceParent::ManagedPPluginScriptableObjectParent() const
{
    return mManagedPPluginScriptableObjectParent;
}

void
PPluginInstanceParent::ManagedPBrowserStreamParent(InfallibleTArray<PBrowserStreamParent*>& aArr) const
{
    aArr = mManagedPBrowserStreamParent;
}

const InfallibleTArray<PBrowserStreamParent*>&
PPluginInstanceParent::ManagedPBrowserStreamParent() const
{
    return mManagedPBrowserStreamParent;
}

void
PPluginInstanceParent::ManagedPPluginStreamParent(InfallibleTArray<PPluginStreamParent*>& aArr) const
{
    aArr = mManagedPPluginStreamParent;
}

const InfallibleTArray<PPluginStreamParent*>&
PPluginInstanceParent::ManagedPPluginStreamParent() const
{
    return mManagedPPluginStreamParent;
}

void
PPluginInstanceParent::ManagedPStreamNotifyParent(InfallibleTArray<PStreamNotifyParent*>& aArr) const
{
    aArr = mManagedPStreamNotifyParent;
}

const InfallibleTArray<PStreamNotifyParent*>&
PPluginInstanceParent::ManagedPStreamNotifyParent() const
{
    return mManagedPStreamNotifyParent;
}

void
PPluginInstanceParent::ManagedPPluginSurfaceParent(InfallibleTArray<PPluginSurfaceParent*>& aArr) const
{
    aArr = mManagedPPluginSurfaceParent;
}

const InfallibleTArray<PPluginSurfaceParent*>&
PPluginInstanceParent::ManagedPPluginSurfaceParent() const
{
    return mManagedPPluginSurfaceParent;
}

PPluginInstance::State
PPluginInstanceParent::state()
{
    return mState;
}

bool
PPluginInstanceParent::Call__delete__(PPluginInstanceParent* actor)
{
    if ((!(actor))) {
        return false;
    }

    PPluginInstance::Msg___delete__* __msg = new PPluginInstance::Msg___delete__();

    (actor)->Write(actor, __msg, false);

    (__msg)->set_routing_id((actor)->mId);
    (__msg)->set_rpc();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginInstanceParent] Sending ", stderr);
    }
    if ((!(PPluginInstance::Transition((actor)->mState, Trigger(Trigger::Send, PPluginInstance::Msg___delete____ID), (&((actor)->mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = ((actor)->mChannel)->Call(__msg, (&(__reply)));
    if (false) {

        if (mozilla::ipc::LoggingEnabled()) {
            (static_cast<const PPluginInstance::Reply___delete__*>((&(__reply))))->Log("[PPluginInstanceParent] Received reply ", stderr);
        }

        __sendok &= false;
    }
    if ((!(PPluginInstance::Transition((actor)->mState, Trigger(Trigger::Recv, PPluginInstance::Reply___delete____ID), (&((actor)->mState)))))) {
        NS_WARNING("bad state transition!");
    }
    (actor)->DestroySubtree(Deletion);
    (actor)->DeallocSubtree();
    ((actor)->mManager)->RemoveManagee(PPluginInstanceMsgStart, actor);

    return __sendok;
}

bool
PPluginInstanceParent::CallNPP_SetWindow(const NPRemoteWindow& window)
{
    PPluginInstance::Msg_NPP_SetWindow* __msg = new PPluginInstance::Msg_NPP_SetWindow();

    Write(window, __msg);

    (__msg)->set_routing_id(mId);
    (__msg)->set_rpc();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginInstanceParent] Sending ", stderr);
    }
    if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Send, PPluginInstance::Msg_NPP_SetWindow__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Call(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PPluginInstance::Reply_NPP_SetWindow*>((&(__reply))))->Log("[PPluginInstanceParent] Received reply ", stderr);
    }

    return true;
}

bool
PPluginInstanceParent::CallNPP_GetValue_NPPVpluginWantsAllNetworkStreams(
        bool* value,
        NPError* result)
{
    PPluginInstance::Msg_NPP_GetValue_NPPVpluginWantsAllNetworkStreams* __msg = new PPluginInstance::Msg_NPP_GetValue_NPPVpluginWantsAllNetworkStreams();


    (__msg)->set_routing_id(mId);
    (__msg)->set_rpc();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginInstanceParent] Sending ", stderr);
    }
    if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Send, PPluginInstance::Msg_NPP_GetValue_NPPVpluginWantsAllNetworkStreams__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Call(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PPluginInstance::Reply_NPP_GetValue_NPPVpluginWantsAllNetworkStreams*>((&(__reply))))->Log("[PPluginInstanceParent] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(value, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read(result, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    (__reply).EndRead(__iter);

    return true;
}

bool
PPluginInstanceParent::CallNPP_GetValue_NPPVpluginNeedsXEmbed(
        bool* value,
        NPError* result)
{
    PPluginInstance::Msg_NPP_GetValue_NPPVpluginNeedsXEmbed* __msg = new PPluginInstance::Msg_NPP_GetValue_NPPVpluginNeedsXEmbed();


    (__msg)->set_routing_id(mId);
    (__msg)->set_rpc();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginInstanceParent] Sending ", stderr);
    }
    if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Send, PPluginInstance::Msg_NPP_GetValue_NPPVpluginNeedsXEmbed__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Call(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PPluginInstance::Reply_NPP_GetValue_NPPVpluginNeedsXEmbed*>((&(__reply))))->Log("[PPluginInstanceParent] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(value, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read(result, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    (__reply).EndRead(__iter);

    return true;
}

bool
PPluginInstanceParent::CallNPP_GetValue_NPPVpluginScriptableNPObject(
        PPluginScriptableObjectParent** value,
        NPError* result)
{
    PPluginInstance::Msg_NPP_GetValue_NPPVpluginScriptableNPObject* __msg = new PPluginInstance::Msg_NPP_GetValue_NPPVpluginScriptableNPObject();


    (__msg)->set_routing_id(mId);
    (__msg)->set_rpc();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginInstanceParent] Sending ", stderr);
    }
    if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Send, PPluginInstance::Msg_NPP_GetValue_NPPVpluginScriptableNPObject__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Call(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PPluginInstance::Reply_NPP_GetValue_NPPVpluginScriptableNPObject*>((&(__reply))))->Log("[PPluginInstanceParent] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(value, (&(__reply)), (&(__iter)), true)))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read(result, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    (__reply).EndRead(__iter);

    return true;
}

bool
PPluginInstanceParent::CallNPP_SetValue_NPNVprivateModeBool(
        const bool& value,
        NPError* result)
{
    PPluginInstance::Msg_NPP_SetValue_NPNVprivateModeBool* __msg = new PPluginInstance::Msg_NPP_SetValue_NPNVprivateModeBool();

    Write(value, __msg);

    (__msg)->set_routing_id(mId);
    (__msg)->set_rpc();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginInstanceParent] Sending ", stderr);
    }
    if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Send, PPluginInstance::Msg_NPP_SetValue_NPNVprivateModeBool__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Call(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PPluginInstance::Reply_NPP_SetValue_NPNVprivateModeBool*>((&(__reply))))->Log("[PPluginInstanceParent] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(result, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    (__reply).EndRead(__iter);

    return true;
}

bool
PPluginInstanceParent::CallNPP_GetValue_NPPVpluginNativeAccessibleAtkPlugId(
        nsCString* plug_id,
        NPError* result)
{
    PPluginInstance::Msg_NPP_GetValue_NPPVpluginNativeAccessibleAtkPlugId* __msg = new PPluginInstance::Msg_NPP_GetValue_NPPVpluginNativeAccessibleAtkPlugId();


    (__msg)->set_routing_id(mId);
    (__msg)->set_rpc();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginInstanceParent] Sending ", stderr);
    }
    if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Send, PPluginInstance::Msg_NPP_GetValue_NPPVpluginNativeAccessibleAtkPlugId__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Call(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PPluginInstance::Reply_NPP_GetValue_NPPVpluginNativeAccessibleAtkPlugId*>((&(__reply))))->Log("[PPluginInstanceParent] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(plug_id, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read(result, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    (__reply).EndRead(__iter);

    return true;
}

bool
PPluginInstanceParent::CallNPP_HandleEvent(
        const NPRemoteEvent& event,
        int16_t* handled)
{
    PPluginInstance::Msg_NPP_HandleEvent* __msg = new PPluginInstance::Msg_NPP_HandleEvent();

    Write(event, __msg);

    (__msg)->set_routing_id(mId);
    (__msg)->set_rpc();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginInstanceParent] Sending ", stderr);
    }
    if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Send, PPluginInstance::Msg_NPP_HandleEvent__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Call(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PPluginInstance::Reply_NPP_HandleEvent*>((&(__reply))))->Log("[PPluginInstanceParent] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(handled, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    (__reply).EndRead(__iter);

    return true;
}

bool
PPluginInstanceParent::CallNPP_HandleEvent_Shmem(
        const NPRemoteEvent& event,
        Shmem& buffer,
        int16_t* handled,
        Shmem* rtnbuffer)
{
    PPluginInstance::Msg_NPP_HandleEvent_Shmem* __msg = new PPluginInstance::Msg_NPP_HandleEvent_Shmem();

    Write(event, __msg);
    Write(buffer, __msg);

    (__msg)->set_routing_id(mId);
    (__msg)->set_rpc();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginInstanceParent] Sending ", stderr);
    }
    if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Send, PPluginInstance::Msg_NPP_HandleEvent_Shmem__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Call(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PPluginInstance::Reply_NPP_HandleEvent_Shmem*>((&(__reply))))->Log("[PPluginInstanceParent] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(handled, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read(rtnbuffer, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    (__reply).EndRead(__iter);

    return true;
}

bool
PPluginInstanceParent::CallNPP_HandleEvent_IOSurface(
        const NPRemoteEvent& event,
        const uint32_t& surfaceid,
        int16_t* handled)
{
    PPluginInstance::Msg_NPP_HandleEvent_IOSurface* __msg = new PPluginInstance::Msg_NPP_HandleEvent_IOSurface();

    Write(event, __msg);
    Write(surfaceid, __msg);

    (__msg)->set_routing_id(mId);
    (__msg)->set_rpc();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginInstanceParent] Sending ", stderr);
    }
    if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Send, PPluginInstance::Msg_NPP_HandleEvent_IOSurface__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Call(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PPluginInstance::Reply_NPP_HandleEvent_IOSurface*>((&(__reply))))->Log("[PPluginInstanceParent] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(handled, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    (__reply).EndRead(__iter);

    return true;
}

bool
PPluginInstanceParent::CallPaint(
        const NPRemoteEvent& event,
        int16_t* handled)
{
    PPluginInstance::Msg_Paint* __msg = new PPluginInstance::Msg_Paint();

    Write(event, __msg);

    (__msg)->set_routing_id(mId);
    (__msg)->set_rpc();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginInstanceParent] Sending ", stderr);
    }
    if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Send, PPluginInstance::Msg_Paint__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Call(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PPluginInstance::Reply_Paint*>((&(__reply))))->Log("[PPluginInstanceParent] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(handled, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    (__reply).EndRead(__iter);

    return true;
}

bool
PPluginInstanceParent::SendWindowPosChanged(const NPRemoteEvent& event)
{
    PPluginInstance::Msg_WindowPosChanged* __msg = new PPluginInstance::Msg_WindowPosChanged();

    Write(event, __msg);

    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginInstanceParent] Sending ", stderr);
    }
    if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Send, PPluginInstance::Msg_WindowPosChanged__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

bool
PPluginInstanceParent::SendContentsScaleFactorChanged(const double& aContentsScaleFactor)
{
    PPluginInstance::Msg_ContentsScaleFactorChanged* __msg = new PPluginInstance::Msg_ContentsScaleFactorChanged();

    Write(aContentsScaleFactor, __msg);

    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginInstanceParent] Sending ", stderr);
    }
    if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Send, PPluginInstance::Msg_ContentsScaleFactorChanged__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

bool
PPluginInstanceParent::SendAsyncSetWindow(
        const gfxSurfaceType& surfaceType,
        const NPRemoteWindow& window)
{
    PPluginInstance::Msg_AsyncSetWindow* __msg = new PPluginInstance::Msg_AsyncSetWindow();

    Write(surfaceType, __msg);
    Write(window, __msg);

    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginInstanceParent] Sending ", stderr);
    }
    if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Send, PPluginInstance::Msg_AsyncSetWindow__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

bool
PPluginInstanceParent::SendUpdateBackground(
        const SurfaceDescriptor& background,
        const nsIntRect& rect)
{
    PPluginInstance::Msg_UpdateBackground* __msg = new PPluginInstance::Msg_UpdateBackground();

    Write(background, __msg);
    Write(rect, __msg);

    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginInstanceParent] Sending ", stderr);
    }
    if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Send, PPluginInstance::Msg_UpdateBackground__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

bool
PPluginInstanceParent::CallHandleTextEvent(
        const nsTextEvent& event,
        bool* handled)
{
    PPluginInstance::Msg_HandleTextEvent* __msg = new PPluginInstance::Msg_HandleTextEvent();

    Write(event, __msg);

    (__msg)->set_routing_id(mId);
    (__msg)->set_rpc();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginInstanceParent] Sending ", stderr);
    }
    if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Send, PPluginInstance::Msg_HandleTextEvent__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Call(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PPluginInstance::Reply_HandleTextEvent*>((&(__reply))))->Log("[PPluginInstanceParent] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(handled, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    (__reply).EndRead(__iter);

    return true;
}

bool
PPluginInstanceParent::CallHandleKeyEvent(
        const nsKeyEvent& event,
        bool* handled)
{
    PPluginInstance::Msg_HandleKeyEvent* __msg = new PPluginInstance::Msg_HandleKeyEvent();

    Write(event, __msg);

    (__msg)->set_routing_id(mId);
    (__msg)->set_rpc();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginInstanceParent] Sending ", stderr);
    }
    if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Send, PPluginInstance::Msg_HandleKeyEvent__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Call(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PPluginInstance::Reply_HandleKeyEvent*>((&(__reply))))->Log("[PPluginInstanceParent] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(handled, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    (__reply).EndRead(__iter);

    return true;
}

bool
PPluginInstanceParent::SendNPP_DidComposite()
{
    PPluginInstance::Msg_NPP_DidComposite* __msg = new PPluginInstance::Msg_NPP_DidComposite();


    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginInstanceParent] Sending ", stderr);
    }
    if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Send, PPluginInstance::Msg_NPP_DidComposite__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

bool
PPluginInstanceParent::CallNPP_Destroy(NPError* rv)
{
    PPluginInstance::Msg_NPP_Destroy* __msg = new PPluginInstance::Msg_NPP_Destroy();


    (__msg)->set_routing_id(mId);
    (__msg)->set_rpc();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginInstanceParent] Sending ", stderr);
    }
    if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Send, PPluginInstance::Msg_NPP_Destroy__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Call(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PPluginInstance::Reply_NPP_Destroy*>((&(__reply))))->Log("[PPluginInstanceParent] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(rv, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    (__reply).EndRead(__iter);

    return true;
}

PPluginScriptableObjectParent*
PPluginInstanceParent::SendPPluginScriptableObjectConstructor()
{
    return SendPPluginScriptableObjectConstructor(AllocPPluginScriptableObject());
}

PPluginScriptableObjectParent*
PPluginInstanceParent::SendPPluginScriptableObjectConstructor(PPluginScriptableObjectParent* actor)
{
    if ((!(actor))) {
        return 0;
    }
    (actor)->mId = Register(actor);
    (actor)->mManager = this;
    (actor)->mChannel = mChannel;
    (mManagedPPluginScriptableObjectParent).InsertElementSorted(actor);
    (actor)->mState = mozilla::plugins::PPluginScriptableObject::__Start;

    PPluginInstance::Msg_PPluginScriptableObjectConstructor* __msg = new PPluginInstance::Msg_PPluginScriptableObjectConstructor();

    Write(actor, __msg, false);

    (__msg)->set_routing_id(mId);


    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginInstanceParent] Sending ", stderr);
    }
    if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Send, PPluginInstance::Msg_PPluginScriptableObjectConstructor__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    if ((!(__sendok))) {
        (actor)->DestroySubtree(FailedConstructor);
        (actor)->DeallocSubtree();
        ((actor)->mManager)->RemoveManagee(PPluginScriptableObjectMsgStart, actor);
        return 0;
    }
    return actor;
}

PBrowserStreamParent*
PPluginInstanceParent::CallPBrowserStreamConstructor(
        const nsCString& url,
        const uint32_t& length,
        const uint32_t& lastmodified,
        PStreamNotifyParent* notifyData,
        const nsCString& headers,
        const nsCString& mimeType,
        const bool& seekable,
        NPError* rv,
        uint16_t* stype)
{
    return CallPBrowserStreamConstructor(AllocPBrowserStream(url, length, lastmodified, notifyData, headers, mimeType, seekable, rv, stype), url, length, lastmodified, notifyData, headers, mimeType, seekable, rv, stype);
}

PBrowserStreamParent*
PPluginInstanceParent::CallPBrowserStreamConstructor(
        PBrowserStreamParent* actor,
        const nsCString& url,
        const uint32_t& length,
        const uint32_t& lastmodified,
        PStreamNotifyParent* notifyData,
        const nsCString& headers,
        const nsCString& mimeType,
        const bool& seekable,
        NPError* rv,
        uint16_t* stype)
{
    if ((!(actor))) {
        return 0;
    }
    (actor)->mId = Register(actor);
    (actor)->mManager = this;
    (actor)->mChannel = mChannel;
    (mManagedPBrowserStreamParent).InsertElementSorted(actor);
    (actor)->mState = mozilla::plugins::PBrowserStream::__Start;

    PPluginInstance::Msg_PBrowserStreamConstructor* __msg = new PPluginInstance::Msg_PBrowserStreamConstructor();

    Write(actor, __msg, false);
    Write(url, __msg);
    Write(length, __msg);
    Write(lastmodified, __msg);
    Write(notifyData, __msg, true);
    Write(headers, __msg);
    Write(mimeType, __msg);
    Write(seekable, __msg);

    (__msg)->set_routing_id(mId);
    (__msg)->set_rpc();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginInstanceParent] Sending ", stderr);
    }
    if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Send, PPluginInstance::Msg_PBrowserStreamConstructor__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Call(__msg, (&(__reply)));
    if ((!(__sendok))) {
        (actor)->DestroySubtree(FailedConstructor);
        (actor)->DeallocSubtree();
        ((actor)->mManager)->RemoveManagee(PBrowserStreamMsgStart, actor);
        return 0;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PPluginInstance::Reply_PBrowserStreamConstructor*>((&(__reply))))->Log("[PPluginInstanceParent] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(rv, (&(__reply)), (&(__iter)))))) {
        if (true) {
            (actor)->DestroySubtree(FailedConstructor);
            (actor)->DeallocSubtree();
            ((actor)->mManager)->RemoveManagee(PBrowserStreamMsgStart, actor);
            return 0;
        }
    }
    if ((!(Read(stype, (&(__reply)), (&(__iter)))))) {
        if (true) {
            (actor)->DestroySubtree(FailedConstructor);
            (actor)->DeallocSubtree();
            ((actor)->mManager)->RemoveManagee(PBrowserStreamMsgStart, actor);
            return 0;
        }
    }
    (__reply).EndRead(__iter);
    return actor;
}

bool
PPluginInstanceParent::CallSetPluginFocus()
{
    PPluginInstance::Msg_SetPluginFocus* __msg = new PPluginInstance::Msg_SetPluginFocus();


    (__msg)->set_routing_id(mId);
    (__msg)->set_rpc();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginInstanceParent] Sending ", stderr);
    }
    if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Send, PPluginInstance::Msg_SetPluginFocus__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Call(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PPluginInstance::Reply_SetPluginFocus*>((&(__reply))))->Log("[PPluginInstanceParent] Received reply ", stderr);
    }

    return true;
}

bool
PPluginInstanceParent::CallUpdateWindow()
{
    PPluginInstance::Msg_UpdateWindow* __msg = new PPluginInstance::Msg_UpdateWindow();


    (__msg)->set_routing_id(mId);
    (__msg)->set_rpc();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginInstanceParent] Sending ", stderr);
    }
    if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Send, PPluginInstance::Msg_UpdateWindow__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Call(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PPluginInstance::Reply_UpdateWindow*>((&(__reply))))->Log("[PPluginInstanceParent] Received reply ", stderr);
    }

    return true;
}

PPluginBackgroundDestroyerParent*
PPluginInstanceParent::SendPPluginBackgroundDestroyerConstructor()
{
    return SendPPluginBackgroundDestroyerConstructor(AllocPPluginBackgroundDestroyer());
}

PPluginBackgroundDestroyerParent*
PPluginInstanceParent::SendPPluginBackgroundDestroyerConstructor(PPluginBackgroundDestroyerParent* actor)
{
    if ((!(actor))) {
        return 0;
    }
    (actor)->mId = Register(actor);
    (actor)->mManager = this;
    (actor)->mChannel = mChannel;
    (mManagedPPluginBackgroundDestroyerParent).InsertElementSorted(actor);
    (actor)->mState = mozilla::plugins::PPluginBackgroundDestroyer::__Start;

    PPluginInstance::Msg_PPluginBackgroundDestroyerConstructor* __msg = new PPluginInstance::Msg_PPluginBackgroundDestroyerConstructor();

    Write(actor, __msg, false);

    (__msg)->set_routing_id(mId);


    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginInstanceParent] Sending ", stderr);
    }
    if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Send, PPluginInstance::Msg_PPluginBackgroundDestroyerConstructor__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    if ((!(__sendok))) {
        (actor)->DestroySubtree(FailedConstructor);
        (actor)->DeallocSubtree();
        ((actor)->mManager)->RemoveManagee(PPluginBackgroundDestroyerMsgStart, actor);
        return 0;
    }
    return actor;
}

int32_t
PPluginInstanceParent::Register(ChannelListener* aRouted)
{
    return (mManager)->Register(aRouted);
}

int32_t
PPluginInstanceParent::RegisterID(
        ChannelListener* aRouted,
        int32_t aId)
{
    return (mManager)->RegisterID(aRouted, aId);
}

ChannelListener*
PPluginInstanceParent::Lookup(int32_t aId)
{
    return (mManager)->Lookup(aId);
}

void
PPluginInstanceParent::Unregister(int32_t aId)
{
    return (mManager)->Unregister(aId);
}

void
PPluginInstanceParent::RemoveManagee(
        int32_t aProtocolId,
        ChannelListener* aListener)
{
    switch (aProtocolId) {
    case PPluginBackgroundDestroyerMsgStart:
        {
            PPluginBackgroundDestroyerParent* actor = static_cast<PPluginBackgroundDestroyerParent*>(aListener);
            NS_ABORT_IF_FALSE(((mManagedPPluginBackgroundDestroyerParent).NoIndex) != ((mManagedPPluginBackgroundDestroyerParent).BinaryIndexOf(actor)), "actor not managed by this!");

            (mManagedPPluginBackgroundDestroyerParent).RemoveElementSorted(actor);
            DeallocPPluginBackgroundDestroyer(actor);
            return;
        }
    case PPluginScriptableObjectMsgStart:
        {
            PPluginScriptableObjectParent* actor = static_cast<PPluginScriptableObjectParent*>(aListener);
            NS_ABORT_IF_FALSE(((mManagedPPluginScriptableObjectParent).NoIndex) != ((mManagedPPluginScriptableObjectParent).BinaryIndexOf(actor)), "actor not managed by this!");

            (mManagedPPluginScriptableObjectParent).RemoveElementSorted(actor);
            DeallocPPluginScriptableObject(actor);
            return;
        }
    case PBrowserStreamMsgStart:
        {
            PBrowserStreamParent* actor = static_cast<PBrowserStreamParent*>(aListener);
            NS_ABORT_IF_FALSE(((mManagedPBrowserStreamParent).NoIndex) != ((mManagedPBrowserStreamParent).BinaryIndexOf(actor)), "actor not managed by this!");

            (mManagedPBrowserStreamParent).RemoveElementSorted(actor);
            DeallocPBrowserStream(actor);
            return;
        }
    case PPluginStreamMsgStart:
        {
            PPluginStreamParent* actor = static_cast<PPluginStreamParent*>(aListener);
            NS_ABORT_IF_FALSE(((mManagedPPluginStreamParent).NoIndex) != ((mManagedPPluginStreamParent).BinaryIndexOf(actor)), "actor not managed by this!");

            (mManagedPPluginStreamParent).RemoveElementSorted(actor);
            DeallocPPluginStream(actor);
            return;
        }
    case PStreamNotifyMsgStart:
        {
            PStreamNotifyParent* actor = static_cast<PStreamNotifyParent*>(aListener);
            NS_ABORT_IF_FALSE(((mManagedPStreamNotifyParent).NoIndex) != ((mManagedPStreamNotifyParent).BinaryIndexOf(actor)), "actor not managed by this!");

            (mManagedPStreamNotifyParent).RemoveElementSorted(actor);
            DeallocPStreamNotify(actor);
            return;
        }
    case PPluginSurfaceMsgStart:
        {
            PPluginSurfaceParent* actor = static_cast<PPluginSurfaceParent*>(aListener);
            NS_ABORT_IF_FALSE(((mManagedPPluginSurfaceParent).NoIndex) != ((mManagedPPluginSurfaceParent).BinaryIndexOf(actor)), "actor not managed by this!");

            (mManagedPPluginSurfaceParent).RemoveElementSorted(actor);
            DeallocPPluginSurface(actor);
            return;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return;
        }
    }
}

Shmem::SharedMemory*
PPluginInstanceParent::CreateSharedMemory(
        size_t aSize,
        Shmem::SharedMemory::SharedMemoryType aType,
        bool aUnsafe,
        Shmem::id_t* aId)
{
    return (mManager)->CreateSharedMemory(aSize, aType, aUnsafe, aId);
}

bool
PPluginInstanceParent::AdoptSharedMemory(
        Shmem::SharedMemory* segment,
        Shmem::id_t* aId)
{
    return (mManager)->AdoptSharedMemory(segment, aId);
}

Shmem::SharedMemory*
PPluginInstanceParent::LookupSharedMemory(Shmem::id_t aId)
{
    return (mManager)->LookupSharedMemory(aId);
}

bool
PPluginInstanceParent::IsTrackingSharedMemory(Shmem::SharedMemory* segment)
{
    return (mManager)->IsTrackingSharedMemory(segment);
}

bool
PPluginInstanceParent::DestroySharedMemory(Shmem& shmem)
{
    return (mManager)->DestroySharedMemory(shmem);
}

ProcessHandle
PPluginInstanceParent::OtherProcess() const
{
    return (mManager)->OtherProcess();
}

AsyncChannel*
PPluginInstanceParent::GetIPCChannel()
{
    return mChannel;
}

PPluginInstanceParent::Result
PPluginInstanceParent::OnMessageReceived(const Message& __msg)
{
    if (((mState) == (PPluginInstance::__Dying)) && ((((__msg).is_reply()) != (true)) || (((__msg).is_rpc()) != (true)))) {
        FatalError("incoming message racing with actor deletion");
        return MsgProcessed;
    }
    switch ((__msg).type()) {
    case PPluginInstance::Msg_NPN_InvalidateRect__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginInstance::Msg_NPN_InvalidateRect");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Msg_NPN_InvalidateRect*>((&(__msg))))->Log("[PPluginInstanceParent] Received ", stderr);
            }

            void* __iter = 0;
            NPRect rect;

            if ((!(Read((&(rect)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Recv, PPluginInstance::Msg_NPN_InvalidateRect__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvNPN_InvalidateRect(rect)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for NPN_InvalidateRect returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PPluginInstance::Msg_PPluginSurfaceConstructor__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginInstance::Msg_PPluginSurfaceConstructor");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Msg_PPluginSurfaceConstructor*>((&(__msg))))->Log("[PPluginInstanceParent] Received ", stderr);
            }

            void* __iter = 0;
            ActorHandle __handle;
            PPluginSurfaceParent* actor;
            WindowsSharedMemoryHandle handle;
            gfxIntSize size;
            bool transparent;

            if ((!(Read((&(__handle)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(handle)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(size)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(transparent)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Recv, PPluginInstance::Msg_PPluginSurfaceConstructor__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            actor = AllocPPluginSurface(handle, size, transparent);
            if ((!(actor))) {
                return MsgValueError;
            }
            (actor)->mId = RegisterID(actor, (__handle).mId);
            (actor)->mManager = this;
            (actor)->mChannel = mChannel;
            (mManagedPPluginSurfaceParent).InsertElementSorted(actor);
            (actor)->mState = mozilla::plugins::PPluginSurface::__Start;

            if ((!(RecvPPluginSurfaceConstructor(actor, handle, size, transparent)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for PPluginSurface returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PPluginInstance::Msg_RedrawPlugin__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginInstance::Msg_RedrawPlugin");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Msg_RedrawPlugin*>((&(__msg))))->Log("[PPluginInstanceParent] Received ", stderr);
            }

            if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Recv, PPluginInstance::Msg_RedrawPlugin__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvRedrawPlugin()))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for RedrawPlugin returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PPluginInstance::Msg_ReleaseDXGISharedSurface__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginInstance::Msg_ReleaseDXGISharedSurface");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Msg_ReleaseDXGISharedSurface*>((&(__msg))))->Log("[PPluginInstanceParent] Received ", stderr);
            }

            void* __iter = 0;
            DXGISharedSurfaceHandle handle;

            if ((!(Read((&(handle)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Recv, PPluginInstance::Msg_ReleaseDXGISharedSurface__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvReleaseDXGISharedSurface(handle)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for ReleaseDXGISharedSurface returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PPluginInstance::Reply_PPluginScriptableObjectConstructor__ID:
        {
            return MsgProcessed;
        }
    case PPluginInstance::Msg_PPluginScriptableObjectConstructor__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginInstance::Msg_PPluginScriptableObjectConstructor");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Msg_PPluginScriptableObjectConstructor*>((&(__msg))))->Log("[PPluginInstanceParent] Received ", stderr);
            }

            void* __iter = 0;
            ActorHandle __handle;
            PPluginScriptableObjectParent* actor;

            if ((!(Read((&(__handle)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Recv, PPluginInstance::Msg_PPluginScriptableObjectConstructor__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            actor = AllocPPluginScriptableObject();
            if ((!(actor))) {
                return MsgValueError;
            }
            (actor)->mId = RegisterID(actor, (__handle).mId);
            (actor)->mManager = this;
            (actor)->mChannel = mChannel;
            (mManagedPPluginScriptableObjectParent).InsertElementSorted(actor);
            (actor)->mState = mozilla::plugins::PPluginScriptableObject::__Start;

            if ((!(RecvPPluginScriptableObjectConstructor(actor)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for PPluginScriptableObject returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PPluginInstance::Reply_PPluginBackgroundDestroyerConstructor__ID:
        {
            return MsgProcessed;
        }
    default:
        {
            return MsgNotKnown;
        }
    }
}

PPluginInstanceParent::Result
PPluginInstanceParent::OnMessageReceived(
        const Message& __msg,
        Message*& __reply)
{
    if (((mState) == (PPluginInstance::__Dying)) && ((((__msg).is_reply()) != (true)) || (((__msg).is_rpc()) != (true)))) {
        FatalError("incoming message racing with actor deletion");
        return MsgProcessed;
    }
    switch ((__msg).type()) {
    case PPluginInstance::Msg_Show__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginInstance::Msg_Show");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Msg_Show*>((&(__msg))))->Log("[PPluginInstanceParent] Received ", stderr);
            }

            void* __iter = 0;
            NPRect updatedRect;
            SurfaceDescriptor newSurface;

            if ((!(Read((&(updatedRect)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(newSurface)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Recv, PPluginInstance::Msg_Show__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            SurfaceDescriptor prevSurface;
            int32_t __id = mId;
            if ((!(RecvShow(updatedRect, newSurface, (&(prevSurface)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for Show returned error code");
                return MsgProcessingError;
            }

            __reply = new PPluginInstance::Reply_Show();

            Write(prevSurface, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_sync();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Reply_Show*>(__reply))->Log("[PPluginInstanceParent] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    case PPluginInstance::Msg_NegotiatedCarbon__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginInstance::Msg_NegotiatedCarbon");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Msg_NegotiatedCarbon*>((&(__msg))))->Log("[PPluginInstanceParent] Received ", stderr);
            }

            if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Recv, PPluginInstance::Msg_NegotiatedCarbon__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            int32_t __id = mId;
            if ((!(RecvNegotiatedCarbon()))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for NegotiatedCarbon returned error code");
                return MsgProcessingError;
            }

            __reply = new PPluginInstance::Reply_NegotiatedCarbon();

            (__reply)->set_routing_id(__id);
            (__reply)->set_sync();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Reply_NegotiatedCarbon*>(__reply))->Log("[PPluginInstanceParent] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    default:
        {
            return MsgNotKnown;
        }
    }
}

PPluginInstanceParent::Result
PPluginInstanceParent::OnCallReceived(
        const Message& __msg,
        Message*& __reply)
{
    if (((mState) == (PPluginInstance::__Dying)) && ((((__msg).is_reply()) != (true)) || (((__msg).is_rpc()) != (true)))) {
        FatalError("incoming message racing with actor deletion");
        return MsgProcessed;
    }
    switch ((__msg).type()) {
    case PPluginInstance::Msg_NPN_GetValue_NPNVWindowNPObject__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginInstance::Msg_NPN_GetValue_NPNVWindowNPObject");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Msg_NPN_GetValue_NPNVWindowNPObject*>((&(__msg))))->Log("[PPluginInstanceParent] Received ", stderr);
            }

            if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Recv, PPluginInstance::Msg_NPN_GetValue_NPNVWindowNPObject__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            PPluginScriptableObjectParent* value;
            NPError result;
            int32_t __id = mId;
            if ((!(AnswerNPN_GetValue_NPNVWindowNPObject((&(value)), (&(result)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for NPN_GetValue_NPNVWindowNPObject returned error code");
                return MsgProcessingError;
            }

            __reply = new PPluginInstance::Reply_NPN_GetValue_NPNVWindowNPObject();

            Write(value, __reply, true);
            Write(result, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_rpc();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Reply_NPN_GetValue_NPNVWindowNPObject*>(__reply))->Log("[PPluginInstanceParent] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    case PPluginInstance::Msg_NPN_GetValue_NPNVPluginElementNPObject__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginInstance::Msg_NPN_GetValue_NPNVPluginElementNPObject");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Msg_NPN_GetValue_NPNVPluginElementNPObject*>((&(__msg))))->Log("[PPluginInstanceParent] Received ", stderr);
            }

            if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Recv, PPluginInstance::Msg_NPN_GetValue_NPNVPluginElementNPObject__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            PPluginScriptableObjectParent* value;
            NPError result;
            int32_t __id = mId;
            if ((!(AnswerNPN_GetValue_NPNVPluginElementNPObject((&(value)), (&(result)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for NPN_GetValue_NPNVPluginElementNPObject returned error code");
                return MsgProcessingError;
            }

            __reply = new PPluginInstance::Reply_NPN_GetValue_NPNVPluginElementNPObject();

            Write(value, __reply, true);
            Write(result, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_rpc();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Reply_NPN_GetValue_NPNVPluginElementNPObject*>(__reply))->Log("[PPluginInstanceParent] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    case PPluginInstance::Msg_NPN_GetValue_NPNVprivateModeBool__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginInstance::Msg_NPN_GetValue_NPNVprivateModeBool");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Msg_NPN_GetValue_NPNVprivateModeBool*>((&(__msg))))->Log("[PPluginInstanceParent] Received ", stderr);
            }

            if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Recv, PPluginInstance::Msg_NPN_GetValue_NPNVprivateModeBool__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            bool value;
            NPError result;
            int32_t __id = mId;
            if ((!(AnswerNPN_GetValue_NPNVprivateModeBool((&(value)), (&(result)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for NPN_GetValue_NPNVprivateModeBool returned error code");
                return MsgProcessingError;
            }

            __reply = new PPluginInstance::Reply_NPN_GetValue_NPNVprivateModeBool();

            Write(value, __reply);
            Write(result, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_rpc();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Reply_NPN_GetValue_NPNVprivateModeBool*>(__reply))->Log("[PPluginInstanceParent] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    case PPluginInstance::Msg_NPN_GetValue_NPNVnetscapeWindow__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginInstance::Msg_NPN_GetValue_NPNVnetscapeWindow");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Msg_NPN_GetValue_NPNVnetscapeWindow*>((&(__msg))))->Log("[PPluginInstanceParent] Received ", stderr);
            }

            if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Recv, PPluginInstance::Msg_NPN_GetValue_NPNVnetscapeWindow__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            NativeWindowHandle value;
            NPError result;
            int32_t __id = mId;
            if ((!(AnswerNPN_GetValue_NPNVnetscapeWindow((&(value)), (&(result)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for NPN_GetValue_NPNVnetscapeWindow returned error code");
                return MsgProcessingError;
            }

            __reply = new PPluginInstance::Reply_NPN_GetValue_NPNVnetscapeWindow();

            Write(value, __reply);
            Write(result, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_rpc();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Reply_NPN_GetValue_NPNVnetscapeWindow*>(__reply))->Log("[PPluginInstanceParent] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    case PPluginInstance::Msg_NPN_GetValue_NPNVdocumentOrigin__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginInstance::Msg_NPN_GetValue_NPNVdocumentOrigin");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Msg_NPN_GetValue_NPNVdocumentOrigin*>((&(__msg))))->Log("[PPluginInstanceParent] Received ", stderr);
            }

            if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Recv, PPluginInstance::Msg_NPN_GetValue_NPNVdocumentOrigin__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            nsCString value;
            NPError result;
            int32_t __id = mId;
            if ((!(AnswerNPN_GetValue_NPNVdocumentOrigin((&(value)), (&(result)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for NPN_GetValue_NPNVdocumentOrigin returned error code");
                return MsgProcessingError;
            }

            __reply = new PPluginInstance::Reply_NPN_GetValue_NPNVdocumentOrigin();

            Write(value, __reply);
            Write(result, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_rpc();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Reply_NPN_GetValue_NPNVdocumentOrigin*>(__reply))->Log("[PPluginInstanceParent] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    case PPluginInstance::Msg_NPN_GetValue_DrawingModelSupport__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginInstance::Msg_NPN_GetValue_DrawingModelSupport");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Msg_NPN_GetValue_DrawingModelSupport*>((&(__msg))))->Log("[PPluginInstanceParent] Received ", stderr);
            }

            void* __iter = 0;
            NPNVariable model;

            if ((!(Read((&(model)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Recv, PPluginInstance::Msg_NPN_GetValue_DrawingModelSupport__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            bool value;
            int32_t __id = mId;
            if ((!(AnswerNPN_GetValue_DrawingModelSupport(model, (&(value)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for NPN_GetValue_DrawingModelSupport returned error code");
                return MsgProcessingError;
            }

            __reply = new PPluginInstance::Reply_NPN_GetValue_DrawingModelSupport();

            Write(value, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_rpc();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Reply_NPN_GetValue_DrawingModelSupport*>(__reply))->Log("[PPluginInstanceParent] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    case PPluginInstance::Msg_NPN_SetValue_NPPVpluginWindow__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginInstance::Msg_NPN_SetValue_NPPVpluginWindow");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Msg_NPN_SetValue_NPPVpluginWindow*>((&(__msg))))->Log("[PPluginInstanceParent] Received ", stderr);
            }

            void* __iter = 0;
            bool windowed;

            if ((!(Read((&(windowed)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Recv, PPluginInstance::Msg_NPN_SetValue_NPPVpluginWindow__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            NPError result;
            int32_t __id = mId;
            if ((!(AnswerNPN_SetValue_NPPVpluginWindow(windowed, (&(result)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for NPN_SetValue_NPPVpluginWindow returned error code");
                return MsgProcessingError;
            }

            __reply = new PPluginInstance::Reply_NPN_SetValue_NPPVpluginWindow();

            Write(result, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_rpc();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Reply_NPN_SetValue_NPPVpluginWindow*>(__reply))->Log("[PPluginInstanceParent] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    case PPluginInstance::Msg_NPN_SetValue_NPPVpluginTransparent__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginInstance::Msg_NPN_SetValue_NPPVpluginTransparent");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Msg_NPN_SetValue_NPPVpluginTransparent*>((&(__msg))))->Log("[PPluginInstanceParent] Received ", stderr);
            }

            void* __iter = 0;
            bool transparent;

            if ((!(Read((&(transparent)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Recv, PPluginInstance::Msg_NPN_SetValue_NPPVpluginTransparent__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            NPError result;
            int32_t __id = mId;
            if ((!(AnswerNPN_SetValue_NPPVpluginTransparent(transparent, (&(result)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for NPN_SetValue_NPPVpluginTransparent returned error code");
                return MsgProcessingError;
            }

            __reply = new PPluginInstance::Reply_NPN_SetValue_NPPVpluginTransparent();

            Write(result, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_rpc();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Reply_NPN_SetValue_NPPVpluginTransparent*>(__reply))->Log("[PPluginInstanceParent] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    case PPluginInstance::Msg_NPN_SetValue_NPPVpluginUsesDOMForCursor__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginInstance::Msg_NPN_SetValue_NPPVpluginUsesDOMForCursor");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Msg_NPN_SetValue_NPPVpluginUsesDOMForCursor*>((&(__msg))))->Log("[PPluginInstanceParent] Received ", stderr);
            }

            void* __iter = 0;
            bool useDOMForCursor;

            if ((!(Read((&(useDOMForCursor)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Recv, PPluginInstance::Msg_NPN_SetValue_NPPVpluginUsesDOMForCursor__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            NPError result;
            int32_t __id = mId;
            if ((!(AnswerNPN_SetValue_NPPVpluginUsesDOMForCursor(useDOMForCursor, (&(result)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for NPN_SetValue_NPPVpluginUsesDOMForCursor returned error code");
                return MsgProcessingError;
            }

            __reply = new PPluginInstance::Reply_NPN_SetValue_NPPVpluginUsesDOMForCursor();

            Write(result, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_rpc();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Reply_NPN_SetValue_NPPVpluginUsesDOMForCursor*>(__reply))->Log("[PPluginInstanceParent] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    case PPluginInstance::Msg_NPN_SetValue_NPPVpluginDrawingModel__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginInstance::Msg_NPN_SetValue_NPPVpluginDrawingModel");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Msg_NPN_SetValue_NPPVpluginDrawingModel*>((&(__msg))))->Log("[PPluginInstanceParent] Received ", stderr);
            }

            void* __iter = 0;
            int drawingModel;

            if ((!(Read((&(drawingModel)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Recv, PPluginInstance::Msg_NPN_SetValue_NPPVpluginDrawingModel__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            OptionalShmem remoteImageData;
            CrossProcessMutexHandle mutex;
            NPError result;
            int32_t __id = mId;
            if ((!(AnswerNPN_SetValue_NPPVpluginDrawingModel(drawingModel, (&(remoteImageData)), (&(mutex)), (&(result)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for NPN_SetValue_NPPVpluginDrawingModel returned error code");
                return MsgProcessingError;
            }

            __reply = new PPluginInstance::Reply_NPN_SetValue_NPPVpluginDrawingModel();

            Write(remoteImageData, __reply);
            Write(mutex, __reply);
            Write(result, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_rpc();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Reply_NPN_SetValue_NPPVpluginDrawingModel*>(__reply))->Log("[PPluginInstanceParent] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    case PPluginInstance::Msg_NPN_SetValue_NPPVpluginEventModel__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginInstance::Msg_NPN_SetValue_NPPVpluginEventModel");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Msg_NPN_SetValue_NPPVpluginEventModel*>((&(__msg))))->Log("[PPluginInstanceParent] Received ", stderr);
            }

            void* __iter = 0;
            int eventModel;

            if ((!(Read((&(eventModel)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Recv, PPluginInstance::Msg_NPN_SetValue_NPPVpluginEventModel__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            NPError result;
            int32_t __id = mId;
            if ((!(AnswerNPN_SetValue_NPPVpluginEventModel(eventModel, (&(result)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for NPN_SetValue_NPPVpluginEventModel returned error code");
                return MsgProcessingError;
            }

            __reply = new PPluginInstance::Reply_NPN_SetValue_NPPVpluginEventModel();

            Write(result, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_rpc();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Reply_NPN_SetValue_NPPVpluginEventModel*>(__reply))->Log("[PPluginInstanceParent] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    case PPluginInstance::Msg_NPN_GetURL__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginInstance::Msg_NPN_GetURL");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Msg_NPN_GetURL*>((&(__msg))))->Log("[PPluginInstanceParent] Received ", stderr);
            }

            void* __iter = 0;
            nsCString url;
            nsCString target;

            if ((!(Read((&(url)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(target)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Recv, PPluginInstance::Msg_NPN_GetURL__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            NPError result;
            int32_t __id = mId;
            if ((!(AnswerNPN_GetURL(url, target, (&(result)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for NPN_GetURL returned error code");
                return MsgProcessingError;
            }

            __reply = new PPluginInstance::Reply_NPN_GetURL();

            Write(result, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_rpc();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Reply_NPN_GetURL*>(__reply))->Log("[PPluginInstanceParent] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    case PPluginInstance::Msg_NPN_PostURL__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginInstance::Msg_NPN_PostURL");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Msg_NPN_PostURL*>((&(__msg))))->Log("[PPluginInstanceParent] Received ", stderr);
            }

            void* __iter = 0;
            nsCString url;
            nsCString target;
            nsCString buffer;
            bool file;

            if ((!(Read((&(url)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(target)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(buffer)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(file)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Recv, PPluginInstance::Msg_NPN_PostURL__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            NPError result;
            int32_t __id = mId;
            if ((!(AnswerNPN_PostURL(url, target, buffer, file, (&(result)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for NPN_PostURL returned error code");
                return MsgProcessingError;
            }

            __reply = new PPluginInstance::Reply_NPN_PostURL();

            Write(result, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_rpc();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Reply_NPN_PostURL*>(__reply))->Log("[PPluginInstanceParent] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    case PPluginInstance::Msg_PStreamNotifyConstructor__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginInstance::Msg_PStreamNotifyConstructor");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Msg_PStreamNotifyConstructor*>((&(__msg))))->Log("[PPluginInstanceParent] Received ", stderr);
            }

            void* __iter = 0;
            ActorHandle __handle;
            PStreamNotifyParent* actor;
            nsCString url;
            nsCString target;
            bool post;
            nsCString buffer;
            bool file;

            if ((!(Read((&(__handle)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(url)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(target)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(post)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(buffer)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(file)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Recv, PPluginInstance::Msg_PStreamNotifyConstructor__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            NPError result;
            actor = AllocPStreamNotify(url, target, post, buffer, file, (&(result)));
            if ((!(actor))) {
                return MsgValueError;
            }
            (actor)->mId = RegisterID(actor, (__handle).mId);
            (actor)->mManager = this;
            (actor)->mChannel = mChannel;
            (mManagedPStreamNotifyParent).InsertElementSorted(actor);
            (actor)->mState = mozilla::plugins::PStreamNotify::__Start;

            int32_t __id = mId;
            if ((!(AnswerPStreamNotifyConstructor(actor, url, target, post, buffer, file, (&(result)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for PStreamNotify returned error code");
                return MsgProcessingError;
            }
            __reply = new PPluginInstance::Reply_PStreamNotifyConstructor();

            Write(result, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_rpc();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Reply_PStreamNotifyConstructor*>(__reply))->Log("[PPluginInstanceParent] Sending reply ", stderr);
            }

            return MsgProcessed;
        }
    case PPluginInstance::Msg_NPN_PushPopupsEnabledState__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginInstance::Msg_NPN_PushPopupsEnabledState");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Msg_NPN_PushPopupsEnabledState*>((&(__msg))))->Log("[PPluginInstanceParent] Received ", stderr);
            }

            void* __iter = 0;
            bool aState;

            if ((!(Read((&(aState)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Recv, PPluginInstance::Msg_NPN_PushPopupsEnabledState__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            int32_t __id = mId;
            if ((!(AnswerNPN_PushPopupsEnabledState(aState)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for NPN_PushPopupsEnabledState returned error code");
                return MsgProcessingError;
            }

            __reply = new PPluginInstance::Reply_NPN_PushPopupsEnabledState();

            (__reply)->set_routing_id(__id);
            (__reply)->set_rpc();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Reply_NPN_PushPopupsEnabledState*>(__reply))->Log("[PPluginInstanceParent] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    case PPluginInstance::Msg_NPN_PopPopupsEnabledState__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginInstance::Msg_NPN_PopPopupsEnabledState");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Msg_NPN_PopPopupsEnabledState*>((&(__msg))))->Log("[PPluginInstanceParent] Received ", stderr);
            }

            if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Recv, PPluginInstance::Msg_NPN_PopPopupsEnabledState__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            int32_t __id = mId;
            if ((!(AnswerNPN_PopPopupsEnabledState()))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for NPN_PopPopupsEnabledState returned error code");
                return MsgProcessingError;
            }

            __reply = new PPluginInstance::Reply_NPN_PopPopupsEnabledState();

            (__reply)->set_routing_id(__id);
            (__reply)->set_rpc();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Reply_NPN_PopPopupsEnabledState*>(__reply))->Log("[PPluginInstanceParent] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    case PPluginInstance::Msg_NPN_GetValueForURL__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginInstance::Msg_NPN_GetValueForURL");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Msg_NPN_GetValueForURL*>((&(__msg))))->Log("[PPluginInstanceParent] Received ", stderr);
            }

            void* __iter = 0;
            NPNURLVariable variable;
            nsCString url;

            if ((!(Read((&(variable)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(url)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Recv, PPluginInstance::Msg_NPN_GetValueForURL__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            nsCString value;
            NPError result;
            int32_t __id = mId;
            if ((!(AnswerNPN_GetValueForURL(variable, url, (&(value)), (&(result)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for NPN_GetValueForURL returned error code");
                return MsgProcessingError;
            }

            __reply = new PPluginInstance::Reply_NPN_GetValueForURL();

            Write(value, __reply);
            Write(result, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_rpc();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Reply_NPN_GetValueForURL*>(__reply))->Log("[PPluginInstanceParent] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    case PPluginInstance::Msg_NPN_SetValueForURL__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginInstance::Msg_NPN_SetValueForURL");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Msg_NPN_SetValueForURL*>((&(__msg))))->Log("[PPluginInstanceParent] Received ", stderr);
            }

            void* __iter = 0;
            NPNURLVariable variable;
            nsCString url;
            nsCString value;

            if ((!(Read((&(variable)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(url)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(value)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Recv, PPluginInstance::Msg_NPN_SetValueForURL__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            NPError result;
            int32_t __id = mId;
            if ((!(AnswerNPN_SetValueForURL(variable, url, value, (&(result)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for NPN_SetValueForURL returned error code");
                return MsgProcessingError;
            }

            __reply = new PPluginInstance::Reply_NPN_SetValueForURL();

            Write(result, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_rpc();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Reply_NPN_SetValueForURL*>(__reply))->Log("[PPluginInstanceParent] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    case PPluginInstance::Msg_NPN_GetAuthenticationInfo__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginInstance::Msg_NPN_GetAuthenticationInfo");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Msg_NPN_GetAuthenticationInfo*>((&(__msg))))->Log("[PPluginInstanceParent] Received ", stderr);
            }

            void* __iter = 0;
            nsCString protocol_;
            nsCString host;
            int32_t port;
            nsCString scheme;
            nsCString realm;

            if ((!(Read((&(protocol_)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(host)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(port)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(scheme)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(realm)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Recv, PPluginInstance::Msg_NPN_GetAuthenticationInfo__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            nsCString username;
            nsCString password;
            NPError result;
            int32_t __id = mId;
            if ((!(AnswerNPN_GetAuthenticationInfo(protocol_, host, port, scheme, realm, (&(username)), (&(password)), (&(result)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for NPN_GetAuthenticationInfo returned error code");
                return MsgProcessingError;
            }

            __reply = new PPluginInstance::Reply_NPN_GetAuthenticationInfo();

            Write(username, __reply);
            Write(password, __reply);
            Write(result, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_rpc();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Reply_NPN_GetAuthenticationInfo*>(__reply))->Log("[PPluginInstanceParent] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    case PPluginInstance::Msg_NPN_ConvertPoint__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginInstance::Msg_NPN_ConvertPoint");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Msg_NPN_ConvertPoint*>((&(__msg))))->Log("[PPluginInstanceParent] Received ", stderr);
            }

            void* __iter = 0;
            double sourceX;
            bool ignoreDestX;
            double sourceY;
            bool ignoreDestY;
            NPCoordinateSpace sourceSpace;
            NPCoordinateSpace destSpace;

            if ((!(Read((&(sourceX)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(ignoreDestX)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(sourceY)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(ignoreDestY)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(sourceSpace)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(destSpace)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Recv, PPluginInstance::Msg_NPN_ConvertPoint__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            double destX;
            double destY;
            bool result;
            int32_t __id = mId;
            if ((!(AnswerNPN_ConvertPoint(sourceX, ignoreDestX, sourceY, ignoreDestY, sourceSpace, destSpace, (&(destX)), (&(destY)), (&(result)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for NPN_ConvertPoint returned error code");
                return MsgProcessingError;
            }

            __reply = new PPluginInstance::Reply_NPN_ConvertPoint();

            Write(destX, __reply);
            Write(destY, __reply);
            Write(result, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_rpc();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Reply_NPN_ConvertPoint*>(__reply))->Log("[PPluginInstanceParent] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    case PPluginInstance::Msg_NPN_InitAsyncSurface__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginInstance::Msg_NPN_InitAsyncSurface");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Msg_NPN_InitAsyncSurface*>((&(__msg))))->Log("[PPluginInstanceParent] Received ", stderr);
            }

            void* __iter = 0;
            gfxIntSize size;
            NPImageFormat format;

            if ((!(Read((&(size)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(format)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Recv, PPluginInstance::Msg_NPN_InitAsyncSurface__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            NPRemoteAsyncSurface surfData;
            bool result;
            int32_t __id = mId;
            if ((!(AnswerNPN_InitAsyncSurface(size, format, (&(surfData)), (&(result)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for NPN_InitAsyncSurface returned error code");
                return MsgProcessingError;
            }

            __reply = new PPluginInstance::Reply_NPN_InitAsyncSurface();

            Write(surfData, __reply);
            Write(result, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_rpc();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Reply_NPN_InitAsyncSurface*>(__reply))->Log("[PPluginInstanceParent] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    case PPluginInstance::Msg_PPluginStreamConstructor__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginInstance::Msg_PPluginStreamConstructor");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Msg_PPluginStreamConstructor*>((&(__msg))))->Log("[PPluginInstanceParent] Received ", stderr);
            }

            void* __iter = 0;
            ActorHandle __handle;
            PPluginStreamParent* actor;
            nsCString mimeType;
            nsCString target;

            if ((!(Read((&(__handle)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(mimeType)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(target)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Recv, PPluginInstance::Msg_PPluginStreamConstructor__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            NPError result;
            actor = AllocPPluginStream(mimeType, target, (&(result)));
            if ((!(actor))) {
                return MsgValueError;
            }
            (actor)->mId = RegisterID(actor, (__handle).mId);
            (actor)->mManager = this;
            (actor)->mChannel = mChannel;
            (mManagedPPluginStreamParent).InsertElementSorted(actor);
            (actor)->mState = mozilla::plugins::PPluginStream::__Start;

            int32_t __id = mId;
            if ((!(AnswerPPluginStreamConstructor(actor, mimeType, target, (&(result)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for PPluginStream returned error code");
                return MsgProcessingError;
            }
            __reply = new PPluginInstance::Reply_PPluginStreamConstructor();

            Write(result, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_rpc();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Reply_PPluginStreamConstructor*>(__reply))->Log("[PPluginInstanceParent] Sending reply ", stderr);
            }

            return MsgProcessed;
        }
    case PPluginInstance::Msg_PluginFocusChange__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginInstance::Msg_PluginFocusChange");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Msg_PluginFocusChange*>((&(__msg))))->Log("[PPluginInstanceParent] Received ", stderr);
            }

            void* __iter = 0;
            bool gotFocus;

            if ((!(Read((&(gotFocus)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Recv, PPluginInstance::Msg_PluginFocusChange__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            int32_t __id = mId;
            if ((!(AnswerPluginFocusChange(gotFocus)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for PluginFocusChange returned error code");
                return MsgProcessingError;
            }

            __reply = new PPluginInstance::Reply_PluginFocusChange();

            (__reply)->set_routing_id(__id);
            (__reply)->set_rpc();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Reply_PluginFocusChange*>(__reply))->Log("[PPluginInstanceParent] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    default:
        {
            return MsgNotKnown;
        }
    }
}

void
PPluginInstanceParent::OnProcessingError(Result code)
{
    NS_RUNTIMEABORT("`OnProcessingError' called on non-toplevel actor");
}

int32_t
PPluginInstanceParent::GetProtocolTypeId()
{
    return PPluginInstanceMsgStart;
}

bool
PPluginInstanceParent::OnReplyTimeout()
{
    NS_RUNTIMEABORT("`OnReplyTimeout' called on non-toplevel actor");
    return false;
}

void
PPluginInstanceParent::OnChannelClose()
{
    NS_RUNTIMEABORT("`OnClose' called on non-toplevel actor");
}

void
PPluginInstanceParent::OnChannelError()
{
    NS_RUNTIMEABORT("`OnError' called on non-toplevel actor");
}

void
PPluginInstanceParent::OnChannelConnected(int32_t pid)
{
    NS_RUNTIMEABORT("'OnConnected' called on non-toplevel actor");
}

bool
PPluginInstanceParent::AllocShmem(
        size_t aSize,
        Shmem::SharedMemory::SharedMemoryType aType,
        Shmem* aMem)
{
    Shmem::id_t aId;
    nsAutoPtr<Shmem::SharedMemory> rawmem(CreateSharedMemory(aSize, aType, false, (&(aId))));
    if ((!(rawmem))) {
        return false;
    }

    (*(aMem)) = Shmem(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(), (rawmem).forget(), aId);
    return true;
}

bool
PPluginInstanceParent::AllocUnsafeShmem(
        size_t aSize,
        Shmem::SharedMemory::SharedMemoryType aType,
        Shmem* aMem)
{
    Shmem::id_t aId;
    nsAutoPtr<Shmem::SharedMemory> rawmem(CreateSharedMemory(aSize, aType, true, (&(aId))));
    if ((!(rawmem))) {
        return false;
    }

    (*(aMem)) = Shmem(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(), (rawmem).forget(), aId);
    return true;
}

bool
PPluginInstanceParent::AdoptShmem(
        Shmem& aMem,
        Shmem* aOutMem)
{
    Shmem::SharedMemory* rawmem = (aMem).Segment(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead());
    if (((!(rawmem))) || (IsTrackingSharedMemory(rawmem))) {
        NS_RUNTIMEABORT("bad Shmem");
    }

    Shmem::id_t aId;
    if ((!(AdoptSharedMemory(rawmem, (&(aId)))))) {
        return false;
    }

    (*(aOutMem)) = Shmem(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(), rawmem, aId);
    return true;
}

bool
PPluginInstanceParent::DeallocShmem(Shmem& aMem)
{
    bool ok = DestroySharedMemory(aMem);
    (aMem).forget(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead());
    return ok;
}

void
PPluginInstanceParent::FatalError(const char* const msg) const
{
    // Virtual method to prevent inlining.
    // This give us better error reporting.
    // See bug 589371

    NS_ERROR("IPDL error:");
    NS_ERROR(msg);
    mozilla::ipc::ProtocolErrorBreakpoint(msg);

    NS_ERROR("[PPluginInstanceParent] killing child side as a result");

    if ((!(base::KillProcess(OtherProcess(), base::PROCESS_END_KILLED_BY_USER, false)))) {
        NS_ERROR("  may have failed to kill child!");
    }
}

void
PPluginInstanceParent::DestroySubtree(ActorDestroyReason why)
{
    // Unregister from our manager.
    Unregister(mId);
    mId = 1;

    ActorDestroyReason subtreewhy = (((why) == (Deletion)) || ((why) == (FailedConstructor)) ? AncestorDeletion : why);

    {
        // Recursively shutting down PPluginBackgroundDestroyer kids
        InfallibleTArray<PPluginBackgroundDestroyerParent*> kids(mManagedPPluginBackgroundDestroyerParent);
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DestroySubtree(subtreewhy);
        }
    }
    {
        // Recursively shutting down PPluginScriptableObject kids
        InfallibleTArray<PPluginScriptableObjectParent*> kids(mManagedPPluginScriptableObjectParent);
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DestroySubtree(subtreewhy);
        }
    }
    {
        // Recursively shutting down PBrowserStream kids
        InfallibleTArray<PBrowserStreamParent*> kids(mManagedPBrowserStreamParent);
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DestroySubtree(subtreewhy);
        }
    }
    {
        // Recursively shutting down PPluginStream kids
        InfallibleTArray<PPluginStreamParent*> kids(mManagedPPluginStreamParent);
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DestroySubtree(subtreewhy);
        }
    }
    {
        // Recursively shutting down PStreamNotify kids
        InfallibleTArray<PStreamNotifyParent*> kids(mManagedPStreamNotifyParent);
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DestroySubtree(subtreewhy);
        }
    }
    {
        // Recursively shutting down PPluginSurface kids
        InfallibleTArray<PPluginSurfaceParent*> kids(mManagedPPluginSurfaceParent);
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DestroySubtree(subtreewhy);
        }
    }

    // Finally, destroy "us".
    ActorDestroy(why);
}

void
PPluginInstanceParent::DeallocSubtree()
{
    {
        // Recursively deleting PPluginBackgroundDestroyer kids
        InfallibleTArray<PPluginBackgroundDestroyerParent*>& kids = mManagedPPluginBackgroundDestroyerParent;
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DeallocSubtree();
        }

        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            DeallocPPluginBackgroundDestroyer(kids[i]);
        }
        (mManagedPPluginBackgroundDestroyerParent).Clear();
    }
    {
        // Recursively deleting PPluginScriptableObject kids
        InfallibleTArray<PPluginScriptableObjectParent*>& kids = mManagedPPluginScriptableObjectParent;
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DeallocSubtree();
        }

        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            DeallocPPluginScriptableObject(kids[i]);
        }
        (mManagedPPluginScriptableObjectParent).Clear();
    }
    {
        // Recursively deleting PBrowserStream kids
        InfallibleTArray<PBrowserStreamParent*>& kids = mManagedPBrowserStreamParent;
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DeallocSubtree();
        }

        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            DeallocPBrowserStream(kids[i]);
        }
        (mManagedPBrowserStreamParent).Clear();
    }
    {
        // Recursively deleting PPluginStream kids
        InfallibleTArray<PPluginStreamParent*>& kids = mManagedPPluginStreamParent;
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DeallocSubtree();
        }

        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            DeallocPPluginStream(kids[i]);
        }
        (mManagedPPluginStreamParent).Clear();
    }
    {
        // Recursively deleting PStreamNotify kids
        InfallibleTArray<PStreamNotifyParent*>& kids = mManagedPStreamNotifyParent;
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DeallocSubtree();
        }

        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            DeallocPStreamNotify(kids[i]);
        }
        (mManagedPStreamNotifyParent).Clear();
    }
    {
        // Recursively deleting PPluginSurface kids
        InfallibleTArray<PPluginSurfaceParent*>& kids = mManagedPPluginSurfaceParent;
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DeallocSubtree();
        }

        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            DeallocPPluginSurface(kids[i]);
        }
        (mManagedPPluginSurfaceParent).Clear();
    }
}

void
PPluginInstanceParent::Write(
        const SurfaceDescriptor& __v,
        Message* __msg)
{
    typedef SurfaceDescriptor __type;
    Write(int((__v).type()), __msg);

    switch ((__v).type()) {
    case __type::TShmem:
        {
            Write((__v).get_Shmem(), __msg);
            return;
        }
    case __type::TSurfaceDescriptorX11:
        {
            Write((__v).get_SurfaceDescriptorX11(), __msg);
            return;
        }
    case __type::TPPluginSurfaceParent:
        {
            Write((__v).get_PPluginSurfaceParent(), __msg, false);
            return;
        }
    case __type::TPPluginSurfaceChild:
        {
            NS_RUNTIMEABORT("wrong side!");
            return;
        }
    case __type::TIOSurfaceDescriptor:
        {
            Write((__v).get_IOSurfaceDescriptor(), __msg);
            return;
        }
    case __type::Tnull_t:
        {
            Write((__v).get_null_t(), __msg);
            return;
        }
    default:
        {
            NS_RUNTIMEABORT("unknown union type");
            return;
        }
    }
}

bool
PPluginInstanceParent::Read(
        SurfaceDescriptor* __v,
        const Message* __msg,
        void** __iter)
{
    typedef SurfaceDescriptor __type;
    int type;
    if ((!(Read((&(type)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }

    switch (type) {
    case __type::TShmem:
        {
            Shmem tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_Shmem())), __msg, __iter);
        }
    case __type::TSurfaceDescriptorX11:
        {
            SurfaceDescriptorX11 tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_SurfaceDescriptorX11())), __msg, __iter);
        }
    case __type::TPPluginSurfaceParent:
        {
            return false;
        }
    case __type::TPPluginSurfaceChild:
        {
            PPluginSurfaceParent* tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_PPluginSurfaceParent())), __msg, __iter, false);
        }
    case __type::TIOSurfaceDescriptor:
        {
            IOSurfaceDescriptor tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_IOSurfaceDescriptor())), __msg, __iter);
        }
    case __type::Tnull_t:
        {
            null_t tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_null_t())), __msg, __iter);
        }
    default:
        {
            mozilla::ipc::ProtocolErrorBreakpoint("unknown union type");
            return false;
        }
    }
}

void
PPluginInstanceParent::Write(
        PPluginStreamParent* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PPluginInstanceParent::Read(
        PPluginStreamParent** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PPluginInstance");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PPluginStream");
        return false;
    }

    if ((PPluginStreamMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PPluginStream has different type");
        return false;
    }

    (*(__v)) = static_cast<PPluginStreamParent*>(listener);
    return true;
}

void
PPluginInstanceParent::Write(
        const NPRemoteAsyncSurface& __v,
        Message* __msg)
{
    Write((__v).version(), __msg);
    Write((__v).size(), __msg);
    Write((__v).format(), __msg);
    Write((__v).stride(), __msg);
    Write((__v).data(), __msg);
    Write((__v).hostPtr(), __msg);
}

bool
PPluginInstanceParent::Read(
        NPRemoteAsyncSurface* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->version())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->size())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->format())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->stride())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->data())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->hostPtr())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PPluginInstanceParent::Write(
        Shmem& __v,
        Message* __msg)
{
    IPC::WriteParam(__msg, __v);
    (__v).RevokeRights(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead());
    (__v).forget(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead());
}

bool
PPluginInstanceParent::Read(
        Shmem* __v,
        const Message* __msg,
        void** __iter)
{
    Shmem tmp;
    if ((!(IPC::ReadParam(__msg, __iter, (&(tmp)))))) {
        return false;
    }

    Shmem::id_t shmemid = (tmp).Id(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead());
    Shmem::SharedMemory* rawmem = LookupSharedMemory(shmemid);
    if (rawmem) {
        (*(__v)) = Shmem(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(), rawmem, shmemid);
        return true;
    }
    return false;
}

void
PPluginInstanceParent::Write(
        PPluginSurfaceParent* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PPluginInstanceParent::Read(
        PPluginSurfaceParent** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PPluginInstance");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PPluginSurface");
        return false;
    }

    if ((PPluginSurfaceMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PPluginSurface has different type");
        return false;
    }

    (*(__v)) = static_cast<PPluginSurfaceParent*>(listener);
    return true;
}

void
PPluginInstanceParent::Write(
        PPluginBackgroundDestroyerParent* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PPluginInstanceParent::Read(
        PPluginBackgroundDestroyerParent** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PPluginInstance");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PPluginBackgroundDestroyer");
        return false;
    }

    if ((PPluginBackgroundDestroyerMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PPluginBackgroundDestroyer has different type");
        return false;
    }

    (*(__v)) = static_cast<PPluginBackgroundDestroyerParent*>(listener);
    return true;
}

void
PPluginInstanceParent::Write(
        const IOSurfaceDescriptor& __v,
        Message* __msg)
{
    Write((__v).surfaceId(), __msg);
    Write((__v).contentsScaleFactor(), __msg);
}

bool
PPluginInstanceParent::Read(
        IOSurfaceDescriptor* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->surfaceId())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->contentsScaleFactor())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PPluginInstanceParent::Write(
        PBrowserStreamParent* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PPluginInstanceParent::Read(
        PBrowserStreamParent** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PPluginInstance");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PBrowserStream");
        return false;
    }

    if ((PBrowserStreamMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PBrowserStream has different type");
        return false;
    }

    (*(__v)) = static_cast<PBrowserStreamParent*>(listener);
    return true;
}

void
PPluginInstanceParent::Write(
        PPluginInstanceParent* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PPluginInstanceParent::Read(
        PPluginInstanceParent** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PPluginInstance");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PPluginInstance");
        return false;
    }

    if ((PPluginInstanceMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PPluginInstance has different type");
        return false;
    }

    (*(__v)) = static_cast<PPluginInstanceParent*>(listener);
    return true;
}

void
PPluginInstanceParent::Write(
        const OptionalShmem& __v,
        Message* __msg)
{
    typedef OptionalShmem __type;
    Write(int((__v).type()), __msg);

    switch ((__v).type()) {
    case __type::TShmem:
        {
            Write((__v).get_Shmem(), __msg);
            return;
        }
    case __type::Tnull_t:
        {
            Write((__v).get_null_t(), __msg);
            return;
        }
    default:
        {
            NS_RUNTIMEABORT("unknown union type");
            return;
        }
    }
}

bool
PPluginInstanceParent::Read(
        OptionalShmem* __v,
        const Message* __msg,
        void** __iter)
{
    typedef OptionalShmem __type;
    int type;
    if ((!(Read((&(type)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }

    switch (type) {
    case __type::TShmem:
        {
            Shmem tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_Shmem())), __msg, __iter);
        }
    case __type::Tnull_t:
        {
            null_t tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_null_t())), __msg, __iter);
        }
    default:
        {
            mozilla::ipc::ProtocolErrorBreakpoint("unknown union type");
            return false;
        }
    }
}

void
PPluginInstanceParent::Write(
        PStreamNotifyParent* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PPluginInstanceParent::Read(
        PStreamNotifyParent** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PPluginInstance");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PStreamNotify");
        return false;
    }

    if ((PStreamNotifyMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PStreamNotify has different type");
        return false;
    }

    (*(__v)) = static_cast<PStreamNotifyParent*>(listener);
    return true;
}

void
PPluginInstanceParent::Write(
        const AsyncSurfaceDescriptor& __v,
        Message* __msg)
{
    typedef AsyncSurfaceDescriptor __type;
    Write(int((__v).type()), __msg);

    switch ((__v).type()) {
    case __type::TShmem:
        {
            Write((__v).get_Shmem(), __msg);
            return;
        }
    case __type::TDXGISharedSurfaceHandle:
        {
            Write((__v).get_DXGISharedSurfaceHandle(), __msg);
            return;
        }
    default:
        {
            NS_RUNTIMEABORT("unknown union type");
            return;
        }
    }
}

bool
PPluginInstanceParent::Read(
        AsyncSurfaceDescriptor* __v,
        const Message* __msg,
        void** __iter)
{
    typedef AsyncSurfaceDescriptor __type;
    int type;
    if ((!(Read((&(type)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }

    switch (type) {
    case __type::TShmem:
        {
            Shmem tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_Shmem())), __msg, __iter);
        }
    case __type::TDXGISharedSurfaceHandle:
        {
            DXGISharedSurfaceHandle tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_DXGISharedSurfaceHandle())), __msg, __iter);
        }
    default:
        {
            mozilla::ipc::ProtocolErrorBreakpoint("unknown union type");
            return false;
        }
    }
}

void
PPluginInstanceParent::Write(
        PPluginScriptableObjectParent* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PPluginInstanceParent::Read(
        PPluginScriptableObjectParent** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PPluginInstance");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PPluginScriptableObject");
        return false;
    }

    if ((PPluginScriptableObjectMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PPluginScriptableObject has different type");
        return false;
    }

    (*(__v)) = static_cast<PPluginScriptableObjectParent*>(listener);
    return true;
}



} // namespace plugins
} // namespace mozilla
