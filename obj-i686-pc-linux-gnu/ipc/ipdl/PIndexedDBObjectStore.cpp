//
// Automatically generated by ipdlc.
// Edit at your own risk
//


#include "mozilla/dom/indexedDB/PIndexedDBObjectStore.h"

namespace mozilla {
namespace dom {
namespace indexedDB {
namespace PIndexedDBObjectStore {

bool
Transition(
        State from,
        mozilla::ipc::Trigger trigger,
        State* next)
{
    switch (from) {
    case __Null:
    case __Error:
        if ((Msg___delete____ID) == ((trigger).mMsg)) {
            (*(next)) = __Dead;
            return true;
        }
        return (__Null) == (from);
    case __Dead:
        NS_RUNTIMEABORT("__delete__()d actor");
        return false;
    case __Dying:
        NS_RUNTIMEABORT("__delete__()d (and unexpectedly dying) actor");
        return false;
    default:
        NS_RUNTIMEABORT("corrupted actor state");
        return false;
    }
    (*(next)) = __Error;
    return false;
}

} // namespace PIndexedDBObjectStore
} // namespace indexedDB
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct KeyRange|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
namespace ipc {
namespace FIXME_Bug_521898_objectstore {
KeyRange::KeyRange()
{
    Init();
}

KeyRange::~KeyRange()
{
}

bool
KeyRange::operator==(const KeyRange& _o) const
{
    if ((!((lower()) == ((_o).lower())))) {
        return false;
    }
    if ((!((upper()) == ((_o).upper())))) {
        return false;
    }
    if ((!((lowerOpen()) == ((_o).lowerOpen())))) {
        return false;
    }
    if ((!((upperOpen()) == ((_o).upperOpen())))) {
        return false;
    }
    if ((!((isOnly()) == ((_o).isOnly())))) {
        return false;
    }
    return true;
}

void
KeyRange::Init()
{
}

void
KeyRange::Assign(
        const Key& _lower,
        const Key& _upper,
        const bool& _lowerOpen,
        const bool& _upperOpen,
        const bool& _isOnly)
{
    lower_ = _lower;
    upper_ = _upper;
    lowerOpen_ = _lowerOpen;
    upperOpen_ = _upperOpen;
    isOnly_ = _isOnly;
}

} // namespace FIXME_Bug_521898_objectstore
} // namespace ipc
} // namespace indexedDB
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |union OptionalKeyRange|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
namespace ipc {
namespace FIXME_Bug_521898_objectstore {
bool
OptionalKeyRange::MaybeDestroy(Type aNewType)
{
    if ((mType) == (T__None)) {
        return true;
    }
    if ((mType) == (aNewType)) {
        return false;
    }
    switch (mType) {
    case TKeyRange:
        {
            (ptr_KeyRange())->~KeyRange__tdef();
            break;
        }
    case Tvoid_t:
        {
            (ptr_void_t())->~void_t__tdef();
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("not reached");
            break;
        }
    }
    return true;
}

OptionalKeyRange::OptionalKeyRange(const KeyRange& aOther)
{
    new (ptr_KeyRange()) KeyRange(aOther);
    mType = TKeyRange;
}

OptionalKeyRange::OptionalKeyRange(const void_t& aOther)
{
    new (ptr_void_t()) void_t(aOther);
    mType = Tvoid_t;
}

OptionalKeyRange::OptionalKeyRange(const OptionalKeyRange& aOther)
{
    (aOther).AssertSanity();
    switch ((aOther).type()) {
    case TKeyRange:
        {
            new (ptr_KeyRange()) KeyRange((aOther).get_KeyRange());
            break;
        }
    case Tvoid_t:
        {
            new (ptr_void_t()) void_t((aOther).get_void_t());
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return;
        }
    }
    mType = (aOther).type();
}

OptionalKeyRange::~OptionalKeyRange()
{
    MaybeDestroy(T__None);
}

OptionalKeyRange&
OptionalKeyRange::operator=(const KeyRange& aRhs)
{
    if (MaybeDestroy(TKeyRange)) {
        new (ptr_KeyRange()) KeyRange;
    }
    (*(ptr_KeyRange())) = aRhs;
    mType = TKeyRange;
    return (*(this));
}

OptionalKeyRange&
OptionalKeyRange::operator=(const void_t& aRhs)
{
    if (MaybeDestroy(Tvoid_t)) {
        new (ptr_void_t()) void_t;
    }
    (*(ptr_void_t())) = aRhs;
    mType = Tvoid_t;
    return (*(this));
}

OptionalKeyRange&
OptionalKeyRange::operator=(const OptionalKeyRange& aRhs)
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case TKeyRange:
        {
            if (MaybeDestroy(t)) {
                new (ptr_KeyRange()) KeyRange;
            }
            (*(ptr_KeyRange())) = (aRhs).get_KeyRange();
            break;
        }
    case Tvoid_t:
        {
            if (MaybeDestroy(t)) {
                new (ptr_void_t()) void_t;
            }
            (*(ptr_void_t())) = (aRhs).get_void_t();
            break;
        }
    case T__None:
        {
            MaybeDestroy(t);
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            break;
        }
    }
    mType = t;
    return (*(this));
}

bool
OptionalKeyRange::operator==(const KeyRange& aRhs) const
{
    return (get_KeyRange()) == (aRhs);
}

bool
OptionalKeyRange::operator==(const void_t& aRhs) const
{
    return (get_void_t()) == (aRhs);
}

bool
OptionalKeyRange::operator==(const OptionalKeyRange& aRhs) const
{
    if ((type()) != ((aRhs).type())) {
        return false;
    }

    switch (type()) {
    case TKeyRange:
        {
            return (get_KeyRange()) == ((aRhs).get_KeyRange());
        }
    case Tvoid_t:
        {
            return (get_void_t()) == ((aRhs).get_void_t());
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return false;
        }
    }
}

} // namespace FIXME_Bug_521898_objectstore
} // namespace ipc
} // namespace indexedDB
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct GetParams|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
namespace ipc {
namespace FIXME_Bug_521898_objectstore {
GetParams::GetParams()
{
    Init();
}

GetParams::~GetParams()
{
}

bool
GetParams::operator==(const GetParams& _o) const
{
    if ((!((keyRange()) == ((_o).keyRange())))) {
        return false;
    }
    return true;
}

void
GetParams::Init()
{
}

void
GetParams::Assign(const KeyRange& _keyRange)
{
    keyRange_ = _keyRange;
}

} // namespace FIXME_Bug_521898_objectstore
} // namespace ipc
} // namespace indexedDB
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct GetAllParams|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
namespace ipc {
namespace FIXME_Bug_521898_objectstore {
GetAllParams::GetAllParams()
{
    Init();
}

GetAllParams::~GetAllParams()
{
}

bool
GetAllParams::operator==(const GetAllParams& _o) const
{
    if ((!((optionalKeyRange()) == ((_o).optionalKeyRange())))) {
        return false;
    }
    if ((!((limit()) == ((_o).limit())))) {
        return false;
    }
    return true;
}

void
GetAllParams::Init()
{
}

void
GetAllParams::Assign(
        const OptionalKeyRange& _optionalKeyRange,
        const uint32_t& _limit)
{
    optionalKeyRange_ = _optionalKeyRange;
    limit_ = _limit;
}

} // namespace FIXME_Bug_521898_objectstore
} // namespace ipc
} // namespace indexedDB
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct CountParams|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
namespace ipc {
namespace FIXME_Bug_521898_objectstore {
CountParams::CountParams()
{
    Init();
}

CountParams::~CountParams()
{
}

bool
CountParams::operator==(const CountParams& _o) const
{
    if ((!((optionalKeyRange()) == ((_o).optionalKeyRange())))) {
        return false;
    }
    return true;
}

void
CountParams::Init()
{
}

void
CountParams::Assign(const OptionalKeyRange& _optionalKeyRange)
{
    optionalKeyRange_ = _optionalKeyRange;
}

} // namespace FIXME_Bug_521898_objectstore
} // namespace ipc
} // namespace indexedDB
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct OpenCursorParams|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
namespace ipc {
namespace FIXME_Bug_521898_objectstore {
OpenCursorParams::OpenCursorParams()
{
    Init();
}

OpenCursorParams::~OpenCursorParams()
{
}

bool
OpenCursorParams::operator==(const OpenCursorParams& _o) const
{
    if ((!((optionalKeyRange()) == ((_o).optionalKeyRange())))) {
        return false;
    }
    if ((!((direction()) == ((_o).direction())))) {
        return false;
    }
    return true;
}

void
OpenCursorParams::Init()
{
}

void
OpenCursorParams::Assign(
        const OptionalKeyRange& _optionalKeyRange,
        const Direction& _direction)
{
    optionalKeyRange_ = _optionalKeyRange;
    direction_ = _direction;
}

} // namespace FIXME_Bug_521898_objectstore
} // namespace ipc
} // namespace indexedDB
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct AddPutParams|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
namespace ipc {
AddPutParams::AddPutParams()
{
    Init();
}

AddPutParams::~AddPutParams()
{
}

bool
AddPutParams::operator==(const AddPutParams& _o) const
{
    if ((!((cloneInfo()) == ((_o).cloneInfo())))) {
        return false;
    }
    if ((!((key()) == ((_o).key())))) {
        return false;
    }
    if ((!((indexUpdateInfos()) == ((_o).indexUpdateInfos())))) {
        return false;
    }
    if ((!((blobsParent()) == ((_o).blobsParent())))) {
        return false;
    }
    if ((!((blobsChild()) == ((_o).blobsChild())))) {
        return false;
    }
    return true;
}

void
AddPutParams::Init()
{
}

void
AddPutParams::Assign(
        const SerializedStructuredCloneWriteInfo& _cloneInfo,
        const Key& _key,
        const InfallibleTArray<IndexUpdateInfo>& _indexUpdateInfos,
        const InfallibleTArray<PBlobParent*>& _blobsParent,
        const InfallibleTArray<PBlobChild*>& _blobsChild)
{
    cloneInfo_ = _cloneInfo;
    key_ = _key;
    indexUpdateInfos_ = _indexUpdateInfos;
    blobsParent_ = _blobsParent;
    blobsChild_ = _blobsChild;
}

} // namespace ipc
} // namespace indexedDB
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct AddParams|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
namespace ipc {
AddParams::AddParams()
{
    Init();
}

AddParams::~AddParams()
{
}

bool
AddParams::operator==(const AddParams& _o) const
{
    if ((!((commonParams()) == ((_o).commonParams())))) {
        return false;
    }
    return true;
}

void
AddParams::Init()
{
}

void
AddParams::Assign(const AddPutParams& _commonParams)
{
    commonParams_ = _commonParams;
}

} // namespace ipc
} // namespace indexedDB
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct PutParams|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
namespace ipc {
PutParams::PutParams()
{
    Init();
}

PutParams::~PutParams()
{
}

bool
PutParams::operator==(const PutParams& _o) const
{
    if ((!((commonParams()) == ((_o).commonParams())))) {
        return false;
    }
    return true;
}

void
PutParams::Init()
{
}

void
PutParams::Assign(const AddPutParams& _commonParams)
{
    commonParams_ = _commonParams;
}

} // namespace ipc
} // namespace indexedDB
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct DeleteParams|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
namespace ipc {
DeleteParams::DeleteParams()
{
    Init();
}

DeleteParams::~DeleteParams()
{
}

bool
DeleteParams::operator==(const DeleteParams& _o) const
{
    if ((!((keyRange()) == ((_o).keyRange())))) {
        return false;
    }
    return true;
}

void
DeleteParams::Init()
{
}

void
DeleteParams::Assign(const KeyRange& _keyRange)
{
    keyRange_ = _keyRange;
}

} // namespace ipc
} // namespace indexedDB
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct ClearParams|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
namespace ipc {
ClearParams::ClearParams()
{
    Init();
}

ClearParams::~ClearParams()
{
}

bool
ClearParams::operator==(const ClearParams& _o) const
{
    if ((!((FIXME_Bug_753159()) == ((_o).FIXME_Bug_753159())))) {
        return false;
    }
    return true;
}

void
ClearParams::Init()
{
}

void
ClearParams::Assign(const void_t& _FIXME_Bug_753159)
{
    FIXME_Bug_753159_ = _FIXME_Bug_753159;
}

} // namespace ipc
} // namespace indexedDB
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |union ObjectStoreRequestParams|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
namespace ipc {
bool
ObjectStoreRequestParams::MaybeDestroy(Type aNewType)
{
    if ((mType) == (T__None)) {
        return true;
    }
    if ((mType) == (aNewType)) {
        return false;
    }
    switch (mType) {
    case TGetParams:
        {
            (ptr_GetParams())->~GetParams__tdef();
            break;
        }
    case TGetAllParams:
        {
            (ptr_GetAllParams())->~GetAllParams__tdef();
            break;
        }
    case TAddParams:
        {
            (ptr_AddParams())->~AddParams__tdef();
            break;
        }
    case TPutParams:
        {
            (ptr_PutParams())->~PutParams__tdef();
            break;
        }
    case TDeleteParams:
        {
            (ptr_DeleteParams())->~DeleteParams__tdef();
            break;
        }
    case TClearParams:
        {
            (ptr_ClearParams())->~ClearParams__tdef();
            break;
        }
    case TCountParams:
        {
            (ptr_CountParams())->~CountParams__tdef();
            break;
        }
    case TOpenCursorParams:
        {
            (ptr_OpenCursorParams())->~OpenCursorParams__tdef();
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("not reached");
            break;
        }
    }
    return true;
}

ObjectStoreRequestParams::ObjectStoreRequestParams(const GetParams& aOther)
{
    new (ptr_GetParams()) GetParams(aOther);
    mType = TGetParams;
}

ObjectStoreRequestParams::ObjectStoreRequestParams(const GetAllParams& aOther)
{
    new (ptr_GetAllParams()) GetAllParams(aOther);
    mType = TGetAllParams;
}

ObjectStoreRequestParams::ObjectStoreRequestParams(const AddParams& aOther)
{
    new (ptr_AddParams()) AddParams(aOther);
    mType = TAddParams;
}

ObjectStoreRequestParams::ObjectStoreRequestParams(const PutParams& aOther)
{
    new (ptr_PutParams()) PutParams(aOther);
    mType = TPutParams;
}

ObjectStoreRequestParams::ObjectStoreRequestParams(const DeleteParams& aOther)
{
    new (ptr_DeleteParams()) DeleteParams(aOther);
    mType = TDeleteParams;
}

ObjectStoreRequestParams::ObjectStoreRequestParams(const ClearParams& aOther)
{
    new (ptr_ClearParams()) ClearParams(aOther);
    mType = TClearParams;
}

ObjectStoreRequestParams::ObjectStoreRequestParams(const CountParams& aOther)
{
    new (ptr_CountParams()) CountParams(aOther);
    mType = TCountParams;
}

ObjectStoreRequestParams::ObjectStoreRequestParams(const OpenCursorParams& aOther)
{
    new (ptr_OpenCursorParams()) OpenCursorParams(aOther);
    mType = TOpenCursorParams;
}

ObjectStoreRequestParams::ObjectStoreRequestParams(const ObjectStoreRequestParams& aOther)
{
    (aOther).AssertSanity();
    switch ((aOther).type()) {
    case TGetParams:
        {
            new (ptr_GetParams()) GetParams((aOther).get_GetParams());
            break;
        }
    case TGetAllParams:
        {
            new (ptr_GetAllParams()) GetAllParams((aOther).get_GetAllParams());
            break;
        }
    case TAddParams:
        {
            new (ptr_AddParams()) AddParams((aOther).get_AddParams());
            break;
        }
    case TPutParams:
        {
            new (ptr_PutParams()) PutParams((aOther).get_PutParams());
            break;
        }
    case TDeleteParams:
        {
            new (ptr_DeleteParams()) DeleteParams((aOther).get_DeleteParams());
            break;
        }
    case TClearParams:
        {
            new (ptr_ClearParams()) ClearParams((aOther).get_ClearParams());
            break;
        }
    case TCountParams:
        {
            new (ptr_CountParams()) CountParams((aOther).get_CountParams());
            break;
        }
    case TOpenCursorParams:
        {
            new (ptr_OpenCursorParams()) OpenCursorParams((aOther).get_OpenCursorParams());
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return;
        }
    }
    mType = (aOther).type();
}

ObjectStoreRequestParams::~ObjectStoreRequestParams()
{
    MaybeDestroy(T__None);
}

ObjectStoreRequestParams&
ObjectStoreRequestParams::operator=(const GetParams& aRhs)
{
    if (MaybeDestroy(TGetParams)) {
        new (ptr_GetParams()) GetParams;
    }
    (*(ptr_GetParams())) = aRhs;
    mType = TGetParams;
    return (*(this));
}

ObjectStoreRequestParams&
ObjectStoreRequestParams::operator=(const GetAllParams& aRhs)
{
    if (MaybeDestroy(TGetAllParams)) {
        new (ptr_GetAllParams()) GetAllParams;
    }
    (*(ptr_GetAllParams())) = aRhs;
    mType = TGetAllParams;
    return (*(this));
}

ObjectStoreRequestParams&
ObjectStoreRequestParams::operator=(const AddParams& aRhs)
{
    if (MaybeDestroy(TAddParams)) {
        new (ptr_AddParams()) AddParams;
    }
    (*(ptr_AddParams())) = aRhs;
    mType = TAddParams;
    return (*(this));
}

ObjectStoreRequestParams&
ObjectStoreRequestParams::operator=(const PutParams& aRhs)
{
    if (MaybeDestroy(TPutParams)) {
        new (ptr_PutParams()) PutParams;
    }
    (*(ptr_PutParams())) = aRhs;
    mType = TPutParams;
    return (*(this));
}

ObjectStoreRequestParams&
ObjectStoreRequestParams::operator=(const DeleteParams& aRhs)
{
    if (MaybeDestroy(TDeleteParams)) {
        new (ptr_DeleteParams()) DeleteParams;
    }
    (*(ptr_DeleteParams())) = aRhs;
    mType = TDeleteParams;
    return (*(this));
}

ObjectStoreRequestParams&
ObjectStoreRequestParams::operator=(const ClearParams& aRhs)
{
    if (MaybeDestroy(TClearParams)) {
        new (ptr_ClearParams()) ClearParams;
    }
    (*(ptr_ClearParams())) = aRhs;
    mType = TClearParams;
    return (*(this));
}

ObjectStoreRequestParams&
ObjectStoreRequestParams::operator=(const CountParams& aRhs)
{
    if (MaybeDestroy(TCountParams)) {
        new (ptr_CountParams()) CountParams;
    }
    (*(ptr_CountParams())) = aRhs;
    mType = TCountParams;
    return (*(this));
}

ObjectStoreRequestParams&
ObjectStoreRequestParams::operator=(const OpenCursorParams& aRhs)
{
    if (MaybeDestroy(TOpenCursorParams)) {
        new (ptr_OpenCursorParams()) OpenCursorParams;
    }
    (*(ptr_OpenCursorParams())) = aRhs;
    mType = TOpenCursorParams;
    return (*(this));
}

ObjectStoreRequestParams&
ObjectStoreRequestParams::operator=(const ObjectStoreRequestParams& aRhs)
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case TGetParams:
        {
            if (MaybeDestroy(t)) {
                new (ptr_GetParams()) GetParams;
            }
            (*(ptr_GetParams())) = (aRhs).get_GetParams();
            break;
        }
    case TGetAllParams:
        {
            if (MaybeDestroy(t)) {
                new (ptr_GetAllParams()) GetAllParams;
            }
            (*(ptr_GetAllParams())) = (aRhs).get_GetAllParams();
            break;
        }
    case TAddParams:
        {
            if (MaybeDestroy(t)) {
                new (ptr_AddParams()) AddParams;
            }
            (*(ptr_AddParams())) = (aRhs).get_AddParams();
            break;
        }
    case TPutParams:
        {
            if (MaybeDestroy(t)) {
                new (ptr_PutParams()) PutParams;
            }
            (*(ptr_PutParams())) = (aRhs).get_PutParams();
            break;
        }
    case TDeleteParams:
        {
            if (MaybeDestroy(t)) {
                new (ptr_DeleteParams()) DeleteParams;
            }
            (*(ptr_DeleteParams())) = (aRhs).get_DeleteParams();
            break;
        }
    case TClearParams:
        {
            if (MaybeDestroy(t)) {
                new (ptr_ClearParams()) ClearParams;
            }
            (*(ptr_ClearParams())) = (aRhs).get_ClearParams();
            break;
        }
    case TCountParams:
        {
            if (MaybeDestroy(t)) {
                new (ptr_CountParams()) CountParams;
            }
            (*(ptr_CountParams())) = (aRhs).get_CountParams();
            break;
        }
    case TOpenCursorParams:
        {
            if (MaybeDestroy(t)) {
                new (ptr_OpenCursorParams()) OpenCursorParams;
            }
            (*(ptr_OpenCursorParams())) = (aRhs).get_OpenCursorParams();
            break;
        }
    case T__None:
        {
            MaybeDestroy(t);
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            break;
        }
    }
    mType = t;
    return (*(this));
}

bool
ObjectStoreRequestParams::operator==(const GetParams& aRhs) const
{
    return (get_GetParams()) == (aRhs);
}

bool
ObjectStoreRequestParams::operator==(const GetAllParams& aRhs) const
{
    return (get_GetAllParams()) == (aRhs);
}

bool
ObjectStoreRequestParams::operator==(const AddParams& aRhs) const
{
    return (get_AddParams()) == (aRhs);
}

bool
ObjectStoreRequestParams::operator==(const PutParams& aRhs) const
{
    return (get_PutParams()) == (aRhs);
}

bool
ObjectStoreRequestParams::operator==(const DeleteParams& aRhs) const
{
    return (get_DeleteParams()) == (aRhs);
}

bool
ObjectStoreRequestParams::operator==(const ClearParams& aRhs) const
{
    return (get_ClearParams()) == (aRhs);
}

bool
ObjectStoreRequestParams::operator==(const CountParams& aRhs) const
{
    return (get_CountParams()) == (aRhs);
}

bool
ObjectStoreRequestParams::operator==(const OpenCursorParams& aRhs) const
{
    return (get_OpenCursorParams()) == (aRhs);
}

bool
ObjectStoreRequestParams::operator==(const ObjectStoreRequestParams& aRhs) const
{
    if ((type()) != ((aRhs).type())) {
        return false;
    }

    switch (type()) {
    case TGetParams:
        {
            return (get_GetParams()) == ((aRhs).get_GetParams());
        }
    case TGetAllParams:
        {
            return (get_GetAllParams()) == ((aRhs).get_GetAllParams());
        }
    case TAddParams:
        {
            return (get_AddParams()) == ((aRhs).get_AddParams());
        }
    case TPutParams:
        {
            return (get_PutParams()) == ((aRhs).get_PutParams());
        }
    case TDeleteParams:
        {
            return (get_DeleteParams()) == ((aRhs).get_DeleteParams());
        }
    case TClearParams:
        {
            return (get_ClearParams()) == ((aRhs).get_ClearParams());
        }
    case TCountParams:
        {
            return (get_CountParams()) == ((aRhs).get_CountParams());
        }
    case TOpenCursorParams:
        {
            return (get_OpenCursorParams()) == ((aRhs).get_OpenCursorParams());
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return false;
        }
    }
}

} // namespace ipc
} // namespace indexedDB
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct CreateIndexParams|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
namespace ipc {
CreateIndexParams::CreateIndexParams()
{
    Init();
}

CreateIndexParams::~CreateIndexParams()
{
}

bool
CreateIndexParams::operator==(const CreateIndexParams& _o) const
{
    if ((!((info()) == ((_o).info())))) {
        return false;
    }
    return true;
}

void
CreateIndexParams::Init()
{
}

void
CreateIndexParams::Assign(const IndexInfo& _info)
{
    info_ = _info;
}

} // namespace ipc
} // namespace indexedDB
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct GetIndexParams|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
namespace ipc {
GetIndexParams::GetIndexParams()
{
    Init();
}

GetIndexParams::~GetIndexParams()
{
}

bool
GetIndexParams::operator==(const GetIndexParams& _o) const
{
    if ((!((name()) == ((_o).name())))) {
        return false;
    }
    return true;
}

void
GetIndexParams::Init()
{
}

void
GetIndexParams::Assign(const nsString& _name)
{
    name_ = _name;
}

} // namespace ipc
} // namespace indexedDB
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |union IndexConstructorParams|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
namespace ipc {
bool
IndexConstructorParams::MaybeDestroy(Type aNewType)
{
    if ((mType) == (T__None)) {
        return true;
    }
    if ((mType) == (aNewType)) {
        return false;
    }
    switch (mType) {
    case TCreateIndexParams:
        {
            (ptr_CreateIndexParams())->~CreateIndexParams__tdef();
            break;
        }
    case TGetIndexParams:
        {
            (ptr_GetIndexParams())->~GetIndexParams__tdef();
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("not reached");
            break;
        }
    }
    return true;
}

IndexConstructorParams::IndexConstructorParams(const CreateIndexParams& aOther)
{
    new (ptr_CreateIndexParams()) CreateIndexParams(aOther);
    mType = TCreateIndexParams;
}

IndexConstructorParams::IndexConstructorParams(const GetIndexParams& aOther)
{
    new (ptr_GetIndexParams()) GetIndexParams(aOther);
    mType = TGetIndexParams;
}

IndexConstructorParams::IndexConstructorParams(const IndexConstructorParams& aOther)
{
    (aOther).AssertSanity();
    switch ((aOther).type()) {
    case TCreateIndexParams:
        {
            new (ptr_CreateIndexParams()) CreateIndexParams((aOther).get_CreateIndexParams());
            break;
        }
    case TGetIndexParams:
        {
            new (ptr_GetIndexParams()) GetIndexParams((aOther).get_GetIndexParams());
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return;
        }
    }
    mType = (aOther).type();
}

IndexConstructorParams::~IndexConstructorParams()
{
    MaybeDestroy(T__None);
}

IndexConstructorParams&
IndexConstructorParams::operator=(const CreateIndexParams& aRhs)
{
    if (MaybeDestroy(TCreateIndexParams)) {
        new (ptr_CreateIndexParams()) CreateIndexParams;
    }
    (*(ptr_CreateIndexParams())) = aRhs;
    mType = TCreateIndexParams;
    return (*(this));
}

IndexConstructorParams&
IndexConstructorParams::operator=(const GetIndexParams& aRhs)
{
    if (MaybeDestroy(TGetIndexParams)) {
        new (ptr_GetIndexParams()) GetIndexParams;
    }
    (*(ptr_GetIndexParams())) = aRhs;
    mType = TGetIndexParams;
    return (*(this));
}

IndexConstructorParams&
IndexConstructorParams::operator=(const IndexConstructorParams& aRhs)
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case TCreateIndexParams:
        {
            if (MaybeDestroy(t)) {
                new (ptr_CreateIndexParams()) CreateIndexParams;
            }
            (*(ptr_CreateIndexParams())) = (aRhs).get_CreateIndexParams();
            break;
        }
    case TGetIndexParams:
        {
            if (MaybeDestroy(t)) {
                new (ptr_GetIndexParams()) GetIndexParams;
            }
            (*(ptr_GetIndexParams())) = (aRhs).get_GetIndexParams();
            break;
        }
    case T__None:
        {
            MaybeDestroy(t);
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            break;
        }
    }
    mType = t;
    return (*(this));
}

bool
IndexConstructorParams::operator==(const CreateIndexParams& aRhs) const
{
    return (get_CreateIndexParams()) == (aRhs);
}

bool
IndexConstructorParams::operator==(const GetIndexParams& aRhs) const
{
    return (get_GetIndexParams()) == (aRhs);
}

bool
IndexConstructorParams::operator==(const IndexConstructorParams& aRhs) const
{
    if ((type()) != ((aRhs).type())) {
        return false;
    }

    switch (type()) {
    case TCreateIndexParams:
        {
            return (get_CreateIndexParams()) == ((aRhs).get_CreateIndexParams());
        }
    case TGetIndexParams:
        {
            return (get_GetIndexParams()) == ((aRhs).get_GetIndexParams());
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return false;
        }
    }
}

} // namespace ipc
} // namespace indexedDB
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct ObjectStoreCursorConstructorParams|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
namespace ipc {
ObjectStoreCursorConstructorParams::ObjectStoreCursorConstructorParams()
{
    Init();
}

ObjectStoreCursorConstructorParams::~ObjectStoreCursorConstructorParams()
{
}

bool
ObjectStoreCursorConstructorParams::operator==(const ObjectStoreCursorConstructorParams& _o) const
{
    if ((!((requestParent()) == ((_o).requestParent())))) {
        return false;
    }
    if ((!((requestChild()) == ((_o).requestChild())))) {
        return false;
    }
    if ((!((direction()) == ((_o).direction())))) {
        return false;
    }
    if ((!((key()) == ((_o).key())))) {
        return false;
    }
    if ((!((cloneInfo()) == ((_o).cloneInfo())))) {
        return false;
    }
    if ((!((blobsParent()) == ((_o).blobsParent())))) {
        return false;
    }
    if ((!((blobsChild()) == ((_o).blobsChild())))) {
        return false;
    }
    return true;
}

void
ObjectStoreCursorConstructorParams::Init()
{
    requestParent_ = 0;
    requestChild_ = 0;
}

void
ObjectStoreCursorConstructorParams::Assign(
        PIndexedDBRequestParent* _requestParent,
        PIndexedDBRequestChild* _requestChild,
        const Direction& _direction,
        const Key& _key,
        const SerializedStructuredCloneReadInfo& _cloneInfo,
        const InfallibleTArray<PBlobParent*>& _blobsParent,
        const InfallibleTArray<PBlobChild*>& _blobsChild)
{
    requestParent_ = _requestParent;
    requestChild_ = _requestChild;
    direction_ = _direction;
    key_ = _key;
    cloneInfo_ = _cloneInfo;
    blobsParent_ = _blobsParent;
    blobsChild_ = _blobsChild;
}

} // namespace ipc
} // namespace indexedDB
} // namespace dom
} // namespace mozilla
