//
// Automatically generated by ipdlc.
// Edit at your own risk
//


#include "mozilla/dom/PBrowserParent.h"

#include "mozilla/dom/PBlobParent.h"
#include "mozilla/dom/PContentParent.h"
#include "mozilla/dom/PContentDialogParent.h"
#include "mozilla/ipc/PDocumentRendererParent.h"
#include "mozilla/dom/PContentPermissionRequestParent.h"
#include "mozilla/layout/PRenderFrameParent.h"
#include "mozilla/docshell/POfflineCacheUpdateParent.h"
#include "mozilla/dom/indexedDB/PIndexedDBParent.h"

typedef IPC::Message Message;
typedef mozilla::ipc::RPCChannel Channel;
typedef mozilla::ipc::RPCChannel::RPCListener ChannelListener;
typedef base::ProcessHandle ProcessHandle;
typedef mozilla::ipc::AsyncChannel AsyncChannel;
typedef mozilla::ipc::SharedMemory SharedMemory;
typedef mozilla::ipc::Trigger Trigger;
typedef mozilla::ipc::ActorHandle ActorHandle;
typedef mozilla::dom::ClonedMessageData ClonedMessageData;
typedef mozilla::dom::FileBlobConstructorParams FileBlobConstructorParams;
typedef mozilla::ipc::FileDescriptor FileDescriptor;
typedef mozilla::layers::FrameMetrics FrameMetrics;
typedef mozilla::ipc::GenericURIParams GenericURIParams;
typedef mozilla::ipc::JARURIParams JARURIParams;
typedef mozilla::layers::LayersBackend LayersBackend;
typedef mozilla::dom::NormalBlobConstructorParams NormalBlobConstructorParams;
typedef mozilla::ipc::OptionalURIParams OptionalURIParams;
typedef IPC::Principal Principal;
typedef mozilla::dom::ScreenOrientation ScreenOrientation;
typedef mozilla::layout::ScrollingBehavior ScrollingBehavior;
typedef mozilla::SerializedStructuredCloneBuffer SerializedStructuredCloneBuffer;
typedef mozilla::ipc::Shmem Shmem;
typedef mozilla::ipc::SimpleURIParams SimpleURIParams;
typedef mozilla::ipc::StandardURLParams StandardURLParams;
typedef mozilla::ipc::StandardURLSegment StandardURLSegment;
typedef mozilla::ipc::URIParams URIParams;
typedef mozilla::widget::WheelEvent WheelEvent;
typedef mozilla::WindowsHandle WindowsHandle;
typedef mozilla::void_t void_t;
using mozilla::dom::PBlobParent;
using mozilla::dom::PContentParent;
using mozilla::dom::PContentDialogParent;
using mozilla::ipc::PDocumentRendererParent;
using mozilla::dom::PContentPermissionRequestParent;
using mozilla::layout::PRenderFrameParent;
using mozilla::docshell::POfflineCacheUpdateParent;
using mozilla::dom::indexedDB::PIndexedDBParent;

namespace mozilla {
namespace dom {


bool
PBrowserParent::RecvPContentPermissionRequestConstructor(
        PContentPermissionRequestParent* actor,
        const nsCString& aType,
        const nsCString& aAccess,
        const Principal& principal)
{
    return true;
}

bool
PBrowserParent::RecvPContentDialogConstructor(
        PContentDialogParent* actor,
        const uint32_t& aType,
        const nsCString& aName,
        const nsCString& aFeatures,
        const InfallibleTArray<int32_t>& aIntParams,
        const InfallibleTArray<nsString>& aStringParams)
{
    return true;
}

bool
PBrowserParent::RecvPRenderFrameConstructor(
        PRenderFrameParent* actor,
        ScrollingBehavior* scrolling,
        LayersBackend* backend,
        int32_t* maxTextureSize,
        uint64_t* layersId)
{
    return true;
}

bool
PBrowserParent::RecvPOfflineCacheUpdateConstructor(
        POfflineCacheUpdateParent* actor,
        const URIParams& manifestURI,
        const URIParams& documentURI,
        const bool& stickDocument)
{
    return true;
}

bool
PBrowserParent::RecvPIndexedDBConstructor(
        PIndexedDBParent* actor,
        const nsCString& asciiOrigin,
        bool* allowed)
{
    return true;
}

bool
PBrowserParent::Recv__delete__()
{
    return true;
}

void
PBrowserParent::ActorDestroy(ActorDestroyReason why)
{
}

PBrowserParent::PBrowserParent() :
    mId(0),
    mState(PBrowser::__Dead)
{
    MOZ_COUNT_CTOR(PBrowserParent);
}

PBrowserParent::~PBrowserParent()
{
    MOZ_COUNT_DTOR(PBrowserParent);
}

PContentParent*
PBrowserParent::Manager() const
{
    return static_cast<PContentParent*>(mManager);
}

void
PBrowserParent::ManagedPContentDialogParent(InfallibleTArray<PContentDialogParent*>& aArr) const
{
    aArr = mManagedPContentDialogParent;
}

const InfallibleTArray<PContentDialogParent*>&
PBrowserParent::ManagedPContentDialogParent() const
{
    return mManagedPContentDialogParent;
}

void
PBrowserParent::ManagedPDocumentRendererParent(InfallibleTArray<PDocumentRendererParent*>& aArr) const
{
    aArr = mManagedPDocumentRendererParent;
}

const InfallibleTArray<PDocumentRendererParent*>&
PBrowserParent::ManagedPDocumentRendererParent() const
{
    return mManagedPDocumentRendererParent;
}

void
PBrowserParent::ManagedPContentPermissionRequestParent(InfallibleTArray<PContentPermissionRequestParent*>& aArr) const
{
    aArr = mManagedPContentPermissionRequestParent;
}

const InfallibleTArray<PContentPermissionRequestParent*>&
PBrowserParent::ManagedPContentPermissionRequestParent() const
{
    return mManagedPContentPermissionRequestParent;
}

void
PBrowserParent::ManagedPRenderFrameParent(InfallibleTArray<PRenderFrameParent*>& aArr) const
{
    aArr = mManagedPRenderFrameParent;
}

const InfallibleTArray<PRenderFrameParent*>&
PBrowserParent::ManagedPRenderFrameParent() const
{
    return mManagedPRenderFrameParent;
}

void
PBrowserParent::ManagedPOfflineCacheUpdateParent(InfallibleTArray<POfflineCacheUpdateParent*>& aArr) const
{
    aArr = mManagedPOfflineCacheUpdateParent;
}

const InfallibleTArray<POfflineCacheUpdateParent*>&
PBrowserParent::ManagedPOfflineCacheUpdateParent() const
{
    return mManagedPOfflineCacheUpdateParent;
}

void
PBrowserParent::ManagedPIndexedDBParent(InfallibleTArray<PIndexedDBParent*>& aArr) const
{
    aArr = mManagedPIndexedDBParent;
}

const InfallibleTArray<PIndexedDBParent*>&
PBrowserParent::ManagedPIndexedDBParent() const
{
    return mManagedPIndexedDBParent;
}

PBrowser::State
PBrowserParent::state()
{
    return mState;
}

bool
PBrowserParent::SendAsyncMessage(
        const nsString& aMessage,
        const ClonedMessageData& aData)
{
    PBrowser::Msg_AsyncMessage* __msg = new PBrowser::Msg_AsyncMessage();

    Write(aMessage, __msg);
    Write(aData, __msg);

    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PBrowserParent] Sending ", stderr);
    }
    if ((!(PBrowser::Transition(mState, Trigger(Trigger::Send, PBrowser::Msg_AsyncMessage__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

bool
PBrowserParent::SendShow(const nsIntSize& size)
{
    PBrowser::Msg_Show* __msg = new PBrowser::Msg_Show();

    Write(size, __msg);

    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PBrowserParent] Sending ", stderr);
    }
    if ((!(PBrowser::Transition(mState, Trigger(Trigger::Send, PBrowser::Msg_Show__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

bool
PBrowserParent::SendLoadURL(const nsCString& uri)
{
    PBrowser::Msg_LoadURL* __msg = new PBrowser::Msg_LoadURL();

    Write(uri, __msg);

    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PBrowserParent] Sending ", stderr);
    }
    if ((!(PBrowser::Transition(mState, Trigger(Trigger::Send, PBrowser::Msg_LoadURL__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

bool
PBrowserParent::SendUpdateDimensions(
        const nsRect& rect,
        const nsIntSize& size,
        const ScreenOrientation& orientation)
{
    PBrowser::Msg_UpdateDimensions* __msg = new PBrowser::Msg_UpdateDimensions();

    Write(rect, __msg);
    Write(size, __msg);
    Write(orientation, __msg);

    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PBrowserParent] Sending ", stderr);
    }
    if ((!(PBrowser::Transition(mState, Trigger(Trigger::Send, PBrowser::Msg_UpdateDimensions__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

bool
PBrowserParent::SendUpdateFrame(const FrameMetrics& frame)
{
    PBrowser::Msg_UpdateFrame* __msg = new PBrowser::Msg_UpdateFrame();

    Write(frame, __msg);

    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PBrowserParent] Sending ", stderr);
    }
    if ((!(PBrowser::Transition(mState, Trigger(Trigger::Send, PBrowser::Msg_UpdateFrame__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

bool
PBrowserParent::SendHandleDoubleTap(const nsIntPoint& point)
{
    PBrowser::Msg_HandleDoubleTap* __msg = new PBrowser::Msg_HandleDoubleTap();

    Write(point, __msg);

    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PBrowserParent] Sending ", stderr);
    }
    if ((!(PBrowser::Transition(mState, Trigger(Trigger::Send, PBrowser::Msg_HandleDoubleTap__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

bool
PBrowserParent::SendHandleSingleTap(const nsIntPoint& point)
{
    PBrowser::Msg_HandleSingleTap* __msg = new PBrowser::Msg_HandleSingleTap();

    Write(point, __msg);

    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PBrowserParent] Sending ", stderr);
    }
    if ((!(PBrowser::Transition(mState, Trigger(Trigger::Send, PBrowser::Msg_HandleSingleTap__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

bool
PBrowserParent::SendHandleLongTap(const nsIntPoint& point)
{
    PBrowser::Msg_HandleLongTap* __msg = new PBrowser::Msg_HandleLongTap();

    Write(point, __msg);

    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PBrowserParent] Sending ", stderr);
    }
    if ((!(PBrowser::Transition(mState, Trigger(Trigger::Send, PBrowser::Msg_HandleLongTap__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

bool
PBrowserParent::SendActivate()
{
    PBrowser::Msg_Activate* __msg = new PBrowser::Msg_Activate();


    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PBrowserParent] Sending ", stderr);
    }
    if ((!(PBrowser::Transition(mState, Trigger(Trigger::Send, PBrowser::Msg_Activate__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

bool
PBrowserParent::SendDeactivate()
{
    PBrowser::Msg_Deactivate* __msg = new PBrowser::Msg_Deactivate();


    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PBrowserParent] Sending ", stderr);
    }
    if ((!(PBrowser::Transition(mState, Trigger(Trigger::Send, PBrowser::Msg_Deactivate__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

bool
PBrowserParent::SendMouseEvent(
        const nsString& aType,
        const float& aX,
        const float& aY,
        const int32_t& aButton,
        const int32_t& aClickCount,
        const int32_t& aModifiers,
        const bool& aIgnoreRootScrollFrame)
{
    PBrowser::Msg_MouseEvent* __msg = new PBrowser::Msg_MouseEvent();

    Write(aType, __msg);
    Write(aX, __msg);
    Write(aY, __msg);
    Write(aButton, __msg);
    Write(aClickCount, __msg);
    Write(aModifiers, __msg);
    Write(aIgnoreRootScrollFrame, __msg);

    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PBrowserParent] Sending ", stderr);
    }
    if ((!(PBrowser::Transition(mState, Trigger(Trigger::Send, PBrowser::Msg_MouseEvent__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

bool
PBrowserParent::SendRealMouseEvent(const nsMouseEvent& event)
{
    PBrowser::Msg_RealMouseEvent* __msg = new PBrowser::Msg_RealMouseEvent();

    Write(event, __msg);

    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PBrowserParent] Sending ", stderr);
    }
    if ((!(PBrowser::Transition(mState, Trigger(Trigger::Send, PBrowser::Msg_RealMouseEvent__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

bool
PBrowserParent::SendRealKeyEvent(const nsKeyEvent& event)
{
    PBrowser::Msg_RealKeyEvent* __msg = new PBrowser::Msg_RealKeyEvent();

    Write(event, __msg);

    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PBrowserParent] Sending ", stderr);
    }
    if ((!(PBrowser::Transition(mState, Trigger(Trigger::Send, PBrowser::Msg_RealKeyEvent__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

bool
PBrowserParent::SendMouseWheelEvent(const WheelEvent& event)
{
    PBrowser::Msg_MouseWheelEvent* __msg = new PBrowser::Msg_MouseWheelEvent();

    Write(event, __msg);

    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PBrowserParent] Sending ", stderr);
    }
    if ((!(PBrowser::Transition(mState, Trigger(Trigger::Send, PBrowser::Msg_MouseWheelEvent__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

bool
PBrowserParent::SendRealTouchEvent(const nsTouchEvent& event)
{
    PBrowser::Msg_RealTouchEvent* __msg = new PBrowser::Msg_RealTouchEvent();

    Write(event, __msg);

    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PBrowserParent] Sending ", stderr);
    }
    if ((!(PBrowser::Transition(mState, Trigger(Trigger::Send, PBrowser::Msg_RealTouchEvent__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

bool
PBrowserParent::SendRealTouchMoveEvent(const nsTouchEvent& event)
{
    PBrowser::Msg_RealTouchMoveEvent* __msg = new PBrowser::Msg_RealTouchMoveEvent();

    Write(event, __msg);

    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PBrowserParent] Sending ", stderr);
    }
    if ((!(PBrowser::Transition(mState, Trigger(Trigger::Send, PBrowser::Msg_RealTouchMoveEvent__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

bool
PBrowserParent::SendKeyEvent(
        const nsString& aType,
        const int32_t& aKeyCode,
        const int32_t& aCharCode,
        const int32_t& aModifiers,
        const bool& aPreventDefault)
{
    PBrowser::Msg_KeyEvent* __msg = new PBrowser::Msg_KeyEvent();

    Write(aType, __msg);
    Write(aKeyCode, __msg);
    Write(aCharCode, __msg);
    Write(aModifiers, __msg);
    Write(aPreventDefault, __msg);

    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PBrowserParent] Sending ", stderr);
    }
    if ((!(PBrowser::Transition(mState, Trigger(Trigger::Send, PBrowser::Msg_KeyEvent__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

bool
PBrowserParent::SendCompositionEvent(const nsCompositionEvent& event)
{
    PBrowser::Msg_CompositionEvent* __msg = new PBrowser::Msg_CompositionEvent();

    Write(event, __msg);

    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PBrowserParent] Sending ", stderr);
    }
    if ((!(PBrowser::Transition(mState, Trigger(Trigger::Send, PBrowser::Msg_CompositionEvent__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

bool
PBrowserParent::SendTextEvent(const nsTextEvent& event)
{
    PBrowser::Msg_TextEvent* __msg = new PBrowser::Msg_TextEvent();

    Write(event, __msg);

    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PBrowserParent] Sending ", stderr);
    }
    if ((!(PBrowser::Transition(mState, Trigger(Trigger::Send, PBrowser::Msg_TextEvent__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

bool
PBrowserParent::SendSelectionEvent(const nsSelectionEvent& event)
{
    PBrowser::Msg_SelectionEvent* __msg = new PBrowser::Msg_SelectionEvent();

    Write(event, __msg);

    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PBrowserParent] Sending ", stderr);
    }
    if ((!(PBrowser::Transition(mState, Trigger(Trigger::Send, PBrowser::Msg_SelectionEvent__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

bool
PBrowserParent::SendActivateFrameEvent(
        const nsString& aType,
        const bool& capture)
{
    PBrowser::Msg_ActivateFrameEvent* __msg = new PBrowser::Msg_ActivateFrameEvent();

    Write(aType, __msg);
    Write(capture, __msg);

    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PBrowserParent] Sending ", stderr);
    }
    if ((!(PBrowser::Transition(mState, Trigger(Trigger::Send, PBrowser::Msg_ActivateFrameEvent__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

bool
PBrowserParent::SendLoadRemoteScript(const nsString& aURL)
{
    PBrowser::Msg_LoadRemoteScript* __msg = new PBrowser::Msg_LoadRemoteScript();

    Write(aURL, __msg);

    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PBrowserParent] Sending ", stderr);
    }
    if ((!(PBrowser::Transition(mState, Trigger(Trigger::Send, PBrowser::Msg_LoadRemoteScript__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

PDocumentRendererParent*
PBrowserParent::SendPDocumentRendererConstructor(
        const nsRect& documentRect,
        const gfxMatrix& transform,
        const nsString& bgcolor,
        const uint32_t& renderFlags,
        const bool& flushLayout,
        const nsIntSize& renderSize)
{
    return SendPDocumentRendererConstructor(AllocPDocumentRenderer(documentRect, transform, bgcolor, renderFlags, flushLayout, renderSize), documentRect, transform, bgcolor, renderFlags, flushLayout, renderSize);
}

PDocumentRendererParent*
PBrowserParent::SendPDocumentRendererConstructor(
        PDocumentRendererParent* actor,
        const nsRect& documentRect,
        const gfxMatrix& transform,
        const nsString& bgcolor,
        const uint32_t& renderFlags,
        const bool& flushLayout,
        const nsIntSize& renderSize)
{
    if ((!(actor))) {
        return 0;
    }
    (actor)->mId = Register(actor);
    (actor)->mManager = this;
    (actor)->mChannel = mChannel;
    (mManagedPDocumentRendererParent).InsertElementSorted(actor);
    (actor)->mState = mozilla::ipc::PDocumentRenderer::__Start;

    PBrowser::Msg_PDocumentRendererConstructor* __msg = new PBrowser::Msg_PDocumentRendererConstructor();

    Write(actor, __msg, false);
    Write(documentRect, __msg);
    Write(transform, __msg);
    Write(bgcolor, __msg);
    Write(renderFlags, __msg);
    Write(flushLayout, __msg);
    Write(renderSize, __msg);

    (__msg)->set_routing_id(mId);


    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PBrowserParent] Sending ", stderr);
    }
    if ((!(PBrowser::Transition(mState, Trigger(Trigger::Send, PBrowser::Msg_PDocumentRendererConstructor__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    if ((!(__sendok))) {
        (actor)->DestroySubtree(FailedConstructor);
        (actor)->DeallocSubtree();
        ((actor)->mManager)->RemoveManagee(PDocumentRendererMsgStart, actor);
        return 0;
    }
    return actor;
}

bool
PBrowserParent::SendSetAppType(const nsString& appType)
{
    PBrowser::Msg_SetAppType* __msg = new PBrowser::Msg_SetAppType();

    Write(appType, __msg);

    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PBrowserParent] Sending ", stderr);
    }
    if ((!(PBrowser::Transition(mState, Trigger(Trigger::Send, PBrowser::Msg_SetAppType__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

bool
PBrowserParent::SendDestroy()
{
    PBrowser::Msg_Destroy* __msg = new PBrowser::Msg_Destroy();


    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PBrowserParent] Sending ", stderr);
    }
    if ((!(PBrowser::Transition(mState, Trigger(Trigger::Send, PBrowser::Msg_Destroy__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

int32_t
PBrowserParent::Register(ChannelListener* aRouted)
{
    return (mManager)->Register(aRouted);
}

int32_t
PBrowserParent::RegisterID(
        ChannelListener* aRouted,
        int32_t aId)
{
    return (mManager)->RegisterID(aRouted, aId);
}

ChannelListener*
PBrowserParent::Lookup(int32_t aId)
{
    return (mManager)->Lookup(aId);
}

void
PBrowserParent::Unregister(int32_t aId)
{
    return (mManager)->Unregister(aId);
}

void
PBrowserParent::RemoveManagee(
        int32_t aProtocolId,
        ChannelListener* aListener)
{
    switch (aProtocolId) {
    case PContentDialogMsgStart:
        {
            PContentDialogParent* actor = static_cast<PContentDialogParent*>(aListener);
            NS_ABORT_IF_FALSE(((mManagedPContentDialogParent).NoIndex) != ((mManagedPContentDialogParent).BinaryIndexOf(actor)), "actor not managed by this!");

            (mManagedPContentDialogParent).RemoveElementSorted(actor);
            DeallocPContentDialog(actor);
            return;
        }
    case PDocumentRendererMsgStart:
        {
            PDocumentRendererParent* actor = static_cast<PDocumentRendererParent*>(aListener);
            NS_ABORT_IF_FALSE(((mManagedPDocumentRendererParent).NoIndex) != ((mManagedPDocumentRendererParent).BinaryIndexOf(actor)), "actor not managed by this!");

            (mManagedPDocumentRendererParent).RemoveElementSorted(actor);
            DeallocPDocumentRenderer(actor);
            return;
        }
    case PContentPermissionRequestMsgStart:
        {
            PContentPermissionRequestParent* actor = static_cast<PContentPermissionRequestParent*>(aListener);
            NS_ABORT_IF_FALSE(((mManagedPContentPermissionRequestParent).NoIndex) != ((mManagedPContentPermissionRequestParent).BinaryIndexOf(actor)), "actor not managed by this!");

            (mManagedPContentPermissionRequestParent).RemoveElementSorted(actor);
            DeallocPContentPermissionRequest(actor);
            return;
        }
    case PRenderFrameMsgStart:
        {
            PRenderFrameParent* actor = static_cast<PRenderFrameParent*>(aListener);
            NS_ABORT_IF_FALSE(((mManagedPRenderFrameParent).NoIndex) != ((mManagedPRenderFrameParent).BinaryIndexOf(actor)), "actor not managed by this!");

            (mManagedPRenderFrameParent).RemoveElementSorted(actor);
            DeallocPRenderFrame(actor);
            return;
        }
    case POfflineCacheUpdateMsgStart:
        {
            POfflineCacheUpdateParent* actor = static_cast<POfflineCacheUpdateParent*>(aListener);
            NS_ABORT_IF_FALSE(((mManagedPOfflineCacheUpdateParent).NoIndex) != ((mManagedPOfflineCacheUpdateParent).BinaryIndexOf(actor)), "actor not managed by this!");

            (mManagedPOfflineCacheUpdateParent).RemoveElementSorted(actor);
            DeallocPOfflineCacheUpdate(actor);
            return;
        }
    case PIndexedDBMsgStart:
        {
            PIndexedDBParent* actor = static_cast<PIndexedDBParent*>(aListener);
            NS_ABORT_IF_FALSE(((mManagedPIndexedDBParent).NoIndex) != ((mManagedPIndexedDBParent).BinaryIndexOf(actor)), "actor not managed by this!");

            (mManagedPIndexedDBParent).RemoveElementSorted(actor);
            DeallocPIndexedDB(actor);
            return;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return;
        }
    }
}

Shmem::SharedMemory*
PBrowserParent::CreateSharedMemory(
        size_t aSize,
        Shmem::SharedMemory::SharedMemoryType aType,
        bool aUnsafe,
        Shmem::id_t* aId)
{
    return (mManager)->CreateSharedMemory(aSize, aType, aUnsafe, aId);
}

bool
PBrowserParent::AdoptSharedMemory(
        Shmem::SharedMemory* segment,
        Shmem::id_t* aId)
{
    return (mManager)->AdoptSharedMemory(segment, aId);
}

Shmem::SharedMemory*
PBrowserParent::LookupSharedMemory(Shmem::id_t aId)
{
    return (mManager)->LookupSharedMemory(aId);
}

bool
PBrowserParent::IsTrackingSharedMemory(Shmem::SharedMemory* segment)
{
    return (mManager)->IsTrackingSharedMemory(segment);
}

bool
PBrowserParent::DestroySharedMemory(Shmem& shmem)
{
    return (mManager)->DestroySharedMemory(shmem);
}

ProcessHandle
PBrowserParent::OtherProcess() const
{
    return (mManager)->OtherProcess();
}

AsyncChannel*
PBrowserParent::GetIPCChannel()
{
    return mChannel;
}

PBrowserParent::Result
PBrowserParent::OnMessageReceived(const Message& __msg)
{
    switch ((__msg).type()) {
    case PBrowser::Msg_AsyncMessage__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PBrowser::Msg_AsyncMessage");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PBrowser::Msg_AsyncMessage*>((&(__msg))))->Log("[PBrowserParent] Received ", stderr);
            }

            void* __iter = 0;
            nsString aMessage;
            ClonedMessageData aData;

            if ((!(Read((&(aMessage)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(aData)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PBrowser::Transition(mState, Trigger(Trigger::Recv, PBrowser::Msg_AsyncMessage__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvAsyncMessage(aMessage, aData)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for AsyncMessage returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBrowser::Msg_MoveFocus__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PBrowser::Msg_MoveFocus");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PBrowser::Msg_MoveFocus*>((&(__msg))))->Log("[PBrowserParent] Received ", stderr);
            }

            void* __iter = 0;
            bool forward;

            if ((!(Read((&(forward)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PBrowser::Transition(mState, Trigger(Trigger::Recv, PBrowser::Msg_MoveFocus__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvMoveFocus(forward)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for MoveFocus returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBrowser::Msg_Event__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PBrowser::Msg_Event");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PBrowser::Msg_Event*>((&(__msg))))->Log("[PBrowserParent] Received ", stderr);
            }

            void* __iter = 0;
            RemoteDOMEvent aEvent;

            if ((!(Read((&(aEvent)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PBrowser::Transition(mState, Trigger(Trigger::Recv, PBrowser::Msg_Event__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvEvent(aEvent)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for Event returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBrowser::Msg_NotifyIMETextChange__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PBrowser::Msg_NotifyIMETextChange");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PBrowser::Msg_NotifyIMETextChange*>((&(__msg))))->Log("[PBrowserParent] Received ", stderr);
            }

            void* __iter = 0;
            uint32_t offset;
            uint32_t end;
            uint32_t newEnd;

            if ((!(Read((&(offset)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(end)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(newEnd)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PBrowser::Transition(mState, Trigger(Trigger::Recv, PBrowser::Msg_NotifyIMETextChange__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvNotifyIMETextChange(offset, end, newEnd)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for NotifyIMETextChange returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBrowser::Msg_NotifyIMESelection__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PBrowser::Msg_NotifyIMESelection");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PBrowser::Msg_NotifyIMESelection*>((&(__msg))))->Log("[PBrowserParent] Received ", stderr);
            }

            void* __iter = 0;
            uint32_t seqno;
            uint32_t anchor;
            uint32_t focus;

            if ((!(Read((&(seqno)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(anchor)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(focus)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PBrowser::Transition(mState, Trigger(Trigger::Recv, PBrowser::Msg_NotifyIMESelection__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvNotifyIMESelection(seqno, anchor, focus)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for NotifyIMESelection returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBrowser::Msg_NotifyIMETextHint__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PBrowser::Msg_NotifyIMETextHint");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PBrowser::Msg_NotifyIMETextHint*>((&(__msg))))->Log("[PBrowserParent] Received ", stderr);
            }

            void* __iter = 0;
            nsString text;

            if ((!(Read((&(text)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PBrowser::Transition(mState, Trigger(Trigger::Recv, PBrowser::Msg_NotifyIMETextHint__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvNotifyIMETextHint(text)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for NotifyIMETextHint returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBrowser::Msg_SetInputContext__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PBrowser::Msg_SetInputContext");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PBrowser::Msg_SetInputContext*>((&(__msg))))->Log("[PBrowserParent] Received ", stderr);
            }

            void* __iter = 0;
            int32_t IMEEnabled;
            int32_t IMEOpen;
            nsString type;
            nsString inputmode;
            nsString actionHint;
            int32_t cause;
            int32_t focusChange;

            if ((!(Read((&(IMEEnabled)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(IMEOpen)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(type)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(inputmode)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(actionHint)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(cause)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(focusChange)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PBrowser::Transition(mState, Trigger(Trigger::Recv, PBrowser::Msg_SetInputContext__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvSetInputContext(IMEEnabled, IMEOpen, type, inputmode, actionHint, cause, focusChange)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for SetInputContext returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBrowser::Msg_SetCursor__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PBrowser::Msg_SetCursor");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PBrowser::Msg_SetCursor*>((&(__msg))))->Log("[PBrowserParent] Received ", stderr);
            }

            void* __iter = 0;
            uint32_t value;

            if ((!(Read((&(value)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PBrowser::Transition(mState, Trigger(Trigger::Recv, PBrowser::Msg_SetCursor__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvSetCursor(value)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for SetCursor returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBrowser::Msg_SetBackgroundColor__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PBrowser::Msg_SetBackgroundColor");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PBrowser::Msg_SetBackgroundColor*>((&(__msg))))->Log("[PBrowserParent] Received ", stderr);
            }

            void* __iter = 0;
            nscolor color;

            if ((!(Read((&(color)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PBrowser::Transition(mState, Trigger(Trigger::Recv, PBrowser::Msg_SetBackgroundColor__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvSetBackgroundColor(color)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for SetBackgroundColor returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBrowser::Msg_PContentPermissionRequestConstructor__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PBrowser::Msg_PContentPermissionRequestConstructor");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PBrowser::Msg_PContentPermissionRequestConstructor*>((&(__msg))))->Log("[PBrowserParent] Received ", stderr);
            }

            void* __iter = 0;
            ActorHandle __handle;
            PContentPermissionRequestParent* actor;
            nsCString aType;
            nsCString aAccess;
            Principal principal;

            if ((!(Read((&(__handle)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(aType)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(aAccess)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(principal)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PBrowser::Transition(mState, Trigger(Trigger::Recv, PBrowser::Msg_PContentPermissionRequestConstructor__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            actor = AllocPContentPermissionRequest(aType, aAccess, principal);
            if ((!(actor))) {
                return MsgValueError;
            }
            (actor)->mId = RegisterID(actor, (__handle).mId);
            (actor)->mManager = this;
            (actor)->mChannel = mChannel;
            (mManagedPContentPermissionRequestParent).InsertElementSorted(actor);
            (actor)->mState = mozilla::dom::PContentPermissionRequest::__Start;

            if ((!(RecvPContentPermissionRequestConstructor(actor, aType, aAccess, principal)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for PContentPermissionRequest returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBrowser::Msg_PContentDialogConstructor__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PBrowser::Msg_PContentDialogConstructor");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PBrowser::Msg_PContentDialogConstructor*>((&(__msg))))->Log("[PBrowserParent] Received ", stderr);
            }

            void* __iter = 0;
            ActorHandle __handle;
            PContentDialogParent* actor;
            uint32_t aType;
            nsCString aName;
            nsCString aFeatures;
            InfallibleTArray<int32_t> aIntParams;
            InfallibleTArray<nsString> aStringParams;

            if ((!(Read((&(__handle)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(aType)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(aName)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(aFeatures)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(aIntParams)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(aStringParams)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PBrowser::Transition(mState, Trigger(Trigger::Recv, PBrowser::Msg_PContentDialogConstructor__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            actor = AllocPContentDialog(aType, aName, aFeatures, aIntParams, aStringParams);
            if ((!(actor))) {
                return MsgValueError;
            }
            (actor)->mId = RegisterID(actor, (__handle).mId);
            (actor)->mManager = this;
            (actor)->mChannel = mChannel;
            (mManagedPContentDialogParent).InsertElementSorted(actor);
            (actor)->mState = mozilla::dom::PContentDialog::__Start;

            if ((!(RecvPContentDialogConstructor(actor, aType, aName, aFeatures, aIntParams, aStringParams)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for PContentDialog returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBrowser::Msg_POfflineCacheUpdateConstructor__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PBrowser::Msg_POfflineCacheUpdateConstructor");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PBrowser::Msg_POfflineCacheUpdateConstructor*>((&(__msg))))->Log("[PBrowserParent] Received ", stderr);
            }

            void* __iter = 0;
            ActorHandle __handle;
            POfflineCacheUpdateParent* actor;
            URIParams manifestURI;
            URIParams documentURI;
            bool stickDocument;

            if ((!(Read((&(__handle)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(manifestURI)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(documentURI)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(stickDocument)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PBrowser::Transition(mState, Trigger(Trigger::Recv, PBrowser::Msg_POfflineCacheUpdateConstructor__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            actor = AllocPOfflineCacheUpdate(manifestURI, documentURI, stickDocument);
            if ((!(actor))) {
                return MsgValueError;
            }
            (actor)->mId = RegisterID(actor, (__handle).mId);
            (actor)->mManager = this;
            (actor)->mChannel = mChannel;
            (mManagedPOfflineCacheUpdateParent).InsertElementSorted(actor);
            (actor)->mState = mozilla::docshell::POfflineCacheUpdate::__Start;

            if ((!(RecvPOfflineCacheUpdateConstructor(actor, manifestURI, documentURI, stickDocument)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for POfflineCacheUpdate returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBrowser::Msg_ZoomToRect__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PBrowser::Msg_ZoomToRect");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PBrowser::Msg_ZoomToRect*>((&(__msg))))->Log("[PBrowserParent] Received ", stderr);
            }

            void* __iter = 0;
            gfxRect aRect;

            if ((!(Read((&(aRect)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PBrowser::Transition(mState, Trigger(Trigger::Recv, PBrowser::Msg_ZoomToRect__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvZoomToRect(aRect)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for ZoomToRect returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBrowser::Msg_ContentReceivedTouch__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PBrowser::Msg_ContentReceivedTouch");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PBrowser::Msg_ContentReceivedTouch*>((&(__msg))))->Log("[PBrowserParent] Received ", stderr);
            }

            void* __iter = 0;
            bool aPreventDefault;

            if ((!(Read((&(aPreventDefault)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PBrowser::Transition(mState, Trigger(Trigger::Recv, PBrowser::Msg_ContentReceivedTouch__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvContentReceivedTouch(aPreventDefault)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for ContentReceivedTouch returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBrowser::Msg_UpdateZoomConstraints__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PBrowser::Msg_UpdateZoomConstraints");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PBrowser::Msg_UpdateZoomConstraints*>((&(__msg))))->Log("[PBrowserParent] Received ", stderr);
            }

            void* __iter = 0;
            bool aAllowZoom;
            float aMinZoom;
            float aMaxZoom;

            if ((!(Read((&(aAllowZoom)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(aMinZoom)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(aMaxZoom)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PBrowser::Transition(mState, Trigger(Trigger::Recv, PBrowser::Msg_UpdateZoomConstraints__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvUpdateZoomConstraints(aAllowZoom, aMinZoom, aMaxZoom)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for UpdateZoomConstraints returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBrowser::Msg___delete____ID:
        {
            (const_cast<Message&>(__msg)).set_name("PBrowser::Msg___delete__");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PBrowser::Msg___delete__*>((&(__msg))))->Log("[PBrowserParent] Received ", stderr);
            }

            void* __iter = 0;
            PBrowserParent* actor;

            if ((!(Read((&(actor)), (&(__msg)), (&(__iter)), false)))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PBrowser::Transition(mState, Trigger(Trigger::Recv, PBrowser::Msg___delete____ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(Recv__delete__()))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for __delete__ returned error code");
                return MsgProcessingError;
            }

            (actor)->DestroySubtree(Deletion);
            (actor)->DeallocSubtree();
            ((actor)->mManager)->RemoveManagee(PBrowserMsgStart, actor);


            return MsgProcessed;
        }
    case PBrowser::Reply_PDocumentRendererConstructor__ID:
        {
            return MsgProcessed;
        }
    default:
        {
            return MsgNotKnown;
        }
    }
}

PBrowserParent::Result
PBrowserParent::OnMessageReceived(
        const Message& __msg,
        Message*& __reply)
{
    switch ((__msg).type()) {
    case PBrowser::Msg_SyncMessage__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PBrowser::Msg_SyncMessage");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PBrowser::Msg_SyncMessage*>((&(__msg))))->Log("[PBrowserParent] Received ", stderr);
            }

            void* __iter = 0;
            nsString aMessage;
            ClonedMessageData aData;

            if ((!(Read((&(aMessage)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(aData)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PBrowser::Transition(mState, Trigger(Trigger::Recv, PBrowser::Msg_SyncMessage__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            InfallibleTArray<nsString> retval;
            int32_t __id = mId;
            if ((!(RecvSyncMessage(aMessage, aData, (&(retval)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for SyncMessage returned error code");
                return MsgProcessingError;
            }

            __reply = new PBrowser::Reply_SyncMessage();

            Write(retval, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_sync();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PBrowser::Reply_SyncMessage*>(__reply))->Log("[PBrowserParent] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    case PBrowser::Msg_NotifyIMEFocus__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PBrowser::Msg_NotifyIMEFocus");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PBrowser::Msg_NotifyIMEFocus*>((&(__msg))))->Log("[PBrowserParent] Received ", stderr);
            }

            void* __iter = 0;
            bool focus;

            if ((!(Read((&(focus)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PBrowser::Transition(mState, Trigger(Trigger::Recv, PBrowser::Msg_NotifyIMEFocus__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            nsIMEUpdatePreference preference;
            uint32_t seqno;
            int32_t __id = mId;
            if ((!(RecvNotifyIMEFocus(focus, (&(preference)), (&(seqno)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for NotifyIMEFocus returned error code");
                return MsgProcessingError;
            }

            __reply = new PBrowser::Reply_NotifyIMEFocus();

            Write(preference, __reply);
            Write(seqno, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_sync();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PBrowser::Reply_NotifyIMEFocus*>(__reply))->Log("[PBrowserParent] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    case PBrowser::Msg_EndIMEComposition__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PBrowser::Msg_EndIMEComposition");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PBrowser::Msg_EndIMEComposition*>((&(__msg))))->Log("[PBrowserParent] Received ", stderr);
            }

            void* __iter = 0;
            bool cancel;

            if ((!(Read((&(cancel)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PBrowser::Transition(mState, Trigger(Trigger::Recv, PBrowser::Msg_EndIMEComposition__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            nsString composition;
            int32_t __id = mId;
            if ((!(RecvEndIMEComposition(cancel, (&(composition)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for EndIMEComposition returned error code");
                return MsgProcessingError;
            }

            __reply = new PBrowser::Reply_EndIMEComposition();

            Write(composition, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_sync();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PBrowser::Reply_EndIMEComposition*>(__reply))->Log("[PBrowserParent] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    case PBrowser::Msg_GetInputContext__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PBrowser::Msg_GetInputContext");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PBrowser::Msg_GetInputContext*>((&(__msg))))->Log("[PBrowserParent] Received ", stderr);
            }

            if ((!(PBrowser::Transition(mState, Trigger(Trigger::Recv, PBrowser::Msg_GetInputContext__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            int32_t IMEEnabled;
            int32_t IMEOpen;
            intptr_t NativeIMEContext;
            int32_t __id = mId;
            if ((!(RecvGetInputContext((&(IMEEnabled)), (&(IMEOpen)), (&(NativeIMEContext)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for GetInputContext returned error code");
                return MsgProcessingError;
            }

            __reply = new PBrowser::Reply_GetInputContext();

            Write(IMEEnabled, __reply);
            Write(IMEOpen, __reply);
            Write(NativeIMEContext, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_sync();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PBrowser::Reply_GetInputContext*>(__reply))->Log("[PBrowserParent] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    case PBrowser::Msg_GetDPI__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PBrowser::Msg_GetDPI");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PBrowser::Msg_GetDPI*>((&(__msg))))->Log("[PBrowserParent] Received ", stderr);
            }

            if ((!(PBrowser::Transition(mState, Trigger(Trigger::Recv, PBrowser::Msg_GetDPI__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            float value;
            int32_t __id = mId;
            if ((!(RecvGetDPI((&(value)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for GetDPI returned error code");
                return MsgProcessingError;
            }

            __reply = new PBrowser::Reply_GetDPI();

            Write(value, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_sync();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PBrowser::Reply_GetDPI*>(__reply))->Log("[PBrowserParent] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    case PBrowser::Msg_GetWidgetNativeData__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PBrowser::Msg_GetWidgetNativeData");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PBrowser::Msg_GetWidgetNativeData*>((&(__msg))))->Log("[PBrowserParent] Received ", stderr);
            }

            if ((!(PBrowser::Transition(mState, Trigger(Trigger::Recv, PBrowser::Msg_GetWidgetNativeData__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            WindowsHandle value;
            int32_t __id = mId;
            if ((!(RecvGetWidgetNativeData((&(value)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for GetWidgetNativeData returned error code");
                return MsgProcessingError;
            }

            __reply = new PBrowser::Reply_GetWidgetNativeData();

            Write(value, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_sync();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PBrowser::Reply_GetWidgetNativeData*>(__reply))->Log("[PBrowserParent] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    case PBrowser::Msg_PRenderFrameConstructor__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PBrowser::Msg_PRenderFrameConstructor");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PBrowser::Msg_PRenderFrameConstructor*>((&(__msg))))->Log("[PBrowserParent] Received ", stderr);
            }

            void* __iter = 0;
            ActorHandle __handle;
            PRenderFrameParent* actor;

            if ((!(Read((&(__handle)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PBrowser::Transition(mState, Trigger(Trigger::Recv, PBrowser::Msg_PRenderFrameConstructor__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            ScrollingBehavior scrolling;
            LayersBackend backend;
            int32_t maxTextureSize;
            uint64_t layersId;
            actor = AllocPRenderFrame((&(scrolling)), (&(backend)), (&(maxTextureSize)), (&(layersId)));
            if ((!(actor))) {
                return MsgValueError;
            }
            (actor)->mId = RegisterID(actor, (__handle).mId);
            (actor)->mManager = this;
            (actor)->mChannel = mChannel;
            (mManagedPRenderFrameParent).InsertElementSorted(actor);
            (actor)->mState = mozilla::layout::PRenderFrame::__Start;

            int32_t __id = mId;
            if ((!(RecvPRenderFrameConstructor(actor, (&(scrolling)), (&(backend)), (&(maxTextureSize)), (&(layersId)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for PRenderFrame returned error code");
                return MsgProcessingError;
            }
            __reply = new PBrowser::Reply_PRenderFrameConstructor();

            Write(scrolling, __reply);
            Write(backend, __reply);
            Write(maxTextureSize, __reply);
            Write(layersId, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_sync();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PBrowser::Reply_PRenderFrameConstructor*>(__reply))->Log("[PBrowserParent] Sending reply ", stderr);
            }

            return MsgProcessed;
        }
    case PBrowser::Msg_PIndexedDBConstructor__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PBrowser::Msg_PIndexedDBConstructor");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PBrowser::Msg_PIndexedDBConstructor*>((&(__msg))))->Log("[PBrowserParent] Received ", stderr);
            }

            void* __iter = 0;
            ActorHandle __handle;
            PIndexedDBParent* actor;
            nsCString asciiOrigin;

            if ((!(Read((&(__handle)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(asciiOrigin)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PBrowser::Transition(mState, Trigger(Trigger::Recv, PBrowser::Msg_PIndexedDBConstructor__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            bool allowed;
            actor = AllocPIndexedDB(asciiOrigin, (&(allowed)));
            if ((!(actor))) {
                return MsgValueError;
            }
            (actor)->mId = RegisterID(actor, (__handle).mId);
            (actor)->mManager = this;
            (actor)->mChannel = mChannel;
            (mManagedPIndexedDBParent).InsertElementSorted(actor);
            (actor)->mState = mozilla::dom::indexedDB::PIndexedDB::__Start;

            int32_t __id = mId;
            if ((!(RecvPIndexedDBConstructor(actor, asciiOrigin, (&(allowed)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for PIndexedDB returned error code");
                return MsgProcessingError;
            }
            __reply = new PBrowser::Reply_PIndexedDBConstructor();

            Write(allowed, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_sync();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PBrowser::Reply_PIndexedDBConstructor*>(__reply))->Log("[PBrowserParent] Sending reply ", stderr);
            }

            return MsgProcessed;
        }
    case PBrowser::Msg_BrowserFrameOpenWindow__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PBrowser::Msg_BrowserFrameOpenWindow");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PBrowser::Msg_BrowserFrameOpenWindow*>((&(__msg))))->Log("[PBrowserParent] Received ", stderr);
            }

            void* __iter = 0;
            PBrowserParent* opener;
            nsString aURL;
            nsString aName;
            nsString aFeatures;

            if ((!(Read((&(opener)), (&(__msg)), (&(__iter)), false)))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(aURL)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(aName)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(aFeatures)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PBrowser::Transition(mState, Trigger(Trigger::Recv, PBrowser::Msg_BrowserFrameOpenWindow__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            bool windowOpened;
            int32_t __id = mId;
            if ((!(RecvBrowserFrameOpenWindow(opener, aURL, aName, aFeatures, (&(windowOpened)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for BrowserFrameOpenWindow returned error code");
                return MsgProcessingError;
            }

            __reply = new PBrowser::Reply_BrowserFrameOpenWindow();

            Write(windowOpened, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_sync();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PBrowser::Reply_BrowserFrameOpenWindow*>(__reply))->Log("[PBrowserParent] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    default:
        {
            return MsgNotKnown;
        }
    }
}

PBrowserParent::Result
PBrowserParent::OnCallReceived(
        const Message& __msg,
        Message*& __reply)
{
    switch ((__msg).type()) {
    case PBrowser::Msg_CreateWindow__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PBrowser::Msg_CreateWindow");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PBrowser::Msg_CreateWindow*>((&(__msg))))->Log("[PBrowserParent] Received ", stderr);
            }

            if ((!(PBrowser::Transition(mState, Trigger(Trigger::Recv, PBrowser::Msg_CreateWindow__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            PBrowserParent* window;
            int32_t __id = mId;
            if ((!(AnswerCreateWindow((&(window)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for CreateWindow returned error code");
                return MsgProcessingError;
            }

            __reply = new PBrowser::Reply_CreateWindow();

            Write(window, __reply, false);
            (__reply)->set_routing_id(__id);
            (__reply)->set_rpc();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PBrowser::Reply_CreateWindow*>(__reply))->Log("[PBrowserParent] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    default:
        {
            return MsgNotKnown;
        }
    }
}

void
PBrowserParent::OnProcessingError(Result code)
{
    NS_RUNTIMEABORT("`OnProcessingError' called on non-toplevel actor");
}

int32_t
PBrowserParent::GetProtocolTypeId()
{
    return PBrowserMsgStart;
}

bool
PBrowserParent::OnReplyTimeout()
{
    NS_RUNTIMEABORT("`OnReplyTimeout' called on non-toplevel actor");
    return false;
}

void
PBrowserParent::OnChannelClose()
{
    NS_RUNTIMEABORT("`OnClose' called on non-toplevel actor");
}

void
PBrowserParent::OnChannelError()
{
    NS_RUNTIMEABORT("`OnError' called on non-toplevel actor");
}

void
PBrowserParent::OnChannelConnected(int32_t pid)
{
    NS_RUNTIMEABORT("'OnConnected' called on non-toplevel actor");
}

bool
PBrowserParent::AllocShmem(
        size_t aSize,
        Shmem::SharedMemory::SharedMemoryType aType,
        Shmem* aMem)
{
    Shmem::id_t aId;
    nsAutoPtr<Shmem::SharedMemory> rawmem(CreateSharedMemory(aSize, aType, false, (&(aId))));
    if ((!(rawmem))) {
        return false;
    }

    (*(aMem)) = Shmem(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(), (rawmem).forget(), aId);
    return true;
}

bool
PBrowserParent::AllocUnsafeShmem(
        size_t aSize,
        Shmem::SharedMemory::SharedMemoryType aType,
        Shmem* aMem)
{
    Shmem::id_t aId;
    nsAutoPtr<Shmem::SharedMemory> rawmem(CreateSharedMemory(aSize, aType, true, (&(aId))));
    if ((!(rawmem))) {
        return false;
    }

    (*(aMem)) = Shmem(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(), (rawmem).forget(), aId);
    return true;
}

bool
PBrowserParent::AdoptShmem(
        Shmem& aMem,
        Shmem* aOutMem)
{
    Shmem::SharedMemory* rawmem = (aMem).Segment(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead());
    if (((!(rawmem))) || (IsTrackingSharedMemory(rawmem))) {
        NS_RUNTIMEABORT("bad Shmem");
    }

    Shmem::id_t aId;
    if ((!(AdoptSharedMemory(rawmem, (&(aId)))))) {
        return false;
    }

    (*(aOutMem)) = Shmem(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(), rawmem, aId);
    return true;
}

bool
PBrowserParent::DeallocShmem(Shmem& aMem)
{
    bool ok = DestroySharedMemory(aMem);
    (aMem).forget(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead());
    return ok;
}

void
PBrowserParent::FatalError(const char* const msg) const
{
    // Virtual method to prevent inlining.
    // This give us better error reporting.
    // See bug 589371

    NS_ERROR("IPDL error:");
    NS_ERROR(msg);
    mozilla::ipc::ProtocolErrorBreakpoint(msg);

    NS_ERROR("[PBrowserParent] killing child side as a result");

    if ((!(base::KillProcess(OtherProcess(), base::PROCESS_END_KILLED_BY_USER, false)))) {
        NS_ERROR("  may have failed to kill child!");
    }
}

void
PBrowserParent::DestroySubtree(ActorDestroyReason why)
{
    // Unregister from our manager.
    Unregister(mId);
    mId = 1;

    ActorDestroyReason subtreewhy = (((why) == (Deletion)) || ((why) == (FailedConstructor)) ? AncestorDeletion : why);

    {
        // Recursively shutting down PContentDialog kids
        InfallibleTArray<PContentDialogParent*> kids(mManagedPContentDialogParent);
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DestroySubtree(subtreewhy);
        }
    }
    {
        // Recursively shutting down PDocumentRenderer kids
        InfallibleTArray<PDocumentRendererParent*> kids(mManagedPDocumentRendererParent);
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DestroySubtree(subtreewhy);
        }
    }
    {
        // Recursively shutting down PContentPermissionRequest kids
        InfallibleTArray<PContentPermissionRequestParent*> kids(mManagedPContentPermissionRequestParent);
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DestroySubtree(subtreewhy);
        }
    }
    {
        // Recursively shutting down PRenderFrame kids
        InfallibleTArray<PRenderFrameParent*> kids(mManagedPRenderFrameParent);
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DestroySubtree(subtreewhy);
        }
    }
    {
        // Recursively shutting down POfflineCacheUpdate kids
        InfallibleTArray<POfflineCacheUpdateParent*> kids(mManagedPOfflineCacheUpdateParent);
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DestroySubtree(subtreewhy);
        }
    }
    {
        // Recursively shutting down PIndexedDB kids
        InfallibleTArray<PIndexedDBParent*> kids(mManagedPIndexedDBParent);
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DestroySubtree(subtreewhy);
        }
    }

    // Finally, destroy "us".
    ActorDestroy(why);
}

void
PBrowserParent::DeallocSubtree()
{
    {
        // Recursively deleting PContentDialog kids
        InfallibleTArray<PContentDialogParent*>& kids = mManagedPContentDialogParent;
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DeallocSubtree();
        }

        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            DeallocPContentDialog(kids[i]);
        }
        (mManagedPContentDialogParent).Clear();
    }
    {
        // Recursively deleting PDocumentRenderer kids
        InfallibleTArray<PDocumentRendererParent*>& kids = mManagedPDocumentRendererParent;
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DeallocSubtree();
        }

        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            DeallocPDocumentRenderer(kids[i]);
        }
        (mManagedPDocumentRendererParent).Clear();
    }
    {
        // Recursively deleting PContentPermissionRequest kids
        InfallibleTArray<PContentPermissionRequestParent*>& kids = mManagedPContentPermissionRequestParent;
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DeallocSubtree();
        }

        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            DeallocPContentPermissionRequest(kids[i]);
        }
        (mManagedPContentPermissionRequestParent).Clear();
    }
    {
        // Recursively deleting PRenderFrame kids
        InfallibleTArray<PRenderFrameParent*>& kids = mManagedPRenderFrameParent;
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DeallocSubtree();
        }

        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            DeallocPRenderFrame(kids[i]);
        }
        (mManagedPRenderFrameParent).Clear();
    }
    {
        // Recursively deleting POfflineCacheUpdate kids
        InfallibleTArray<POfflineCacheUpdateParent*>& kids = mManagedPOfflineCacheUpdateParent;
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DeallocSubtree();
        }

        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            DeallocPOfflineCacheUpdate(kids[i]);
        }
        (mManagedPOfflineCacheUpdateParent).Clear();
    }
    {
        // Recursively deleting PIndexedDB kids
        InfallibleTArray<PIndexedDBParent*>& kids = mManagedPIndexedDBParent;
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DeallocSubtree();
        }

        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            DeallocPIndexedDB(kids[i]);
        }
        (mManagedPIndexedDBParent).Clear();
    }
}

void
PBrowserParent::Write(
        const ClonedMessageData& __v,
        Message* __msg)
{
    Write((__v).data(), __msg);
    Write((__v).blobsParent(), __msg);
    // skipping actor field that's meaningless on this side
}

bool
PBrowserParent::Read(
        ClonedMessageData* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->data())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->blobsParent())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    // skipping actor field that's meaningless on this side
    return true;
}

void
PBrowserParent::Write(
        PDocumentRendererParent* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PBrowserParent::Read(
        PDocumentRendererParent** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PBrowser");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PDocumentRenderer");
        return false;
    }

    if ((PDocumentRendererMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PDocumentRenderer has different type");
        return false;
    }

    (*(__v)) = static_cast<PDocumentRendererParent*>(listener);
    return true;
}

void
PBrowserParent::Write(
        PBrowserParent* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PBrowserParent::Read(
        PBrowserParent** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PBrowser");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PBrowser");
        return false;
    }

    if ((PBrowserMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PBrowser has different type");
        return false;
    }

    (*(__v)) = static_cast<PBrowserParent*>(listener);
    return true;
}

void
PBrowserParent::Write(
        PContentDialogParent* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PBrowserParent::Read(
        PContentDialogParent** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PBrowser");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PContentDialog");
        return false;
    }

    if ((PContentDialogMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PContentDialog has different type");
        return false;
    }

    (*(__v)) = static_cast<PContentDialogParent*>(listener);
    return true;
}

void
PBrowserParent::Write(
        const InfallibleTArray<PBlobParent*>& __v,
        Message* __msg)
{
    uint32_t length = (__v).Length();
    Write(length, __msg);

    for (uint32_t i = 0; (i) < (length); (++(i))) {
        Write(__v[i], __msg, false);
    }
}

bool
PBrowserParent::Read(
        InfallibleTArray<PBlobParent*>* __v,
        const Message* __msg,
        void** __iter)
{
    InfallibleTArray<PBlobParent*>& a = (*(__v));
    uint32_t length;
    if ((!(Read((&(length)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }

    (__v)->SetLength(length);
    for (uint32_t i = 0; (i) < (length); (++(i))) {
        if ((!(Read((&(a[i])), __msg, __iter, false)))) {
            mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
            return false;
        }
    }
    return true;
}

void
PBrowserParent::Write(
        const SimpleURIParams& __v,
        Message* __msg)
{
    Write((__v).scheme(), __msg);
    Write((__v).path(), __msg);
    Write((__v).ref(), __msg);
    Write((__v).isMutable(), __msg);
}

bool
PBrowserParent::Read(
        SimpleURIParams* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->scheme())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->path())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->ref())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->isMutable())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PBrowserParent::Write(
        const StandardURLParams& __v,
        Message* __msg)
{
    Write((__v).urlType(), __msg);
    Write((__v).port(), __msg);
    Write((__v).defaultPort(), __msg);
    Write((__v).spec(), __msg);
    Write((__v).scheme(), __msg);
    Write((__v).authority(), __msg);
    Write((__v).username(), __msg);
    Write((__v).password(), __msg);
    Write((__v).host(), __msg);
    Write((__v).path(), __msg);
    Write((__v).filePath(), __msg);
    Write((__v).directory(), __msg);
    Write((__v).baseName(), __msg);
    Write((__v).extension(), __msg);
    Write((__v).query(), __msg);
    Write((__v).ref(), __msg);
    Write((__v).originCharset(), __msg);
    Write((__v).isMutable(), __msg);
    Write((__v).supportsFileURL(), __msg);
    Write((__v).hostEncoding(), __msg);
}

bool
PBrowserParent::Read(
        StandardURLParams* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->urlType())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->port())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->defaultPort())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->spec())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->scheme())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->authority())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->username())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->password())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->host())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->path())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->filePath())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->directory())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->baseName())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->extension())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->query())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->ref())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->originCharset())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->isMutable())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->supportsFileURL())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->hostEncoding())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PBrowserParent::Write(
        POfflineCacheUpdateParent* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PBrowserParent::Read(
        POfflineCacheUpdateParent** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PBrowser");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up POfflineCacheUpdate");
        return false;
    }

    if ((POfflineCacheUpdateMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type POfflineCacheUpdate has different type");
        return false;
    }

    (*(__v)) = static_cast<POfflineCacheUpdateParent*>(listener);
    return true;
}

void
PBrowserParent::Write(
        const GenericURIParams& __v,
        Message* __msg)
{
    Write((__v).spec(), __msg);
    Write((__v).charset(), __msg);
}

bool
PBrowserParent::Read(
        GenericURIParams* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->spec())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->charset())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PBrowserParent::Write(
        const JARURIParams& __v,
        Message* __msg)
{
    Write((__v).jarFile(), __msg);
    Write((__v).jarEntry(), __msg);
    Write((__v).charset(), __msg);
}

bool
PBrowserParent::Read(
        JARURIParams* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->jarFile())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->jarEntry())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->charset())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PBrowserParent::Write(
        const StandardURLSegment& __v,
        Message* __msg)
{
    Write((__v).position(), __msg);
    Write((__v).length(), __msg);
}

bool
PBrowserParent::Read(
        StandardURLSegment* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->position())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->length())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PBrowserParent::Write(
        const URIParams& __v,
        Message* __msg)
{
    typedef URIParams __type;
    Write(int((__v).type()), __msg);

    switch ((__v).type()) {
    case __type::TSimpleURIParams:
        {
            Write((__v).get_SimpleURIParams(), __msg);
            return;
        }
    case __type::TStandardURLParams:
        {
            Write((__v).get_StandardURLParams(), __msg);
            return;
        }
    case __type::TJARURIParams:
        {
            Write((__v).get_JARURIParams(), __msg);
            return;
        }
    case __type::TGenericURIParams:
        {
            Write((__v).get_GenericURIParams(), __msg);
            return;
        }
    default:
        {
            NS_RUNTIMEABORT("unknown union type");
            return;
        }
    }
}

bool
PBrowserParent::Read(
        URIParams* __v,
        const Message* __msg,
        void** __iter)
{
    typedef URIParams __type;
    int type;
    if ((!(Read((&(type)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }

    switch (type) {
    case __type::TSimpleURIParams:
        {
            SimpleURIParams tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_SimpleURIParams())), __msg, __iter);
        }
    case __type::TStandardURLParams:
        {
            StandardURLParams tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_StandardURLParams())), __msg, __iter);
        }
    case __type::TJARURIParams:
        {
            JARURIParams tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_JARURIParams())), __msg, __iter);
        }
    case __type::TGenericURIParams:
        {
            GenericURIParams tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_GenericURIParams())), __msg, __iter);
        }
    default:
        {
            mozilla::ipc::ProtocolErrorBreakpoint("unknown union type");
            return false;
        }
    }
}

void
PBrowserParent::Write(
        PBlobParent* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PBrowserParent::Read(
        PBlobParent** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PBrowser");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PBlob");
        return false;
    }

    if ((PBlobMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PBlob has different type");
        return false;
    }

    (*(__v)) = static_cast<PBlobParent*>(listener);
    return true;
}

void
PBrowserParent::Write(
        PIndexedDBParent* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PBrowserParent::Read(
        PIndexedDBParent** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PBrowser");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PIndexedDB");
        return false;
    }

    if ((PIndexedDBMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PIndexedDB has different type");
        return false;
    }

    (*(__v)) = static_cast<PIndexedDBParent*>(listener);
    return true;
}

void
PBrowserParent::Write(
        PRenderFrameParent* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PBrowserParent::Read(
        PRenderFrameParent** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PBrowser");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PRenderFrame");
        return false;
    }

    if ((PRenderFrameMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PRenderFrame has different type");
        return false;
    }

    (*(__v)) = static_cast<PRenderFrameParent*>(listener);
    return true;
}

void
PBrowserParent::Write(
        PContentPermissionRequestParent* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PBrowserParent::Read(
        PContentPermissionRequestParent** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PBrowser");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PContentPermissionRequest");
        return false;
    }

    if ((PContentPermissionRequestMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PContentPermissionRequest has different type");
        return false;
    }

    (*(__v)) = static_cast<PContentPermissionRequestParent*>(listener);
    return true;
}



} // namespace dom
} // namespace mozilla
