//
// Automatically generated by ipdlc.
// Edit at your own risk
//


#include "mozilla/layers/PLayersParent.h"

#include "mozilla/layers/PCompositorParent.h"
#include "mozilla/layers/PGrallocBufferParent.h"
#include "mozilla/layers/PLayerParent.h"
#include "mozilla/layout/PRenderFrameParent.h"

typedef IPC::Message Message;
typedef mozilla::ipc::RPCChannel Channel;
typedef mozilla::ipc::RPCChannel::RPCListener ChannelListener;
typedef base::ProcessHandle ProcessHandle;
typedef mozilla::ipc::AsyncChannel AsyncChannel;
typedef mozilla::ipc::SharedMemory SharedMemory;
typedef mozilla::ipc::Trigger Trigger;
typedef mozilla::ipc::ActorHandle ActorHandle;
typedef mozilla::layers::Animatable Animatable;
typedef mozilla::layers::Animation Animation;
typedef mozilla::layers::AnimationData AnimationData;
typedef mozilla::layers::AnimationSegment AnimationSegment;
typedef mozilla::layers::CanvasLayerAttributes CanvasLayerAttributes;
typedef mozilla::layers::CanvasSurface CanvasSurface;
typedef mozilla::layers::Color Color;
typedef mozilla::layers::ColorLayerAttributes ColorLayerAttributes;
typedef mozilla::layers::CommonLayerAttributes CommonLayerAttributes;
typedef mozilla::layers::ContainerLayerAttributes ContainerLayerAttributes;
typedef mozilla::layers::CubicBezierFunction CubicBezierFunction;
typedef mozilla::layers::Edit Edit;
typedef mozilla::layers::EditReply EditReply;
typedef mozilla::ipc::FileDescriptor FileDescriptor;
typedef mozilla::layers::FrameMetrics FrameMetrics;
typedef mozilla::GraphicsFilterType GraphicsFilterType;
typedef mozilla::layers::ImageLayerAttributes ImageLayerAttributes;
typedef mozilla::layers::LayerAttributes LayerAttributes;
typedef mozilla::layers::MagicGrallocBufferHandle MagicGrallocBufferHandle;
typedef mozilla::layers::MaybeMagicGrallocBufferHandle MaybeMagicGrallocBufferHandle;
typedef mozilla::layers::OpAppendChild OpAppendChild;
typedef mozilla::layers::OpBufferSwap OpBufferSwap;
typedef mozilla::layers::OpCreateCanvasLayer OpCreateCanvasLayer;
typedef mozilla::layers::OpCreateColorLayer OpCreateColorLayer;
typedef mozilla::layers::OpCreateContainerLayer OpCreateContainerLayer;
typedef mozilla::layers::OpCreateImageLayer OpCreateImageLayer;
typedef mozilla::layers::OpCreateRefLayer OpCreateRefLayer;
typedef mozilla::layers::OpCreateThebesLayer OpCreateThebesLayer;
typedef mozilla::layers::OpImageSwap OpImageSwap;
typedef mozilla::layers::OpInsertAfter OpInsertAfter;
typedef mozilla::layers::OpPaintCanvas OpPaintCanvas;
typedef mozilla::layers::OpPaintImage OpPaintImage;
typedef mozilla::layers::OpPaintThebesBuffer OpPaintThebesBuffer;
typedef mozilla::layers::OpPaintTiledLayerBuffer OpPaintTiledLayerBuffer;
typedef mozilla::layers::OpRaiseToTopChild OpRaiseToTopChild;
typedef mozilla::layers::OpRemoveChild OpRemoveChild;
typedef mozilla::layers::OpRepositionChild OpRepositionChild;
typedef mozilla::layers::OpSetLayerAttributes OpSetLayerAttributes;
typedef mozilla::layers::OpSetRoot OpSetRoot;
typedef mozilla::layers::OpThebesBufferSwap OpThebesBufferSwap;
typedef mozilla::layers::OptionalThebesBuffer OptionalThebesBuffer;
typedef mozilla::layers::Perspective Perspective;
typedef mozilla::layers::RGBImage RGBImage;
typedef mozilla::layers::RefLayerAttributes RefLayerAttributes;
typedef mozilla::layers::Rotation Rotation;
typedef mozilla::layers::Rotation3D Rotation3D;
typedef mozilla::layers::RotationX RotationX;
typedef mozilla::layers::RotationY RotationY;
typedef mozilla::layers::RotationZ RotationZ;
typedef mozilla::layers::Scale Scale;
typedef mozilla::dom::ScreenOrientation ScreenOrientation;
typedef mozilla::ScreenRotation ScreenRotation;
typedef mozilla::layers::SharedImage SharedImage;
typedef mozilla::layers::SharedImageID SharedImageID;
typedef mozilla::layers::SharedTextureDescriptor SharedTextureDescriptor;
typedef mozilla::gl::SharedTextureHandle SharedTextureHandle;
typedef mozilla::gl::GLContext::SharedTextureShareType SharedTextureShareType;
typedef mozilla::ipc::Shmem Shmem;
typedef mozilla::layers::SkewX SkewX;
typedef mozilla::layers::SkewY SkewY;
typedef mozilla::layers::SpecificLayerAttributes SpecificLayerAttributes;
typedef mozilla::layers::StepFunction StepFunction;
typedef mozilla::layers::SurfaceDescriptor SurfaceDescriptor;
typedef mozilla::layers::SurfaceDescriptorD3D10 SurfaceDescriptorD3D10;
typedef mozilla::layers::SurfaceDescriptorGralloc SurfaceDescriptorGralloc;
typedef mozilla::layers::SurfaceDescriptorX11 SurfaceDescriptorX11;
typedef mozilla::layers::TargetConfig TargetConfig;
typedef mozilla::layers::ThebesBuffer ThebesBuffer;
typedef mozilla::layers::ThebesLayerAttributes ThebesLayerAttributes;
typedef mozilla::TimeDuration TimeDuration;
typedef mozilla::TimeStamp TimeStamp;
typedef mozilla::layers::TimingFunction TimingFunction;
typedef mozilla::layers::TransformData TransformData;
typedef mozilla::layers::TransformFunction TransformFunction;
typedef mozilla::layers::TransformMatrix TransformMatrix;
typedef mozilla::layers::Translation Translation;
typedef mozilla::WindowsHandle WindowsHandle;
typedef mozilla::layers::YCbCrImage YCbCrImage;
typedef mozilla::layers::YUVImage YUVImage;
typedef mozilla::gfxContentType gfxContentType;
typedef mozilla::null_t null_t;
using mozilla::layers::PCompositorParent;
using mozilla::layers::PGrallocBufferParent;
using mozilla::layers::PLayerParent;
using mozilla::layout::PRenderFrameParent;

namespace mozilla {
namespace layers {


bool
PLayersParent::RecvPGrallocBufferConstructor(
        PGrallocBufferParent* actor,
        const gfxIntSize& size,
        const gfxContentType& content,
        MaybeMagicGrallocBufferHandle* handle)
{
    return true;
}

bool
PLayersParent::RecvPLayerConstructor(PLayerParent* actor)
{
    return true;
}

bool
PLayersParent::Recv__delete__()
{
    return true;
}

void
PLayersParent::ActorDestroy(ActorDestroyReason why)
{
}

PLayersParent::PLayersParent() :
    mId(0),
    mState(PLayers::__Dead)
{
    MOZ_COUNT_CTOR(PLayersParent);
}

PLayersParent::~PLayersParent()
{
    MOZ_COUNT_DTOR(PLayersParent);
}

void
PLayersParent::ManagedPGrallocBufferParent(InfallibleTArray<PGrallocBufferParent*>& aArr) const
{
    aArr = mManagedPGrallocBufferParent;
}

const InfallibleTArray<PGrallocBufferParent*>&
PLayersParent::ManagedPGrallocBufferParent() const
{
    return mManagedPGrallocBufferParent;
}

void
PLayersParent::ManagedPLayerParent(InfallibleTArray<PLayerParent*>& aArr) const
{
    aArr = mManagedPLayerParent;
}

const InfallibleTArray<PLayerParent*>&
PLayersParent::ManagedPLayerParent() const
{
    return mManagedPLayerParent;
}

PLayers::State
PLayersParent::state()
{
    return mState;
}

int32_t
PLayersParent::Register(ChannelListener* aRouted)
{
    return (mManager)->Register(aRouted);
}

int32_t
PLayersParent::RegisterID(
        ChannelListener* aRouted,
        int32_t aId)
{
    return (mManager)->RegisterID(aRouted, aId);
}

ChannelListener*
PLayersParent::Lookup(int32_t aId)
{
    return (mManager)->Lookup(aId);
}

void
PLayersParent::Unregister(int32_t aId)
{
    return (mManager)->Unregister(aId);
}

void
PLayersParent::RemoveManagee(
        int32_t aProtocolId,
        ChannelListener* aListener)
{
    switch (aProtocolId) {
    case PGrallocBufferMsgStart:
        {
            PGrallocBufferParent* actor = static_cast<PGrallocBufferParent*>(aListener);
            NS_ABORT_IF_FALSE(((mManagedPGrallocBufferParent).NoIndex) != ((mManagedPGrallocBufferParent).BinaryIndexOf(actor)), "actor not managed by this!");

            (mManagedPGrallocBufferParent).RemoveElementSorted(actor);
            DeallocPGrallocBuffer(actor);
            return;
        }
    case PLayerMsgStart:
        {
            PLayerParent* actor = static_cast<PLayerParent*>(aListener);
            NS_ABORT_IF_FALSE(((mManagedPLayerParent).NoIndex) != ((mManagedPLayerParent).BinaryIndexOf(actor)), "actor not managed by this!");

            (mManagedPLayerParent).RemoveElementSorted(actor);
            DeallocPLayer(actor);
            return;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return;
        }
    }
}

Shmem::SharedMemory*
PLayersParent::CreateSharedMemory(
        size_t aSize,
        Shmem::SharedMemory::SharedMemoryType aType,
        bool aUnsafe,
        Shmem::id_t* aId)
{
    return (mManager)->CreateSharedMemory(aSize, aType, aUnsafe, aId);
}

bool
PLayersParent::AdoptSharedMemory(
        Shmem::SharedMemory* segment,
        Shmem::id_t* aId)
{
    return (mManager)->AdoptSharedMemory(segment, aId);
}

Shmem::SharedMemory*
PLayersParent::LookupSharedMemory(Shmem::id_t aId)
{
    return (mManager)->LookupSharedMemory(aId);
}

bool
PLayersParent::IsTrackingSharedMemory(Shmem::SharedMemory* segment)
{
    return (mManager)->IsTrackingSharedMemory(segment);
}

bool
PLayersParent::DestroySharedMemory(Shmem& shmem)
{
    return (mManager)->DestroySharedMemory(shmem);
}

ProcessHandle
PLayersParent::OtherProcess() const
{
    return (mManager)->OtherProcess();
}

AsyncChannel*
PLayersParent::GetIPCChannel()
{
    return mChannel;
}

PLayersParent::Result
PLayersParent::OnMessageReceived(const Message& __msg)
{
    switch ((__msg).type()) {
    case PLayers::Msg_PLayerConstructor__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PLayers::Msg_PLayerConstructor");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PLayers::Msg_PLayerConstructor*>((&(__msg))))->Log("[PLayersParent] Received ", stderr);
            }

            void* __iter = 0;
            ActorHandle __handle;
            PLayerParent* actor;

            if ((!(Read((&(__handle)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PLayers::Transition(mState, Trigger(Trigger::Recv, PLayers::Msg_PLayerConstructor__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            actor = AllocPLayer();
            if ((!(actor))) {
                return MsgValueError;
            }
            (actor)->mId = RegisterID(actor, (__handle).mId);
            (actor)->mManager = this;
            (actor)->mChannel = mChannel;
            (mManagedPLayerParent).InsertElementSorted(actor);
            (actor)->mState = mozilla::layers::PLayer::__Start;

            if ((!(RecvPLayerConstructor(actor)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for PLayer returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PLayers::Msg_UpdateNoSwap__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PLayers::Msg_UpdateNoSwap");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PLayers::Msg_UpdateNoSwap*>((&(__msg))))->Log("[PLayersParent] Received ", stderr);
            }

            void* __iter = 0;
            InfallibleTArray<Edit> cset;
            TargetConfig targetConfig;
            bool isFirstPaint;

            if ((!(Read((&(cset)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(targetConfig)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(isFirstPaint)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PLayers::Transition(mState, Trigger(Trigger::Recv, PLayers::Msg_UpdateNoSwap__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvUpdateNoSwap(cset, targetConfig, isFirstPaint)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for UpdateNoSwap returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PLayers::Msg_ClearCachedResources__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PLayers::Msg_ClearCachedResources");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PLayers::Msg_ClearCachedResources*>((&(__msg))))->Log("[PLayersParent] Received ", stderr);
            }

            if ((!(PLayers::Transition(mState, Trigger(Trigger::Recv, PLayers::Msg_ClearCachedResources__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvClearCachedResources()))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for ClearCachedResources returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PLayers::Msg___delete____ID:
        {
            (const_cast<Message&>(__msg)).set_name("PLayers::Msg___delete__");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PLayers::Msg___delete__*>((&(__msg))))->Log("[PLayersParent] Received ", stderr);
            }

            void* __iter = 0;
            PLayersParent* actor;

            if ((!(Read((&(actor)), (&(__msg)), (&(__iter)), false)))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PLayers::Transition(mState, Trigger(Trigger::Recv, PLayers::Msg___delete____ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(Recv__delete__()))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for __delete__ returned error code");
                return MsgProcessingError;
            }

            (actor)->DestroySubtree(Deletion);
            (actor)->DeallocSubtree();
            ((actor)->mManager)->RemoveManagee(PLayersMsgStart, actor);


            return MsgProcessed;
        }
    default:
        {
            return MsgNotKnown;
        }
    }
}

PLayersParent::Result
PLayersParent::OnMessageReceived(
        const Message& __msg,
        Message*& __reply)
{
    switch ((__msg).type()) {
    case PLayers::Msg_PGrallocBufferConstructor__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PLayers::Msg_PGrallocBufferConstructor");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PLayers::Msg_PGrallocBufferConstructor*>((&(__msg))))->Log("[PLayersParent] Received ", stderr);
            }

            void* __iter = 0;
            ActorHandle __handle;
            PGrallocBufferParent* actor;
            gfxIntSize size;
            gfxContentType content;

            if ((!(Read((&(__handle)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(size)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(content)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PLayers::Transition(mState, Trigger(Trigger::Recv, PLayers::Msg_PGrallocBufferConstructor__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            MaybeMagicGrallocBufferHandle handle;
            actor = AllocPGrallocBuffer(size, content, (&(handle)));
            if ((!(actor))) {
                return MsgValueError;
            }
            (actor)->mId = RegisterID(actor, (__handle).mId);
            (actor)->mManager = this;
            (actor)->mChannel = mChannel;
            (mManagedPGrallocBufferParent).InsertElementSorted(actor);
            (actor)->mState = mozilla::layers::PGrallocBuffer::__Start;

            int32_t __id = mId;
            if ((!(RecvPGrallocBufferConstructor(actor, size, content, (&(handle)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for PGrallocBuffer returned error code");
                return MsgProcessingError;
            }
            __reply = new PLayers::Reply_PGrallocBufferConstructor();

            Write(handle, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_sync();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PLayers::Reply_PGrallocBufferConstructor*>(__reply))->Log("[PLayersParent] Sending reply ", stderr);
            }

            return MsgProcessed;
        }
    case PLayers::Msg_Update__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PLayers::Msg_Update");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PLayers::Msg_Update*>((&(__msg))))->Log("[PLayersParent] Received ", stderr);
            }

            void* __iter = 0;
            InfallibleTArray<Edit> cset;
            TargetConfig targetConfig;
            bool isFirstPaint;

            if ((!(Read((&(cset)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(targetConfig)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(isFirstPaint)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PLayers::Transition(mState, Trigger(Trigger::Recv, PLayers::Msg_Update__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            InfallibleTArray<EditReply> reply;
            int32_t __id = mId;
            if ((!(RecvUpdate(cset, targetConfig, isFirstPaint, (&(reply)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for Update returned error code");
                return MsgProcessingError;
            }

            __reply = new PLayers::Reply_Update();

            Write(reply, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_sync();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PLayers::Reply_Update*>(__reply))->Log("[PLayersParent] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    default:
        {
            return MsgNotKnown;
        }
    }
}

PLayersParent::Result
PLayersParent::OnCallReceived(
        const Message& __msg,
        Message*& __reply)
{
    return MsgNotKnown;
}

void
PLayersParent::OnProcessingError(Result code)
{
    NS_RUNTIMEABORT("`OnProcessingError' called on non-toplevel actor");
}

int32_t
PLayersParent::GetProtocolTypeId()
{
    return PLayersMsgStart;
}

bool
PLayersParent::OnReplyTimeout()
{
    NS_RUNTIMEABORT("`OnReplyTimeout' called on non-toplevel actor");
    return false;
}

void
PLayersParent::OnChannelClose()
{
    NS_RUNTIMEABORT("`OnClose' called on non-toplevel actor");
}

void
PLayersParent::OnChannelError()
{
    NS_RUNTIMEABORT("`OnError' called on non-toplevel actor");
}

void
PLayersParent::OnChannelConnected(int32_t pid)
{
    NS_RUNTIMEABORT("'OnConnected' called on non-toplevel actor");
}

bool
PLayersParent::AllocShmem(
        size_t aSize,
        Shmem::SharedMemory::SharedMemoryType aType,
        Shmem* aMem)
{
    Shmem::id_t aId;
    nsAutoPtr<Shmem::SharedMemory> rawmem(CreateSharedMemory(aSize, aType, false, (&(aId))));
    if ((!(rawmem))) {
        return false;
    }

    (*(aMem)) = Shmem(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(), (rawmem).forget(), aId);
    return true;
}

bool
PLayersParent::AllocUnsafeShmem(
        size_t aSize,
        Shmem::SharedMemory::SharedMemoryType aType,
        Shmem* aMem)
{
    Shmem::id_t aId;
    nsAutoPtr<Shmem::SharedMemory> rawmem(CreateSharedMemory(aSize, aType, true, (&(aId))));
    if ((!(rawmem))) {
        return false;
    }

    (*(aMem)) = Shmem(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(), (rawmem).forget(), aId);
    return true;
}

bool
PLayersParent::AdoptShmem(
        Shmem& aMem,
        Shmem* aOutMem)
{
    Shmem::SharedMemory* rawmem = (aMem).Segment(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead());
    if (((!(rawmem))) || (IsTrackingSharedMemory(rawmem))) {
        NS_RUNTIMEABORT("bad Shmem");
    }

    Shmem::id_t aId;
    if ((!(AdoptSharedMemory(rawmem, (&(aId)))))) {
        return false;
    }

    (*(aOutMem)) = Shmem(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(), rawmem, aId);
    return true;
}

bool
PLayersParent::DeallocShmem(Shmem& aMem)
{
    bool ok = DestroySharedMemory(aMem);
    (aMem).forget(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead());
    return ok;
}

void
PLayersParent::FatalError(const char* const msg) const
{
    // Virtual method to prevent inlining.
    // This give us better error reporting.
    // See bug 589371

    NS_ERROR("IPDL error:");
    NS_ERROR(msg);
    mozilla::ipc::ProtocolErrorBreakpoint(msg);

    NS_ERROR("[PLayersParent] killing child side as a result");

    if ((!(base::KillProcess(OtherProcess(), base::PROCESS_END_KILLED_BY_USER, false)))) {
        NS_ERROR("  may have failed to kill child!");
    }
}

void
PLayersParent::DestroySubtree(ActorDestroyReason why)
{
    // Unregister from our manager.
    Unregister(mId);
    mId = 1;

    ActorDestroyReason subtreewhy = (((why) == (Deletion)) || ((why) == (FailedConstructor)) ? AncestorDeletion : why);

    {
        // Recursively shutting down PGrallocBuffer kids
        InfallibleTArray<PGrallocBufferParent*> kids(mManagedPGrallocBufferParent);
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DestroySubtree(subtreewhy);
        }
    }
    {
        // Recursively shutting down PLayer kids
        InfallibleTArray<PLayerParent*> kids(mManagedPLayerParent);
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DestroySubtree(subtreewhy);
        }
    }

    // Finally, destroy "us".
    ActorDestroy(why);
}

void
PLayersParent::DeallocSubtree()
{
    {
        // Recursively deleting PGrallocBuffer kids
        InfallibleTArray<PGrallocBufferParent*>& kids = mManagedPGrallocBufferParent;
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DeallocSubtree();
        }

        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            DeallocPGrallocBuffer(kids[i]);
        }
        (mManagedPGrallocBufferParent).Clear();
    }
    {
        // Recursively deleting PLayer kids
        InfallibleTArray<PLayerParent*>& kids = mManagedPLayerParent;
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DeallocSubtree();
        }

        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            DeallocPLayer(kids[i]);
        }
        (mManagedPLayerParent).Clear();
    }
}

void
PLayersParent::Write(
        const OpAppendChild& __v,
        Message* __msg)
{
    Write((__v).containerParent(), __msg, false);
    // skipping actor field that's meaningless on this side
    Write((__v).childLayerParent(), __msg, false);
    // skipping actor field that's meaningless on this side
}

bool
PLayersParent::Read(
        OpAppendChild* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->containerParent())), __msg, __iter, false)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    // skipping actor field that's meaningless on this side
    if ((!(Read((&((__v)->childLayerParent())), __msg, __iter, false)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    // skipping actor field that's meaningless on this side
    return true;
}

void
PLayersParent::Write(
        const SurfaceDescriptor& __v,
        Message* __msg)
{
    typedef SurfaceDescriptor __type;
    Write(int((__v).type()), __msg);

    switch ((__v).type()) {
    case __type::TShmem:
        {
            Write((__v).get_Shmem(), __msg);
            return;
        }
    case __type::TSurfaceDescriptorD3D10:
        {
            Write((__v).get_SurfaceDescriptorD3D10(), __msg);
            return;
        }
    case __type::TSurfaceDescriptorGralloc:
        {
            Write((__v).get_SurfaceDescriptorGralloc(), __msg);
            return;
        }
    case __type::TSurfaceDescriptorX11:
        {
            Write((__v).get_SurfaceDescriptorX11(), __msg);
            return;
        }
    case __type::TSharedTextureDescriptor:
        {
            Write((__v).get_SharedTextureDescriptor(), __msg);
            return;
        }
    default:
        {
            NS_RUNTIMEABORT("unknown union type");
            return;
        }
    }
}

bool
PLayersParent::Read(
        SurfaceDescriptor* __v,
        const Message* __msg,
        void** __iter)
{
    typedef SurfaceDescriptor __type;
    int type;
    if ((!(Read((&(type)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }

    switch (type) {
    case __type::TShmem:
        {
            Shmem tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_Shmem())), __msg, __iter);
        }
    case __type::TSurfaceDescriptorD3D10:
        {
            SurfaceDescriptorD3D10 tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_SurfaceDescriptorD3D10())), __msg, __iter);
        }
    case __type::TSurfaceDescriptorGralloc:
        {
            SurfaceDescriptorGralloc tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_SurfaceDescriptorGralloc())), __msg, __iter);
        }
    case __type::TSurfaceDescriptorX11:
        {
            SurfaceDescriptorX11 tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_SurfaceDescriptorX11())), __msg, __iter);
        }
    case __type::TSharedTextureDescriptor:
        {
            SharedTextureDescriptor tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_SharedTextureDescriptor())), __msg, __iter);
        }
    default:
        {
            mozilla::ipc::ProtocolErrorBreakpoint("unknown union type");
            return false;
        }
    }
}

void
PLayersParent::Write(
        const CubicBezierFunction& __v,
        Message* __msg)
{
    Write((__v).x1(), __msg);
    Write((__v).y1(), __msg);
    Write((__v).x2(), __msg);
    Write((__v).y2(), __msg);
}

bool
PLayersParent::Read(
        CubicBezierFunction* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->x1())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->y1())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->x2())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->y2())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PLayersParent::Write(
        const Color& __v,
        Message* __msg)
{
    Write((__v).value(), __msg);
}

bool
PLayersParent::Read(
        Color* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->value())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PLayersParent::Write(
        const OpInsertAfter& __v,
        Message* __msg)
{
    Write((__v).containerParent(), __msg, false);
    // skipping actor field that's meaningless on this side
    Write((__v).childLayerParent(), __msg, false);
    // skipping actor field that's meaningless on this side
    Write((__v).afterParent(), __msg, false);
    // skipping actor field that's meaningless on this side
}

bool
PLayersParent::Read(
        OpInsertAfter* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->containerParent())), __msg, __iter, false)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    // skipping actor field that's meaningless on this side
    if ((!(Read((&((__v)->childLayerParent())), __msg, __iter, false)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    // skipping actor field that's meaningless on this side
    if ((!(Read((&((__v)->afterParent())), __msg, __iter, false)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    // skipping actor field that's meaningless on this side
    return true;
}

void
PLayersParent::Write(
        const OpPaintThebesBuffer& __v,
        Message* __msg)
{
    Write((__v).layerParent(), __msg, false);
    // skipping actor field that's meaningless on this side
    Write((__v).newFrontBuffer(), __msg);
    Write((__v).updatedRegion(), __msg);
}

bool
PLayersParent::Read(
        OpPaintThebesBuffer* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->layerParent())), __msg, __iter, false)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    // skipping actor field that's meaningless on this side
    if ((!(Read((&((__v)->newFrontBuffer())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->updatedRegion())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PLayersParent::Write(
        const CanvasLayerAttributes& __v,
        Message* __msg)
{
    Write((__v).filter(), __msg);
}

bool
PLayersParent::Read(
        CanvasLayerAttributes* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->filter())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PLayersParent::Write(
        const TransformFunction& __v,
        Message* __msg)
{
    typedef TransformFunction __type;
    Write(int((__v).type()), __msg);

    switch ((__v).type()) {
    case __type::TPerspective:
        {
            Write((__v).get_Perspective(), __msg);
            return;
        }
    case __type::TRotationX:
        {
            Write((__v).get_RotationX(), __msg);
            return;
        }
    case __type::TRotationY:
        {
            Write((__v).get_RotationY(), __msg);
            return;
        }
    case __type::TRotationZ:
        {
            Write((__v).get_RotationZ(), __msg);
            return;
        }
    case __type::TRotation:
        {
            Write((__v).get_Rotation(), __msg);
            return;
        }
    case __type::TRotation3D:
        {
            Write((__v).get_Rotation3D(), __msg);
            return;
        }
    case __type::TScale:
        {
            Write((__v).get_Scale(), __msg);
            return;
        }
    case __type::TSkewX:
        {
            Write((__v).get_SkewX(), __msg);
            return;
        }
    case __type::TSkewY:
        {
            Write((__v).get_SkewY(), __msg);
            return;
        }
    case __type::TTranslation:
        {
            Write((__v).get_Translation(), __msg);
            return;
        }
    case __type::TTransformMatrix:
        {
            Write((__v).get_TransformMatrix(), __msg);
            return;
        }
    default:
        {
            NS_RUNTIMEABORT("unknown union type");
            return;
        }
    }
}

bool
PLayersParent::Read(
        TransformFunction* __v,
        const Message* __msg,
        void** __iter)
{
    typedef TransformFunction __type;
    int type;
    if ((!(Read((&(type)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }

    switch (type) {
    case __type::TPerspective:
        {
            Perspective tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_Perspective())), __msg, __iter);
        }
    case __type::TRotationX:
        {
            RotationX tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_RotationX())), __msg, __iter);
        }
    case __type::TRotationY:
        {
            RotationY tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_RotationY())), __msg, __iter);
        }
    case __type::TRotationZ:
        {
            RotationZ tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_RotationZ())), __msg, __iter);
        }
    case __type::TRotation:
        {
            Rotation tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_Rotation())), __msg, __iter);
        }
    case __type::TRotation3D:
        {
            Rotation3D tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_Rotation3D())), __msg, __iter);
        }
    case __type::TScale:
        {
            Scale tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_Scale())), __msg, __iter);
        }
    case __type::TSkewX:
        {
            SkewX tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_SkewX())), __msg, __iter);
        }
    case __type::TSkewY:
        {
            SkewY tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_SkewY())), __msg, __iter);
        }
    case __type::TTranslation:
        {
            Translation tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_Translation())), __msg, __iter);
        }
    case __type::TTransformMatrix:
        {
            TransformMatrix tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_TransformMatrix())), __msg, __iter);
        }
    default:
        {
            mozilla::ipc::ProtocolErrorBreakpoint("unknown union type");
            return false;
        }
    }
}

void
PLayersParent::Write(
        const Animation& __v,
        Message* __msg)
{
    Write((__v).startTime(), __msg);
    Write((__v).duration(), __msg);
    Write((__v).segments(), __msg);
    Write((__v).numIterations(), __msg);
    Write((__v).direction(), __msg);
    Write((__v).property(), __msg);
    Write((__v).data(), __msg);
}

bool
PLayersParent::Read(
        Animation* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->startTime())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->duration())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->segments())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->numIterations())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->direction())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->property())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->data())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PLayersParent::Write(
        const OpCreateColorLayer& __v,
        Message* __msg)
{
    Write((__v).layerParent(), __msg, false);
    // skipping actor field that's meaningless on this side
}

bool
PLayersParent::Read(
        OpCreateColorLayer* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->layerParent())), __msg, __iter, false)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    // skipping actor field that's meaningless on this side
    return true;
}

void
PLayersParent::Write(
        const OpPaintTiledLayerBuffer& __v,
        Message* __msg)
{
    Write((__v).layerParent(), __msg, false);
    // skipping actor field that's meaningless on this side
    Write((__v).tiledLayerBuffer(), __msg);
}

bool
PLayersParent::Read(
        OpPaintTiledLayerBuffer* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->layerParent())), __msg, __iter, false)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    // skipping actor field that's meaningless on this side
    if ((!(Read((&((__v)->tiledLayerBuffer())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PLayersParent::Write(
        const ImageLayerAttributes& __v,
        Message* __msg)
{
    Write((__v).filter(), __msg);
    Write((__v).forceSingleTile(), __msg);
}

bool
PLayersParent::Read(
        ImageLayerAttributes* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->filter())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->forceSingleTile())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PLayersParent::Write(
        const YUVImage& __v,
        Message* __msg)
{
    Write((__v).Ydata(), __msg);
    Write((__v).Udata(), __msg);
    Write((__v).Vdata(), __msg);
    Write((__v).picture(), __msg);
}

bool
PLayersParent::Read(
        YUVImage* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->Ydata())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->Udata())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->Vdata())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->picture())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PLayersParent::Write(
        PGrallocBufferParent* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PLayersParent::Read(
        PGrallocBufferParent** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PLayers");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PGrallocBuffer");
        return false;
    }

    if ((PGrallocBufferMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PGrallocBuffer has different type");
        return false;
    }

    (*(__v)) = static_cast<PGrallocBufferParent*>(listener);
    return true;
}

void
PLayersParent::Write(
        const Translation& __v,
        Message* __msg)
{
    Write((__v).x(), __msg);
    Write((__v).y(), __msg);
    Write((__v).z(), __msg);
}

bool
PLayersParent::Read(
        Translation* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->x())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->y())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->z())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PLayersParent::Write(
        const Perspective& __v,
        Message* __msg)
{
    Write((__v).value(), __msg);
}

bool
PLayersParent::Read(
        Perspective* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->value())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PLayersParent::Write(
        PLayerParent* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PLayersParent::Read(
        PLayerParent** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PLayers");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PLayer");
        return false;
    }

    if ((PLayerMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PLayer has different type");
        return false;
    }

    (*(__v)) = static_cast<PLayerParent*>(listener);
    return true;
}

void
PLayersParent::Write(
        const SurfaceDescriptorGralloc& __v,
        Message* __msg)
{
    Write((__v).bufferParent(), __msg, false);
    // skipping actor field that's meaningless on this side
    Write((__v).external(), __msg);
}

bool
PLayersParent::Read(
        SurfaceDescriptorGralloc* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->bufferParent())), __msg, __iter, false)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    // skipping actor field that's meaningless on this side
    if ((!(Read((&((__v)->external())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PLayersParent::Write(
        const OpCreateThebesLayer& __v,
        Message* __msg)
{
    Write((__v).layerParent(), __msg, false);
    // skipping actor field that's meaningless on this side
}

bool
PLayersParent::Read(
        OpCreateThebesLayer* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->layerParent())), __msg, __iter, false)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    // skipping actor field that's meaningless on this side
    return true;
}

void
PLayersParent::Write(
        const EditReply& __v,
        Message* __msg)
{
    typedef EditReply __type;
    Write(int((__v).type()), __msg);

    switch ((__v).type()) {
    case __type::TOpBufferSwap:
        {
            Write((__v).get_OpBufferSwap(), __msg);
            return;
        }
    case __type::TOpThebesBufferSwap:
        {
            Write((__v).get_OpThebesBufferSwap(), __msg);
            return;
        }
    case __type::TOpImageSwap:
        {
            Write((__v).get_OpImageSwap(), __msg);
            return;
        }
    default:
        {
            NS_RUNTIMEABORT("unknown union type");
            return;
        }
    }
}

bool
PLayersParent::Read(
        EditReply* __v,
        const Message* __msg,
        void** __iter)
{
    typedef EditReply __type;
    int type;
    if ((!(Read((&(type)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }

    switch (type) {
    case __type::TOpBufferSwap:
        {
            OpBufferSwap tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_OpBufferSwap())), __msg, __iter);
        }
    case __type::TOpThebesBufferSwap:
        {
            OpThebesBufferSwap tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_OpThebesBufferSwap())), __msg, __iter);
        }
    case __type::TOpImageSwap:
        {
            OpImageSwap tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_OpImageSwap())), __msg, __iter);
        }
    default:
        {
            mozilla::ipc::ProtocolErrorBreakpoint("unknown union type");
            return false;
        }
    }
}

void
PLayersParent::Write(
        const InfallibleTArray<Edit>& __v,
        Message* __msg)
{
    uint32_t length = (__v).Length();
    Write(length, __msg);

    for (uint32_t i = 0; (i) < (length); (++(i))) {
        Write(__v[i], __msg);
    }
}

bool
PLayersParent::Read(
        InfallibleTArray<Edit>* __v,
        const Message* __msg,
        void** __iter)
{
    InfallibleTArray<Edit>& a = (*(__v));
    uint32_t length;
    if ((!(Read((&(length)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }

    (__v)->SetLength(length);
    for (uint32_t i = 0; (i) < (length); (++(i))) {
        if ((!(Read((&(a[i])), __msg, __iter)))) {
            mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
            return false;
        }
    }
    return true;
}

void
PLayersParent::Write(
        const Edit& __v,
        Message* __msg)
{
    typedef Edit __type;
    Write(int((__v).type()), __msg);

    switch ((__v).type()) {
    case __type::TOpCreateThebesLayer:
        {
            Write((__v).get_OpCreateThebesLayer(), __msg);
            return;
        }
    case __type::TOpCreateContainerLayer:
        {
            Write((__v).get_OpCreateContainerLayer(), __msg);
            return;
        }
    case __type::TOpCreateImageLayer:
        {
            Write((__v).get_OpCreateImageLayer(), __msg);
            return;
        }
    case __type::TOpCreateColorLayer:
        {
            Write((__v).get_OpCreateColorLayer(), __msg);
            return;
        }
    case __type::TOpCreateCanvasLayer:
        {
            Write((__v).get_OpCreateCanvasLayer(), __msg);
            return;
        }
    case __type::TOpCreateRefLayer:
        {
            Write((__v).get_OpCreateRefLayer(), __msg);
            return;
        }
    case __type::TOpSetLayerAttributes:
        {
            Write((__v).get_OpSetLayerAttributes(), __msg);
            return;
        }
    case __type::TOpSetRoot:
        {
            Write((__v).get_OpSetRoot(), __msg);
            return;
        }
    case __type::TOpInsertAfter:
        {
            Write((__v).get_OpInsertAfter(), __msg);
            return;
        }
    case __type::TOpAppendChild:
        {
            Write((__v).get_OpAppendChild(), __msg);
            return;
        }
    case __type::TOpRemoveChild:
        {
            Write((__v).get_OpRemoveChild(), __msg);
            return;
        }
    case __type::TOpRepositionChild:
        {
            Write((__v).get_OpRepositionChild(), __msg);
            return;
        }
    case __type::TOpRaiseToTopChild:
        {
            Write((__v).get_OpRaiseToTopChild(), __msg);
            return;
        }
    case __type::TOpPaintThebesBuffer:
        {
            Write((__v).get_OpPaintThebesBuffer(), __msg);
            return;
        }
    case __type::TOpPaintTiledLayerBuffer:
        {
            Write((__v).get_OpPaintTiledLayerBuffer(), __msg);
            return;
        }
    case __type::TOpPaintCanvas:
        {
            Write((__v).get_OpPaintCanvas(), __msg);
            return;
        }
    case __type::TOpPaintImage:
        {
            Write((__v).get_OpPaintImage(), __msg);
            return;
        }
    default:
        {
            NS_RUNTIMEABORT("unknown union type");
            return;
        }
    }
}

bool
PLayersParent::Read(
        Edit* __v,
        const Message* __msg,
        void** __iter)
{
    typedef Edit __type;
    int type;
    if ((!(Read((&(type)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }

    switch (type) {
    case __type::TOpCreateThebesLayer:
        {
            OpCreateThebesLayer tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_OpCreateThebesLayer())), __msg, __iter);
        }
    case __type::TOpCreateContainerLayer:
        {
            OpCreateContainerLayer tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_OpCreateContainerLayer())), __msg, __iter);
        }
    case __type::TOpCreateImageLayer:
        {
            OpCreateImageLayer tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_OpCreateImageLayer())), __msg, __iter);
        }
    case __type::TOpCreateColorLayer:
        {
            OpCreateColorLayer tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_OpCreateColorLayer())), __msg, __iter);
        }
    case __type::TOpCreateCanvasLayer:
        {
            OpCreateCanvasLayer tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_OpCreateCanvasLayer())), __msg, __iter);
        }
    case __type::TOpCreateRefLayer:
        {
            OpCreateRefLayer tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_OpCreateRefLayer())), __msg, __iter);
        }
    case __type::TOpSetLayerAttributes:
        {
            OpSetLayerAttributes tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_OpSetLayerAttributes())), __msg, __iter);
        }
    case __type::TOpSetRoot:
        {
            OpSetRoot tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_OpSetRoot())), __msg, __iter);
        }
    case __type::TOpInsertAfter:
        {
            OpInsertAfter tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_OpInsertAfter())), __msg, __iter);
        }
    case __type::TOpAppendChild:
        {
            OpAppendChild tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_OpAppendChild())), __msg, __iter);
        }
    case __type::TOpRemoveChild:
        {
            OpRemoveChild tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_OpRemoveChild())), __msg, __iter);
        }
    case __type::TOpRepositionChild:
        {
            OpRepositionChild tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_OpRepositionChild())), __msg, __iter);
        }
    case __type::TOpRaiseToTopChild:
        {
            OpRaiseToTopChild tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_OpRaiseToTopChild())), __msg, __iter);
        }
    case __type::TOpPaintThebesBuffer:
        {
            OpPaintThebesBuffer tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_OpPaintThebesBuffer())), __msg, __iter);
        }
    case __type::TOpPaintTiledLayerBuffer:
        {
            OpPaintTiledLayerBuffer tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_OpPaintTiledLayerBuffer())), __msg, __iter);
        }
    case __type::TOpPaintCanvas:
        {
            OpPaintCanvas tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_OpPaintCanvas())), __msg, __iter);
        }
    case __type::TOpPaintImage:
        {
            OpPaintImage tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_OpPaintImage())), __msg, __iter);
        }
    default:
        {
            mozilla::ipc::ProtocolErrorBreakpoint("unknown union type");
            return false;
        }
    }
}

void
PLayersParent::Write(
        const SharedImage& __v,
        Message* __msg)
{
    typedef SharedImage __type;
    Write(int((__v).type()), __msg);

    switch ((__v).type()) {
    case __type::TSurfaceDescriptor:
        {
            Write((__v).get_SurfaceDescriptor(), __msg);
            return;
        }
    case __type::TRGBImage:
        {
            Write((__v).get_RGBImage(), __msg);
            return;
        }
    case __type::TYCbCrImage:
        {
            Write((__v).get_YCbCrImage(), __msg);
            return;
        }
    case __type::TYUVImage:
        {
            Write((__v).get_YUVImage(), __msg);
            return;
        }
    case __type::TSharedImageID:
        {
            Write((__v).get_SharedImageID(), __msg);
            return;
        }
    case __type::Tnull_t:
        {
            Write((__v).get_null_t(), __msg);
            return;
        }
    default:
        {
            NS_RUNTIMEABORT("unknown union type");
            return;
        }
    }
}

bool
PLayersParent::Read(
        SharedImage* __v,
        const Message* __msg,
        void** __iter)
{
    typedef SharedImage __type;
    int type;
    if ((!(Read((&(type)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }

    switch (type) {
    case __type::TSurfaceDescriptor:
        {
            SurfaceDescriptor tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_SurfaceDescriptor())), __msg, __iter);
        }
    case __type::TRGBImage:
        {
            RGBImage tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_RGBImage())), __msg, __iter);
        }
    case __type::TYCbCrImage:
        {
            YCbCrImage tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_YCbCrImage())), __msg, __iter);
        }
    case __type::TYUVImage:
        {
            YUVImage tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_YUVImage())), __msg, __iter);
        }
    case __type::TSharedImageID:
        {
            SharedImageID tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_SharedImageID())), __msg, __iter);
        }
    case __type::Tnull_t:
        {
            null_t tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_null_t())), __msg, __iter);
        }
    default:
        {
            mozilla::ipc::ProtocolErrorBreakpoint("unknown union type");
            return false;
        }
    }
}

void
PLayersParent::Write(
        const AnimationSegment& __v,
        Message* __msg)
{
    Write((__v).startState(), __msg);
    Write((__v).endState(), __msg);
    Write((__v).startPortion(), __msg);
    Write((__v).endPortion(), __msg);
    Write((__v).sampleFn(), __msg);
}

bool
PLayersParent::Read(
        AnimationSegment* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->startState())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->endState())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->startPortion())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->endPortion())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->sampleFn())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PLayersParent::Write(
        const CanvasSurface& __v,
        Message* __msg)
{
    typedef CanvasSurface __type;
    Write(int((__v).type()), __msg);

    switch ((__v).type()) {
    case __type::TSurfaceDescriptor:
        {
            Write((__v).get_SurfaceDescriptor(), __msg);
            return;
        }
    case __type::Tnull_t:
        {
            Write((__v).get_null_t(), __msg);
            return;
        }
    default:
        {
            NS_RUNTIMEABORT("unknown union type");
            return;
        }
    }
}

bool
PLayersParent::Read(
        CanvasSurface* __v,
        const Message* __msg,
        void** __iter)
{
    typedef CanvasSurface __type;
    int type;
    if ((!(Read((&(type)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }

    switch (type) {
    case __type::TSurfaceDescriptor:
        {
            SurfaceDescriptor tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_SurfaceDescriptor())), __msg, __iter);
        }
    case __type::Tnull_t:
        {
            null_t tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_null_t())), __msg, __iter);
        }
    default:
        {
            mozilla::ipc::ProtocolErrorBreakpoint("unknown union type");
            return false;
        }
    }
}

void
PLayersParent::Write(
        const YCbCrImage& __v,
        Message* __msg)
{
    Write((__v).data(), __msg);
    Write((__v).offset(), __msg);
    Write((__v).picture(), __msg);
}

bool
PLayersParent::Read(
        YCbCrImage* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->data())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->offset())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->picture())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PLayersParent::Write(
        const OptionalThebesBuffer& __v,
        Message* __msg)
{
    typedef OptionalThebesBuffer __type;
    Write(int((__v).type()), __msg);

    switch ((__v).type()) {
    case __type::TThebesBuffer:
        {
            Write((__v).get_ThebesBuffer(), __msg);
            return;
        }
    case __type::Tnull_t:
        {
            Write((__v).get_null_t(), __msg);
            return;
        }
    default:
        {
            NS_RUNTIMEABORT("unknown union type");
            return;
        }
    }
}

bool
PLayersParent::Read(
        OptionalThebesBuffer* __v,
        const Message* __msg,
        void** __iter)
{
    typedef OptionalThebesBuffer __type;
    int type;
    if ((!(Read((&(type)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }

    switch (type) {
    case __type::TThebesBuffer:
        {
            ThebesBuffer tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_ThebesBuffer())), __msg, __iter);
        }
    case __type::Tnull_t:
        {
            null_t tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_null_t())), __msg, __iter);
        }
    default:
        {
            mozilla::ipc::ProtocolErrorBreakpoint("unknown union type");
            return false;
        }
    }
}

void
PLayersParent::Write(
        const OpBufferSwap& __v,
        Message* __msg)
{
    Write((__v).layerParent(), __msg, false);
    // skipping actor field that's meaningless on this side
    Write((__v).newBackBuffer(), __msg);
}

bool
PLayersParent::Read(
        OpBufferSwap* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->layerParent())), __msg, __iter, false)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    // skipping actor field that's meaningless on this side
    if ((!(Read((&((__v)->newBackBuffer())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PLayersParent::Write(
        PLayersParent* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PLayersParent::Read(
        PLayersParent** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PLayers");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PLayers");
        return false;
    }

    if ((PLayersMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PLayers has different type");
        return false;
    }

    (*(__v)) = static_cast<PLayersParent*>(listener);
    return true;
}

void
PLayersParent::Write(
        const OpImageSwap& __v,
        Message* __msg)
{
    Write((__v).layerParent(), __msg, false);
    // skipping actor field that's meaningless on this side
    Write((__v).newBackImage(), __msg);
}

bool
PLayersParent::Read(
        OpImageSwap* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->layerParent())), __msg, __iter, false)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    // skipping actor field that's meaningless on this side
    if ((!(Read((&((__v)->newBackImage())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PLayersParent::Write(
        const ColorLayerAttributes& __v,
        Message* __msg)
{
    Write((__v).color(), __msg);
}

bool
PLayersParent::Read(
        ColorLayerAttributes* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->color())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PLayersParent::Write(
        const SurfaceDescriptorD3D10& __v,
        Message* __msg)
{
    Write((__v).handle(), __msg);
}

bool
PLayersParent::Read(
        SurfaceDescriptorD3D10* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->handle())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PLayersParent::Write(
        const SkewX& __v,
        Message* __msg)
{
    Write((__v).x(), __msg);
}

bool
PLayersParent::Read(
        SkewX* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->x())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PLayersParent::Write(
        const SkewY& __v,
        Message* __msg)
{
    Write((__v).y(), __msg);
}

bool
PLayersParent::Read(
        SkewY* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->y())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PLayersParent::Write(
        const RotationZ& __v,
        Message* __msg)
{
    Write((__v).radians(), __msg);
}

bool
PLayersParent::Read(
        RotationZ* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->radians())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PLayersParent::Write(
        const SharedTextureDescriptor& __v,
        Message* __msg)
{
    Write((__v).shareType(), __msg);
    Write((__v).handle(), __msg);
    Write((__v).size(), __msg);
    Write((__v).inverted(), __msg);
}

bool
PLayersParent::Read(
        SharedTextureDescriptor* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->shareType())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->handle())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->size())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->inverted())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PLayersParent::Write(
        const RotationX& __v,
        Message* __msg)
{
    Write((__v).radians(), __msg);
}

bool
PLayersParent::Read(
        RotationX* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->radians())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PLayersParent::Write(
        const RotationY& __v,
        Message* __msg)
{
    Write((__v).radians(), __msg);
}

bool
PLayersParent::Read(
        RotationY* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->radians())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PLayersParent::Write(
        const Animatable& __v,
        Message* __msg)
{
    typedef Animatable __type;
    Write(int((__v).type()), __msg);

    switch ((__v).type()) {
    case __type::Tfloat:
        {
            Write((__v).get_float(), __msg);
            return;
        }
    case __type::TArrayOfTransformFunction:
        {
            Write((__v).get_ArrayOfTransformFunction(), __msg);
            return;
        }
    default:
        {
            NS_RUNTIMEABORT("unknown union type");
            return;
        }
    }
}

bool
PLayersParent::Read(
        Animatable* __v,
        const Message* __msg,
        void** __iter)
{
    typedef Animatable __type;
    int type;
    if ((!(Read((&(type)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }

    switch (type) {
    case __type::Tfloat:
        {
            float tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_float())), __msg, __iter);
        }
    case __type::TArrayOfTransformFunction:
        {
            InfallibleTArray<TransformFunction> tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_ArrayOfTransformFunction())), __msg, __iter);
        }
    default:
        {
            mozilla::ipc::ProtocolErrorBreakpoint("unknown union type");
            return false;
        }
    }
}

void
PLayersParent::Write(
        Shmem& __v,
        Message* __msg)
{
    IPC::WriteParam(__msg, __v);
    (__v).RevokeRights(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead());
    (__v).forget(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead());
}

bool
PLayersParent::Read(
        Shmem* __v,
        const Message* __msg,
        void** __iter)
{
    Shmem tmp;
    if ((!(IPC::ReadParam(__msg, __iter, (&(tmp)))))) {
        return false;
    }

    Shmem::id_t shmemid = (tmp).Id(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead());
    Shmem::SharedMemory* rawmem = LookupSharedMemory(shmemid);
    if (rawmem) {
        (*(__v)) = Shmem(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(), rawmem, shmemid);
        return true;
    }
    return false;
}

void
PLayersParent::Write(
        const OpCreateRefLayer& __v,
        Message* __msg)
{
    Write((__v).layerParent(), __msg, false);
    // skipping actor field that's meaningless on this side
}

bool
PLayersParent::Read(
        OpCreateRefLayer* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->layerParent())), __msg, __iter, false)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    // skipping actor field that's meaningless on this side
    return true;
}

void
PLayersParent::Write(
        const OpPaintImage& __v,
        Message* __msg)
{
    Write((__v).layerParent(), __msg, false);
    // skipping actor field that's meaningless on this side
    Write((__v).newFrontBuffer(), __msg);
}

bool
PLayersParent::Read(
        OpPaintImage* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->layerParent())), __msg, __iter, false)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    // skipping actor field that's meaningless on this side
    if ((!(Read((&((__v)->newFrontBuffer())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PLayersParent::Write(
        const OpThebesBufferSwap& __v,
        Message* __msg)
{
    Write((__v).layerParent(), __msg, false);
    // skipping actor field that's meaningless on this side
    Write((__v).newBackBuffer(), __msg);
    Write((__v).newValidRegion(), __msg);
    Write((__v).readOnlyFrontBuffer(), __msg);
    Write((__v).frontUpdatedRegion(), __msg);
}

bool
PLayersParent::Read(
        OpThebesBufferSwap* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->layerParent())), __msg, __iter, false)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    // skipping actor field that's meaningless on this side
    if ((!(Read((&((__v)->newBackBuffer())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->newValidRegion())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->readOnlyFrontBuffer())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->frontUpdatedRegion())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PLayersParent::Write(
        const OpCreateContainerLayer& __v,
        Message* __msg)
{
    Write((__v).layerParent(), __msg, false);
    // skipping actor field that's meaningless on this side
}

bool
PLayersParent::Read(
        OpCreateContainerLayer* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->layerParent())), __msg, __iter, false)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    // skipping actor field that's meaningless on this side
    return true;
}

void
PLayersParent::Write(
        const LayerAttributes& __v,
        Message* __msg)
{
    Write((__v).common(), __msg);
    Write((__v).specific(), __msg);
}

bool
PLayersParent::Read(
        LayerAttributes* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->common())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->specific())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PLayersParent::Write(
        const Rotation& __v,
        Message* __msg)
{
    Write((__v).radians(), __msg);
}

bool
PLayersParent::Read(
        Rotation* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->radians())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PLayersParent::Write(
        const InfallibleTArray<TransformFunction>& __v,
        Message* __msg)
{
    uint32_t length = (__v).Length();
    Write(length, __msg);

    for (uint32_t i = 0; (i) < (length); (++(i))) {
        Write(__v[i], __msg);
    }
}

bool
PLayersParent::Read(
        InfallibleTArray<TransformFunction>* __v,
        const Message* __msg,
        void** __iter)
{
    InfallibleTArray<TransformFunction>& a = (*(__v));
    uint32_t length;
    if ((!(Read((&(length)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }

    (__v)->SetLength(length);
    for (uint32_t i = 0; (i) < (length); (++(i))) {
        if ((!(Read((&(a[i])), __msg, __iter)))) {
            mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
            return false;
        }
    }
    return true;
}

void
PLayersParent::Write(
        const OpSetRoot& __v,
        Message* __msg)
{
    Write((__v).rootParent(), __msg, false);
    // skipping actor field that's meaningless on this side
}

bool
PLayersParent::Read(
        OpSetRoot* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->rootParent())), __msg, __iter, false)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    // skipping actor field that's meaningless on this side
    return true;
}

void
PLayersParent::Write(
        const TransformData& __v,
        Message* __msg)
{
    Write((__v).origin(), __msg);
    Write((__v).mozOrigin(), __msg);
    Write((__v).perspectiveOrigin(), __msg);
    Write((__v).bounds(), __msg);
    Write((__v).perspective(), __msg);
}

bool
PLayersParent::Read(
        TransformData* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->origin())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->mozOrigin())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->perspectiveOrigin())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->bounds())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->perspective())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PLayersParent::Write(
        const OpRemoveChild& __v,
        Message* __msg)
{
    Write((__v).containerParent(), __msg, false);
    // skipping actor field that's meaningless on this side
    Write((__v).childLayerParent(), __msg, false);
    // skipping actor field that's meaningless on this side
}

bool
PLayersParent::Read(
        OpRemoveChild* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->containerParent())), __msg, __iter, false)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    // skipping actor field that's meaningless on this side
    if ((!(Read((&((__v)->childLayerParent())), __msg, __iter, false)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    // skipping actor field that's meaningless on this side
    return true;
}

void
PLayersParent::Write(
        const ContainerLayerAttributes& __v,
        Message* __msg)
{
    Write((__v).metrics(), __msg);
    Write((__v).preXScale(), __msg);
    Write((__v).preYScale(), __msg);
}

bool
PLayersParent::Read(
        ContainerLayerAttributes* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->metrics())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->preXScale())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->preYScale())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PLayersParent::Write(
        const AnimationData& __v,
        Message* __msg)
{
    typedef AnimationData __type;
    Write(int((__v).type()), __msg);

    switch ((__v).type()) {
    case __type::Tnull_t:
        {
            Write((__v).get_null_t(), __msg);
            return;
        }
    case __type::TTransformData:
        {
            Write((__v).get_TransformData(), __msg);
            return;
        }
    default:
        {
            NS_RUNTIMEABORT("unknown union type");
            return;
        }
    }
}

bool
PLayersParent::Read(
        AnimationData* __v,
        const Message* __msg,
        void** __iter)
{
    typedef AnimationData __type;
    int type;
    if ((!(Read((&(type)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }

    switch (type) {
    case __type::Tnull_t:
        {
            null_t tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_null_t())), __msg, __iter);
        }
    case __type::TTransformData:
        {
            TransformData tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_TransformData())), __msg, __iter);
        }
    default:
        {
            mozilla::ipc::ProtocolErrorBreakpoint("unknown union type");
            return false;
        }
    }
}

void
PLayersParent::Write(
        const OpRepositionChild& __v,
        Message* __msg)
{
    Write((__v).containerParent(), __msg, false);
    // skipping actor field that's meaningless on this side
    Write((__v).childLayerParent(), __msg, false);
    // skipping actor field that's meaningless on this side
    Write((__v).afterParent(), __msg, false);
    // skipping actor field that's meaningless on this side
}

bool
PLayersParent::Read(
        OpRepositionChild* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->containerParent())), __msg, __iter, false)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    // skipping actor field that's meaningless on this side
    if ((!(Read((&((__v)->childLayerParent())), __msg, __iter, false)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    // skipping actor field that's meaningless on this side
    if ((!(Read((&((__v)->afterParent())), __msg, __iter, false)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    // skipping actor field that's meaningless on this side
    return true;
}

void
PLayersParent::Write(
        const InfallibleTArray<AnimationSegment>& __v,
        Message* __msg)
{
    uint32_t length = (__v).Length();
    Write(length, __msg);

    for (uint32_t i = 0; (i) < (length); (++(i))) {
        Write(__v[i], __msg);
    }
}

bool
PLayersParent::Read(
        InfallibleTArray<AnimationSegment>* __v,
        const Message* __msg,
        void** __iter)
{
    InfallibleTArray<AnimationSegment>& a = (*(__v));
    uint32_t length;
    if ((!(Read((&(length)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }

    (__v)->SetLength(length);
    for (uint32_t i = 0; (i) < (length); (++(i))) {
        if ((!(Read((&(a[i])), __msg, __iter)))) {
            mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
            return false;
        }
    }
    return true;
}

void
PLayersParent::Write(
        const TargetConfig& __v,
        Message* __msg)
{
    Write((__v).naturalBounds(), __msg);
    Write((__v).rotation(), __msg);
    Write((__v).clientBounds(), __msg);
    Write((__v).orientation(), __msg);
}

bool
PLayersParent::Read(
        TargetConfig* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->naturalBounds())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->rotation())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->clientBounds())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->orientation())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PLayersParent::Write(
        const OpSetLayerAttributes& __v,
        Message* __msg)
{
    Write((__v).layerParent(), __msg, false);
    // skipping actor field that's meaningless on this side
    Write((__v).attrs(), __msg);
}

bool
PLayersParent::Read(
        OpSetLayerAttributes* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->layerParent())), __msg, __iter, false)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    // skipping actor field that's meaningless on this side
    if ((!(Read((&((__v)->attrs())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PLayersParent::Write(
        const ThebesBuffer& __v,
        Message* __msg)
{
    Write((__v).buffer(), __msg);
    Write((__v).rect(), __msg);
    Write((__v).rotation(), __msg);
}

bool
PLayersParent::Read(
        ThebesBuffer* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->buffer())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->rect())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->rotation())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PLayersParent::Write(
        const SpecificLayerAttributes& __v,
        Message* __msg)
{
    typedef SpecificLayerAttributes __type;
    Write(int((__v).type()), __msg);

    switch ((__v).type()) {
    case __type::Tnull_t:
        {
            Write((__v).get_null_t(), __msg);
            return;
        }
    case __type::TThebesLayerAttributes:
        {
            Write((__v).get_ThebesLayerAttributes(), __msg);
            return;
        }
    case __type::TContainerLayerAttributes:
        {
            Write((__v).get_ContainerLayerAttributes(), __msg);
            return;
        }
    case __type::TColorLayerAttributes:
        {
            Write((__v).get_ColorLayerAttributes(), __msg);
            return;
        }
    case __type::TCanvasLayerAttributes:
        {
            Write((__v).get_CanvasLayerAttributes(), __msg);
            return;
        }
    case __type::TRefLayerAttributes:
        {
            Write((__v).get_RefLayerAttributes(), __msg);
            return;
        }
    case __type::TImageLayerAttributes:
        {
            Write((__v).get_ImageLayerAttributes(), __msg);
            return;
        }
    default:
        {
            NS_RUNTIMEABORT("unknown union type");
            return;
        }
    }
}

bool
PLayersParent::Read(
        SpecificLayerAttributes* __v,
        const Message* __msg,
        void** __iter)
{
    typedef SpecificLayerAttributes __type;
    int type;
    if ((!(Read((&(type)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }

    switch (type) {
    case __type::Tnull_t:
        {
            null_t tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_null_t())), __msg, __iter);
        }
    case __type::TThebesLayerAttributes:
        {
            ThebesLayerAttributes tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_ThebesLayerAttributes())), __msg, __iter);
        }
    case __type::TContainerLayerAttributes:
        {
            ContainerLayerAttributes tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_ContainerLayerAttributes())), __msg, __iter);
        }
    case __type::TColorLayerAttributes:
        {
            ColorLayerAttributes tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_ColorLayerAttributes())), __msg, __iter);
        }
    case __type::TCanvasLayerAttributes:
        {
            CanvasLayerAttributes tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_CanvasLayerAttributes())), __msg, __iter);
        }
    case __type::TRefLayerAttributes:
        {
            RefLayerAttributes tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_RefLayerAttributes())), __msg, __iter);
        }
    case __type::TImageLayerAttributes:
        {
            ImageLayerAttributes tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_ImageLayerAttributes())), __msg, __iter);
        }
    default:
        {
            mozilla::ipc::ProtocolErrorBreakpoint("unknown union type");
            return false;
        }
    }
}

void
PLayersParent::Write(
        const ThebesLayerAttributes& __v,
        Message* __msg)
{
    Write((__v).validRegion(), __msg);
}

bool
PLayersParent::Read(
        ThebesLayerAttributes* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->validRegion())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PLayersParent::Write(
        const OpRaiseToTopChild& __v,
        Message* __msg)
{
    Write((__v).containerParent(), __msg, false);
    // skipping actor field that's meaningless on this side
    Write((__v).childLayerParent(), __msg, false);
    // skipping actor field that's meaningless on this side
}

bool
PLayersParent::Read(
        OpRaiseToTopChild* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->containerParent())), __msg, __iter, false)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    // skipping actor field that's meaningless on this side
    if ((!(Read((&((__v)->childLayerParent())), __msg, __iter, false)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    // skipping actor field that's meaningless on this side
    return true;
}

void
PLayersParent::Write(
        const InfallibleTArray<EditReply>& __v,
        Message* __msg)
{
    uint32_t length = (__v).Length();
    Write(length, __msg);

    for (uint32_t i = 0; (i) < (length); (++(i))) {
        Write(__v[i], __msg);
    }
}

bool
PLayersParent::Read(
        InfallibleTArray<EditReply>* __v,
        const Message* __msg,
        void** __iter)
{
    InfallibleTArray<EditReply>& a = (*(__v));
    uint32_t length;
    if ((!(Read((&(length)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }

    (__v)->SetLength(length);
    for (uint32_t i = 0; (i) < (length); (++(i))) {
        if ((!(Read((&(a[i])), __msg, __iter)))) {
            mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
            return false;
        }
    }
    return true;
}

void
PLayersParent::Write(
        const SharedImageID& __v,
        Message* __msg)
{
    Write((__v).id(), __msg);
}

bool
PLayersParent::Read(
        SharedImageID* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->id())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PLayersParent::Write(
        const TransformMatrix& __v,
        Message* __msg)
{
    Write((__v).value(), __msg);
}

bool
PLayersParent::Read(
        TransformMatrix* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->value())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PLayersParent::Write(
        const OpCreateImageLayer& __v,
        Message* __msg)
{
    Write((__v).layerParent(), __msg, false);
    // skipping actor field that's meaningless on this side
}

bool
PLayersParent::Read(
        OpCreateImageLayer* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->layerParent())), __msg, __iter, false)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    // skipping actor field that's meaningless on this side
    return true;
}

void
PLayersParent::Write(
        const CommonLayerAttributes& __v,
        Message* __msg)
{
    Write((__v).visibleRegion(), __msg);
    Write((__v).transform(), __msg);
    Write((__v).postXScale(), __msg);
    Write((__v).postYScale(), __msg);
    Write((__v).contentFlags(), __msg);
    Write((__v).opacity(), __msg);
    Write((__v).useClipRect(), __msg);
    Write((__v).clipRect(), __msg);
    Write((__v).isFixedPosition(), __msg);
    Write((__v).fixedPositionAnchor(), __msg);
    Write((__v).maskLayerParent(), __msg, true);
    // skipping actor field that's meaningless on this side
    Write((__v).animations(), __msg);
}

bool
PLayersParent::Read(
        CommonLayerAttributes* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->visibleRegion())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->transform())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->postXScale())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->postYScale())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->contentFlags())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->opacity())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->useClipRect())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->clipRect())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->isFixedPosition())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->fixedPositionAnchor())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->maskLayerParent())), __msg, __iter, true)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    // skipping actor field that's meaningless on this side
    if ((!(Read((&((__v)->animations())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PLayersParent::Write(
        const OpCreateCanvasLayer& __v,
        Message* __msg)
{
    Write((__v).layerParent(), __msg, false);
    // skipping actor field that's meaningless on this side
}

bool
PLayersParent::Read(
        OpCreateCanvasLayer* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->layerParent())), __msg, __iter, false)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    // skipping actor field that's meaningless on this side
    return true;
}

void
PLayersParent::Write(
        const TimingFunction& __v,
        Message* __msg)
{
    typedef TimingFunction __type;
    Write(int((__v).type()), __msg);

    switch ((__v).type()) {
    case __type::TCubicBezierFunction:
        {
            Write((__v).get_CubicBezierFunction(), __msg);
            return;
        }
    case __type::TStepFunction:
        {
            Write((__v).get_StepFunction(), __msg);
            return;
        }
    default:
        {
            NS_RUNTIMEABORT("unknown union type");
            return;
        }
    }
}

bool
PLayersParent::Read(
        TimingFunction* __v,
        const Message* __msg,
        void** __iter)
{
    typedef TimingFunction __type;
    int type;
    if ((!(Read((&(type)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }

    switch (type) {
    case __type::TCubicBezierFunction:
        {
            CubicBezierFunction tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_CubicBezierFunction())), __msg, __iter);
        }
    case __type::TStepFunction:
        {
            StepFunction tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_StepFunction())), __msg, __iter);
        }
    default:
        {
            mozilla::ipc::ProtocolErrorBreakpoint("unknown union type");
            return false;
        }
    }
}

void
PLayersParent::Write(
        const MaybeMagicGrallocBufferHandle& __v,
        Message* __msg)
{
    typedef MaybeMagicGrallocBufferHandle __type;
    Write(int((__v).type()), __msg);

    switch ((__v).type()) {
    case __type::TMagicGrallocBufferHandle:
        {
            Write((__v).get_MagicGrallocBufferHandle(), __msg);
            return;
        }
    case __type::Tnull_t:
        {
            Write((__v).get_null_t(), __msg);
            return;
        }
    default:
        {
            NS_RUNTIMEABORT("unknown union type");
            return;
        }
    }
}

bool
PLayersParent::Read(
        MaybeMagicGrallocBufferHandle* __v,
        const Message* __msg,
        void** __iter)
{
    typedef MaybeMagicGrallocBufferHandle __type;
    int type;
    if ((!(Read((&(type)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }

    switch (type) {
    case __type::TMagicGrallocBufferHandle:
        {
            MagicGrallocBufferHandle tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_MagicGrallocBufferHandle())), __msg, __iter);
        }
    case __type::Tnull_t:
        {
            null_t tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_null_t())), __msg, __iter);
        }
    default:
        {
            mozilla::ipc::ProtocolErrorBreakpoint("unknown union type");
            return false;
        }
    }
}

void
PLayersParent::Write(
        const Rotation3D& __v,
        Message* __msg)
{
    Write((__v).x(), __msg);
    Write((__v).y(), __msg);
    Write((__v).z(), __msg);
    Write((__v).radians(), __msg);
}

bool
PLayersParent::Read(
        Rotation3D* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->x())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->y())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->z())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->radians())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PLayersParent::Write(
        const RGBImage& __v,
        Message* __msg)
{
    Write((__v).data(), __msg);
    Write((__v).picture(), __msg);
    Write((__v).rgbFormat(), __msg);
}

bool
PLayersParent::Read(
        RGBImage* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->data())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->picture())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->rgbFormat())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PLayersParent::Write(
        const RefLayerAttributes& __v,
        Message* __msg)
{
    Write((__v).id(), __msg);
}

bool
PLayersParent::Read(
        RefLayerAttributes* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->id())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PLayersParent::Write(
        const StepFunction& __v,
        Message* __msg)
{
    Write((__v).steps(), __msg);
    Write((__v).type(), __msg);
}

bool
PLayersParent::Read(
        StepFunction* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->steps())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->type())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PLayersParent::Write(
        const OpPaintCanvas& __v,
        Message* __msg)
{
    Write((__v).layerParent(), __msg, false);
    // skipping actor field that's meaningless on this side
    Write((__v).newFrontBuffer(), __msg);
    Write((__v).needYFlip(), __msg);
}

bool
PLayersParent::Read(
        OpPaintCanvas* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->layerParent())), __msg, __iter, false)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    // skipping actor field that's meaningless on this side
    if ((!(Read((&((__v)->newFrontBuffer())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->needYFlip())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PLayersParent::Write(
        const InfallibleTArray<Animation>& __v,
        Message* __msg)
{
    uint32_t length = (__v).Length();
    Write(length, __msg);

    for (uint32_t i = 0; (i) < (length); (++(i))) {
        Write(__v[i], __msg);
    }
}

bool
PLayersParent::Read(
        InfallibleTArray<Animation>* __v,
        const Message* __msg,
        void** __iter)
{
    InfallibleTArray<Animation>& a = (*(__v));
    uint32_t length;
    if ((!(Read((&(length)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }

    (__v)->SetLength(length);
    for (uint32_t i = 0; (i) < (length); (++(i))) {
        if ((!(Read((&(a[i])), __msg, __iter)))) {
            mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
            return false;
        }
    }
    return true;
}

void
PLayersParent::Write(
        const Scale& __v,
        Message* __msg)
{
    Write((__v).x(), __msg);
    Write((__v).y(), __msg);
    Write((__v).z(), __msg);
}

bool
PLayersParent::Read(
        Scale* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->x())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->y())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->z())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}



} // namespace layers
} // namespace mozilla
