//
// Automatically generated by ipdlc.
// Edit at your own risk
//


#include "mozilla/dom/PContentChild.h"
#ifdef MOZ_CRASHREPORTER
#  include "nsXULAppAPI.h"
#endif 

#include "mozilla/dom/PBlobChild.h"
#include "mozilla/dom/bluetooth/PBluetoothChild.h"
#include "mozilla/dom/PBrowserChild.h"
#include "mozilla/layers/PCompositorChild.h"
#include "mozilla/dom/PCrashReporterChild.h"
#include "mozilla/dom/PExternalHelperAppChild.h"
#include "mozilla/dom/devicestorage/PDeviceStorageRequestChild.h"
#include "mozilla/hal_sandbox/PHalChild.h"
#include "mozilla/layers/PImageBridgeChild.h"
#include "mozilla/dom/indexedDB/PIndexedDBChild.h"
#include "mozilla/dom/PMemoryReportRequestChild.h"
#include "mozilla/net/PNeckoChild.h"
#include "mozilla/dom/sms/PSmsChild.h"
#include "mozilla/dom/PStorageChild.h"
#include "mozilla/ipc/PTestShellChild.h"

typedef IPC::Message Message;
typedef mozilla::ipc::RPCChannel Channel;
typedef mozilla::ipc::RPCChannel::RPCListener ChannelListener;
typedef base::ProcessHandle ProcessHandle;
typedef mozilla::ipc::AsyncChannel AsyncChannel;
typedef mozilla::ipc::SharedMemory SharedMemory;
typedef mozilla::ipc::Trigger Trigger;
typedef mozilla::ipc::ActorHandle ActorHandle;
typedef mozilla::dom::AppFrameIPCTabContext AppFrameIPCTabContext;
typedef mozilla::dom::AudioChannelType AudioChannelType;
typedef mozilla::dom::BlobConstructorParams BlobConstructorParams;
typedef mozilla::dom::BrowserFrameIPCTabContext BrowserFrameIPCTabContext;
typedef mozilla::dom::ClonedMessageData ClonedMessageData;
typedef mozilla::dom::DeviceStorageAddParams DeviceStorageAddParams;
typedef mozilla::dom::DeviceStorageDeleteParams DeviceStorageDeleteParams;
typedef mozilla::dom::DeviceStorageEnumerationParams DeviceStorageEnumerationParams;
typedef mozilla::dom::DeviceStorageGetParams DeviceStorageGetParams;
typedef mozilla::dom::DeviceStorageParams DeviceStorageParams;
typedef mozilla::dom::DeviceStorageStatParams DeviceStorageStatParams;
typedef mozilla::dom::FileBlobConstructorParams FileBlobConstructorParams;
typedef mozilla::ipc::FileDescriptor FileDescriptor;
typedef mozilla::dom::FontListEntry FontListEntry;
typedef mozilla::ipc::GenericURIParams GenericURIParams;
typedef mozilla::dom::IPCTabAppBrowserContext IPCTabAppBrowserContext;
typedef mozilla::dom::IPCTabContext IPCTabContext;
typedef mozilla::ipc::JARURIParams JARURIParams;
typedef mozilla::dom::MaybePrefValue MaybePrefValue;
typedef mozilla::dom::MysteryBlobConstructorParams MysteryBlobConstructorParams;
typedef mozilla::dom::NativeThreadId NativeThreadId;
typedef mozilla::dom::NormalBlobConstructorParams NormalBlobConstructorParams;
typedef mozilla::ipc::OptionalURIParams OptionalURIParams;
typedef IPC::Permission Permission;
typedef mozilla::dom::PopupIPCTabContext PopupIPCTabContext;
typedef mozilla::dom::PrefSetting PrefSetting;
typedef mozilla::dom::PrefValue PrefValue;
typedef IPC::Principal Principal;
typedef mozilla::layout::ScrollingBehavior ScrollingBehavior;
typedef mozilla::SerializedStructuredCloneBuffer SerializedStructuredCloneBuffer;
typedef mozilla::ipc::Shmem Shmem;
typedef mozilla::ipc::SimpleURIParams SimpleURIParams;
typedef mozilla::dom::SlicedBlobConstructorParams SlicedBlobConstructorParams;
typedef mozilla::ipc::StandardURLParams StandardURLParams;
typedef mozilla::ipc::StandardURLSegment StandardURLSegment;
typedef mozilla::dom::StorageClone StorageClone;
typedef mozilla::dom::StorageConstructData StorageConstructData;
typedef mozilla::ipc::URIParams URIParams;
typedef mozilla::dom::VanillaFrameIPCTabContext VanillaFrameIPCTabContext;
typedef mozilla::null_t null_t;
typedef mozilla::void_t void_t;
using mozilla::dom::PBlobChild;
using mozilla::dom::bluetooth::PBluetoothChild;
using mozilla::dom::PBrowserChild;
using mozilla::layers::PCompositorChild;
using mozilla::dom::PCrashReporterChild;
using mozilla::dom::PExternalHelperAppChild;
using mozilla::dom::devicestorage::PDeviceStorageRequestChild;
using mozilla::hal_sandbox::PHalChild;
using mozilla::layers::PImageBridgeChild;
using mozilla::dom::indexedDB::PIndexedDBChild;
using mozilla::dom::PMemoryReportRequestChild;
using mozilla::net::PNeckoChild;
using mozilla::dom::sms::PSmsChild;
using mozilla::dom::PStorageChild;
using mozilla::ipc::PTestShellChild;

namespace mozilla {
namespace dom {


bool
PContentChild::RecvPBrowserConstructor(
        PBrowserChild* actor,
        const IPCTabContext& context,
        const uint32_t& chromeFlags)
{
    return true;
}

bool
PContentChild::RecvPBlobConstructor(
        PBlobChild* actor,
        const BlobConstructorParams& params)
{
    return true;
}

bool
PContentChild::RecvPMemoryReportRequestConstructor(PMemoryReportRequestChild* actor)
{
    return true;
}

bool
PContentChild::RecvPTestShellConstructor(PTestShellChild* actor)
{
    return true;
}

void
PContentChild::ActorDestroy(ActorDestroyReason why)
{
}

void
PContentChild::ProcessingError(Result code)
{
}

bool
PContentChild::ShouldContinueFromReplyTimeout()
{
    return true;
}

void
PContentChild::EnteredCxxStack()
{
}

void
PContentChild::ExitedCxxStack()
{
}

void
PContentChild::EnteredCall()
{
}

void
PContentChild::ExitedCall()
{
}

PContentChild::PContentChild() :
    mChannel(ALLOW_THIS_IN_INITIALIZER_LIST(this)),
    mLastRouteId(0),
    mLastShmemId(0),
    mState(PContent::__Start)
{
    MOZ_COUNT_CTOR(PContentChild);
}

PContentChild::~PContentChild()
{
    MOZ_COUNT_DTOR(PContentChild);
}

bool
PContentChild::Open(
        Channel::Transport* aTransport,
        ProcessHandle aOtherProcess,
        MessageLoop* aThread,
        AsyncChannel::Side aSide)
{
    mOtherProcess = aOtherProcess;
    return (mChannel).Open(aTransport, aThread, aSide);
}

bool
PContentChild::Open(
        AsyncChannel* aChannel,
        MessageLoop* aMessageLoop,
        AsyncChannel::Side aSide)
{
    mOtherProcess = 0;
    return (mChannel).Open(aChannel, aMessageLoop, aSide);
}

void
PContentChild::Close()
{
    (mChannel).Close();
}

void
PContentChild::SetReplyTimeoutMs(int32_t aTimeoutMs)
{
    (mChannel).SetReplyTimeoutMs(aTimeoutMs);
}

void
PContentChild::ManagedPBlobChild(InfallibleTArray<PBlobChild*>& aArr) const
{
    aArr = mManagedPBlobChild;
}

const InfallibleTArray<PBlobChild*>&
PContentChild::ManagedPBlobChild() const
{
    return mManagedPBlobChild;
}

void
PContentChild::ManagedPBluetoothChild(InfallibleTArray<PBluetoothChild*>& aArr) const
{
    aArr = mManagedPBluetoothChild;
}

const InfallibleTArray<PBluetoothChild*>&
PContentChild::ManagedPBluetoothChild() const
{
    return mManagedPBluetoothChild;
}

void
PContentChild::ManagedPBrowserChild(InfallibleTArray<PBrowserChild*>& aArr) const
{
    aArr = mManagedPBrowserChild;
}

const InfallibleTArray<PBrowserChild*>&
PContentChild::ManagedPBrowserChild() const
{
    return mManagedPBrowserChild;
}

void
PContentChild::ManagedPCrashReporterChild(InfallibleTArray<PCrashReporterChild*>& aArr) const
{
    aArr = mManagedPCrashReporterChild;
}

const InfallibleTArray<PCrashReporterChild*>&
PContentChild::ManagedPCrashReporterChild() const
{
    return mManagedPCrashReporterChild;
}

void
PContentChild::ManagedPDeviceStorageRequestChild(InfallibleTArray<PDeviceStorageRequestChild*>& aArr) const
{
    aArr = mManagedPDeviceStorageRequestChild;
}

const InfallibleTArray<PDeviceStorageRequestChild*>&
PContentChild::ManagedPDeviceStorageRequestChild() const
{
    return mManagedPDeviceStorageRequestChild;
}

void
PContentChild::ManagedPExternalHelperAppChild(InfallibleTArray<PExternalHelperAppChild*>& aArr) const
{
    aArr = mManagedPExternalHelperAppChild;
}

const InfallibleTArray<PExternalHelperAppChild*>&
PContentChild::ManagedPExternalHelperAppChild() const
{
    return mManagedPExternalHelperAppChild;
}

void
PContentChild::ManagedPHalChild(InfallibleTArray<PHalChild*>& aArr) const
{
    aArr = mManagedPHalChild;
}

const InfallibleTArray<PHalChild*>&
PContentChild::ManagedPHalChild() const
{
    return mManagedPHalChild;
}

void
PContentChild::ManagedPIndexedDBChild(InfallibleTArray<PIndexedDBChild*>& aArr) const
{
    aArr = mManagedPIndexedDBChild;
}

const InfallibleTArray<PIndexedDBChild*>&
PContentChild::ManagedPIndexedDBChild() const
{
    return mManagedPIndexedDBChild;
}

void
PContentChild::ManagedPMemoryReportRequestChild(InfallibleTArray<PMemoryReportRequestChild*>& aArr) const
{
    aArr = mManagedPMemoryReportRequestChild;
}

const InfallibleTArray<PMemoryReportRequestChild*>&
PContentChild::ManagedPMemoryReportRequestChild() const
{
    return mManagedPMemoryReportRequestChild;
}

void
PContentChild::ManagedPNeckoChild(InfallibleTArray<PNeckoChild*>& aArr) const
{
    aArr = mManagedPNeckoChild;
}

const InfallibleTArray<PNeckoChild*>&
PContentChild::ManagedPNeckoChild() const
{
    return mManagedPNeckoChild;
}

void
PContentChild::ManagedPSmsChild(InfallibleTArray<PSmsChild*>& aArr) const
{
    aArr = mManagedPSmsChild;
}

const InfallibleTArray<PSmsChild*>&
PContentChild::ManagedPSmsChild() const
{
    return mManagedPSmsChild;
}

void
PContentChild::ManagedPStorageChild(InfallibleTArray<PStorageChild*>& aArr) const
{
    aArr = mManagedPStorageChild;
}

const InfallibleTArray<PStorageChild*>&
PContentChild::ManagedPStorageChild() const
{
    return mManagedPStorageChild;
}

void
PContentChild::ManagedPTestShellChild(InfallibleTArray<PTestShellChild*>& aArr) const
{
    aArr = mManagedPTestShellChild;
}

const InfallibleTArray<PTestShellChild*>&
PContentChild::ManagedPTestShellChild() const
{
    return mManagedPTestShellChild;
}

PContent::State
PContentChild::state()
{
    return mState;
}

PBrowserChild*
PContentChild::SendPBrowserConstructor(
        const IPCTabContext& context,
        const uint32_t& chromeFlags)
{
    return SendPBrowserConstructor(AllocPBrowser(context, chromeFlags), context, chromeFlags);
}

PBrowserChild*
PContentChild::SendPBrowserConstructor(
        PBrowserChild* actor,
        const IPCTabContext& context,
        const uint32_t& chromeFlags)
{
    if ((!(actor))) {
        return 0;
    }
    (actor)->mId = Register(actor);
    (actor)->mManager = this;
    (actor)->mChannel = (&(mChannel));
    (mManagedPBrowserChild).InsertElementSorted(actor);
    (actor)->mState = mozilla::dom::PBrowser::__Start;

    PContent::Msg_PBrowserConstructor* __msg = new PContent::Msg_PBrowserConstructor();

    Write(actor, __msg, false);
    Write(context, __msg);
    Write(chromeFlags, __msg);

    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);


    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PContentChild] Sending ", stderr);
    }
    if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_PBrowserConstructor__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg);
    if ((!(__sendok))) {
        (actor)->DestroySubtree(FailedConstructor);
        (actor)->DeallocSubtree();
        ((actor)->mManager)->RemoveManagee(PBrowserMsgStart, actor);
        return 0;
    }
    return actor;
}

PBlobChild*
PContentChild::SendPBlobConstructor(const BlobConstructorParams& params)
{
    return SendPBlobConstructor(AllocPBlob(params), params);
}

PBlobChild*
PContentChild::SendPBlobConstructor(
        PBlobChild* actor,
        const BlobConstructorParams& params)
{
    if ((!(actor))) {
        return 0;
    }
    (actor)->mId = Register(actor);
    (actor)->mManager = this;
    (actor)->mChannel = (&(mChannel));
    (mManagedPBlobChild).InsertElementSorted(actor);
    (actor)->mState = mozilla::dom::PBlob::__Start;

    PContent::Msg_PBlobConstructor* __msg = new PContent::Msg_PBlobConstructor();

    Write(actor, __msg, false);
    Write(params, __msg);

    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);


    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PContentChild] Sending ", stderr);
    }
    if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_PBlobConstructor__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg);
    if ((!(__sendok))) {
        (actor)->DestroySubtree(FailedConstructor);
        (actor)->DeallocSubtree();
        ((actor)->mManager)->RemoveManagee(PBlobMsgStart, actor);
        return 0;
    }
    return actor;
}

bool
PContentChild::SendGetProcessAttributes(
        uint64_t* id,
        bool* startBackground,
        bool* isForApp,
        bool* isForBrowser)
{
    PContent::Msg_GetProcessAttributes* __msg = new PContent::Msg_GetProcessAttributes();


    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);
    (__msg)->set_sync();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PContentChild] Sending ", stderr);
    }
    if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_GetProcessAttributes__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PContent::Reply_GetProcessAttributes*>((&(__reply))))->Log("[PContentChild] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(id, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read(startBackground, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read(isForApp, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read(isForBrowser, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    (__reply).EndRead(__iter);

    return true;
}

bool
PContentChild::SendGetXPCOMProcessAttributes(bool* isOffline)
{
    PContent::Msg_GetXPCOMProcessAttributes* __msg = new PContent::Msg_GetXPCOMProcessAttributes();


    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);
    (__msg)->set_sync();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PContentChild] Sending ", stderr);
    }
    if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_GetXPCOMProcessAttributes__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PContent::Reply_GetXPCOMProcessAttributes*>((&(__reply))))->Log("[PContentChild] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(isOffline, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    (__reply).EndRead(__iter);

    return true;
}

PDeviceStorageRequestChild*
PContentChild::SendPDeviceStorageRequestConstructor(const DeviceStorageParams& params)
{
    return SendPDeviceStorageRequestConstructor(AllocPDeviceStorageRequest(params), params);
}

PDeviceStorageRequestChild*
PContentChild::SendPDeviceStorageRequestConstructor(
        PDeviceStorageRequestChild* actor,
        const DeviceStorageParams& params)
{
    if ((!(actor))) {
        return 0;
    }
    (actor)->mId = Register(actor);
    (actor)->mManager = this;
    (actor)->mChannel = (&(mChannel));
    (mManagedPDeviceStorageRequestChild).InsertElementSorted(actor);
    (actor)->mState = mozilla::dom::devicestorage::PDeviceStorageRequest::__Start;

    PContent::Msg_PDeviceStorageRequestConstructor* __msg = new PContent::Msg_PDeviceStorageRequestConstructor();

    Write(actor, __msg, false);
    Write(params, __msg);

    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);


    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PContentChild] Sending ", stderr);
    }
    if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_PDeviceStorageRequestConstructor__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg);
    if ((!(__sendok))) {
        (actor)->DestroySubtree(FailedConstructor);
        (actor)->DeallocSubtree();
        ((actor)->mManager)->RemoveManagee(PDeviceStorageRequestMsgStart, actor);
        return 0;
    }
    return actor;
}

PCrashReporterChild*
PContentChild::SendPCrashReporterConstructor(
        const NativeThreadId& tid,
        const uint32_t& processType)
{
    return SendPCrashReporterConstructor(AllocPCrashReporter(tid, processType), tid, processType);
}

PCrashReporterChild*
PContentChild::SendPCrashReporterConstructor(
        PCrashReporterChild* actor,
        const NativeThreadId& tid,
        const uint32_t& processType)
{
    if ((!(actor))) {
        return 0;
    }
    (actor)->mId = Register(actor);
    (actor)->mManager = this;
    (actor)->mChannel = (&(mChannel));
    (mManagedPCrashReporterChild).InsertElementSorted(actor);
    (actor)->mState = mozilla::dom::PCrashReporter::__Start;

    PContent::Msg_PCrashReporterConstructor* __msg = new PContent::Msg_PCrashReporterConstructor();

    Write(actor, __msg, false);
    Write(tid, __msg);
    Write(processType, __msg);

    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);
    (__msg)->set_sync();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PContentChild] Sending ", stderr);
    }
    if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_PCrashReporterConstructor__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg, (&(__reply)));
    if ((!(__sendok))) {
        (actor)->DestroySubtree(FailedConstructor);
        (actor)->DeallocSubtree();
        ((actor)->mManager)->RemoveManagee(PCrashReporterMsgStart, actor);
        return 0;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PContent::Reply_PCrashReporterConstructor*>((&(__reply))))->Log("[PContentChild] Received reply ", stderr);
    }
    return actor;
}

PHalChild*
PContentChild::SendPHalConstructor()
{
    return SendPHalConstructor(AllocPHal());
}

PHalChild*
PContentChild::SendPHalConstructor(PHalChild* actor)
{
    if ((!(actor))) {
        return 0;
    }
    (actor)->mId = Register(actor);
    (actor)->mManager = this;
    (actor)->mChannel = (&(mChannel));
    (mManagedPHalChild).InsertElementSorted(actor);
    (actor)->mState = mozilla::hal_sandbox::PHal::__Start;

    PContent::Msg_PHalConstructor* __msg = new PContent::Msg_PHalConstructor();

    Write(actor, __msg, false);

    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);


    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PContentChild] Sending ", stderr);
    }
    if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_PHalConstructor__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg);
    if ((!(__sendok))) {
        (actor)->DestroySubtree(FailedConstructor);
        (actor)->DeallocSubtree();
        ((actor)->mManager)->RemoveManagee(PHalMsgStart, actor);
        return 0;
    }
    return actor;
}

PIndexedDBChild*
PContentChild::SendPIndexedDBConstructor()
{
    return SendPIndexedDBConstructor(AllocPIndexedDB());
}

PIndexedDBChild*
PContentChild::SendPIndexedDBConstructor(PIndexedDBChild* actor)
{
    if ((!(actor))) {
        return 0;
    }
    (actor)->mId = Register(actor);
    (actor)->mManager = this;
    (actor)->mChannel = (&(mChannel));
    (mManagedPIndexedDBChild).InsertElementSorted(actor);
    (actor)->mState = mozilla::dom::indexedDB::PIndexedDB::__Start;

    PContent::Msg_PIndexedDBConstructor* __msg = new PContent::Msg_PIndexedDBConstructor();

    Write(actor, __msg, false);

    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);


    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PContentChild] Sending ", stderr);
    }
    if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_PIndexedDBConstructor__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg);
    if ((!(__sendok))) {
        (actor)->DestroySubtree(FailedConstructor);
        (actor)->DeallocSubtree();
        ((actor)->mManager)->RemoveManagee(PIndexedDBMsgStart, actor);
        return 0;
    }
    return actor;
}

PNeckoChild*
PContentChild::SendPNeckoConstructor()
{
    return SendPNeckoConstructor(AllocPNecko());
}

PNeckoChild*
PContentChild::SendPNeckoConstructor(PNeckoChild* actor)
{
    if ((!(actor))) {
        return 0;
    }
    (actor)->mId = Register(actor);
    (actor)->mManager = this;
    (actor)->mChannel = (&(mChannel));
    (mManagedPNeckoChild).InsertElementSorted(actor);
    (actor)->mState = mozilla::net::PNecko::__Start;

    PContent::Msg_PNeckoConstructor* __msg = new PContent::Msg_PNeckoConstructor();

    Write(actor, __msg, false);

    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);


    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PContentChild] Sending ", stderr);
    }
    if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_PNeckoConstructor__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg);
    if ((!(__sendok))) {
        (actor)->DestroySubtree(FailedConstructor);
        (actor)->DeallocSubtree();
        ((actor)->mManager)->RemoveManagee(PNeckoMsgStart, actor);
        return 0;
    }
    return actor;
}

PSmsChild*
PContentChild::SendPSmsConstructor()
{
    return SendPSmsConstructor(AllocPSms());
}

PSmsChild*
PContentChild::SendPSmsConstructor(PSmsChild* actor)
{
    if ((!(actor))) {
        return 0;
    }
    (actor)->mId = Register(actor);
    (actor)->mManager = this;
    (actor)->mChannel = (&(mChannel));
    (mManagedPSmsChild).InsertElementSorted(actor);
    (actor)->mState = mozilla::dom::sms::PSms::__Start;

    PContent::Msg_PSmsConstructor* __msg = new PContent::Msg_PSmsConstructor();

    Write(actor, __msg, false);

    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);


    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PContentChild] Sending ", stderr);
    }
    if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_PSmsConstructor__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg);
    if ((!(__sendok))) {
        (actor)->DestroySubtree(FailedConstructor);
        (actor)->DeallocSubtree();
        ((actor)->mManager)->RemoveManagee(PSmsMsgStart, actor);
        return 0;
    }
    return actor;
}

PStorageChild*
PContentChild::SendPStorageConstructor(const StorageConstructData& data)
{
    return SendPStorageConstructor(AllocPStorage(data), data);
}

PStorageChild*
PContentChild::SendPStorageConstructor(
        PStorageChild* actor,
        const StorageConstructData& data)
{
    if ((!(actor))) {
        return 0;
    }
    (actor)->mId = Register(actor);
    (actor)->mManager = this;
    (actor)->mChannel = (&(mChannel));
    (mManagedPStorageChild).InsertElementSorted(actor);
    (actor)->mState = mozilla::dom::PStorage::__Start;

    PContent::Msg_PStorageConstructor* __msg = new PContent::Msg_PStorageConstructor();

    Write(actor, __msg, false);
    Write(data, __msg);

    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);


    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PContentChild] Sending ", stderr);
    }
    if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_PStorageConstructor__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg);
    if ((!(__sendok))) {
        (actor)->DestroySubtree(FailedConstructor);
        (actor)->DeallocSubtree();
        ((actor)->mManager)->RemoveManagee(PStorageMsgStart, actor);
        return 0;
    }
    return actor;
}

PBluetoothChild*
PContentChild::SendPBluetoothConstructor()
{
    return SendPBluetoothConstructor(AllocPBluetooth());
}

PBluetoothChild*
PContentChild::SendPBluetoothConstructor(PBluetoothChild* actor)
{
    if ((!(actor))) {
        return 0;
    }
    (actor)->mId = Register(actor);
    (actor)->mManager = this;
    (actor)->mChannel = (&(mChannel));
    (mManagedPBluetoothChild).InsertElementSorted(actor);
    (actor)->mState = mozilla::dom::bluetooth::PBluetooth::__Start;

    PContent::Msg_PBluetoothConstructor* __msg = new PContent::Msg_PBluetoothConstructor();

    Write(actor, __msg, false);

    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);


    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PContentChild] Sending ", stderr);
    }
    if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_PBluetoothConstructor__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg);
    if ((!(__sendok))) {
        (actor)->DestroySubtree(FailedConstructor);
        (actor)->DeallocSubtree();
        ((actor)->mManager)->RemoveManagee(PBluetoothMsgStart, actor);
        return 0;
    }
    return actor;
}

bool
PContentChild::SendStartVisitedQuery(const URIParams& uri)
{
    PContent::Msg_StartVisitedQuery* __msg = new PContent::Msg_StartVisitedQuery();

    Write(uri, __msg);

    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PContentChild] Sending ", stderr);
    }
    if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_StartVisitedQuery__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg);
    return __sendok;
}

bool
PContentChild::SendVisitURI(
        const URIParams& uri,
        const OptionalURIParams& referrer,
        const uint32_t& flags)
{
    PContent::Msg_VisitURI* __msg = new PContent::Msg_VisitURI();

    Write(uri, __msg);
    Write(referrer, __msg);
    Write(flags, __msg);

    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PContentChild] Sending ", stderr);
    }
    if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_VisitURI__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg);
    return __sendok;
}

bool
PContentChild::SendSetURITitle(
        const URIParams& uri,
        const nsString& title)
{
    PContent::Msg_SetURITitle* __msg = new PContent::Msg_SetURITitle();

    Write(uri, __msg);
    Write(title, __msg);

    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PContentChild] Sending ", stderr);
    }
    if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_SetURITitle__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg);
    return __sendok;
}

bool
PContentChild::SendShowFilePicker(
        const int16_t& mode,
        const int16_t& selectedType,
        const bool& addToRecentDocs,
        const nsString& title,
        const nsString& defaultFile,
        const nsString& defaultExtension,
        const InfallibleTArray<nsString>& filters,
        const InfallibleTArray<nsString>& filterNames,
        InfallibleTArray<nsString>* files,
        int16_t* retValue,
        nsresult* result)
{
    PContent::Msg_ShowFilePicker* __msg = new PContent::Msg_ShowFilePicker();

    Write(mode, __msg);
    Write(selectedType, __msg);
    Write(addToRecentDocs, __msg);
    Write(title, __msg);
    Write(defaultFile, __msg);
    Write(defaultExtension, __msg);
    Write(filters, __msg);
    Write(filterNames, __msg);

    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);
    (__msg)->set_sync();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PContentChild] Sending ", stderr);
    }
    if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_ShowFilePicker__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PContent::Reply_ShowFilePicker*>((&(__reply))))->Log("[PContentChild] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(files, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read(retValue, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read(result, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    (__reply).EndRead(__iter);

    return true;
}

bool
PContentChild::SendLoadURIExternal(const URIParams& uri)
{
    PContent::Msg_LoadURIExternal* __msg = new PContent::Msg_LoadURIExternal();

    Write(uri, __msg);

    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PContentChild] Sending ", stderr);
    }
    if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_LoadURIExternal__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg);
    return __sendok;
}

bool
PContentChild::SendReadPrefsArray(InfallibleTArray<PrefSetting>* prefs)
{
    PContent::Msg_ReadPrefsArray* __msg = new PContent::Msg_ReadPrefsArray();


    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);
    (__msg)->set_sync();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PContentChild] Sending ", stderr);
    }
    if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_ReadPrefsArray__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PContent::Reply_ReadPrefsArray*>((&(__reply))))->Log("[PContentChild] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(prefs, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    (__reply).EndRead(__iter);

    return true;
}

bool
PContentChild::SendReadFontList(InfallibleTArray<FontListEntry>* retValue)
{
    PContent::Msg_ReadFontList* __msg = new PContent::Msg_ReadFontList();


    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);
    (__msg)->set_sync();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PContentChild] Sending ", stderr);
    }
    if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_ReadFontList__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PContent::Reply_ReadFontList*>((&(__reply))))->Log("[PContentChild] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(retValue, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    (__reply).EndRead(__iter);

    return true;
}

bool
PContentChild::SendSyncMessage(
        const nsString& aMessage,
        const ClonedMessageData& aData,
        InfallibleTArray<nsString>* retval)
{
    PContent::Msg_SyncMessage* __msg = new PContent::Msg_SyncMessage();

    Write(aMessage, __msg);
    Write(aData, __msg);

    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);
    (__msg)->set_sync();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PContentChild] Sending ", stderr);
    }
    if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_SyncMessage__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PContent::Reply_SyncMessage*>((&(__reply))))->Log("[PContentChild] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(retval, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    (__reply).EndRead(__iter);

    return true;
}

bool
PContentChild::SendShowAlertNotification(
        const nsString& imageUrl,
        const nsString& title,
        const nsString& text,
        const bool& textClickable,
        const nsString& cookie,
        const nsString& name)
{
    PContent::Msg_ShowAlertNotification* __msg = new PContent::Msg_ShowAlertNotification();

    Write(imageUrl, __msg);
    Write(title, __msg);
    Write(text, __msg);
    Write(textClickable, __msg);
    Write(cookie, __msg);
    Write(name, __msg);

    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PContentChild] Sending ", stderr);
    }
    if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_ShowAlertNotification__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg);
    return __sendok;
}

PExternalHelperAppChild*
PContentChild::SendPExternalHelperAppConstructor(
        const OptionalURIParams& uri,
        const nsCString& aMimeContentType,
        const nsCString& aContentDisposition,
        const bool& aForceSave,
        const int64_t& aContentLength,
        const OptionalURIParams& aReferrer)
{
    return SendPExternalHelperAppConstructor(AllocPExternalHelperApp(uri, aMimeContentType, aContentDisposition, aForceSave, aContentLength, aReferrer), uri, aMimeContentType, aContentDisposition, aForceSave, aContentLength, aReferrer);
}

PExternalHelperAppChild*
PContentChild::SendPExternalHelperAppConstructor(
        PExternalHelperAppChild* actor,
        const OptionalURIParams& uri,
        const nsCString& aMimeContentType,
        const nsCString& aContentDisposition,
        const bool& aForceSave,
        const int64_t& aContentLength,
        const OptionalURIParams& aReferrer)
{
    if ((!(actor))) {
        return 0;
    }
    (actor)->mId = Register(actor);
    (actor)->mManager = this;
    (actor)->mChannel = (&(mChannel));
    (mManagedPExternalHelperAppChild).InsertElementSorted(actor);
    (actor)->mState = mozilla::dom::PExternalHelperApp::__Start;

    PContent::Msg_PExternalHelperAppConstructor* __msg = new PContent::Msg_PExternalHelperAppConstructor();

    Write(actor, __msg, false);
    Write(uri, __msg);
    Write(aMimeContentType, __msg);
    Write(aContentDisposition, __msg);
    Write(aForceSave, __msg);
    Write(aContentLength, __msg);
    Write(aReferrer, __msg);

    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);


    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PContentChild] Sending ", stderr);
    }
    if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_PExternalHelperAppConstructor__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg);
    if ((!(__sendok))) {
        (actor)->DestroySubtree(FailedConstructor);
        (actor)->DeallocSubtree();
        ((actor)->mManager)->RemoveManagee(PExternalHelperAppMsgStart, actor);
        return 0;
    }
    return actor;
}

bool
PContentChild::SendAddGeolocationListener(const Principal& principal)
{
    PContent::Msg_AddGeolocationListener* __msg = new PContent::Msg_AddGeolocationListener();

    Write(principal, __msg);

    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PContentChild] Sending ", stderr);
    }
    if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_AddGeolocationListener__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg);
    return __sendok;
}

bool
PContentChild::SendRemoveGeolocationListener()
{
    PContent::Msg_RemoveGeolocationListener* __msg = new PContent::Msg_RemoveGeolocationListener();


    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PContentChild] Sending ", stderr);
    }
    if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_RemoveGeolocationListener__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg);
    return __sendok;
}

bool
PContentChild::SendSetGeolocationHigherAccuracy(const bool& enable)
{
    PContent::Msg_SetGeolocationHigherAccuracy* __msg = new PContent::Msg_SetGeolocationHigherAccuracy();

    Write(enable, __msg);

    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PContentChild] Sending ", stderr);
    }
    if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_SetGeolocationHigherAccuracy__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg);
    return __sendok;
}

bool
PContentChild::SendConsoleMessage(const nsString& message)
{
    PContent::Msg_ConsoleMessage* __msg = new PContent::Msg_ConsoleMessage();

    Write(message, __msg);

    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PContentChild] Sending ", stderr);
    }
    if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_ConsoleMessage__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg);
    return __sendok;
}

bool
PContentChild::SendScriptError(
        const nsString& message,
        const nsString& sourceName,
        const nsString& sourceLine,
        const uint32_t& lineNumber,
        const uint32_t& colNumber,
        const uint32_t& flags,
        const nsCString& category)
{
    PContent::Msg_ScriptError* __msg = new PContent::Msg_ScriptError();

    Write(message, __msg);
    Write(sourceName, __msg);
    Write(sourceLine, __msg);
    Write(lineNumber, __msg);
    Write(colNumber, __msg);
    Write(flags, __msg);
    Write(category, __msg);

    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PContentChild] Sending ", stderr);
    }
    if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_ScriptError__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg);
    return __sendok;
}

bool
PContentChild::SendReadPermissions(InfallibleTArray<Permission>* permissions)
{
    PContent::Msg_ReadPermissions* __msg = new PContent::Msg_ReadPermissions();


    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);
    (__msg)->set_sync();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PContentChild] Sending ", stderr);
    }
    if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_ReadPermissions__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PContent::Reply_ReadPermissions*>((&(__reply))))->Log("[PContentChild] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(permissions, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    (__reply).EndRead(__iter);

    return true;
}

bool
PContentChild::SendSetClipboardText(
        const nsString& text,
        const bool& isPrivateData,
        const int32_t& whichClipboard)
{
    PContent::Msg_SetClipboardText* __msg = new PContent::Msg_SetClipboardText();

    Write(text, __msg);
    Write(isPrivateData, __msg);
    Write(whichClipboard, __msg);

    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PContentChild] Sending ", stderr);
    }
    if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_SetClipboardText__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg);
    return __sendok;
}

bool
PContentChild::SendGetClipboardText(
        const int32_t& whichClipboard,
        nsString* text)
{
    PContent::Msg_GetClipboardText* __msg = new PContent::Msg_GetClipboardText();

    Write(whichClipboard, __msg);

    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);
    (__msg)->set_sync();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PContentChild] Sending ", stderr);
    }
    if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_GetClipboardText__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PContent::Reply_GetClipboardText*>((&(__reply))))->Log("[PContentChild] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(text, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    (__reply).EndRead(__iter);

    return true;
}

bool
PContentChild::SendEmptyClipboard()
{
    PContent::Msg_EmptyClipboard* __msg = new PContent::Msg_EmptyClipboard();


    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PContentChild] Sending ", stderr);
    }
    if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_EmptyClipboard__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg);
    return __sendok;
}

bool
PContentChild::SendClipboardHasText(bool* hasText)
{
    PContent::Msg_ClipboardHasText* __msg = new PContent::Msg_ClipboardHasText();


    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);
    (__msg)->set_sync();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PContentChild] Sending ", stderr);
    }
    if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_ClipboardHasText__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PContent::Reply_ClipboardHasText*>((&(__reply))))->Log("[PContentChild] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(hasText, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    (__reply).EndRead(__iter);

    return true;
}

bool
PContentChild::SendGetSystemColors(
        const uint32_t& colorsCount,
        InfallibleTArray<uint32_t>* colors)
{
    PContent::Msg_GetSystemColors* __msg = new PContent::Msg_GetSystemColors();

    Write(colorsCount, __msg);

    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);
    (__msg)->set_sync();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PContentChild] Sending ", stderr);
    }
    if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_GetSystemColors__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PContent::Reply_GetSystemColors*>((&(__reply))))->Log("[PContentChild] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(colors, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    (__reply).EndRead(__iter);

    return true;
}

bool
PContentChild::SendGetIconForExtension(
        const nsCString& aFileExt,
        const uint32_t& aIconSize,
        InfallibleTArray<uint8_t>* bits)
{
    PContent::Msg_GetIconForExtension* __msg = new PContent::Msg_GetIconForExtension();

    Write(aFileExt, __msg);
    Write(aIconSize, __msg);

    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);
    (__msg)->set_sync();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PContentChild] Sending ", stderr);
    }
    if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_GetIconForExtension__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PContent::Reply_GetIconForExtension*>((&(__reply))))->Log("[PContentChild] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(bits, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    (__reply).EndRead(__iter);

    return true;
}

bool
PContentChild::SendGetShowPasswordSetting(bool* showPassword)
{
    PContent::Msg_GetShowPasswordSetting* __msg = new PContent::Msg_GetShowPasswordSetting();


    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);
    (__msg)->set_sync();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PContentChild] Sending ", stderr);
    }
    if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_GetShowPasswordSetting__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PContent::Reply_GetShowPasswordSetting*>((&(__reply))))->Log("[PContentChild] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(showPassword, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    (__reply).EndRead(__iter);

    return true;
}

bool
PContentChild::SendPrivateDocShellsExist(const bool& aExist)
{
    PContent::Msg_PrivateDocShellsExist* __msg = new PContent::Msg_PrivateDocShellsExist();

    Write(aExist, __msg);

    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PContentChild] Sending ", stderr);
    }
    if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_PrivateDocShellsExist__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg);
    return __sendok;
}

bool
PContentChild::SendFirstIdle()
{
    PContent::Msg_FirstIdle* __msg = new PContent::Msg_FirstIdle();


    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PContentChild] Sending ", stderr);
    }
    if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_FirstIdle__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg);
    return __sendok;
}

bool
PContentChild::SendAudioChannelGetMuted(
        const AudioChannelType& aType,
        const bool& aMozHidden,
        bool* value)
{
    PContent::Msg_AudioChannelGetMuted* __msg = new PContent::Msg_AudioChannelGetMuted();

    Write(aType, __msg);
    Write(aMozHidden, __msg);

    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);
    (__msg)->set_sync();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PContentChild] Sending ", stderr);
    }
    if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_AudioChannelGetMuted__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PContent::Reply_AudioChannelGetMuted*>((&(__reply))))->Log("[PContentChild] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(value, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    (__reply).EndRead(__iter);

    return true;
}

bool
PContentChild::SendAudioChannelRegisterType(const AudioChannelType& aType)
{
    PContent::Msg_AudioChannelRegisterType* __msg = new PContent::Msg_AudioChannelRegisterType();

    Write(aType, __msg);

    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PContentChild] Sending ", stderr);
    }
    if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_AudioChannelRegisterType__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg);
    return __sendok;
}

bool
PContentChild::SendAudioChannelUnregisterType(const AudioChannelType& aType)
{
    PContent::Msg_AudioChannelUnregisterType* __msg = new PContent::Msg_AudioChannelUnregisterType();

    Write(aType, __msg);

    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PContentChild] Sending ", stderr);
    }
    if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_AudioChannelUnregisterType__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg);
    return __sendok;
}

bool
PContentChild::SendAsyncMessage(
        const nsString& aMessage,
        const ClonedMessageData& aData)
{
    PContent::Msg_AsyncMessage* __msg = new PContent::Msg_AsyncMessage();

    Write(aMessage, __msg);
    Write(aData, __msg);

    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PContentChild] Sending ", stderr);
    }
    if ((!(PContent::Transition(mState, Trigger(Trigger::Recv, PContent::Msg_AsyncMessage__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg);
    return __sendok;
}

int32_t
PContentChild::Register(ChannelListener* aRouted)
{
    int32_t tmp = (--(mLastRouteId));
    (mActorMap).AddWithID(aRouted, tmp);
    return tmp;
}

int32_t
PContentChild::RegisterID(
        ChannelListener* aRouted,
        int32_t aId)
{
    (mActorMap).AddWithID(aRouted, aId);
    return aId;
}

ChannelListener*
PContentChild::Lookup(int32_t aId)
{
    return (mActorMap).Lookup(aId);
}

void
PContentChild::Unregister(int32_t aId)
{
    return (mActorMap).Remove(aId);
}

void
PContentChild::RemoveManagee(
        int32_t aProtocolId,
        ChannelListener* aListener)
{
    switch (aProtocolId) {
    case PBlobMsgStart:
        {
            PBlobChild* actor = static_cast<PBlobChild*>(aListener);
            NS_ABORT_IF_FALSE(((mManagedPBlobChild).NoIndex) != ((mManagedPBlobChild).BinaryIndexOf(actor)), "actor not managed by this!");

            (mManagedPBlobChild).RemoveElementSorted(actor);
            DeallocPBlob(actor);
            return;
        }
    case PBluetoothMsgStart:
        {
            PBluetoothChild* actor = static_cast<PBluetoothChild*>(aListener);
            NS_ABORT_IF_FALSE(((mManagedPBluetoothChild).NoIndex) != ((mManagedPBluetoothChild).BinaryIndexOf(actor)), "actor not managed by this!");

            (mManagedPBluetoothChild).RemoveElementSorted(actor);
            DeallocPBluetooth(actor);
            return;
        }
    case PBrowserMsgStart:
        {
            PBrowserChild* actor = static_cast<PBrowserChild*>(aListener);
            NS_ABORT_IF_FALSE(((mManagedPBrowserChild).NoIndex) != ((mManagedPBrowserChild).BinaryIndexOf(actor)), "actor not managed by this!");

            (mManagedPBrowserChild).RemoveElementSorted(actor);
            DeallocPBrowser(actor);
            return;
        }
    case PCrashReporterMsgStart:
        {
            PCrashReporterChild* actor = static_cast<PCrashReporterChild*>(aListener);
            NS_ABORT_IF_FALSE(((mManagedPCrashReporterChild).NoIndex) != ((mManagedPCrashReporterChild).BinaryIndexOf(actor)), "actor not managed by this!");

            (mManagedPCrashReporterChild).RemoveElementSorted(actor);
            DeallocPCrashReporter(actor);
            return;
        }
    case PDeviceStorageRequestMsgStart:
        {
            PDeviceStorageRequestChild* actor = static_cast<PDeviceStorageRequestChild*>(aListener);
            NS_ABORT_IF_FALSE(((mManagedPDeviceStorageRequestChild).NoIndex) != ((mManagedPDeviceStorageRequestChild).BinaryIndexOf(actor)), "actor not managed by this!");

            (mManagedPDeviceStorageRequestChild).RemoveElementSorted(actor);
            DeallocPDeviceStorageRequest(actor);
            return;
        }
    case PExternalHelperAppMsgStart:
        {
            PExternalHelperAppChild* actor = static_cast<PExternalHelperAppChild*>(aListener);
            NS_ABORT_IF_FALSE(((mManagedPExternalHelperAppChild).NoIndex) != ((mManagedPExternalHelperAppChild).BinaryIndexOf(actor)), "actor not managed by this!");

            (mManagedPExternalHelperAppChild).RemoveElementSorted(actor);
            DeallocPExternalHelperApp(actor);
            return;
        }
    case PHalMsgStart:
        {
            PHalChild* actor = static_cast<PHalChild*>(aListener);
            NS_ABORT_IF_FALSE(((mManagedPHalChild).NoIndex) != ((mManagedPHalChild).BinaryIndexOf(actor)), "actor not managed by this!");

            (mManagedPHalChild).RemoveElementSorted(actor);
            DeallocPHal(actor);
            return;
        }
    case PIndexedDBMsgStart:
        {
            PIndexedDBChild* actor = static_cast<PIndexedDBChild*>(aListener);
            NS_ABORT_IF_FALSE(((mManagedPIndexedDBChild).NoIndex) != ((mManagedPIndexedDBChild).BinaryIndexOf(actor)), "actor not managed by this!");

            (mManagedPIndexedDBChild).RemoveElementSorted(actor);
            DeallocPIndexedDB(actor);
            return;
        }
    case PMemoryReportRequestMsgStart:
        {
            PMemoryReportRequestChild* actor = static_cast<PMemoryReportRequestChild*>(aListener);
            NS_ABORT_IF_FALSE(((mManagedPMemoryReportRequestChild).NoIndex) != ((mManagedPMemoryReportRequestChild).BinaryIndexOf(actor)), "actor not managed by this!");

            (mManagedPMemoryReportRequestChild).RemoveElementSorted(actor);
            DeallocPMemoryReportRequest(actor);
            return;
        }
    case PNeckoMsgStart:
        {
            PNeckoChild* actor = static_cast<PNeckoChild*>(aListener);
            NS_ABORT_IF_FALSE(((mManagedPNeckoChild).NoIndex) != ((mManagedPNeckoChild).BinaryIndexOf(actor)), "actor not managed by this!");

            (mManagedPNeckoChild).RemoveElementSorted(actor);
            DeallocPNecko(actor);
            return;
        }
    case PSmsMsgStart:
        {
            PSmsChild* actor = static_cast<PSmsChild*>(aListener);
            NS_ABORT_IF_FALSE(((mManagedPSmsChild).NoIndex) != ((mManagedPSmsChild).BinaryIndexOf(actor)), "actor not managed by this!");

            (mManagedPSmsChild).RemoveElementSorted(actor);
            DeallocPSms(actor);
            return;
        }
    case PStorageMsgStart:
        {
            PStorageChild* actor = static_cast<PStorageChild*>(aListener);
            NS_ABORT_IF_FALSE(((mManagedPStorageChild).NoIndex) != ((mManagedPStorageChild).BinaryIndexOf(actor)), "actor not managed by this!");

            (mManagedPStorageChild).RemoveElementSorted(actor);
            DeallocPStorage(actor);
            return;
        }
    case PTestShellMsgStart:
        {
            PTestShellChild* actor = static_cast<PTestShellChild*>(aListener);
            NS_ABORT_IF_FALSE(((mManagedPTestShellChild).NoIndex) != ((mManagedPTestShellChild).BinaryIndexOf(actor)), "actor not managed by this!");

            (mManagedPTestShellChild).RemoveElementSorted(actor);
            DeallocPTestShell(actor);
            return;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return;
        }
    }
}

Shmem::SharedMemory*
PContentChild::CreateSharedMemory(
        size_t aSize,
        Shmem::SharedMemory::SharedMemoryType aType,
        bool aUnsafe,
        Shmem::id_t* aId)
{
    nsAutoPtr<Shmem::SharedMemory> segment(Shmem::Alloc(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(), aSize, aType, aUnsafe));
    if ((!(segment))) {
        return 0;
    }
    Shmem shmem(
            Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(),
            (segment).get(),
            (--(mLastShmemId)));
    Message* descriptor = (shmem).ShareTo(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(), OtherProcess(), MSG_ROUTING_CONTROL);
    if ((!(descriptor))) {
        return 0;
    }
    if ((!((mChannel).Send(descriptor)))) {
    }
    (*(aId)) = (shmem).Id(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead());
    (mShmemMap).AddWithID(segment, (*(aId)));
    return (segment).forget();
}

bool
PContentChild::AdoptSharedMemory(
        Shmem::SharedMemory* segment,
        Shmem::id_t* aId)
{
    Shmem shmem(
            Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(),
            segment,
            (--(mLastShmemId)));
    Message* descriptor = (shmem).ShareTo(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(), OtherProcess(), MSG_ROUTING_CONTROL);
    if ((!(descriptor))) {
        return false;
    }
    if ((!((mChannel).Send(descriptor)))) {
    }
    (*(aId)) = (shmem).Id(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead());
    (mShmemMap).AddWithID(segment, (*(aId)));
    (segment)->AddRef();
    return true;
}

Shmem::SharedMemory*
PContentChild::LookupSharedMemory(Shmem::id_t aId)
{
    return (mShmemMap).Lookup(aId);
}

bool
PContentChild::IsTrackingSharedMemory(Shmem::SharedMemory* segment)
{
    return (mShmemMap).HasData(segment);
}

bool
PContentChild::DestroySharedMemory(Shmem& shmem)
{
    Shmem::id_t aId = (shmem).Id(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead());
    Shmem::SharedMemory* segment = LookupSharedMemory(aId);
    if ((!(segment))) {
        return false;
    }
    Message* descriptor = (shmem).UnshareFrom(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(), OtherProcess(), MSG_ROUTING_CONTROL);

    (mShmemMap).Remove(aId);
    Shmem::Dealloc(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(), segment);

    return (descriptor) && ((mChannel).Send(descriptor));
}

ProcessHandle
PContentChild::OtherProcess() const
{
    return mOtherProcess;
}

AsyncChannel*
PContentChild::GetIPCChannel()
{
    return (&(mChannel));
}

PContentChild::Result
PContentChild::OnMessageReceived(const Message& __msg)
{
    int32_t __route = (__msg).routing_id();
    if ((MSG_ROUTING_CONTROL) != (__route)) {
        ChannelListener* __routed = Lookup(__route);
        if ((!(__routed))) {
            return MsgRouteError;
        }
        return (__routed)->OnMessageReceived(__msg);
    }

    switch ((__msg).type()) {
    case PContent::Reply_PBrowserConstructor__ID:
        {
            return MsgProcessed;
        }
    case PContent::Msg_PBrowserConstructor__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PContent::Msg_PBrowserConstructor");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Msg_PBrowserConstructor*>((&(__msg))))->Log("[PContentChild] Received ", stderr);
            }

            void* __iter = 0;
            ActorHandle __handle;
            PBrowserChild* actor;
            IPCTabContext context;
            uint32_t chromeFlags;

            if ((!(Read((&(__handle)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(context)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(chromeFlags)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PContent::Transition(mState, Trigger(Trigger::Send, PContent::Msg_PBrowserConstructor__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            actor = AllocPBrowser(context, chromeFlags);
            if ((!(actor))) {
                return MsgValueError;
            }
            (actor)->mId = RegisterID(actor, (__handle).mId);
            (actor)->mManager = this;
            (actor)->mChannel = (&(mChannel));
            (mManagedPBrowserChild).InsertElementSorted(actor);
            (actor)->mState = mozilla::dom::PBrowser::__Start;

            if ((!(RecvPBrowserConstructor(actor, context, chromeFlags)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for PBrowser returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PContent::Reply_PBlobConstructor__ID:
        {
            return MsgProcessed;
        }
    case PContent::Msg_PBlobConstructor__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PContent::Msg_PBlobConstructor");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Msg_PBlobConstructor*>((&(__msg))))->Log("[PContentChild] Received ", stderr);
            }

            void* __iter = 0;
            ActorHandle __handle;
            PBlobChild* actor;
            BlobConstructorParams params;

            if ((!(Read((&(__handle)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(params)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PContent::Transition(mState, Trigger(Trigger::Send, PContent::Msg_PBlobConstructor__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            actor = AllocPBlob(params);
            if ((!(actor))) {
                return MsgValueError;
            }
            (actor)->mId = RegisterID(actor, (__handle).mId);
            (actor)->mManager = this;
            (actor)->mChannel = (&(mChannel));
            (mManagedPBlobChild).InsertElementSorted(actor);
            (actor)->mState = mozilla::dom::PBlob::__Start;

            if ((!(RecvPBlobConstructor(actor, params)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for PBlob returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PContent::Msg_PMemoryReportRequestConstructor__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PContent::Msg_PMemoryReportRequestConstructor");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Msg_PMemoryReportRequestConstructor*>((&(__msg))))->Log("[PContentChild] Received ", stderr);
            }

            void* __iter = 0;
            ActorHandle __handle;
            PMemoryReportRequestChild* actor;

            if ((!(Read((&(__handle)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PContent::Transition(mState, Trigger(Trigger::Send, PContent::Msg_PMemoryReportRequestConstructor__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            actor = AllocPMemoryReportRequest();
            if ((!(actor))) {
                return MsgValueError;
            }
            (actor)->mId = RegisterID(actor, (__handle).mId);
            (actor)->mManager = this;
            (actor)->mChannel = (&(mChannel));
            (mManagedPMemoryReportRequestChild).InsertElementSorted(actor);
            (actor)->mState = mozilla::dom::PMemoryReportRequest::__Start;

            if ((!(RecvPMemoryReportRequestConstructor(actor)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for PMemoryReportRequest returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PContent::Msg_AudioChannelNotify__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PContent::Msg_AudioChannelNotify");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Msg_AudioChannelNotify*>((&(__msg))))->Log("[PContentChild] Received ", stderr);
            }

            if ((!(PContent::Transition(mState, Trigger(Trigger::Send, PContent::Msg_AudioChannelNotify__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvAudioChannelNotify()))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for AudioChannelNotify returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PContent::Msg_DumpMemoryReportsToFile__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PContent::Msg_DumpMemoryReportsToFile");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Msg_DumpMemoryReportsToFile*>((&(__msg))))->Log("[PContentChild] Received ", stderr);
            }

            void* __iter = 0;
            nsString identifier;
            bool minimizeMemoryUsage;
            bool dumpChildProcesses;

            if ((!(Read((&(identifier)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(minimizeMemoryUsage)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(dumpChildProcesses)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PContent::Transition(mState, Trigger(Trigger::Send, PContent::Msg_DumpMemoryReportsToFile__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvDumpMemoryReportsToFile(identifier, minimizeMemoryUsage, dumpChildProcesses)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for DumpMemoryReportsToFile returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PContent::Msg_DumpGCAndCCLogsToFile__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PContent::Msg_DumpGCAndCCLogsToFile");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Msg_DumpGCAndCCLogsToFile*>((&(__msg))))->Log("[PContentChild] Received ", stderr);
            }

            void* __iter = 0;
            nsString identifier;
            bool dumpChildProcesses;

            if ((!(Read((&(identifier)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(dumpChildProcesses)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PContent::Transition(mState, Trigger(Trigger::Send, PContent::Msg_DumpGCAndCCLogsToFile__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvDumpGCAndCCLogsToFile(identifier, dumpChildProcesses)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for DumpGCAndCCLogsToFile returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PContent::Msg_PTestShellConstructor__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PContent::Msg_PTestShellConstructor");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Msg_PTestShellConstructor*>((&(__msg))))->Log("[PContentChild] Received ", stderr);
            }

            void* __iter = 0;
            ActorHandle __handle;
            PTestShellChild* actor;

            if ((!(Read((&(__handle)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PContent::Transition(mState, Trigger(Trigger::Send, PContent::Msg_PTestShellConstructor__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            actor = AllocPTestShell();
            if ((!(actor))) {
                return MsgValueError;
            }
            (actor)->mId = RegisterID(actor, (__handle).mId);
            (actor)->mManager = this;
            (actor)->mChannel = (&(mChannel));
            (mManagedPTestShellChild).InsertElementSorted(actor);
            (actor)->mState = mozilla::ipc::PTestShell::__Start;

            if ((!(RecvPTestShellConstructor(actor)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for PTestShell returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PContent::Msg_RegisterChrome__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PContent::Msg_RegisterChrome");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Msg_RegisterChrome*>((&(__msg))))->Log("[PContentChild] Received ", stderr);
            }

            void* __iter = 0;
            InfallibleTArray<ChromePackage> packages;
            InfallibleTArray<ResourceMapping> resources;
            InfallibleTArray<OverrideMapping> overrides;
            nsCString locale;

            if ((!(Read((&(packages)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(resources)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(overrides)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(locale)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PContent::Transition(mState, Trigger(Trigger::Send, PContent::Msg_RegisterChrome__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvRegisterChrome(packages, resources, overrides, locale)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for RegisterChrome returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PContent::Msg_SetOffline__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PContent::Msg_SetOffline");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Msg_SetOffline*>((&(__msg))))->Log("[PContentChild] Received ", stderr);
            }

            void* __iter = 0;
            bool offline;

            if ((!(Read((&(offline)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PContent::Transition(mState, Trigger(Trigger::Send, PContent::Msg_SetOffline__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvSetOffline(offline)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for SetOffline returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PContent::Msg_NotifyVisited__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PContent::Msg_NotifyVisited");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Msg_NotifyVisited*>((&(__msg))))->Log("[PContentChild] Received ", stderr);
            }

            void* __iter = 0;
            URIParams uri;

            if ((!(Read((&(uri)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PContent::Transition(mState, Trigger(Trigger::Send, PContent::Msg_NotifyVisited__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvNotifyVisited(uri)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for NotifyVisited returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PContent::Msg_PreferenceUpdate__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PContent::Msg_PreferenceUpdate");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Msg_PreferenceUpdate*>((&(__msg))))->Log("[PContentChild] Received ", stderr);
            }

            void* __iter = 0;
            PrefSetting pref;

            if ((!(Read((&(pref)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PContent::Transition(mState, Trigger(Trigger::Send, PContent::Msg_PreferenceUpdate__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvPreferenceUpdate(pref)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for PreferenceUpdate returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PContent::Msg_NotifyAlertsObserver__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PContent::Msg_NotifyAlertsObserver");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Msg_NotifyAlertsObserver*>((&(__msg))))->Log("[PContentChild] Received ", stderr);
            }

            void* __iter = 0;
            nsCString topic;
            nsString data;

            if ((!(Read((&(topic)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(data)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PContent::Transition(mState, Trigger(Trigger::Send, PContent::Msg_NotifyAlertsObserver__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvNotifyAlertsObserver(topic, data)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for NotifyAlertsObserver returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PContent::Msg_GeolocationUpdate__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PContent::Msg_GeolocationUpdate");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Msg_GeolocationUpdate*>((&(__msg))))->Log("[PContentChild] Received ", stderr);
            }

            void* __iter = 0;
            GeoPosition somewhere;

            if ((!(Read((&(somewhere)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PContent::Transition(mState, Trigger(Trigger::Send, PContent::Msg_GeolocationUpdate__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvGeolocationUpdate(somewhere)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for GeolocationUpdate returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PContent::Msg_AddPermission__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PContent::Msg_AddPermission");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Msg_AddPermission*>((&(__msg))))->Log("[PContentChild] Received ", stderr);
            }

            void* __iter = 0;
            Permission permission;

            if ((!(Read((&(permission)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PContent::Transition(mState, Trigger(Trigger::Send, PContent::Msg_AddPermission__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvAddPermission(permission)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for AddPermission returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PContent::Msg_ScreenSizeChanged__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PContent::Msg_ScreenSizeChanged");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Msg_ScreenSizeChanged*>((&(__msg))))->Log("[PContentChild] Received ", stderr);
            }

            void* __iter = 0;
            gfxIntSize size;

            if ((!(Read((&(size)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PContent::Transition(mState, Trigger(Trigger::Send, PContent::Msg_ScreenSizeChanged__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvScreenSizeChanged(size)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for ScreenSizeChanged returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PContent::Msg_FlushMemory__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PContent::Msg_FlushMemory");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Msg_FlushMemory*>((&(__msg))))->Log("[PContentChild] Received ", stderr);
            }

            void* __iter = 0;
            nsString reason;

            if ((!(Read((&(reason)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PContent::Transition(mState, Trigger(Trigger::Send, PContent::Msg_FlushMemory__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvFlushMemory(reason)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for FlushMemory returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PContent::Msg_GarbageCollect__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PContent::Msg_GarbageCollect");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Msg_GarbageCollect*>((&(__msg))))->Log("[PContentChild] Received ", stderr);
            }

            if ((!(PContent::Transition(mState, Trigger(Trigger::Send, PContent::Msg_GarbageCollect__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvGarbageCollect()))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for GarbageCollect returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PContent::Msg_CycleCollect__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PContent::Msg_CycleCollect");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Msg_CycleCollect*>((&(__msg))))->Log("[PContentChild] Received ", stderr);
            }

            if ((!(PContent::Transition(mState, Trigger(Trigger::Send, PContent::Msg_CycleCollect__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvCycleCollect()))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for CycleCollect returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PContent::Msg_ActivateA11y__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PContent::Msg_ActivateA11y");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Msg_ActivateA11y*>((&(__msg))))->Log("[PContentChild] Received ", stderr);
            }

            if ((!(PContent::Transition(mState, Trigger(Trigger::Send, PContent::Msg_ActivateA11y__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvActivateA11y()))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for ActivateA11y returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PContent::Msg_AppInfo__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PContent::Msg_AppInfo");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Msg_AppInfo*>((&(__msg))))->Log("[PContentChild] Received ", stderr);
            }

            void* __iter = 0;
            nsCString version;
            nsCString buildID;

            if ((!(Read((&(version)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(buildID)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PContent::Transition(mState, Trigger(Trigger::Send, PContent::Msg_AppInfo__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvAppInfo(version, buildID)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for AppInfo returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PContent::Msg_LastPrivateDocShellDestroyed__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PContent::Msg_LastPrivateDocShellDestroyed");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Msg_LastPrivateDocShellDestroyed*>((&(__msg))))->Log("[PContentChild] Received ", stderr);
            }

            if ((!(PContent::Transition(mState, Trigger(Trigger::Send, PContent::Msg_LastPrivateDocShellDestroyed__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvLastPrivateDocShellDestroyed()))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for LastPrivateDocShellDestroyed returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PContent::Msg_FilePathUpdate__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PContent::Msg_FilePathUpdate");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Msg_FilePathUpdate*>((&(__msg))))->Log("[PContentChild] Received ", stderr);
            }

            void* __iter = 0;
            nsString type;
            nsString filepath;
            nsCString reasons;

            if ((!(Read((&(type)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(filepath)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(reasons)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PContent::Transition(mState, Trigger(Trigger::Send, PContent::Msg_FilePathUpdate__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvFilePathUpdate(type, filepath, reasons)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for FilePathUpdate returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PContent::Msg_FileSystemUpdate__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PContent::Msg_FileSystemUpdate");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Msg_FileSystemUpdate*>((&(__msg))))->Log("[PContentChild] Received ", stderr);
            }

            void* __iter = 0;
            nsString fsName;
            nsString mountPoint;
            int32_t fsState;

            if ((!(Read((&(fsName)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(mountPoint)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(fsState)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PContent::Transition(mState, Trigger(Trigger::Send, PContent::Msg_FileSystemUpdate__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvFileSystemUpdate(fsName, mountPoint, fsState)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for FileSystemUpdate returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PContent::Reply_PDeviceStorageRequestConstructor__ID:
        {
            return MsgProcessed;
        }
    case PContent::Reply_PHalConstructor__ID:
        {
            return MsgProcessed;
        }
    case PContent::Reply_PIndexedDBConstructor__ID:
        {
            return MsgProcessed;
        }
    case PContent::Reply_PNeckoConstructor__ID:
        {
            return MsgProcessed;
        }
    case PContent::Reply_PSmsConstructor__ID:
        {
            return MsgProcessed;
        }
    case PContent::Reply_PStorageConstructor__ID:
        {
            return MsgProcessed;
        }
    case PContent::Reply_PBluetoothConstructor__ID:
        {
            return MsgProcessed;
        }
    case PContent::Reply_PExternalHelperAppConstructor__ID:
        {
            return MsgProcessed;
        }
    case PContent::Msg_AsyncMessage__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PContent::Msg_AsyncMessage");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PContent::Msg_AsyncMessage*>((&(__msg))))->Log("[PContentChild] Received ", stderr);
            }

            void* __iter = 0;
            nsString aMessage;
            ClonedMessageData aData;

            if ((!(Read((&(aMessage)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(aData)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PContent::Transition(mState, Trigger(Trigger::Send, PContent::Msg_AsyncMessage__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvAsyncMessage(aMessage, aData)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for AsyncMessage returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case CHANNEL_OPENED_MESSAGE_TYPE:
        {
            TransportDescriptor td;
            ProcessId pid;
            ProtocolId p;
            if ((!(mozilla::ipc::UnpackChannelOpened(mozilla::ipc::PrivateIPDLInterface(), __msg, (&(td)), (&(pid)), (&(p)))))) {
                return MsgPayloadError;
            }

            switch (p) {
            case PCompositorMsgStart:
                {
                    Transport* t;
                    if ((!(t = mozilla::ipc::OpenDescriptor(td, mozilla::ipc::Transport::MODE_CLIENT)))) {
                        return MsgValueError;
                    }
                    if ((!(AllocPCompositor(t, pid)))) {
                        return MsgProcessingError;
                    }
                    break;
                }
            case PImageBridgeMsgStart:
                {
                    Transport* t;
                    if ((!(t = mozilla::ipc::OpenDescriptor(td, mozilla::ipc::Transport::MODE_CLIENT)))) {
                        return MsgValueError;
                    }
                    if ((!(AllocPImageBridge(t, pid)))) {
                        return MsgProcessingError;
                    }
                    break;
                }
            default:
                NS_RUNTIMEABORT("Invalid protocol");
                return MsgValueError;
            }
            return MsgProcessed;
        }
    default:
        {
            return MsgNotKnown;
        }
    case SHMEM_CREATED_MESSAGE_TYPE:
        {
            Shmem::id_t id;
            nsAutoPtr<Shmem::SharedMemory> rawmem(Shmem::OpenExisting(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(), __msg, (&(id)), true));
            if ((!(rawmem))) {
                return MsgPayloadError;
            }
            (mShmemMap).AddWithID((rawmem).forget(), id);

            return MsgProcessed;
        }
    case SHMEM_DESTROYED_MESSAGE_TYPE:
        {
            Shmem::id_t id;
            void* iter = 0;
            if ((!(IPC::ReadParam((&(__msg)), (&(iter)), (&(id)))))) {
                return MsgPayloadError;
            }
            (__msg).EndRead(iter);

            Shmem::SharedMemory* rawmem = LookupSharedMemory(id);
            if ((!(rawmem))) {
                return MsgValueError;
            }
            (mShmemMap).Remove(id);
            Shmem::Dealloc(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(), rawmem);
            return MsgProcessed;
        }
    }
}

PContentChild::Result
PContentChild::OnMessageReceived(
        const Message& __msg,
        Message*& __reply)
{
    int32_t __route = (__msg).routing_id();
    if ((MSG_ROUTING_CONTROL) != (__route)) {
        ChannelListener* __routed = Lookup(__route);
        if ((!(__routed))) {
            return MsgRouteError;
        }
        return (__routed)->OnMessageReceived(__msg, __reply);
    }

    return MsgNotKnown;
}

PContentChild::Result
PContentChild::OnCallReceived(
        const Message& __msg,
        Message*& __reply)
{
    int32_t __route = (__msg).routing_id();
    if ((MSG_ROUTING_CONTROL) != (__route)) {
        ChannelListener* __routed = Lookup(__route);
        if ((!(__routed))) {
            return MsgRouteError;
        }
        return (__routed)->OnCallReceived(__msg, __reply);
    }

    return MsgNotKnown;
}

void
PContentChild::OnProcessingError(Result code)
{
    return ProcessingError(code);
}

int32_t
PContentChild::GetProtocolTypeId()
{
    return PContentMsgStart;
}

bool
PContentChild::OnReplyTimeout()
{
    return ShouldContinueFromReplyTimeout();
}

void
PContentChild::OnEnteredCxxStack()
{
    return EnteredCxxStack();
}

void
PContentChild::OnExitedCxxStack()
{
    return ExitedCxxStack();
}

void
PContentChild::OnEnteredCall()
{
    return EnteredCall();
}

void
PContentChild::OnExitedCall()
{
    return ExitedCall();
}

bool
PContentChild::IsOnCxxStack() const
{
    return (mChannel).IsOnCxxStack();
}

void
PContentChild::FlushPendingRPCQueue()
{
    ((this)->mChannel).FlushPendingRPCQueue();
}

void
PContentChild::OnChannelClose()
{
    DestroySubtree(NormalShutdown);
    DeallocSubtree();
    DeallocShmems();
}

void
PContentChild::OnChannelError()
{
    DestroySubtree(AbnormalShutdown);
    DeallocSubtree();
    DeallocShmems();
}

void
PContentChild::OnChannelConnected(int32_t pid)
{
}

bool
PContentChild::AllocShmem(
        size_t aSize,
        Shmem::SharedMemory::SharedMemoryType aType,
        Shmem* aMem)
{
    Shmem::id_t aId;
    nsAutoPtr<Shmem::SharedMemory> rawmem(CreateSharedMemory(aSize, aType, false, (&(aId))));
    if ((!(rawmem))) {
        return false;
    }

    (*(aMem)) = Shmem(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(), (rawmem).forget(), aId);
    return true;
}

bool
PContentChild::AllocUnsafeShmem(
        size_t aSize,
        Shmem::SharedMemory::SharedMemoryType aType,
        Shmem* aMem)
{
    Shmem::id_t aId;
    nsAutoPtr<Shmem::SharedMemory> rawmem(CreateSharedMemory(aSize, aType, true, (&(aId))));
    if ((!(rawmem))) {
        return false;
    }

    (*(aMem)) = Shmem(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(), (rawmem).forget(), aId);
    return true;
}

bool
PContentChild::AdoptShmem(
        Shmem& aMem,
        Shmem* aOutMem)
{
    Shmem::SharedMemory* rawmem = (aMem).Segment(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead());
    if (((!(rawmem))) || (IsTrackingSharedMemory(rawmem))) {
        NS_RUNTIMEABORT("bad Shmem");
    }

    Shmem::id_t aId;
    if ((!(AdoptSharedMemory(rawmem, (&(aId)))))) {
        return false;
    }

    (*(aOutMem)) = Shmem(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(), rawmem, aId);
    return true;
}

bool
PContentChild::DeallocShmem(Shmem& aMem)
{
    bool ok = DestroySharedMemory(aMem);
    (aMem).forget(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead());
    return ok;
}

void
PContentChild::ProcessNativeEventsInRPCCall()
{
#ifdef OS_WIN
    (mChannel).ProcessNativeEventsInRPCCall();
#else 
    NS_RUNTIMEABORT("This method is Windows-only");
#endif 
}

void
PContentChild::FatalError(const char* const msg) const
{
    // Virtual method to prevent inlining.
    // This give us better error reporting.
    // See bug 589371

    NS_ERROR("IPDL error:");
    NS_ERROR(msg);
    mozilla::ipc::ProtocolErrorBreakpoint(msg);

    NS_RUNTIMEABORT("[PContentChild] abort()ing as a result");
}

void
PContentChild::DestroySubtree(ActorDestroyReason why)
{
    ActorDestroyReason subtreewhy = (((why) == (Deletion)) || ((why) == (FailedConstructor)) ? AncestorDeletion : why);

    {
        // Recursively shutting down PBlob kids
        InfallibleTArray<PBlobChild*> kids(mManagedPBlobChild);
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DestroySubtree(subtreewhy);
        }
    }
    {
        // Recursively shutting down PBluetooth kids
        InfallibleTArray<PBluetoothChild*> kids(mManagedPBluetoothChild);
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DestroySubtree(subtreewhy);
        }
    }
    {
        // Recursively shutting down PBrowser kids
        InfallibleTArray<PBrowserChild*> kids(mManagedPBrowserChild);
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DestroySubtree(subtreewhy);
        }
    }
    {
        // Recursively shutting down PCrashReporter kids
        InfallibleTArray<PCrashReporterChild*> kids(mManagedPCrashReporterChild);
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DestroySubtree(subtreewhy);
        }
    }
    {
        // Recursively shutting down PDeviceStorageRequest kids
        InfallibleTArray<PDeviceStorageRequestChild*> kids(mManagedPDeviceStorageRequestChild);
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DestroySubtree(subtreewhy);
        }
    }
    {
        // Recursively shutting down PExternalHelperApp kids
        InfallibleTArray<PExternalHelperAppChild*> kids(mManagedPExternalHelperAppChild);
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DestroySubtree(subtreewhy);
        }
    }
    {
        // Recursively shutting down PHal kids
        InfallibleTArray<PHalChild*> kids(mManagedPHalChild);
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DestroySubtree(subtreewhy);
        }
    }
    {
        // Recursively shutting down PIndexedDB kids
        InfallibleTArray<PIndexedDBChild*> kids(mManagedPIndexedDBChild);
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DestroySubtree(subtreewhy);
        }
    }
    {
        // Recursively shutting down PMemoryReportRequest kids
        InfallibleTArray<PMemoryReportRequestChild*> kids(mManagedPMemoryReportRequestChild);
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DestroySubtree(subtreewhy);
        }
    }
    {
        // Recursively shutting down PNecko kids
        InfallibleTArray<PNeckoChild*> kids(mManagedPNeckoChild);
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DestroySubtree(subtreewhy);
        }
    }
    {
        // Recursively shutting down PSms kids
        InfallibleTArray<PSmsChild*> kids(mManagedPSmsChild);
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DestroySubtree(subtreewhy);
        }
    }
    {
        // Recursively shutting down PStorage kids
        InfallibleTArray<PStorageChild*> kids(mManagedPStorageChild);
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DestroySubtree(subtreewhy);
        }
    }
    {
        // Recursively shutting down PTestShell kids
        InfallibleTArray<PTestShellChild*> kids(mManagedPTestShellChild);
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DestroySubtree(subtreewhy);
        }
    }

    // Finally, destroy "us".
    ActorDestroy(why);
}

void
PContentChild::DeallocSubtree()
{
    {
        // Recursively deleting PBlob kids
        InfallibleTArray<PBlobChild*>& kids = mManagedPBlobChild;
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DeallocSubtree();
        }

        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            DeallocPBlob(kids[i]);
        }
        (mManagedPBlobChild).Clear();
    }
    {
        // Recursively deleting PBluetooth kids
        InfallibleTArray<PBluetoothChild*>& kids = mManagedPBluetoothChild;
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DeallocSubtree();
        }

        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            DeallocPBluetooth(kids[i]);
        }
        (mManagedPBluetoothChild).Clear();
    }
    {
        // Recursively deleting PBrowser kids
        InfallibleTArray<PBrowserChild*>& kids = mManagedPBrowserChild;
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DeallocSubtree();
        }

        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            DeallocPBrowser(kids[i]);
        }
        (mManagedPBrowserChild).Clear();
    }
    {
        // Recursively deleting PCrashReporter kids
        InfallibleTArray<PCrashReporterChild*>& kids = mManagedPCrashReporterChild;
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DeallocSubtree();
        }

        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            DeallocPCrashReporter(kids[i]);
        }
        (mManagedPCrashReporterChild).Clear();
    }
    {
        // Recursively deleting PDeviceStorageRequest kids
        InfallibleTArray<PDeviceStorageRequestChild*>& kids = mManagedPDeviceStorageRequestChild;
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DeallocSubtree();
        }

        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            DeallocPDeviceStorageRequest(kids[i]);
        }
        (mManagedPDeviceStorageRequestChild).Clear();
    }
    {
        // Recursively deleting PExternalHelperApp kids
        InfallibleTArray<PExternalHelperAppChild*>& kids = mManagedPExternalHelperAppChild;
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DeallocSubtree();
        }

        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            DeallocPExternalHelperApp(kids[i]);
        }
        (mManagedPExternalHelperAppChild).Clear();
    }
    {
        // Recursively deleting PHal kids
        InfallibleTArray<PHalChild*>& kids = mManagedPHalChild;
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DeallocSubtree();
        }

        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            DeallocPHal(kids[i]);
        }
        (mManagedPHalChild).Clear();
    }
    {
        // Recursively deleting PIndexedDB kids
        InfallibleTArray<PIndexedDBChild*>& kids = mManagedPIndexedDBChild;
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DeallocSubtree();
        }

        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            DeallocPIndexedDB(kids[i]);
        }
        (mManagedPIndexedDBChild).Clear();
    }
    {
        // Recursively deleting PMemoryReportRequest kids
        InfallibleTArray<PMemoryReportRequestChild*>& kids = mManagedPMemoryReportRequestChild;
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DeallocSubtree();
        }

        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            DeallocPMemoryReportRequest(kids[i]);
        }
        (mManagedPMemoryReportRequestChild).Clear();
    }
    {
        // Recursively deleting PNecko kids
        InfallibleTArray<PNeckoChild*>& kids = mManagedPNeckoChild;
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DeallocSubtree();
        }

        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            DeallocPNecko(kids[i]);
        }
        (mManagedPNeckoChild).Clear();
    }
    {
        // Recursively deleting PSms kids
        InfallibleTArray<PSmsChild*>& kids = mManagedPSmsChild;
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DeallocSubtree();
        }

        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            DeallocPSms(kids[i]);
        }
        (mManagedPSmsChild).Clear();
    }
    {
        // Recursively deleting PStorage kids
        InfallibleTArray<PStorageChild*>& kids = mManagedPStorageChild;
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DeallocSubtree();
        }

        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            DeallocPStorage(kids[i]);
        }
        (mManagedPStorageChild).Clear();
    }
    {
        // Recursively deleting PTestShell kids
        InfallibleTArray<PTestShellChild*>& kids = mManagedPTestShellChild;
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DeallocSubtree();
        }

        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            DeallocPTestShell(kids[i]);
        }
        (mManagedPTestShellChild).Clear();
    }
}

void
PContentChild::DeallocShmems()
{
    for (IDMap<SharedMemory>::const_iterator cit = (mShmemMap).begin(); (cit) != ((mShmemMap).end()); (++(cit))) {
        Shmem::Dealloc(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(), (cit)->second);
    }
    (mShmemMap).Clear();
}

void
PContentChild::Write(
        const BlobConstructorParams& __v,
        Message* __msg)
{
    typedef BlobConstructorParams __type;
    Write(int((__v).type()), __msg);

    switch ((__v).type()) {
    case __type::TNormalBlobConstructorParams:
        {
            Write((__v).get_NormalBlobConstructorParams(), __msg);
            return;
        }
    case __type::TFileBlobConstructorParams:
        {
            Write((__v).get_FileBlobConstructorParams(), __msg);
            return;
        }
    case __type::TSlicedBlobConstructorParams:
        {
            Write((__v).get_SlicedBlobConstructorParams(), __msg);
            return;
        }
    case __type::TMysteryBlobConstructorParams:
        {
            Write((__v).get_MysteryBlobConstructorParams(), __msg);
            return;
        }
    default:
        {
            NS_RUNTIMEABORT("unknown union type");
            return;
        }
    }
}

bool
PContentChild::Read(
        BlobConstructorParams* __v,
        const Message* __msg,
        void** __iter)
{
    typedef BlobConstructorParams __type;
    int type;
    if ((!(Read((&(type)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }

    switch (type) {
    case __type::TNormalBlobConstructorParams:
        {
            NormalBlobConstructorParams tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_NormalBlobConstructorParams())), __msg, __iter);
        }
    case __type::TFileBlobConstructorParams:
        {
            FileBlobConstructorParams tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_FileBlobConstructorParams())), __msg, __iter);
        }
    case __type::TSlicedBlobConstructorParams:
        {
            SlicedBlobConstructorParams tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_SlicedBlobConstructorParams())), __msg, __iter);
        }
    case __type::TMysteryBlobConstructorParams:
        {
            MysteryBlobConstructorParams tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_MysteryBlobConstructorParams())), __msg, __iter);
        }
    default:
        {
            mozilla::ipc::ProtocolErrorBreakpoint("unknown union type");
            return false;
        }
    }
}

void
PContentChild::Write(
        const IPCTabContext& __v,
        Message* __msg)
{
    Write((__v).appBrowserContext(), __msg);
    Write((__v).scrollingBehavior(), __msg);
}

bool
PContentChild::Read(
        IPCTabContext* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->appBrowserContext())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->scrollingBehavior())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PContentChild::Write(
        const OptionalURIParams& __v,
        Message* __msg)
{
    typedef OptionalURIParams __type;
    Write(int((__v).type()), __msg);

    switch ((__v).type()) {
    case __type::Tvoid_t:
        {
            Write((__v).get_void_t(), __msg);
            return;
        }
    case __type::TURIParams:
        {
            Write((__v).get_URIParams(), __msg);
            return;
        }
    default:
        {
            NS_RUNTIMEABORT("unknown union type");
            return;
        }
    }
}

bool
PContentChild::Read(
        OptionalURIParams* __v,
        const Message* __msg,
        void** __iter)
{
    typedef OptionalURIParams __type;
    int type;
    if ((!(Read((&(type)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }

    switch (type) {
    case __type::Tvoid_t:
        {
            void_t tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_void_t())), __msg, __iter);
        }
    case __type::TURIParams:
        {
            URIParams tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_URIParams())), __msg, __iter);
        }
    default:
        {
            mozilla::ipc::ProtocolErrorBreakpoint("unknown union type");
            return false;
        }
    }
}

void
PContentChild::Write(
        PIndexedDBChild* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PContentChild::Read(
        PIndexedDBChild** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PContent");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PIndexedDB");
        return false;
    }

    if ((PIndexedDBMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PIndexedDB has different type");
        return false;
    }

    (*(__v)) = static_cast<PIndexedDBChild*>(listener);
    return true;
}

void
PContentChild::Write(
        const StandardURLParams& __v,
        Message* __msg)
{
    Write((__v).urlType(), __msg);
    Write((__v).port(), __msg);
    Write((__v).defaultPort(), __msg);
    Write((__v).spec(), __msg);
    Write((__v).scheme(), __msg);
    Write((__v).authority(), __msg);
    Write((__v).username(), __msg);
    Write((__v).password(), __msg);
    Write((__v).host(), __msg);
    Write((__v).path(), __msg);
    Write((__v).filePath(), __msg);
    Write((__v).directory(), __msg);
    Write((__v).baseName(), __msg);
    Write((__v).extension(), __msg);
    Write((__v).query(), __msg);
    Write((__v).ref(), __msg);
    Write((__v).originCharset(), __msg);
    Write((__v).isMutable(), __msg);
    Write((__v).supportsFileURL(), __msg);
    Write((__v).hostEncoding(), __msg);
}

bool
PContentChild::Read(
        StandardURLParams* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->urlType())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->port())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->defaultPort())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->spec())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->scheme())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->authority())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->username())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->password())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->host())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->path())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->filePath())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->directory())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->baseName())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->extension())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->query())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->ref())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->originCharset())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->isMutable())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->supportsFileURL())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->hostEncoding())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PContentChild::Write(
        const URIParams& __v,
        Message* __msg)
{
    typedef URIParams __type;
    Write(int((__v).type()), __msg);

    switch ((__v).type()) {
    case __type::TSimpleURIParams:
        {
            Write((__v).get_SimpleURIParams(), __msg);
            return;
        }
    case __type::TStandardURLParams:
        {
            Write((__v).get_StandardURLParams(), __msg);
            return;
        }
    case __type::TJARURIParams:
        {
            Write((__v).get_JARURIParams(), __msg);
            return;
        }
    case __type::TGenericURIParams:
        {
            Write((__v).get_GenericURIParams(), __msg);
            return;
        }
    default:
        {
            NS_RUNTIMEABORT("unknown union type");
            return;
        }
    }
}

bool
PContentChild::Read(
        URIParams* __v,
        const Message* __msg,
        void** __iter)
{
    typedef URIParams __type;
    int type;
    if ((!(Read((&(type)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }

    switch (type) {
    case __type::TSimpleURIParams:
        {
            SimpleURIParams tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_SimpleURIParams())), __msg, __iter);
        }
    case __type::TStandardURLParams:
        {
            StandardURLParams tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_StandardURLParams())), __msg, __iter);
        }
    case __type::TJARURIParams:
        {
            JARURIParams tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_JARURIParams())), __msg, __iter);
        }
    case __type::TGenericURIParams:
        {
            GenericURIParams tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_GenericURIParams())), __msg, __iter);
        }
    default:
        {
            mozilla::ipc::ProtocolErrorBreakpoint("unknown union type");
            return false;
        }
    }
}

void
PContentChild::Write(
        PBlobChild* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PContentChild::Read(
        PBlobChild** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PContent");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PBlob");
        return false;
    }

    if ((PBlobMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PBlob has different type");
        return false;
    }

    (*(__v)) = static_cast<PBlobChild*>(listener);
    return true;
}

void
PContentChild::Write(
        const InfallibleTArray<FontListEntry>& __v,
        Message* __msg)
{
    uint32_t length = (__v).Length();
    Write(length, __msg);

    for (uint32_t i = 0; (i) < (length); (++(i))) {
        Write(__v[i], __msg);
    }
}

bool
PContentChild::Read(
        InfallibleTArray<FontListEntry>* __v,
        const Message* __msg,
        void** __iter)
{
    InfallibleTArray<FontListEntry>& a = (*(__v));
    uint32_t length;
    if ((!(Read((&(length)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }

    (__v)->SetLength(length);
    for (uint32_t i = 0; (i) < (length); (++(i))) {
        if ((!(Read((&(a[i])), __msg, __iter)))) {
            mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
            return false;
        }
    }
    return true;
}

void
PContentChild::Write(
        PCrashReporterChild* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PContentChild::Read(
        PCrashReporterChild** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PContent");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PCrashReporter");
        return false;
    }

    if ((PCrashReporterMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PCrashReporter has different type");
        return false;
    }

    (*(__v)) = static_cast<PCrashReporterChild*>(listener);
    return true;
}

void
PContentChild::Write(
        PSmsChild* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PContentChild::Read(
        PSmsChild** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PContent");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PSms");
        return false;
    }

    if ((PSmsMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PSms has different type");
        return false;
    }

    (*(__v)) = static_cast<PSmsChild*>(listener);
    return true;
}

void
PContentChild::Write(
        const IPCTabAppBrowserContext& __v,
        Message* __msg)
{
    typedef IPCTabAppBrowserContext __type;
    Write(int((__v).type()), __msg);

    switch ((__v).type()) {
    case __type::TPopupIPCTabContext:
        {
            Write((__v).get_PopupIPCTabContext(), __msg);
            return;
        }
    case __type::TAppFrameIPCTabContext:
        {
            Write((__v).get_AppFrameIPCTabContext(), __msg);
            return;
        }
    case __type::TBrowserFrameIPCTabContext:
        {
            Write((__v).get_BrowserFrameIPCTabContext(), __msg);
            return;
        }
    case __type::TVanillaFrameIPCTabContext:
        {
            Write((__v).get_VanillaFrameIPCTabContext(), __msg);
            return;
        }
    default:
        {
            NS_RUNTIMEABORT("unknown union type");
            return;
        }
    }
}

bool
PContentChild::Read(
        IPCTabAppBrowserContext* __v,
        const Message* __msg,
        void** __iter)
{
    typedef IPCTabAppBrowserContext __type;
    int type;
    if ((!(Read((&(type)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }

    switch (type) {
    case __type::TPopupIPCTabContext:
        {
            PopupIPCTabContext tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_PopupIPCTabContext())), __msg, __iter);
        }
    case __type::TAppFrameIPCTabContext:
        {
            AppFrameIPCTabContext tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_AppFrameIPCTabContext())), __msg, __iter);
        }
    case __type::TBrowserFrameIPCTabContext:
        {
            BrowserFrameIPCTabContext tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_BrowserFrameIPCTabContext())), __msg, __iter);
        }
    case __type::TVanillaFrameIPCTabContext:
        {
            VanillaFrameIPCTabContext tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_VanillaFrameIPCTabContext())), __msg, __iter);
        }
    default:
        {
            mozilla::ipc::ProtocolErrorBreakpoint("unknown union type");
            return false;
        }
    }
}

void
PContentChild::Write(
        const BrowserFrameIPCTabContext& __v,
        Message* __msg)
{
    Write((__v).browserFrameOwnerAppId(), __msg);
}

bool
PContentChild::Read(
        BrowserFrameIPCTabContext* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->browserFrameOwnerAppId())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PContentChild::Write(
        const InfallibleTArray<PrefSetting>& __v,
        Message* __msg)
{
    uint32_t length = (__v).Length();
    Write(length, __msg);

    for (uint32_t i = 0; (i) < (length); (++(i))) {
        Write(__v[i], __msg);
    }
}

bool
PContentChild::Read(
        InfallibleTArray<PrefSetting>* __v,
        const Message* __msg,
        void** __iter)
{
    InfallibleTArray<PrefSetting>& a = (*(__v));
    uint32_t length;
    if ((!(Read((&(length)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }

    (__v)->SetLength(length);
    for (uint32_t i = 0; (i) < (length); (++(i))) {
        if ((!(Read((&(a[i])), __msg, __iter)))) {
            mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
            return false;
        }
    }
    return true;
}

void
PContentChild::Write(
        const PrefValue& __v,
        Message* __msg)
{
    typedef PrefValue __type;
    Write(int((__v).type()), __msg);

    switch ((__v).type()) {
    case __type::TnsCString:
        {
            Write((__v).get_nsCString(), __msg);
            return;
        }
    case __type::Tint32_t:
        {
            Write((__v).get_int32_t(), __msg);
            return;
        }
    case __type::Tbool:
        {
            Write((__v).get_bool(), __msg);
            return;
        }
    default:
        {
            NS_RUNTIMEABORT("unknown union type");
            return;
        }
    }
}

bool
PContentChild::Read(
        PrefValue* __v,
        const Message* __msg,
        void** __iter)
{
    typedef PrefValue __type;
    int type;
    if ((!(Read((&(type)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }

    switch (type) {
    case __type::TnsCString:
        {
            nsCString tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_nsCString())), __msg, __iter);
        }
    case __type::Tint32_t:
        {
            int32_t tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_int32_t())), __msg, __iter);
        }
    case __type::Tbool:
        {
            bool tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_bool())), __msg, __iter);
        }
    default:
        {
            mozilla::ipc::ProtocolErrorBreakpoint("unknown union type");
            return false;
        }
    }
}

void
PContentChild::Write(
        PExternalHelperAppChild* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PContentChild::Read(
        PExternalHelperAppChild** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PContent");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PExternalHelperApp");
        return false;
    }

    if ((PExternalHelperAppMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PExternalHelperApp has different type");
        return false;
    }

    (*(__v)) = static_cast<PExternalHelperAppChild*>(listener);
    return true;
}

void
PContentChild::Write(
        const FontListEntry& __v,
        Message* __msg)
{
    Write((__v).familyName(), __msg);
    Write((__v).faceName(), __msg);
    Write((__v).filepath(), __msg);
    Write((__v).weight(), __msg);
    Write((__v).stretch(), __msg);
    Write((__v).italic(), __msg);
    Write((__v).index(), __msg);
}

bool
PContentChild::Read(
        FontListEntry* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->familyName())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->faceName())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->filepath())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->weight())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->stretch())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->italic())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->index())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PContentChild::Write(
        const DeviceStorageEnumerationParams& __v,
        Message* __msg)
{
    Write((__v).type(), __msg);
    Write((__v).fullpath(), __msg);
    Write((__v).since(), __msg);
}

bool
PContentChild::Read(
        DeviceStorageEnumerationParams* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->type())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->fullpath())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->since())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PContentChild::Write(
        const VanillaFrameIPCTabContext& __v,
        Message* __msg)
{
}

bool
PContentChild::Read(
        VanillaFrameIPCTabContext* __v,
        const Message* __msg,
        void** __iter)
{
    return true;
}

void
PContentChild::Write(
        PTestShellChild* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PContentChild::Read(
        PTestShellChild** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PContent");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PTestShell");
        return false;
    }

    if ((PTestShellMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PTestShell has different type");
        return false;
    }

    (*(__v)) = static_cast<PTestShellChild*>(listener);
    return true;
}

void
PContentChild::Write(
        PMemoryReportRequestChild* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PContentChild::Read(
        PMemoryReportRequestChild** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PContent");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PMemoryReportRequest");
        return false;
    }

    if ((PMemoryReportRequestMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PMemoryReportRequest has different type");
        return false;
    }

    (*(__v)) = static_cast<PMemoryReportRequestChild*>(listener);
    return true;
}

void
PContentChild::Write(
        const GenericURIParams& __v,
        Message* __msg)
{
    Write((__v).spec(), __msg);
    Write((__v).charset(), __msg);
}

bool
PContentChild::Read(
        GenericURIParams* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->spec())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->charset())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PContentChild::Write(
        const DeviceStorageGetParams& __v,
        Message* __msg)
{
    Write((__v).type(), __msg);
    Write((__v).name(), __msg);
    Write((__v).fullpath(), __msg);
}

bool
PContentChild::Read(
        DeviceStorageGetParams* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->type())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->name())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->fullpath())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PContentChild::Write(
        const DeviceStorageAddParams& __v,
        Message* __msg)
{
    Write((__v).type(), __msg);
    // skipping actor field that's meaningless on this side
    Write((__v).blobChild(), __msg, false);
    Write((__v).name(), __msg);
    Write((__v).fullpath(), __msg);
}

bool
PContentChild::Read(
        DeviceStorageAddParams* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->type())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    // skipping actor field that's meaningless on this side
    if ((!(Read((&((__v)->blobChild())), __msg, __iter, false)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->name())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->fullpath())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PContentChild::Write(
        const SlicedBlobConstructorParams& __v,
        Message* __msg)
{
    // skipping actor field that's meaningless on this side
    Write((__v).sourceChild(), __msg, false);
    Write((__v).begin(), __msg);
    Write((__v).end(), __msg);
    Write((__v).contentType(), __msg);
}

bool
PContentChild::Read(
        SlicedBlobConstructorParams* __v,
        const Message* __msg,
        void** __iter)
{
    // skipping actor field that's meaningless on this side
    if ((!(Read((&((__v)->sourceChild())), __msg, __iter, false)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->begin())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->end())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->contentType())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PContentChild::Write(
        const MaybePrefValue& __v,
        Message* __msg)
{
    typedef MaybePrefValue __type;
    Write(int((__v).type()), __msg);

    switch ((__v).type()) {
    case __type::TPrefValue:
        {
            Write((__v).get_PrefValue(), __msg);
            return;
        }
    case __type::Tnull_t:
        {
            Write((__v).get_null_t(), __msg);
            return;
        }
    default:
        {
            NS_RUNTIMEABORT("unknown union type");
            return;
        }
    }
}

bool
PContentChild::Read(
        MaybePrefValue* __v,
        const Message* __msg,
        void** __iter)
{
    typedef MaybePrefValue __type;
    int type;
    if ((!(Read((&(type)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }

    switch (type) {
    case __type::TPrefValue:
        {
            PrefValue tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_PrefValue())), __msg, __iter);
        }
    case __type::Tnull_t:
        {
            null_t tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_null_t())), __msg, __iter);
        }
    default:
        {
            mozilla::ipc::ProtocolErrorBreakpoint("unknown union type");
            return false;
        }
    }
}

void
PContentChild::Write(
        PNeckoChild* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PContentChild::Read(
        PNeckoChild** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PContent");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PNecko");
        return false;
    }

    if ((PNeckoMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PNecko has different type");
        return false;
    }

    (*(__v)) = static_cast<PNeckoChild*>(listener);
    return true;
}

void
PContentChild::Write(
        const ClonedMessageData& __v,
        Message* __msg)
{
    Write((__v).data(), __msg);
    // skipping actor field that's meaningless on this side
    Write((__v).blobsChild(), __msg);
}

bool
PContentChild::Read(
        ClonedMessageData* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->data())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    // skipping actor field that's meaningless on this side
    if ((!(Read((&((__v)->blobsChild())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PContentChild::Write(
        const InfallibleTArray<PBlobChild*>& __v,
        Message* __msg)
{
    uint32_t length = (__v).Length();
    Write(length, __msg);

    for (uint32_t i = 0; (i) < (length); (++(i))) {
        Write(__v[i], __msg, false);
    }
}

bool
PContentChild::Read(
        InfallibleTArray<PBlobChild*>* __v,
        const Message* __msg,
        void** __iter)
{
    InfallibleTArray<PBlobChild*>& a = (*(__v));
    uint32_t length;
    if ((!(Read((&(length)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }

    (__v)->SetLength(length);
    for (uint32_t i = 0; (i) < (length); (++(i))) {
        if ((!(Read((&(a[i])), __msg, __iter, false)))) {
            mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
            return false;
        }
    }
    return true;
}

void
PContentChild::Write(
        PDeviceStorageRequestChild* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PContentChild::Read(
        PDeviceStorageRequestChild** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PContent");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PDeviceStorageRequest");
        return false;
    }

    if ((PDeviceStorageRequestMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PDeviceStorageRequest has different type");
        return false;
    }

    (*(__v)) = static_cast<PDeviceStorageRequestChild*>(listener);
    return true;
}

void
PContentChild::Write(
        const NormalBlobConstructorParams& __v,
        Message* __msg)
{
    Write((__v).contentType(), __msg);
    Write((__v).length(), __msg);
}

bool
PContentChild::Read(
        NormalBlobConstructorParams* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->contentType())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->length())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PContentChild::Write(
        const DeviceStorageStatParams& __v,
        Message* __msg)
{
    Write((__v).type(), __msg);
    Write((__v).fullpath(), __msg);
}

bool
PContentChild::Read(
        DeviceStorageStatParams* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->type())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->fullpath())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PContentChild::Write(
        const StorageClone& __v,
        Message* __msg)
{
    // skipping actor field that's meaningless on this side
    Write((__v).actorChild(), __msg, false);
    Write((__v).callerSecure(), __msg);
}

bool
PContentChild::Read(
        StorageClone* __v,
        const Message* __msg,
        void** __iter)
{
    // skipping actor field that's meaningless on this side
    if ((!(Read((&((__v)->actorChild())), __msg, __iter, false)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->callerSecure())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PContentChild::Write(
        const JARURIParams& __v,
        Message* __msg)
{
    Write((__v).jarFile(), __msg);
    Write((__v).jarEntry(), __msg);
    Write((__v).charset(), __msg);
}

bool
PContentChild::Read(
        JARURIParams* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->jarFile())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->jarEntry())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->charset())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PContentChild::Write(
        const MysteryBlobConstructorParams& __v,
        Message* __msg)
{
}

bool
PContentChild::Read(
        MysteryBlobConstructorParams* __v,
        const Message* __msg,
        void** __iter)
{
    return true;
}

void
PContentChild::Write(
        const DeviceStorageParams& __v,
        Message* __msg)
{
    typedef DeviceStorageParams __type;
    Write(int((__v).type()), __msg);

    switch ((__v).type()) {
    case __type::TDeviceStorageAddParams:
        {
            Write((__v).get_DeviceStorageAddParams(), __msg);
            return;
        }
    case __type::TDeviceStorageGetParams:
        {
            Write((__v).get_DeviceStorageGetParams(), __msg);
            return;
        }
    case __type::TDeviceStorageDeleteParams:
        {
            Write((__v).get_DeviceStorageDeleteParams(), __msg);
            return;
        }
    case __type::TDeviceStorageEnumerationParams:
        {
            Write((__v).get_DeviceStorageEnumerationParams(), __msg);
            return;
        }
    case __type::TDeviceStorageStatParams:
        {
            Write((__v).get_DeviceStorageStatParams(), __msg);
            return;
        }
    default:
        {
            NS_RUNTIMEABORT("unknown union type");
            return;
        }
    }
}

bool
PContentChild::Read(
        DeviceStorageParams* __v,
        const Message* __msg,
        void** __iter)
{
    typedef DeviceStorageParams __type;
    int type;
    if ((!(Read((&(type)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }

    switch (type) {
    case __type::TDeviceStorageAddParams:
        {
            DeviceStorageAddParams tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_DeviceStorageAddParams())), __msg, __iter);
        }
    case __type::TDeviceStorageGetParams:
        {
            DeviceStorageGetParams tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_DeviceStorageGetParams())), __msg, __iter);
        }
    case __type::TDeviceStorageDeleteParams:
        {
            DeviceStorageDeleteParams tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_DeviceStorageDeleteParams())), __msg, __iter);
        }
    case __type::TDeviceStorageEnumerationParams:
        {
            DeviceStorageEnumerationParams tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_DeviceStorageEnumerationParams())), __msg, __iter);
        }
    case __type::TDeviceStorageStatParams:
        {
            DeviceStorageStatParams tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_DeviceStorageStatParams())), __msg, __iter);
        }
    default:
        {
            mozilla::ipc::ProtocolErrorBreakpoint("unknown union type");
            return false;
        }
    }
}

void
PContentChild::Write(
        PBluetoothChild* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PContentChild::Read(
        PBluetoothChild** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PContent");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PBluetooth");
        return false;
    }

    if ((PBluetoothMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PBluetooth has different type");
        return false;
    }

    (*(__v)) = static_cast<PBluetoothChild*>(listener);
    return true;
}

void
PContentChild::Write(
        const PopupIPCTabContext& __v,
        Message* __msg)
{
    // skipping actor field that's meaningless on this side
    Write((__v).openerChild(), __msg, false);
    Write((__v).isBrowserElement(), __msg);
}

bool
PContentChild::Read(
        PopupIPCTabContext* __v,
        const Message* __msg,
        void** __iter)
{
    // skipping actor field that's meaningless on this side
    if ((!(Read((&((__v)->openerChild())), __msg, __iter, false)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->isBrowserElement())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PContentChild::Write(
        const SimpleURIParams& __v,
        Message* __msg)
{
    Write((__v).scheme(), __msg);
    Write((__v).path(), __msg);
    Write((__v).ref(), __msg);
    Write((__v).isMutable(), __msg);
}

bool
PContentChild::Read(
        SimpleURIParams* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->scheme())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->path())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->ref())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->isMutable())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PContentChild::Write(
        const StorageConstructData& __v,
        Message* __msg)
{
    typedef StorageConstructData __type;
    Write(int((__v).type()), __msg);

    switch ((__v).type()) {
    case __type::Tnull_t:
        {
            Write((__v).get_null_t(), __msg);
            return;
        }
    case __type::TStorageClone:
        {
            Write((__v).get_StorageClone(), __msg);
            return;
        }
    default:
        {
            NS_RUNTIMEABORT("unknown union type");
            return;
        }
    }
}

bool
PContentChild::Read(
        StorageConstructData* __v,
        const Message* __msg,
        void** __iter)
{
    typedef StorageConstructData __type;
    int type;
    if ((!(Read((&(type)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }

    switch (type) {
    case __type::Tnull_t:
        {
            null_t tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_null_t())), __msg, __iter);
        }
    case __type::TStorageClone:
        {
            StorageClone tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_StorageClone())), __msg, __iter);
        }
    default:
        {
            mozilla::ipc::ProtocolErrorBreakpoint("unknown union type");
            return false;
        }
    }
}

void
PContentChild::Write(
        PStorageChild* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PContentChild::Read(
        PStorageChild** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PContent");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PStorage");
        return false;
    }

    if ((PStorageMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PStorage has different type");
        return false;
    }

    (*(__v)) = static_cast<PStorageChild*>(listener);
    return true;
}

void
PContentChild::Write(
        PBrowserChild* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PContentChild::Read(
        PBrowserChild** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PContent");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PBrowser");
        return false;
    }

    if ((PBrowserMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PBrowser has different type");
        return false;
    }

    (*(__v)) = static_cast<PBrowserChild*>(listener);
    return true;
}

void
PContentChild::Write(
        const DeviceStorageDeleteParams& __v,
        Message* __msg)
{
    Write((__v).type(), __msg);
    Write((__v).fullpath(), __msg);
}

bool
PContentChild::Read(
        DeviceStorageDeleteParams* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->type())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->fullpath())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PContentChild::Write(
        const PrefSetting& __v,
        Message* __msg)
{
    Write((__v).name(), __msg);
    Write((__v).defaultValue(), __msg);
    Write((__v).userValue(), __msg);
}

bool
PContentChild::Read(
        PrefSetting* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->name())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->defaultValue())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->userValue())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PContentChild::Write(
        PHalChild* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PContentChild::Read(
        PHalChild** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PContent");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PHal");
        return false;
    }

    if ((PHalMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PHal has different type");
        return false;
    }

    (*(__v)) = static_cast<PHalChild*>(listener);
    return true;
}

void
PContentChild::Write(
        const StandardURLSegment& __v,
        Message* __msg)
{
    Write((__v).position(), __msg);
    Write((__v).length(), __msg);
}

bool
PContentChild::Read(
        StandardURLSegment* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->position())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->length())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PContentChild::Write(
        const FileBlobConstructorParams& __v,
        Message* __msg)
{
    Write((__v).name(), __msg);
    Write((__v).contentType(), __msg);
    Write((__v).length(), __msg);
    Write((__v).modDate(), __msg);
}

bool
PContentChild::Read(
        FileBlobConstructorParams* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->name())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->contentType())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->length())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->modDate())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PContentChild::Write(
        const AppFrameIPCTabContext& __v,
        Message* __msg)
{
    Write((__v).ownAppId(), __msg);
    Write((__v).appFrameOwnerAppId(), __msg);
}

bool
PContentChild::Read(
        AppFrameIPCTabContext* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->ownAppId())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->appFrameOwnerAppId())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}



} // namespace dom
} // namespace mozilla
