//
// Automatically generated by ipdlc.
// Edit at your own risk
//


#include "mozilla/dom/indexedDB/PIndexedDBDatabase.h"

namespace mozilla {
namespace dom {
namespace indexedDB {
namespace PIndexedDBDatabase {

bool
Transition(
        State from,
        mozilla::ipc::Trigger trigger,
        State* next)
{
    switch (from) {
    case __Null:
    case __Error:
        if ((Msg___delete____ID) == ((trigger).mMsg)) {
            (*(next)) = __Dead;
            return true;
        }
        return (__Null) == (from);
    case __Dead:
        NS_RUNTIMEABORT("__delete__()d actor");
        return false;
    case __Dying:
        NS_RUNTIMEABORT("__delete__()d (and unexpectedly dying) actor");
        return false;
    default:
        NS_RUNTIMEABORT("corrupted actor state");
        return false;
    }
    (*(next)) = __Error;
    return false;
}

} // namespace PIndexedDBDatabase
} // namespace indexedDB
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct NormalTransactionParams|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
namespace ipc {
NormalTransactionParams::NormalTransactionParams()
{
    Init();
}

NormalTransactionParams::~NormalTransactionParams()
{
}

bool
NormalTransactionParams::operator==(const NormalTransactionParams& _o) const
{
    if ((!((names()) == ((_o).names())))) {
        return false;
    }
    if ((!((mode()) == ((_o).mode())))) {
        return false;
    }
    return true;
}

void
NormalTransactionParams::Init()
{
}

void
NormalTransactionParams::Assign(
        const InfallibleTArray<nsString>& _names,
        const Mode& _mode)
{
    names_ = _names;
    mode_ = _mode;
}

} // namespace ipc
} // namespace indexedDB
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct VersionChangeTransactionParams|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
namespace ipc {
VersionChangeTransactionParams::VersionChangeTransactionParams()
{
    Init();
}

VersionChangeTransactionParams::~VersionChangeTransactionParams()
{
}

bool
VersionChangeTransactionParams::operator==(const VersionChangeTransactionParams& _o) const
{
    if ((!((dbInfo()) == ((_o).dbInfo())))) {
        return false;
    }
    if ((!((osInfo()) == ((_o).osInfo())))) {
        return false;
    }
    if ((!((oldVersion()) == ((_o).oldVersion())))) {
        return false;
    }
    return true;
}

void
VersionChangeTransactionParams::Init()
{
}

void
VersionChangeTransactionParams::Assign(
        const DatabaseInfoGuts& _dbInfo,
        const InfallibleTArray<ObjectStoreInfoGuts>& _osInfo,
        const uint64_t& _oldVersion)
{
    dbInfo_ = _dbInfo;
    osInfo_ = _osInfo;
    oldVersion_ = _oldVersion;
}

} // namespace ipc
} // namespace indexedDB
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |union TransactionParams|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
namespace ipc {
bool
TransactionParams::MaybeDestroy(Type aNewType)
{
    if ((mType) == (T__None)) {
        return true;
    }
    if ((mType) == (aNewType)) {
        return false;
    }
    switch (mType) {
    case TNormalTransactionParams:
        {
            (ptr_NormalTransactionParams())->~NormalTransactionParams__tdef();
            break;
        }
    case TVersionChangeTransactionParams:
        {
            (ptr_VersionChangeTransactionParams())->~VersionChangeTransactionParams__tdef();
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("not reached");
            break;
        }
    }
    return true;
}

TransactionParams::TransactionParams(const NormalTransactionParams& aOther)
{
    new (ptr_NormalTransactionParams()) NormalTransactionParams(aOther);
    mType = TNormalTransactionParams;
}

TransactionParams::TransactionParams(const VersionChangeTransactionParams& aOther)
{
    new (ptr_VersionChangeTransactionParams()) VersionChangeTransactionParams(aOther);
    mType = TVersionChangeTransactionParams;
}

TransactionParams::TransactionParams(const TransactionParams& aOther)
{
    (aOther).AssertSanity();
    switch ((aOther).type()) {
    case TNormalTransactionParams:
        {
            new (ptr_NormalTransactionParams()) NormalTransactionParams((aOther).get_NormalTransactionParams());
            break;
        }
    case TVersionChangeTransactionParams:
        {
            new (ptr_VersionChangeTransactionParams()) VersionChangeTransactionParams((aOther).get_VersionChangeTransactionParams());
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return;
        }
    }
    mType = (aOther).type();
}

TransactionParams::~TransactionParams()
{
    MaybeDestroy(T__None);
}

TransactionParams&
TransactionParams::operator=(const NormalTransactionParams& aRhs)
{
    if (MaybeDestroy(TNormalTransactionParams)) {
        new (ptr_NormalTransactionParams()) NormalTransactionParams;
    }
    (*(ptr_NormalTransactionParams())) = aRhs;
    mType = TNormalTransactionParams;
    return (*(this));
}

TransactionParams&
TransactionParams::operator=(const VersionChangeTransactionParams& aRhs)
{
    if (MaybeDestroy(TVersionChangeTransactionParams)) {
        new (ptr_VersionChangeTransactionParams()) VersionChangeTransactionParams;
    }
    (*(ptr_VersionChangeTransactionParams())) = aRhs;
    mType = TVersionChangeTransactionParams;
    return (*(this));
}

TransactionParams&
TransactionParams::operator=(const TransactionParams& aRhs)
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case TNormalTransactionParams:
        {
            if (MaybeDestroy(t)) {
                new (ptr_NormalTransactionParams()) NormalTransactionParams;
            }
            (*(ptr_NormalTransactionParams())) = (aRhs).get_NormalTransactionParams();
            break;
        }
    case TVersionChangeTransactionParams:
        {
            if (MaybeDestroy(t)) {
                new (ptr_VersionChangeTransactionParams()) VersionChangeTransactionParams;
            }
            (*(ptr_VersionChangeTransactionParams())) = (aRhs).get_VersionChangeTransactionParams();
            break;
        }
    case T__None:
        {
            MaybeDestroy(t);
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            break;
        }
    }
    mType = t;
    return (*(this));
}

bool
TransactionParams::operator==(const NormalTransactionParams& aRhs) const
{
    return (get_NormalTransactionParams()) == (aRhs);
}

bool
TransactionParams::operator==(const VersionChangeTransactionParams& aRhs) const
{
    return (get_VersionChangeTransactionParams()) == (aRhs);
}

bool
TransactionParams::operator==(const TransactionParams& aRhs) const
{
    if ((type()) != ((aRhs).type())) {
        return false;
    }

    switch (type()) {
    case TNormalTransactionParams:
        {
            return (get_NormalTransactionParams()) == ((aRhs).get_NormalTransactionParams());
        }
    case TVersionChangeTransactionParams:
        {
            return (get_VersionChangeTransactionParams()) == ((aRhs).get_VersionChangeTransactionParams());
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return false;
        }
    }
}

} // namespace ipc
} // namespace indexedDB
} // namespace dom
} // namespace mozilla
