//
// Automatically generated by ipdlc.
// Edit at your own risk
//


#include "mozilla/dom/PStorage.h"

namespace mozilla {
namespace dom {
namespace PStorage {

bool
Transition(
        State from,
        mozilla::ipc::Trigger trigger,
        State* next)
{
    switch (from) {
    case __Null:
    case __Error:
        if ((Msg___delete____ID) == ((trigger).mMsg)) {
            (*(next)) = __Dead;
            return true;
        }
        return (__Null) == (from);
    case __Dead:
        NS_RUNTIMEABORT("__delete__()d actor");
        return false;
    case __Dying:
        NS_RUNTIMEABORT("__delete__()d (and unexpectedly dying) actor");
        return false;
    default:
        NS_RUNTIMEABORT("corrupted actor state");
        return false;
    }
    (*(next)) = __Error;
    return false;
}

} // namespace PStorage
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct ItemData|
//
namespace mozilla {
namespace dom {
ItemData::ItemData()
{
    Init();
}

ItemData::~ItemData()
{
}

bool
ItemData::operator==(const ItemData& _o) const
{
    if ((!((value()) == ((_o).value())))) {
        return false;
    }
    if ((!((secure()) == ((_o).secure())))) {
        return false;
    }
    return true;
}

void
ItemData::Init()
{
}

void
ItemData::Assign(
        const nsString& _value,
        const bool& _secure)
{
    value_ = _value;
    secure_ = _secure;
}

} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |union StorageItem|
//
namespace mozilla {
namespace dom {
bool
StorageItem::MaybeDestroy(Type aNewType)
{
    if ((mType) == (T__None)) {
        return true;
    }
    if ((mType) == (aNewType)) {
        return false;
    }
    switch (mType) {
    case Tnull_t:
        {
            (ptr_null_t())->~null_t__tdef();
            break;
        }
    case TItemData:
        {
            (ptr_ItemData())->~ItemData__tdef();
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("not reached");
            break;
        }
    }
    return true;
}

StorageItem::StorageItem(const null_t& aOther)
{
    new (ptr_null_t()) null_t(aOther);
    mType = Tnull_t;
}

StorageItem::StorageItem(const ItemData& aOther)
{
    new (ptr_ItemData()) ItemData(aOther);
    mType = TItemData;
}

StorageItem::StorageItem(const StorageItem& aOther)
{
    (aOther).AssertSanity();
    switch ((aOther).type()) {
    case Tnull_t:
        {
            new (ptr_null_t()) null_t((aOther).get_null_t());
            break;
        }
    case TItemData:
        {
            new (ptr_ItemData()) ItemData((aOther).get_ItemData());
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return;
        }
    }
    mType = (aOther).type();
}

StorageItem::~StorageItem()
{
    MaybeDestroy(T__None);
}

StorageItem&
StorageItem::operator=(const null_t& aRhs)
{
    if (MaybeDestroy(Tnull_t)) {
        new (ptr_null_t()) null_t;
    }
    (*(ptr_null_t())) = aRhs;
    mType = Tnull_t;
    return (*(this));
}

StorageItem&
StorageItem::operator=(const ItemData& aRhs)
{
    if (MaybeDestroy(TItemData)) {
        new (ptr_ItemData()) ItemData;
    }
    (*(ptr_ItemData())) = aRhs;
    mType = TItemData;
    return (*(this));
}

StorageItem&
StorageItem::operator=(const StorageItem& aRhs)
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case Tnull_t:
        {
            if (MaybeDestroy(t)) {
                new (ptr_null_t()) null_t;
            }
            (*(ptr_null_t())) = (aRhs).get_null_t();
            break;
        }
    case TItemData:
        {
            if (MaybeDestroy(t)) {
                new (ptr_ItemData()) ItemData;
            }
            (*(ptr_ItemData())) = (aRhs).get_ItemData();
            break;
        }
    case T__None:
        {
            MaybeDestroy(t);
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            break;
        }
    }
    mType = t;
    return (*(this));
}

bool
StorageItem::operator==(const null_t& aRhs) const
{
    return (get_null_t()) == (aRhs);
}

bool
StorageItem::operator==(const ItemData& aRhs) const
{
    return (get_ItemData()) == (aRhs);
}

bool
StorageItem::operator==(const StorageItem& aRhs) const
{
    if ((type()) != ((aRhs).type())) {
        return false;
    }

    switch (type()) {
    case Tnull_t:
        {
            return (get_null_t()) == ((aRhs).get_null_t());
        }
    case TItemData:
        {
            return (get_ItemData()) == ((aRhs).get_ItemData());
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return false;
        }
    }
}

} // namespace dom
} // namespace mozilla
