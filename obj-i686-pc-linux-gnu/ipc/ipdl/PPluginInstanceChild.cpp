//
// Automatically generated by ipdlc.
// Edit at your own risk
//


#include "mozilla/plugins/PPluginInstanceChild.h"

#include "mozilla/plugins/PPluginBackgroundDestroyerChild.h"
#include "mozilla/plugins/PPluginModuleChild.h"
#include "mozilla/plugins/PPluginScriptableObjectChild.h"
#include "mozilla/plugins/PBrowserStreamChild.h"
#include "mozilla/plugins/PPluginStreamChild.h"
#include "mozilla/plugins/PStreamNotifyChild.h"
#include "mozilla/plugins/PPluginSurfaceChild.h"

typedef IPC::Message Message;
typedef mozilla::ipc::RPCChannel Channel;
typedef mozilla::ipc::RPCChannel::RPCListener ChannelListener;
typedef base::ProcessHandle ProcessHandle;
typedef mozilla::ipc::AsyncChannel AsyncChannel;
typedef mozilla::ipc::SharedMemory SharedMemory;
typedef mozilla::ipc::Trigger Trigger;
typedef mozilla::ipc::ActorHandle ActorHandle;
typedef mozilla::plugins::AsyncSurfaceDescriptor AsyncSurfaceDescriptor;
typedef mozilla::CrossProcessMutexHandle CrossProcessMutexHandle;
typedef mozilla::plugins::DXGISharedSurfaceHandle DXGISharedSurfaceHandle;
typedef mozilla::ipc::FileDescriptor FileDescriptor;
typedef mozilla::plugins::IOSurfaceDescriptor IOSurfaceDescriptor;
typedef mozilla::plugins::NPRemoteAsyncSurface NPRemoteAsyncSurface;
typedef mozilla::plugins::NativeWindowHandle NativeWindowHandle;
typedef mozilla::plugins::OptionalShmem OptionalShmem;
typedef mozilla::ipc::Shmem Shmem;
typedef mozilla::plugins::SurfaceDescriptor SurfaceDescriptor;
typedef mozilla::plugins::WindowsSharedMemoryHandle WindowsSharedMemoryHandle;
typedef mozilla::gfxSurfaceType gfxSurfaceType;
typedef mozilla::null_t null_t;
using mozilla::plugins::PPluginBackgroundDestroyerChild;
using mozilla::plugins::PPluginModuleChild;
using mozilla::plugins::PPluginScriptableObjectChild;
using mozilla::plugins::PBrowserStreamChild;
using mozilla::plugins::PPluginStreamChild;
using mozilla::plugins::PStreamNotifyChild;
using mozilla::plugins::PPluginSurfaceChild;

namespace mozilla {
namespace plugins {


bool
PPluginInstanceChild::Answer__delete__()
{
    return true;
}

bool
PPluginInstanceChild::RecvPPluginScriptableObjectConstructor(PPluginScriptableObjectChild* actor)
{
    return true;
}

bool
PPluginInstanceChild::AnswerPBrowserStreamConstructor(
        PBrowserStreamChild* actor,
        const nsCString& url,
        const uint32_t& length,
        const uint32_t& lastmodified,
        PStreamNotifyChild* notifyData,
        const nsCString& headers,
        const nsCString& mimeType,
        const bool& seekable,
        NPError* rv,
        uint16_t* stype)
{
    return true;
}

bool
PPluginInstanceChild::RecvPPluginBackgroundDestroyerConstructor(PPluginBackgroundDestroyerChild* actor)
{
    return true;
}

void
PPluginInstanceChild::ActorDestroy(ActorDestroyReason why)
{
}

PPluginInstanceChild::PPluginInstanceChild() :
    mId(0),
    mState(PPluginInstance::__Dead)
{
    MOZ_COUNT_CTOR(PPluginInstanceChild);
}

PPluginInstanceChild::~PPluginInstanceChild()
{
    MOZ_COUNT_DTOR(PPluginInstanceChild);
}

PPluginModuleChild*
PPluginInstanceChild::Manager() const
{
    return static_cast<PPluginModuleChild*>(mManager);
}

void
PPluginInstanceChild::ManagedPPluginBackgroundDestroyerChild(InfallibleTArray<PPluginBackgroundDestroyerChild*>& aArr) const
{
    aArr = mManagedPPluginBackgroundDestroyerChild;
}

const InfallibleTArray<PPluginBackgroundDestroyerChild*>&
PPluginInstanceChild::ManagedPPluginBackgroundDestroyerChild() const
{
    return mManagedPPluginBackgroundDestroyerChild;
}

void
PPluginInstanceChild::ManagedPPluginScriptableObjectChild(InfallibleTArray<PPluginScriptableObjectChild*>& aArr) const
{
    aArr = mManagedPPluginScriptableObjectChild;
}

const InfallibleTArray<PPluginScriptableObjectChild*>&
PPluginInstanceChild::ManagedPPluginScriptableObjectChild() const
{
    return mManagedPPluginScriptableObjectChild;
}

void
PPluginInstanceChild::ManagedPBrowserStreamChild(InfallibleTArray<PBrowserStreamChild*>& aArr) const
{
    aArr = mManagedPBrowserStreamChild;
}

const InfallibleTArray<PBrowserStreamChild*>&
PPluginInstanceChild::ManagedPBrowserStreamChild() const
{
    return mManagedPBrowserStreamChild;
}

void
PPluginInstanceChild::ManagedPPluginStreamChild(InfallibleTArray<PPluginStreamChild*>& aArr) const
{
    aArr = mManagedPPluginStreamChild;
}

const InfallibleTArray<PPluginStreamChild*>&
PPluginInstanceChild::ManagedPPluginStreamChild() const
{
    return mManagedPPluginStreamChild;
}

void
PPluginInstanceChild::ManagedPStreamNotifyChild(InfallibleTArray<PStreamNotifyChild*>& aArr) const
{
    aArr = mManagedPStreamNotifyChild;
}

const InfallibleTArray<PStreamNotifyChild*>&
PPluginInstanceChild::ManagedPStreamNotifyChild() const
{
    return mManagedPStreamNotifyChild;
}

void
PPluginInstanceChild::ManagedPPluginSurfaceChild(InfallibleTArray<PPluginSurfaceChild*>& aArr) const
{
    aArr = mManagedPPluginSurfaceChild;
}

const InfallibleTArray<PPluginSurfaceChild*>&
PPluginInstanceChild::ManagedPPluginSurfaceChild() const
{
    return mManagedPPluginSurfaceChild;
}

PPluginInstance::State
PPluginInstanceChild::state()
{
    return mState;
}

bool
PPluginInstanceChild::CallNPN_GetValue_NPNVWindowNPObject(
        PPluginScriptableObjectChild** value,
        NPError* result)
{
    PPluginInstance::Msg_NPN_GetValue_NPNVWindowNPObject* __msg = new PPluginInstance::Msg_NPN_GetValue_NPNVWindowNPObject();


    (__msg)->set_routing_id(mId);
    (__msg)->set_rpc();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginInstanceChild] Sending ", stderr);
    }
    if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Recv, PPluginInstance::Msg_NPN_GetValue_NPNVWindowNPObject__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Call(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PPluginInstance::Reply_NPN_GetValue_NPNVWindowNPObject*>((&(__reply))))->Log("[PPluginInstanceChild] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(value, (&(__reply)), (&(__iter)), true)))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read(result, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    (__reply).EndRead(__iter);

    return true;
}

bool
PPluginInstanceChild::CallNPN_GetValue_NPNVPluginElementNPObject(
        PPluginScriptableObjectChild** value,
        NPError* result)
{
    PPluginInstance::Msg_NPN_GetValue_NPNVPluginElementNPObject* __msg = new PPluginInstance::Msg_NPN_GetValue_NPNVPluginElementNPObject();


    (__msg)->set_routing_id(mId);
    (__msg)->set_rpc();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginInstanceChild] Sending ", stderr);
    }
    if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Recv, PPluginInstance::Msg_NPN_GetValue_NPNVPluginElementNPObject__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Call(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PPluginInstance::Reply_NPN_GetValue_NPNVPluginElementNPObject*>((&(__reply))))->Log("[PPluginInstanceChild] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(value, (&(__reply)), (&(__iter)), true)))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read(result, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    (__reply).EndRead(__iter);

    return true;
}

bool
PPluginInstanceChild::CallNPN_GetValue_NPNVprivateModeBool(
        bool* value,
        NPError* result)
{
    PPluginInstance::Msg_NPN_GetValue_NPNVprivateModeBool* __msg = new PPluginInstance::Msg_NPN_GetValue_NPNVprivateModeBool();


    (__msg)->set_routing_id(mId);
    (__msg)->set_rpc();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginInstanceChild] Sending ", stderr);
    }
    if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Recv, PPluginInstance::Msg_NPN_GetValue_NPNVprivateModeBool__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Call(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PPluginInstance::Reply_NPN_GetValue_NPNVprivateModeBool*>((&(__reply))))->Log("[PPluginInstanceChild] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(value, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read(result, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    (__reply).EndRead(__iter);

    return true;
}

bool
PPluginInstanceChild::CallNPN_GetValue_NPNVnetscapeWindow(
        NativeWindowHandle* value,
        NPError* result)
{
    PPluginInstance::Msg_NPN_GetValue_NPNVnetscapeWindow* __msg = new PPluginInstance::Msg_NPN_GetValue_NPNVnetscapeWindow();


    (__msg)->set_routing_id(mId);
    (__msg)->set_rpc();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginInstanceChild] Sending ", stderr);
    }
    if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Recv, PPluginInstance::Msg_NPN_GetValue_NPNVnetscapeWindow__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Call(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PPluginInstance::Reply_NPN_GetValue_NPNVnetscapeWindow*>((&(__reply))))->Log("[PPluginInstanceChild] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(value, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read(result, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    (__reply).EndRead(__iter);

    return true;
}

bool
PPluginInstanceChild::CallNPN_GetValue_NPNVdocumentOrigin(
        nsCString* value,
        NPError* result)
{
    PPluginInstance::Msg_NPN_GetValue_NPNVdocumentOrigin* __msg = new PPluginInstance::Msg_NPN_GetValue_NPNVdocumentOrigin();


    (__msg)->set_routing_id(mId);
    (__msg)->set_rpc();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginInstanceChild] Sending ", stderr);
    }
    if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Recv, PPluginInstance::Msg_NPN_GetValue_NPNVdocumentOrigin__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Call(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PPluginInstance::Reply_NPN_GetValue_NPNVdocumentOrigin*>((&(__reply))))->Log("[PPluginInstanceChild] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(value, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read(result, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    (__reply).EndRead(__iter);

    return true;
}

bool
PPluginInstanceChild::CallNPN_GetValue_DrawingModelSupport(
        const NPNVariable& model,
        bool* value)
{
    PPluginInstance::Msg_NPN_GetValue_DrawingModelSupport* __msg = new PPluginInstance::Msg_NPN_GetValue_DrawingModelSupport();

    Write(model, __msg);

    (__msg)->set_routing_id(mId);
    (__msg)->set_rpc();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginInstanceChild] Sending ", stderr);
    }
    if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Recv, PPluginInstance::Msg_NPN_GetValue_DrawingModelSupport__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Call(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PPluginInstance::Reply_NPN_GetValue_DrawingModelSupport*>((&(__reply))))->Log("[PPluginInstanceChild] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(value, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    (__reply).EndRead(__iter);

    return true;
}

bool
PPluginInstanceChild::CallNPN_SetValue_NPPVpluginWindow(
        const bool& windowed,
        NPError* result)
{
    PPluginInstance::Msg_NPN_SetValue_NPPVpluginWindow* __msg = new PPluginInstance::Msg_NPN_SetValue_NPPVpluginWindow();

    Write(windowed, __msg);

    (__msg)->set_routing_id(mId);
    (__msg)->set_rpc();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginInstanceChild] Sending ", stderr);
    }
    if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Recv, PPluginInstance::Msg_NPN_SetValue_NPPVpluginWindow__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Call(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PPluginInstance::Reply_NPN_SetValue_NPPVpluginWindow*>((&(__reply))))->Log("[PPluginInstanceChild] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(result, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    (__reply).EndRead(__iter);

    return true;
}

bool
PPluginInstanceChild::CallNPN_SetValue_NPPVpluginTransparent(
        const bool& transparent,
        NPError* result)
{
    PPluginInstance::Msg_NPN_SetValue_NPPVpluginTransparent* __msg = new PPluginInstance::Msg_NPN_SetValue_NPPVpluginTransparent();

    Write(transparent, __msg);

    (__msg)->set_routing_id(mId);
    (__msg)->set_rpc();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginInstanceChild] Sending ", stderr);
    }
    if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Recv, PPluginInstance::Msg_NPN_SetValue_NPPVpluginTransparent__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Call(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PPluginInstance::Reply_NPN_SetValue_NPPVpluginTransparent*>((&(__reply))))->Log("[PPluginInstanceChild] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(result, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    (__reply).EndRead(__iter);

    return true;
}

bool
PPluginInstanceChild::CallNPN_SetValue_NPPVpluginUsesDOMForCursor(
        const bool& useDOMForCursor,
        NPError* result)
{
    PPluginInstance::Msg_NPN_SetValue_NPPVpluginUsesDOMForCursor* __msg = new PPluginInstance::Msg_NPN_SetValue_NPPVpluginUsesDOMForCursor();

    Write(useDOMForCursor, __msg);

    (__msg)->set_routing_id(mId);
    (__msg)->set_rpc();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginInstanceChild] Sending ", stderr);
    }
    if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Recv, PPluginInstance::Msg_NPN_SetValue_NPPVpluginUsesDOMForCursor__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Call(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PPluginInstance::Reply_NPN_SetValue_NPPVpluginUsesDOMForCursor*>((&(__reply))))->Log("[PPluginInstanceChild] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(result, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    (__reply).EndRead(__iter);

    return true;
}

bool
PPluginInstanceChild::CallNPN_SetValue_NPPVpluginDrawingModel(
        const int& drawingModel,
        OptionalShmem* remoteImageData,
        CrossProcessMutexHandle* mutex,
        NPError* result)
{
    PPluginInstance::Msg_NPN_SetValue_NPPVpluginDrawingModel* __msg = new PPluginInstance::Msg_NPN_SetValue_NPPVpluginDrawingModel();

    Write(drawingModel, __msg);

    (__msg)->set_routing_id(mId);
    (__msg)->set_rpc();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginInstanceChild] Sending ", stderr);
    }
    if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Recv, PPluginInstance::Msg_NPN_SetValue_NPPVpluginDrawingModel__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Call(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PPluginInstance::Reply_NPN_SetValue_NPPVpluginDrawingModel*>((&(__reply))))->Log("[PPluginInstanceChild] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(remoteImageData, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read(mutex, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read(result, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    (__reply).EndRead(__iter);

    return true;
}

bool
PPluginInstanceChild::CallNPN_SetValue_NPPVpluginEventModel(
        const int& eventModel,
        NPError* result)
{
    PPluginInstance::Msg_NPN_SetValue_NPPVpluginEventModel* __msg = new PPluginInstance::Msg_NPN_SetValue_NPPVpluginEventModel();

    Write(eventModel, __msg);

    (__msg)->set_routing_id(mId);
    (__msg)->set_rpc();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginInstanceChild] Sending ", stderr);
    }
    if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Recv, PPluginInstance::Msg_NPN_SetValue_NPPVpluginEventModel__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Call(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PPluginInstance::Reply_NPN_SetValue_NPPVpluginEventModel*>((&(__reply))))->Log("[PPluginInstanceChild] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(result, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    (__reply).EndRead(__iter);

    return true;
}

bool
PPluginInstanceChild::CallNPN_GetURL(
        const nsCString& url,
        const nsCString& target,
        NPError* result)
{
    PPluginInstance::Msg_NPN_GetURL* __msg = new PPluginInstance::Msg_NPN_GetURL();

    Write(url, __msg);
    Write(target, __msg);

    (__msg)->set_routing_id(mId);
    (__msg)->set_rpc();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginInstanceChild] Sending ", stderr);
    }
    if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Recv, PPluginInstance::Msg_NPN_GetURL__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Call(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PPluginInstance::Reply_NPN_GetURL*>((&(__reply))))->Log("[PPluginInstanceChild] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(result, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    (__reply).EndRead(__iter);

    return true;
}

bool
PPluginInstanceChild::CallNPN_PostURL(
        const nsCString& url,
        const nsCString& target,
        const nsCString& buffer,
        const bool& file,
        NPError* result)
{
    PPluginInstance::Msg_NPN_PostURL* __msg = new PPluginInstance::Msg_NPN_PostURL();

    Write(url, __msg);
    Write(target, __msg);
    Write(buffer, __msg);
    Write(file, __msg);

    (__msg)->set_routing_id(mId);
    (__msg)->set_rpc();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginInstanceChild] Sending ", stderr);
    }
    if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Recv, PPluginInstance::Msg_NPN_PostURL__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Call(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PPluginInstance::Reply_NPN_PostURL*>((&(__reply))))->Log("[PPluginInstanceChild] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(result, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    (__reply).EndRead(__iter);

    return true;
}

PStreamNotifyChild*
PPluginInstanceChild::CallPStreamNotifyConstructor(
        const nsCString& url,
        const nsCString& target,
        const bool& post,
        const nsCString& buffer,
        const bool& file,
        NPError* result)
{
    return CallPStreamNotifyConstructor(AllocPStreamNotify(url, target, post, buffer, file, result), url, target, post, buffer, file, result);
}

PStreamNotifyChild*
PPluginInstanceChild::CallPStreamNotifyConstructor(
        PStreamNotifyChild* actor,
        const nsCString& url,
        const nsCString& target,
        const bool& post,
        const nsCString& buffer,
        const bool& file,
        NPError* result)
{
    if ((!(actor))) {
        return 0;
    }
    (actor)->mId = Register(actor);
    (actor)->mManager = this;
    (actor)->mChannel = mChannel;
    (mManagedPStreamNotifyChild).InsertElementSorted(actor);
    (actor)->mState = mozilla::plugins::PStreamNotify::__Start;

    PPluginInstance::Msg_PStreamNotifyConstructor* __msg = new PPluginInstance::Msg_PStreamNotifyConstructor();

    Write(actor, __msg, false);
    Write(url, __msg);
    Write(target, __msg);
    Write(post, __msg);
    Write(buffer, __msg);
    Write(file, __msg);

    (__msg)->set_routing_id(mId);
    (__msg)->set_rpc();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginInstanceChild] Sending ", stderr);
    }
    if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Recv, PPluginInstance::Msg_PStreamNotifyConstructor__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Call(__msg, (&(__reply)));
    if ((!(__sendok))) {
        (actor)->DestroySubtree(FailedConstructor);
        (actor)->DeallocSubtree();
        ((actor)->mManager)->RemoveManagee(PStreamNotifyMsgStart, actor);
        return 0;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PPluginInstance::Reply_PStreamNotifyConstructor*>((&(__reply))))->Log("[PPluginInstanceChild] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(result, (&(__reply)), (&(__iter)))))) {
        if (true) {
            (actor)->DestroySubtree(FailedConstructor);
            (actor)->DeallocSubtree();
            ((actor)->mManager)->RemoveManagee(PStreamNotifyMsgStart, actor);
            return 0;
        }
    }
    (__reply).EndRead(__iter);
    return actor;
}

bool
PPluginInstanceChild::SendNPN_InvalidateRect(const NPRect& rect)
{
    PPluginInstance::Msg_NPN_InvalidateRect* __msg = new PPluginInstance::Msg_NPN_InvalidateRect();

    Write(rect, __msg);

    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginInstanceChild] Sending ", stderr);
    }
    if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Recv, PPluginInstance::Msg_NPN_InvalidateRect__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

bool
PPluginInstanceChild::SendShow(
        const NPRect& updatedRect,
        const SurfaceDescriptor& newSurface,
        SurfaceDescriptor* prevSurface)
{
    PPluginInstance::Msg_Show* __msg = new PPluginInstance::Msg_Show();

    Write(updatedRect, __msg);
    Write(newSurface, __msg);

    (__msg)->set_routing_id(mId);
    (__msg)->set_sync();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginInstanceChild] Sending ", stderr);
    }
    if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Recv, PPluginInstance::Msg_Show__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PPluginInstance::Reply_Show*>((&(__reply))))->Log("[PPluginInstanceChild] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(prevSurface, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    (__reply).EndRead(__iter);

    return true;
}

PPluginSurfaceChild*
PPluginInstanceChild::SendPPluginSurfaceConstructor(
        const WindowsSharedMemoryHandle& handle,
        const gfxIntSize& size,
        const bool& transparent)
{
    return SendPPluginSurfaceConstructor(AllocPPluginSurface(handle, size, transparent), handle, size, transparent);
}

PPluginSurfaceChild*
PPluginInstanceChild::SendPPluginSurfaceConstructor(
        PPluginSurfaceChild* actor,
        const WindowsSharedMemoryHandle& handle,
        const gfxIntSize& size,
        const bool& transparent)
{
    if ((!(actor))) {
        return 0;
    }
    (actor)->mId = Register(actor);
    (actor)->mManager = this;
    (actor)->mChannel = mChannel;
    (mManagedPPluginSurfaceChild).InsertElementSorted(actor);
    (actor)->mState = mozilla::plugins::PPluginSurface::__Start;

    PPluginInstance::Msg_PPluginSurfaceConstructor* __msg = new PPluginInstance::Msg_PPluginSurfaceConstructor();

    Write(actor, __msg, false);
    Write(handle, __msg);
    Write(size, __msg);
    Write(transparent, __msg);

    (__msg)->set_routing_id(mId);


    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginInstanceChild] Sending ", stderr);
    }
    if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Recv, PPluginInstance::Msg_PPluginSurfaceConstructor__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    if ((!(__sendok))) {
        (actor)->DestroySubtree(FailedConstructor);
        (actor)->DeallocSubtree();
        ((actor)->mManager)->RemoveManagee(PPluginSurfaceMsgStart, actor);
        return 0;
    }
    return actor;
}

bool
PPluginInstanceChild::CallNPN_PushPopupsEnabledState(const bool& aState)
{
    PPluginInstance::Msg_NPN_PushPopupsEnabledState* __msg = new PPluginInstance::Msg_NPN_PushPopupsEnabledState();

    Write(aState, __msg);

    (__msg)->set_routing_id(mId);
    (__msg)->set_rpc();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginInstanceChild] Sending ", stderr);
    }
    if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Recv, PPluginInstance::Msg_NPN_PushPopupsEnabledState__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Call(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PPluginInstance::Reply_NPN_PushPopupsEnabledState*>((&(__reply))))->Log("[PPluginInstanceChild] Received reply ", stderr);
    }

    return true;
}

bool
PPluginInstanceChild::CallNPN_PopPopupsEnabledState()
{
    PPluginInstance::Msg_NPN_PopPopupsEnabledState* __msg = new PPluginInstance::Msg_NPN_PopPopupsEnabledState();


    (__msg)->set_routing_id(mId);
    (__msg)->set_rpc();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginInstanceChild] Sending ", stderr);
    }
    if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Recv, PPluginInstance::Msg_NPN_PopPopupsEnabledState__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Call(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PPluginInstance::Reply_NPN_PopPopupsEnabledState*>((&(__reply))))->Log("[PPluginInstanceChild] Received reply ", stderr);
    }

    return true;
}

bool
PPluginInstanceChild::CallNPN_GetValueForURL(
        const NPNURLVariable& variable,
        const nsCString& url,
        nsCString* value,
        NPError* result)
{
    PPluginInstance::Msg_NPN_GetValueForURL* __msg = new PPluginInstance::Msg_NPN_GetValueForURL();

    Write(variable, __msg);
    Write(url, __msg);

    (__msg)->set_routing_id(mId);
    (__msg)->set_rpc();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginInstanceChild] Sending ", stderr);
    }
    if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Recv, PPluginInstance::Msg_NPN_GetValueForURL__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Call(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PPluginInstance::Reply_NPN_GetValueForURL*>((&(__reply))))->Log("[PPluginInstanceChild] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(value, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read(result, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    (__reply).EndRead(__iter);

    return true;
}

bool
PPluginInstanceChild::CallNPN_SetValueForURL(
        const NPNURLVariable& variable,
        const nsCString& url,
        const nsCString& value,
        NPError* result)
{
    PPluginInstance::Msg_NPN_SetValueForURL* __msg = new PPluginInstance::Msg_NPN_SetValueForURL();

    Write(variable, __msg);
    Write(url, __msg);
    Write(value, __msg);

    (__msg)->set_routing_id(mId);
    (__msg)->set_rpc();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginInstanceChild] Sending ", stderr);
    }
    if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Recv, PPluginInstance::Msg_NPN_SetValueForURL__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Call(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PPluginInstance::Reply_NPN_SetValueForURL*>((&(__reply))))->Log("[PPluginInstanceChild] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(result, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    (__reply).EndRead(__iter);

    return true;
}

bool
PPluginInstanceChild::CallNPN_GetAuthenticationInfo(
        const nsCString& protocol_,
        const nsCString& host,
        const int32_t& port,
        const nsCString& scheme,
        const nsCString& realm,
        nsCString* username,
        nsCString* password,
        NPError* result)
{
    PPluginInstance::Msg_NPN_GetAuthenticationInfo* __msg = new PPluginInstance::Msg_NPN_GetAuthenticationInfo();

    Write(protocol_, __msg);
    Write(host, __msg);
    Write(port, __msg);
    Write(scheme, __msg);
    Write(realm, __msg);

    (__msg)->set_routing_id(mId);
    (__msg)->set_rpc();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginInstanceChild] Sending ", stderr);
    }
    if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Recv, PPluginInstance::Msg_NPN_GetAuthenticationInfo__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Call(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PPluginInstance::Reply_NPN_GetAuthenticationInfo*>((&(__reply))))->Log("[PPluginInstanceChild] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(username, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read(password, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read(result, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    (__reply).EndRead(__iter);

    return true;
}

bool
PPluginInstanceChild::CallNPN_ConvertPoint(
        const double& sourceX,
        const bool& ignoreDestX,
        const double& sourceY,
        const bool& ignoreDestY,
        const NPCoordinateSpace& sourceSpace,
        const NPCoordinateSpace& destSpace,
        double* destX,
        double* destY,
        bool* result)
{
    PPluginInstance::Msg_NPN_ConvertPoint* __msg = new PPluginInstance::Msg_NPN_ConvertPoint();

    Write(sourceX, __msg);
    Write(ignoreDestX, __msg);
    Write(sourceY, __msg);
    Write(ignoreDestY, __msg);
    Write(sourceSpace, __msg);
    Write(destSpace, __msg);

    (__msg)->set_routing_id(mId);
    (__msg)->set_rpc();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginInstanceChild] Sending ", stderr);
    }
    if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Recv, PPluginInstance::Msg_NPN_ConvertPoint__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Call(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PPluginInstance::Reply_NPN_ConvertPoint*>((&(__reply))))->Log("[PPluginInstanceChild] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(destX, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read(destY, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read(result, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    (__reply).EndRead(__iter);

    return true;
}

bool
PPluginInstanceChild::SendRedrawPlugin()
{
    PPluginInstance::Msg_RedrawPlugin* __msg = new PPluginInstance::Msg_RedrawPlugin();


    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginInstanceChild] Sending ", stderr);
    }
    if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Recv, PPluginInstance::Msg_RedrawPlugin__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

bool
PPluginInstanceChild::CallNPN_InitAsyncSurface(
        const gfxIntSize& size,
        const NPImageFormat& format,
        NPRemoteAsyncSurface* surfData,
        bool* result)
{
    PPluginInstance::Msg_NPN_InitAsyncSurface* __msg = new PPluginInstance::Msg_NPN_InitAsyncSurface();

    Write(size, __msg);
    Write(format, __msg);

    (__msg)->set_routing_id(mId);
    (__msg)->set_rpc();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginInstanceChild] Sending ", stderr);
    }
    if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Recv, PPluginInstance::Msg_NPN_InitAsyncSurface__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Call(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PPluginInstance::Reply_NPN_InitAsyncSurface*>((&(__reply))))->Log("[PPluginInstanceChild] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(surfData, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read(result, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    (__reply).EndRead(__iter);

    return true;
}

bool
PPluginInstanceChild::SendNegotiatedCarbon()
{
    PPluginInstance::Msg_NegotiatedCarbon* __msg = new PPluginInstance::Msg_NegotiatedCarbon();


    (__msg)->set_routing_id(mId);
    (__msg)->set_sync();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginInstanceChild] Sending ", stderr);
    }
    if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Recv, PPluginInstance::Msg_NegotiatedCarbon__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PPluginInstance::Reply_NegotiatedCarbon*>((&(__reply))))->Log("[PPluginInstanceChild] Received reply ", stderr);
    }

    return true;
}

bool
PPluginInstanceChild::SendReleaseDXGISharedSurface(const DXGISharedSurfaceHandle& handle)
{
    PPluginInstance::Msg_ReleaseDXGISharedSurface* __msg = new PPluginInstance::Msg_ReleaseDXGISharedSurface();

    Write(handle, __msg);

    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginInstanceChild] Sending ", stderr);
    }
    if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Recv, PPluginInstance::Msg_ReleaseDXGISharedSurface__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

PPluginScriptableObjectChild*
PPluginInstanceChild::SendPPluginScriptableObjectConstructor()
{
    return SendPPluginScriptableObjectConstructor(AllocPPluginScriptableObject());
}

PPluginScriptableObjectChild*
PPluginInstanceChild::SendPPluginScriptableObjectConstructor(PPluginScriptableObjectChild* actor)
{
    if ((!(actor))) {
        return 0;
    }
    (actor)->mId = Register(actor);
    (actor)->mManager = this;
    (actor)->mChannel = mChannel;
    (mManagedPPluginScriptableObjectChild).InsertElementSorted(actor);
    (actor)->mState = mozilla::plugins::PPluginScriptableObject::__Start;

    PPluginInstance::Msg_PPluginScriptableObjectConstructor* __msg = new PPluginInstance::Msg_PPluginScriptableObjectConstructor();

    Write(actor, __msg, false);

    (__msg)->set_routing_id(mId);


    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginInstanceChild] Sending ", stderr);
    }
    if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Recv, PPluginInstance::Msg_PPluginScriptableObjectConstructor__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    if ((!(__sendok))) {
        (actor)->DestroySubtree(FailedConstructor);
        (actor)->DeallocSubtree();
        ((actor)->mManager)->RemoveManagee(PPluginScriptableObjectMsgStart, actor);
        return 0;
    }
    return actor;
}

PPluginStreamChild*
PPluginInstanceChild::CallPPluginStreamConstructor(
        const nsCString& mimeType,
        const nsCString& target,
        NPError* result)
{
    return CallPPluginStreamConstructor(AllocPPluginStream(mimeType, target, result), mimeType, target, result);
}

PPluginStreamChild*
PPluginInstanceChild::CallPPluginStreamConstructor(
        PPluginStreamChild* actor,
        const nsCString& mimeType,
        const nsCString& target,
        NPError* result)
{
    if ((!(actor))) {
        return 0;
    }
    (actor)->mId = Register(actor);
    (actor)->mManager = this;
    (actor)->mChannel = mChannel;
    (mManagedPPluginStreamChild).InsertElementSorted(actor);
    (actor)->mState = mozilla::plugins::PPluginStream::__Start;

    PPluginInstance::Msg_PPluginStreamConstructor* __msg = new PPluginInstance::Msg_PPluginStreamConstructor();

    Write(actor, __msg, false);
    Write(mimeType, __msg);
    Write(target, __msg);

    (__msg)->set_routing_id(mId);
    (__msg)->set_rpc();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginInstanceChild] Sending ", stderr);
    }
    if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Recv, PPluginInstance::Msg_PPluginStreamConstructor__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Call(__msg, (&(__reply)));
    if ((!(__sendok))) {
        (actor)->DestroySubtree(FailedConstructor);
        (actor)->DeallocSubtree();
        ((actor)->mManager)->RemoveManagee(PPluginStreamMsgStart, actor);
        return 0;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PPluginInstance::Reply_PPluginStreamConstructor*>((&(__reply))))->Log("[PPluginInstanceChild] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(result, (&(__reply)), (&(__iter)))))) {
        if (true) {
            (actor)->DestroySubtree(FailedConstructor);
            (actor)->DeallocSubtree();
            ((actor)->mManager)->RemoveManagee(PPluginStreamMsgStart, actor);
            return 0;
        }
    }
    (__reply).EndRead(__iter);
    return actor;
}

bool
PPluginInstanceChild::CallPluginFocusChange(const bool& gotFocus)
{
    PPluginInstance::Msg_PluginFocusChange* __msg = new PPluginInstance::Msg_PluginFocusChange();

    Write(gotFocus, __msg);

    (__msg)->set_routing_id(mId);
    (__msg)->set_rpc();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginInstanceChild] Sending ", stderr);
    }
    if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Recv, PPluginInstance::Msg_PluginFocusChange__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Call(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PPluginInstance::Reply_PluginFocusChange*>((&(__reply))))->Log("[PPluginInstanceChild] Received reply ", stderr);
    }

    return true;
}

int32_t
PPluginInstanceChild::Register(ChannelListener* aRouted)
{
    return (mManager)->Register(aRouted);
}

int32_t
PPluginInstanceChild::RegisterID(
        ChannelListener* aRouted,
        int32_t aId)
{
    return (mManager)->RegisterID(aRouted, aId);
}

ChannelListener*
PPluginInstanceChild::Lookup(int32_t aId)
{
    return (mManager)->Lookup(aId);
}

void
PPluginInstanceChild::Unregister(int32_t aId)
{
    return (mManager)->Unregister(aId);
}

void
PPluginInstanceChild::RemoveManagee(
        int32_t aProtocolId,
        ChannelListener* aListener)
{
    switch (aProtocolId) {
    case PPluginBackgroundDestroyerMsgStart:
        {
            PPluginBackgroundDestroyerChild* actor = static_cast<PPluginBackgroundDestroyerChild*>(aListener);
            NS_ABORT_IF_FALSE(((mManagedPPluginBackgroundDestroyerChild).NoIndex) != ((mManagedPPluginBackgroundDestroyerChild).BinaryIndexOf(actor)), "actor not managed by this!");

            (mManagedPPluginBackgroundDestroyerChild).RemoveElementSorted(actor);
            DeallocPPluginBackgroundDestroyer(actor);
            return;
        }
    case PPluginScriptableObjectMsgStart:
        {
            PPluginScriptableObjectChild* actor = static_cast<PPluginScriptableObjectChild*>(aListener);
            NS_ABORT_IF_FALSE(((mManagedPPluginScriptableObjectChild).NoIndex) != ((mManagedPPluginScriptableObjectChild).BinaryIndexOf(actor)), "actor not managed by this!");

            (mManagedPPluginScriptableObjectChild).RemoveElementSorted(actor);
            DeallocPPluginScriptableObject(actor);
            return;
        }
    case PBrowserStreamMsgStart:
        {
            PBrowserStreamChild* actor = static_cast<PBrowserStreamChild*>(aListener);
            NS_ABORT_IF_FALSE(((mManagedPBrowserStreamChild).NoIndex) != ((mManagedPBrowserStreamChild).BinaryIndexOf(actor)), "actor not managed by this!");

            (mManagedPBrowserStreamChild).RemoveElementSorted(actor);
            DeallocPBrowserStream(actor);
            return;
        }
    case PPluginStreamMsgStart:
        {
            PPluginStreamChild* actor = static_cast<PPluginStreamChild*>(aListener);
            NS_ABORT_IF_FALSE(((mManagedPPluginStreamChild).NoIndex) != ((mManagedPPluginStreamChild).BinaryIndexOf(actor)), "actor not managed by this!");

            (mManagedPPluginStreamChild).RemoveElementSorted(actor);
            DeallocPPluginStream(actor);
            return;
        }
    case PStreamNotifyMsgStart:
        {
            PStreamNotifyChild* actor = static_cast<PStreamNotifyChild*>(aListener);
            NS_ABORT_IF_FALSE(((mManagedPStreamNotifyChild).NoIndex) != ((mManagedPStreamNotifyChild).BinaryIndexOf(actor)), "actor not managed by this!");

            (mManagedPStreamNotifyChild).RemoveElementSorted(actor);
            DeallocPStreamNotify(actor);
            return;
        }
    case PPluginSurfaceMsgStart:
        {
            PPluginSurfaceChild* actor = static_cast<PPluginSurfaceChild*>(aListener);
            NS_ABORT_IF_FALSE(((mManagedPPluginSurfaceChild).NoIndex) != ((mManagedPPluginSurfaceChild).BinaryIndexOf(actor)), "actor not managed by this!");

            (mManagedPPluginSurfaceChild).RemoveElementSorted(actor);
            DeallocPPluginSurface(actor);
            return;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return;
        }
    }
}

Shmem::SharedMemory*
PPluginInstanceChild::CreateSharedMemory(
        size_t aSize,
        Shmem::SharedMemory::SharedMemoryType aType,
        bool aUnsafe,
        Shmem::id_t* aId)
{
    return (mManager)->CreateSharedMemory(aSize, aType, aUnsafe, aId);
}

bool
PPluginInstanceChild::AdoptSharedMemory(
        Shmem::SharedMemory* segment,
        Shmem::id_t* aId)
{
    return (mManager)->AdoptSharedMemory(segment, aId);
}

Shmem::SharedMemory*
PPluginInstanceChild::LookupSharedMemory(Shmem::id_t aId)
{
    return (mManager)->LookupSharedMemory(aId);
}

bool
PPluginInstanceChild::IsTrackingSharedMemory(Shmem::SharedMemory* segment)
{
    return (mManager)->IsTrackingSharedMemory(segment);
}

bool
PPluginInstanceChild::DestroySharedMemory(Shmem& shmem)
{
    return (mManager)->DestroySharedMemory(shmem);
}

ProcessHandle
PPluginInstanceChild::OtherProcess() const
{
    return (mManager)->OtherProcess();
}

AsyncChannel*
PPluginInstanceChild::GetIPCChannel()
{
    return mChannel;
}

PPluginInstanceChild::Result
PPluginInstanceChild::OnMessageReceived(const Message& __msg)
{
    if (((mState) == (PPluginInstance::__Dying)) && ((((__msg).is_reply()) != (true)) || (((__msg).is_rpc()) != (true)))) {
        FatalError("incoming message racing with actor deletion");
        return MsgProcessed;
    }
    switch ((__msg).type()) {
    case PPluginInstance::Msg_WindowPosChanged__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginInstance::Msg_WindowPosChanged");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Msg_WindowPosChanged*>((&(__msg))))->Log("[PPluginInstanceChild] Received ", stderr);
            }

            void* __iter = 0;
            NPRemoteEvent event;

            if ((!(Read((&(event)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Send, PPluginInstance::Msg_WindowPosChanged__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvWindowPosChanged(event)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for WindowPosChanged returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PPluginInstance::Msg_ContentsScaleFactorChanged__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginInstance::Msg_ContentsScaleFactorChanged");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Msg_ContentsScaleFactorChanged*>((&(__msg))))->Log("[PPluginInstanceChild] Received ", stderr);
            }

            void* __iter = 0;
            double aContentsScaleFactor;

            if ((!(Read((&(aContentsScaleFactor)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Send, PPluginInstance::Msg_ContentsScaleFactorChanged__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvContentsScaleFactorChanged(aContentsScaleFactor)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for ContentsScaleFactorChanged returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PPluginInstance::Msg_AsyncSetWindow__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginInstance::Msg_AsyncSetWindow");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Msg_AsyncSetWindow*>((&(__msg))))->Log("[PPluginInstanceChild] Received ", stderr);
            }

            void* __iter = 0;
            gfxSurfaceType surfaceType;
            NPRemoteWindow window;

            if ((!(Read((&(surfaceType)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(window)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Send, PPluginInstance::Msg_AsyncSetWindow__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvAsyncSetWindow(surfaceType, window)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for AsyncSetWindow returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PPluginInstance::Msg_UpdateBackground__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginInstance::Msg_UpdateBackground");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Msg_UpdateBackground*>((&(__msg))))->Log("[PPluginInstanceChild] Received ", stderr);
            }

            void* __iter = 0;
            SurfaceDescriptor background;
            nsIntRect rect;

            if ((!(Read((&(background)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(rect)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Send, PPluginInstance::Msg_UpdateBackground__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvUpdateBackground(background, rect)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for UpdateBackground returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PPluginInstance::Msg_NPP_DidComposite__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginInstance::Msg_NPP_DidComposite");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Msg_NPP_DidComposite*>((&(__msg))))->Log("[PPluginInstanceChild] Received ", stderr);
            }

            if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Send, PPluginInstance::Msg_NPP_DidComposite__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvNPP_DidComposite()))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for NPP_DidComposite returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PPluginInstance::Reply_PPluginSurfaceConstructor__ID:
        {
            return MsgProcessed;
        }
    case PPluginInstance::Reply_PPluginScriptableObjectConstructor__ID:
        {
            return MsgProcessed;
        }
    case PPluginInstance::Msg_PPluginScriptableObjectConstructor__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginInstance::Msg_PPluginScriptableObjectConstructor");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Msg_PPluginScriptableObjectConstructor*>((&(__msg))))->Log("[PPluginInstanceChild] Received ", stderr);
            }

            void* __iter = 0;
            ActorHandle __handle;
            PPluginScriptableObjectChild* actor;

            if ((!(Read((&(__handle)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Send, PPluginInstance::Msg_PPluginScriptableObjectConstructor__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            actor = AllocPPluginScriptableObject();
            if ((!(actor))) {
                return MsgValueError;
            }
            (actor)->mId = RegisterID(actor, (__handle).mId);
            (actor)->mManager = this;
            (actor)->mChannel = mChannel;
            (mManagedPPluginScriptableObjectChild).InsertElementSorted(actor);
            (actor)->mState = mozilla::plugins::PPluginScriptableObject::__Start;

            if ((!(RecvPPluginScriptableObjectConstructor(actor)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for PPluginScriptableObject returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PPluginInstance::Msg_PPluginBackgroundDestroyerConstructor__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginInstance::Msg_PPluginBackgroundDestroyerConstructor");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Msg_PPluginBackgroundDestroyerConstructor*>((&(__msg))))->Log("[PPluginInstanceChild] Received ", stderr);
            }

            void* __iter = 0;
            ActorHandle __handle;
            PPluginBackgroundDestroyerChild* actor;

            if ((!(Read((&(__handle)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Send, PPluginInstance::Msg_PPluginBackgroundDestroyerConstructor__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            actor = AllocPPluginBackgroundDestroyer();
            if ((!(actor))) {
                return MsgValueError;
            }
            (actor)->mId = RegisterID(actor, (__handle).mId);
            (actor)->mManager = this;
            (actor)->mChannel = mChannel;
            (mManagedPPluginBackgroundDestroyerChild).InsertElementSorted(actor);
            (actor)->mState = mozilla::plugins::PPluginBackgroundDestroyer::__Start;

            if ((!(RecvPPluginBackgroundDestroyerConstructor(actor)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for PPluginBackgroundDestroyer returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    default:
        {
            return MsgNotKnown;
        }
    }
}

PPluginInstanceChild::Result
PPluginInstanceChild::OnMessageReceived(
        const Message& __msg,
        Message*& __reply)
{
    if (((mState) == (PPluginInstance::__Dying)) && ((((__msg).is_reply()) != (true)) || (((__msg).is_rpc()) != (true)))) {
        FatalError("incoming message racing with actor deletion");
        return MsgProcessed;
    }
    return MsgNotKnown;
}

PPluginInstanceChild::Result
PPluginInstanceChild::OnCallReceived(
        const Message& __msg,
        Message*& __reply)
{
    if (((mState) == (PPluginInstance::__Dying)) && ((((__msg).is_reply()) != (true)) || (((__msg).is_rpc()) != (true)))) {
        FatalError("incoming message racing with actor deletion");
        return MsgProcessed;
    }
    switch ((__msg).type()) {
    case PPluginInstance::Msg___delete____ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginInstance::Msg___delete__");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Msg___delete__*>((&(__msg))))->Log("[PPluginInstanceChild] Received ", stderr);
            }

            void* __iter = 0;
            PPluginInstanceChild* actor;

            if ((!(Read((&(actor)), (&(__msg)), (&(__iter)), false)))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Send, PPluginInstance::Msg___delete____ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(Answer__delete__()))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for __delete__ returned error code");
                return MsgProcessingError;
            }

            int32_t __id = mId;
            (actor)->DestroySubtree(Deletion);
            (actor)->DeallocSubtree();
            ((actor)->mManager)->RemoveManagee(PPluginInstanceMsgStart, actor);

            __reply = new PPluginInstance::Reply___delete__();

            (__reply)->set_routing_id(__id);
            (__reply)->set_rpc();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Reply___delete__*>(__reply))->Log("[PPluginInstanceChild] Sending reply ", stderr);
            }

            return MsgProcessed;
        }
    case PPluginInstance::Msg_NPP_SetWindow__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginInstance::Msg_NPP_SetWindow");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Msg_NPP_SetWindow*>((&(__msg))))->Log("[PPluginInstanceChild] Received ", stderr);
            }

            void* __iter = 0;
            NPRemoteWindow window;

            if ((!(Read((&(window)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Send, PPluginInstance::Msg_NPP_SetWindow__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            int32_t __id = mId;
            if ((!(AnswerNPP_SetWindow(window)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for NPP_SetWindow returned error code");
                return MsgProcessingError;
            }

            __reply = new PPluginInstance::Reply_NPP_SetWindow();

            (__reply)->set_routing_id(__id);
            (__reply)->set_rpc();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Reply_NPP_SetWindow*>(__reply))->Log("[PPluginInstanceChild] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    case PPluginInstance::Msg_NPP_GetValue_NPPVpluginWantsAllNetworkStreams__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginInstance::Msg_NPP_GetValue_NPPVpluginWantsAllNetworkStreams");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Msg_NPP_GetValue_NPPVpluginWantsAllNetworkStreams*>((&(__msg))))->Log("[PPluginInstanceChild] Received ", stderr);
            }

            if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Send, PPluginInstance::Msg_NPP_GetValue_NPPVpluginWantsAllNetworkStreams__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            bool value;
            NPError result;
            int32_t __id = mId;
            if ((!(AnswerNPP_GetValue_NPPVpluginWantsAllNetworkStreams((&(value)), (&(result)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for NPP_GetValue_NPPVpluginWantsAllNetworkStreams returned error code");
                return MsgProcessingError;
            }

            __reply = new PPluginInstance::Reply_NPP_GetValue_NPPVpluginWantsAllNetworkStreams();

            Write(value, __reply);
            Write(result, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_rpc();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Reply_NPP_GetValue_NPPVpluginWantsAllNetworkStreams*>(__reply))->Log("[PPluginInstanceChild] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    case PPluginInstance::Msg_NPP_GetValue_NPPVpluginNeedsXEmbed__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginInstance::Msg_NPP_GetValue_NPPVpluginNeedsXEmbed");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Msg_NPP_GetValue_NPPVpluginNeedsXEmbed*>((&(__msg))))->Log("[PPluginInstanceChild] Received ", stderr);
            }

            if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Send, PPluginInstance::Msg_NPP_GetValue_NPPVpluginNeedsXEmbed__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            bool value;
            NPError result;
            int32_t __id = mId;
            if ((!(AnswerNPP_GetValue_NPPVpluginNeedsXEmbed((&(value)), (&(result)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for NPP_GetValue_NPPVpluginNeedsXEmbed returned error code");
                return MsgProcessingError;
            }

            __reply = new PPluginInstance::Reply_NPP_GetValue_NPPVpluginNeedsXEmbed();

            Write(value, __reply);
            Write(result, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_rpc();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Reply_NPP_GetValue_NPPVpluginNeedsXEmbed*>(__reply))->Log("[PPluginInstanceChild] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    case PPluginInstance::Msg_NPP_GetValue_NPPVpluginScriptableNPObject__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginInstance::Msg_NPP_GetValue_NPPVpluginScriptableNPObject");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Msg_NPP_GetValue_NPPVpluginScriptableNPObject*>((&(__msg))))->Log("[PPluginInstanceChild] Received ", stderr);
            }

            if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Send, PPluginInstance::Msg_NPP_GetValue_NPPVpluginScriptableNPObject__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            PPluginScriptableObjectChild* value;
            NPError result;
            int32_t __id = mId;
            if ((!(AnswerNPP_GetValue_NPPVpluginScriptableNPObject((&(value)), (&(result)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for NPP_GetValue_NPPVpluginScriptableNPObject returned error code");
                return MsgProcessingError;
            }

            __reply = new PPluginInstance::Reply_NPP_GetValue_NPPVpluginScriptableNPObject();

            Write(value, __reply, true);
            Write(result, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_rpc();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Reply_NPP_GetValue_NPPVpluginScriptableNPObject*>(__reply))->Log("[PPluginInstanceChild] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    case PPluginInstance::Msg_NPP_SetValue_NPNVprivateModeBool__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginInstance::Msg_NPP_SetValue_NPNVprivateModeBool");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Msg_NPP_SetValue_NPNVprivateModeBool*>((&(__msg))))->Log("[PPluginInstanceChild] Received ", stderr);
            }

            void* __iter = 0;
            bool value;

            if ((!(Read((&(value)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Send, PPluginInstance::Msg_NPP_SetValue_NPNVprivateModeBool__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            NPError result;
            int32_t __id = mId;
            if ((!(AnswerNPP_SetValue_NPNVprivateModeBool(value, (&(result)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for NPP_SetValue_NPNVprivateModeBool returned error code");
                return MsgProcessingError;
            }

            __reply = new PPluginInstance::Reply_NPP_SetValue_NPNVprivateModeBool();

            Write(result, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_rpc();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Reply_NPP_SetValue_NPNVprivateModeBool*>(__reply))->Log("[PPluginInstanceChild] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    case PPluginInstance::Msg_NPP_GetValue_NPPVpluginNativeAccessibleAtkPlugId__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginInstance::Msg_NPP_GetValue_NPPVpluginNativeAccessibleAtkPlugId");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Msg_NPP_GetValue_NPPVpluginNativeAccessibleAtkPlugId*>((&(__msg))))->Log("[PPluginInstanceChild] Received ", stderr);
            }

            if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Send, PPluginInstance::Msg_NPP_GetValue_NPPVpluginNativeAccessibleAtkPlugId__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            nsCString plug_id;
            NPError result;
            int32_t __id = mId;
            if ((!(AnswerNPP_GetValue_NPPVpluginNativeAccessibleAtkPlugId((&(plug_id)), (&(result)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for NPP_GetValue_NPPVpluginNativeAccessibleAtkPlugId returned error code");
                return MsgProcessingError;
            }

            __reply = new PPluginInstance::Reply_NPP_GetValue_NPPVpluginNativeAccessibleAtkPlugId();

            Write(plug_id, __reply);
            Write(result, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_rpc();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Reply_NPP_GetValue_NPPVpluginNativeAccessibleAtkPlugId*>(__reply))->Log("[PPluginInstanceChild] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    case PPluginInstance::Msg_NPP_HandleEvent__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginInstance::Msg_NPP_HandleEvent");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Msg_NPP_HandleEvent*>((&(__msg))))->Log("[PPluginInstanceChild] Received ", stderr);
            }

            void* __iter = 0;
            NPRemoteEvent event;

            if ((!(Read((&(event)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Send, PPluginInstance::Msg_NPP_HandleEvent__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            int16_t handled;
            int32_t __id = mId;
            if ((!(AnswerNPP_HandleEvent(event, (&(handled)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for NPP_HandleEvent returned error code");
                return MsgProcessingError;
            }

            __reply = new PPluginInstance::Reply_NPP_HandleEvent();

            Write(handled, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_rpc();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Reply_NPP_HandleEvent*>(__reply))->Log("[PPluginInstanceChild] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    case PPluginInstance::Msg_NPP_HandleEvent_Shmem__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginInstance::Msg_NPP_HandleEvent_Shmem");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Msg_NPP_HandleEvent_Shmem*>((&(__msg))))->Log("[PPluginInstanceChild] Received ", stderr);
            }

            void* __iter = 0;
            NPRemoteEvent event;
            Shmem buffer;

            if ((!(Read((&(event)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(buffer)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Send, PPluginInstance::Msg_NPP_HandleEvent_Shmem__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            int16_t handled;
            Shmem rtnbuffer;
            int32_t __id = mId;
            if ((!(AnswerNPP_HandleEvent_Shmem(event, buffer, (&(handled)), (&(rtnbuffer)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for NPP_HandleEvent_Shmem returned error code");
                return MsgProcessingError;
            }

            __reply = new PPluginInstance::Reply_NPP_HandleEvent_Shmem();

            Write(handled, __reply);
            Write(rtnbuffer, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_rpc();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Reply_NPP_HandleEvent_Shmem*>(__reply))->Log("[PPluginInstanceChild] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    case PPluginInstance::Msg_NPP_HandleEvent_IOSurface__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginInstance::Msg_NPP_HandleEvent_IOSurface");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Msg_NPP_HandleEvent_IOSurface*>((&(__msg))))->Log("[PPluginInstanceChild] Received ", stderr);
            }

            void* __iter = 0;
            NPRemoteEvent event;
            uint32_t surfaceid;

            if ((!(Read((&(event)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(surfaceid)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Send, PPluginInstance::Msg_NPP_HandleEvent_IOSurface__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            int16_t handled;
            int32_t __id = mId;
            if ((!(AnswerNPP_HandleEvent_IOSurface(event, surfaceid, (&(handled)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for NPP_HandleEvent_IOSurface returned error code");
                return MsgProcessingError;
            }

            __reply = new PPluginInstance::Reply_NPP_HandleEvent_IOSurface();

            Write(handled, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_rpc();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Reply_NPP_HandleEvent_IOSurface*>(__reply))->Log("[PPluginInstanceChild] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    case PPluginInstance::Msg_Paint__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginInstance::Msg_Paint");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Msg_Paint*>((&(__msg))))->Log("[PPluginInstanceChild] Received ", stderr);
            }

            void* __iter = 0;
            NPRemoteEvent event;

            if ((!(Read((&(event)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Send, PPluginInstance::Msg_Paint__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            int16_t handled;
            int32_t __id = mId;
            if ((!(AnswerPaint(event, (&(handled)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for Paint returned error code");
                return MsgProcessingError;
            }

            __reply = new PPluginInstance::Reply_Paint();

            Write(handled, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_rpc();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Reply_Paint*>(__reply))->Log("[PPluginInstanceChild] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    case PPluginInstance::Msg_HandleTextEvent__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginInstance::Msg_HandleTextEvent");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Msg_HandleTextEvent*>((&(__msg))))->Log("[PPluginInstanceChild] Received ", stderr);
            }

            void* __iter = 0;
            nsTextEvent event;

            if ((!(Read((&(event)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Send, PPluginInstance::Msg_HandleTextEvent__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            bool handled;
            int32_t __id = mId;
            if ((!(AnswerHandleTextEvent(event, (&(handled)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for HandleTextEvent returned error code");
                return MsgProcessingError;
            }

            __reply = new PPluginInstance::Reply_HandleTextEvent();

            Write(handled, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_rpc();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Reply_HandleTextEvent*>(__reply))->Log("[PPluginInstanceChild] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    case PPluginInstance::Msg_HandleKeyEvent__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginInstance::Msg_HandleKeyEvent");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Msg_HandleKeyEvent*>((&(__msg))))->Log("[PPluginInstanceChild] Received ", stderr);
            }

            void* __iter = 0;
            nsKeyEvent event;

            if ((!(Read((&(event)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Send, PPluginInstance::Msg_HandleKeyEvent__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            bool handled;
            int32_t __id = mId;
            if ((!(AnswerHandleKeyEvent(event, (&(handled)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for HandleKeyEvent returned error code");
                return MsgProcessingError;
            }

            __reply = new PPluginInstance::Reply_HandleKeyEvent();

            Write(handled, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_rpc();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Reply_HandleKeyEvent*>(__reply))->Log("[PPluginInstanceChild] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    case PPluginInstance::Msg_NPP_Destroy__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginInstance::Msg_NPP_Destroy");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Msg_NPP_Destroy*>((&(__msg))))->Log("[PPluginInstanceChild] Received ", stderr);
            }

            if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Send, PPluginInstance::Msg_NPP_Destroy__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            NPError rv;
            int32_t __id = mId;
            if ((!(AnswerNPP_Destroy((&(rv)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for NPP_Destroy returned error code");
                return MsgProcessingError;
            }

            __reply = new PPluginInstance::Reply_NPP_Destroy();

            Write(rv, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_rpc();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Reply_NPP_Destroy*>(__reply))->Log("[PPluginInstanceChild] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    case PPluginInstance::Msg_PBrowserStreamConstructor__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginInstance::Msg_PBrowserStreamConstructor");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Msg_PBrowserStreamConstructor*>((&(__msg))))->Log("[PPluginInstanceChild] Received ", stderr);
            }

            void* __iter = 0;
            ActorHandle __handle;
            PBrowserStreamChild* actor;
            nsCString url;
            uint32_t length;
            uint32_t lastmodified;
            PStreamNotifyChild* notifyData;
            nsCString headers;
            nsCString mimeType;
            bool seekable;

            if ((!(Read((&(__handle)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(url)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(length)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(lastmodified)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(notifyData)), (&(__msg)), (&(__iter)), true)))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(headers)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(mimeType)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(seekable)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Send, PPluginInstance::Msg_PBrowserStreamConstructor__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            NPError rv;
            uint16_t stype;
            actor = AllocPBrowserStream(url, length, lastmodified, notifyData, headers, mimeType, seekable, (&(rv)), (&(stype)));
            if ((!(actor))) {
                return MsgValueError;
            }
            (actor)->mId = RegisterID(actor, (__handle).mId);
            (actor)->mManager = this;
            (actor)->mChannel = mChannel;
            (mManagedPBrowserStreamChild).InsertElementSorted(actor);
            (actor)->mState = mozilla::plugins::PBrowserStream::__Start;

            int32_t __id = mId;
            if ((!(AnswerPBrowserStreamConstructor(actor, url, length, lastmodified, notifyData, headers, mimeType, seekable, (&(rv)), (&(stype)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for PBrowserStream returned error code");
                return MsgProcessingError;
            }
            __reply = new PPluginInstance::Reply_PBrowserStreamConstructor();

            Write(rv, __reply);
            Write(stype, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_rpc();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Reply_PBrowserStreamConstructor*>(__reply))->Log("[PPluginInstanceChild] Sending reply ", stderr);
            }

            return MsgProcessed;
        }
    case PPluginInstance::Msg_SetPluginFocus__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginInstance::Msg_SetPluginFocus");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Msg_SetPluginFocus*>((&(__msg))))->Log("[PPluginInstanceChild] Received ", stderr);
            }

            if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Send, PPluginInstance::Msg_SetPluginFocus__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            int32_t __id = mId;
            if ((!(AnswerSetPluginFocus()))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for SetPluginFocus returned error code");
                return MsgProcessingError;
            }

            __reply = new PPluginInstance::Reply_SetPluginFocus();

            (__reply)->set_routing_id(__id);
            (__reply)->set_rpc();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Reply_SetPluginFocus*>(__reply))->Log("[PPluginInstanceChild] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    case PPluginInstance::Msg_UpdateWindow__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginInstance::Msg_UpdateWindow");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Msg_UpdateWindow*>((&(__msg))))->Log("[PPluginInstanceChild] Received ", stderr);
            }

            if ((!(PPluginInstance::Transition(mState, Trigger(Trigger::Send, PPluginInstance::Msg_UpdateWindow__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            int32_t __id = mId;
            if ((!(AnswerUpdateWindow()))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for UpdateWindow returned error code");
                return MsgProcessingError;
            }

            __reply = new PPluginInstance::Reply_UpdateWindow();

            (__reply)->set_routing_id(__id);
            (__reply)->set_rpc();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginInstance::Reply_UpdateWindow*>(__reply))->Log("[PPluginInstanceChild] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    default:
        {
            return MsgNotKnown;
        }
    }
}

void
PPluginInstanceChild::OnProcessingError(Result code)
{
    NS_RUNTIMEABORT("`OnProcessingError' called on non-toplevel actor");
}

int32_t
PPluginInstanceChild::GetProtocolTypeId()
{
    return PPluginInstanceMsgStart;
}

bool
PPluginInstanceChild::OnReplyTimeout()
{
    NS_RUNTIMEABORT("`OnReplyTimeout' called on non-toplevel actor");
    return false;
}

void
PPluginInstanceChild::OnChannelClose()
{
    NS_RUNTIMEABORT("`OnClose' called on non-toplevel actor");
}

void
PPluginInstanceChild::OnChannelError()
{
    NS_RUNTIMEABORT("`OnError' called on non-toplevel actor");
}

void
PPluginInstanceChild::OnChannelConnected(int32_t pid)
{
    NS_RUNTIMEABORT("'OnConnected' called on non-toplevel actor");
}

bool
PPluginInstanceChild::AllocShmem(
        size_t aSize,
        Shmem::SharedMemory::SharedMemoryType aType,
        Shmem* aMem)
{
    Shmem::id_t aId;
    nsAutoPtr<Shmem::SharedMemory> rawmem(CreateSharedMemory(aSize, aType, false, (&(aId))));
    if ((!(rawmem))) {
        return false;
    }

    (*(aMem)) = Shmem(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(), (rawmem).forget(), aId);
    return true;
}

bool
PPluginInstanceChild::AllocUnsafeShmem(
        size_t aSize,
        Shmem::SharedMemory::SharedMemoryType aType,
        Shmem* aMem)
{
    Shmem::id_t aId;
    nsAutoPtr<Shmem::SharedMemory> rawmem(CreateSharedMemory(aSize, aType, true, (&(aId))));
    if ((!(rawmem))) {
        return false;
    }

    (*(aMem)) = Shmem(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(), (rawmem).forget(), aId);
    return true;
}

bool
PPluginInstanceChild::AdoptShmem(
        Shmem& aMem,
        Shmem* aOutMem)
{
    Shmem::SharedMemory* rawmem = (aMem).Segment(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead());
    if (((!(rawmem))) || (IsTrackingSharedMemory(rawmem))) {
        NS_RUNTIMEABORT("bad Shmem");
    }

    Shmem::id_t aId;
    if ((!(AdoptSharedMemory(rawmem, (&(aId)))))) {
        return false;
    }

    (*(aOutMem)) = Shmem(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(), rawmem, aId);
    return true;
}

bool
PPluginInstanceChild::DeallocShmem(Shmem& aMem)
{
    bool ok = DestroySharedMemory(aMem);
    (aMem).forget(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead());
    return ok;
}

void
PPluginInstanceChild::FatalError(const char* const msg) const
{
    // Virtual method to prevent inlining.
    // This give us better error reporting.
    // See bug 589371

    NS_ERROR("IPDL error:");
    NS_ERROR(msg);
    mozilla::ipc::ProtocolErrorBreakpoint(msg);

    NS_RUNTIMEABORT("[PPluginInstanceChild] abort()ing as a result");
}

void
PPluginInstanceChild::DestroySubtree(ActorDestroyReason why)
{
    // Unregister from our manager.
    Unregister(mId);
    mId = 1;

    ActorDestroyReason subtreewhy = (((why) == (Deletion)) || ((why) == (FailedConstructor)) ? AncestorDeletion : why);

    {
        // Recursively shutting down PPluginBackgroundDestroyer kids
        InfallibleTArray<PPluginBackgroundDestroyerChild*> kids(mManagedPPluginBackgroundDestroyerChild);
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DestroySubtree(subtreewhy);
        }
    }
    {
        // Recursively shutting down PPluginScriptableObject kids
        InfallibleTArray<PPluginScriptableObjectChild*> kids(mManagedPPluginScriptableObjectChild);
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DestroySubtree(subtreewhy);
        }
    }
    {
        // Recursively shutting down PBrowserStream kids
        InfallibleTArray<PBrowserStreamChild*> kids(mManagedPBrowserStreamChild);
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DestroySubtree(subtreewhy);
        }
    }
    {
        // Recursively shutting down PPluginStream kids
        InfallibleTArray<PPluginStreamChild*> kids(mManagedPPluginStreamChild);
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DestroySubtree(subtreewhy);
        }
    }
    {
        // Recursively shutting down PStreamNotify kids
        InfallibleTArray<PStreamNotifyChild*> kids(mManagedPStreamNotifyChild);
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DestroySubtree(subtreewhy);
        }
    }
    {
        // Recursively shutting down PPluginSurface kids
        InfallibleTArray<PPluginSurfaceChild*> kids(mManagedPPluginSurfaceChild);
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DestroySubtree(subtreewhy);
        }
    }

    // Finally, destroy "us".
    ActorDestroy(why);
}

void
PPluginInstanceChild::DeallocSubtree()
{
    {
        // Recursively deleting PPluginBackgroundDestroyer kids
        InfallibleTArray<PPluginBackgroundDestroyerChild*>& kids = mManagedPPluginBackgroundDestroyerChild;
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DeallocSubtree();
        }

        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            DeallocPPluginBackgroundDestroyer(kids[i]);
        }
        (mManagedPPluginBackgroundDestroyerChild).Clear();
    }
    {
        // Recursively deleting PPluginScriptableObject kids
        InfallibleTArray<PPluginScriptableObjectChild*>& kids = mManagedPPluginScriptableObjectChild;
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DeallocSubtree();
        }

        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            DeallocPPluginScriptableObject(kids[i]);
        }
        (mManagedPPluginScriptableObjectChild).Clear();
    }
    {
        // Recursively deleting PBrowserStream kids
        InfallibleTArray<PBrowserStreamChild*>& kids = mManagedPBrowserStreamChild;
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DeallocSubtree();
        }

        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            DeallocPBrowserStream(kids[i]);
        }
        (mManagedPBrowserStreamChild).Clear();
    }
    {
        // Recursively deleting PPluginStream kids
        InfallibleTArray<PPluginStreamChild*>& kids = mManagedPPluginStreamChild;
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DeallocSubtree();
        }

        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            DeallocPPluginStream(kids[i]);
        }
        (mManagedPPluginStreamChild).Clear();
    }
    {
        // Recursively deleting PStreamNotify kids
        InfallibleTArray<PStreamNotifyChild*>& kids = mManagedPStreamNotifyChild;
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DeallocSubtree();
        }

        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            DeallocPStreamNotify(kids[i]);
        }
        (mManagedPStreamNotifyChild).Clear();
    }
    {
        // Recursively deleting PPluginSurface kids
        InfallibleTArray<PPluginSurfaceChild*>& kids = mManagedPPluginSurfaceChild;
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DeallocSubtree();
        }

        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            DeallocPPluginSurface(kids[i]);
        }
        (mManagedPPluginSurfaceChild).Clear();
    }
}

void
PPluginInstanceChild::Write(
        const SurfaceDescriptor& __v,
        Message* __msg)
{
    typedef SurfaceDescriptor __type;
    Write(int((__v).type()), __msg);

    switch ((__v).type()) {
    case __type::TShmem:
        {
            Write((__v).get_Shmem(), __msg);
            return;
        }
    case __type::TSurfaceDescriptorX11:
        {
            Write((__v).get_SurfaceDescriptorX11(), __msg);
            return;
        }
    case __type::TPPluginSurfaceParent:
        {
            NS_RUNTIMEABORT("wrong side!");
            return;
        }
    case __type::TPPluginSurfaceChild:
        {
            Write((__v).get_PPluginSurfaceChild(), __msg, false);
            return;
        }
    case __type::TIOSurfaceDescriptor:
        {
            Write((__v).get_IOSurfaceDescriptor(), __msg);
            return;
        }
    case __type::Tnull_t:
        {
            Write((__v).get_null_t(), __msg);
            return;
        }
    default:
        {
            NS_RUNTIMEABORT("unknown union type");
            return;
        }
    }
}

bool
PPluginInstanceChild::Read(
        SurfaceDescriptor* __v,
        const Message* __msg,
        void** __iter)
{
    typedef SurfaceDescriptor __type;
    int type;
    if ((!(Read((&(type)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }

    switch (type) {
    case __type::TShmem:
        {
            Shmem tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_Shmem())), __msg, __iter);
        }
    case __type::TSurfaceDescriptorX11:
        {
            SurfaceDescriptorX11 tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_SurfaceDescriptorX11())), __msg, __iter);
        }
    case __type::TPPluginSurfaceParent:
        {
            PPluginSurfaceChild* tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_PPluginSurfaceChild())), __msg, __iter, false);
        }
    case __type::TPPluginSurfaceChild:
        {
            return false;
        }
    case __type::TIOSurfaceDescriptor:
        {
            IOSurfaceDescriptor tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_IOSurfaceDescriptor())), __msg, __iter);
        }
    case __type::Tnull_t:
        {
            null_t tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_null_t())), __msg, __iter);
        }
    default:
        {
            mozilla::ipc::ProtocolErrorBreakpoint("unknown union type");
            return false;
        }
    }
}

void
PPluginInstanceChild::Write(
        PPluginStreamChild* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PPluginInstanceChild::Read(
        PPluginStreamChild** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PPluginInstance");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PPluginStream");
        return false;
    }

    if ((PPluginStreamMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PPluginStream has different type");
        return false;
    }

    (*(__v)) = static_cast<PPluginStreamChild*>(listener);
    return true;
}

void
PPluginInstanceChild::Write(
        const NPRemoteAsyncSurface& __v,
        Message* __msg)
{
    Write((__v).version(), __msg);
    Write((__v).size(), __msg);
    Write((__v).format(), __msg);
    Write((__v).stride(), __msg);
    Write((__v).data(), __msg);
    Write((__v).hostPtr(), __msg);
}

bool
PPluginInstanceChild::Read(
        NPRemoteAsyncSurface* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->version())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->size())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->format())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->stride())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->data())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->hostPtr())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PPluginInstanceChild::Write(
        Shmem& __v,
        Message* __msg)
{
    IPC::WriteParam(__msg, __v);
    (__v).RevokeRights(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead());
    (__v).forget(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead());
}

bool
PPluginInstanceChild::Read(
        Shmem* __v,
        const Message* __msg,
        void** __iter)
{
    Shmem tmp;
    if ((!(IPC::ReadParam(__msg, __iter, (&(tmp)))))) {
        return false;
    }

    Shmem::id_t shmemid = (tmp).Id(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead());
    Shmem::SharedMemory* rawmem = LookupSharedMemory(shmemid);
    if (rawmem) {
        (*(__v)) = Shmem(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(), rawmem, shmemid);
        return true;
    }
    return false;
}

void
PPluginInstanceChild::Write(
        PPluginSurfaceChild* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PPluginInstanceChild::Read(
        PPluginSurfaceChild** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PPluginInstance");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PPluginSurface");
        return false;
    }

    if ((PPluginSurfaceMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PPluginSurface has different type");
        return false;
    }

    (*(__v)) = static_cast<PPluginSurfaceChild*>(listener);
    return true;
}

void
PPluginInstanceChild::Write(
        PPluginBackgroundDestroyerChild* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PPluginInstanceChild::Read(
        PPluginBackgroundDestroyerChild** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PPluginInstance");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PPluginBackgroundDestroyer");
        return false;
    }

    if ((PPluginBackgroundDestroyerMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PPluginBackgroundDestroyer has different type");
        return false;
    }

    (*(__v)) = static_cast<PPluginBackgroundDestroyerChild*>(listener);
    return true;
}

void
PPluginInstanceChild::Write(
        const IOSurfaceDescriptor& __v,
        Message* __msg)
{
    Write((__v).surfaceId(), __msg);
    Write((__v).contentsScaleFactor(), __msg);
}

bool
PPluginInstanceChild::Read(
        IOSurfaceDescriptor* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->surfaceId())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->contentsScaleFactor())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PPluginInstanceChild::Write(
        PBrowserStreamChild* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PPluginInstanceChild::Read(
        PBrowserStreamChild** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PPluginInstance");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PBrowserStream");
        return false;
    }

    if ((PBrowserStreamMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PBrowserStream has different type");
        return false;
    }

    (*(__v)) = static_cast<PBrowserStreamChild*>(listener);
    return true;
}

void
PPluginInstanceChild::Write(
        PPluginInstanceChild* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PPluginInstanceChild::Read(
        PPluginInstanceChild** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PPluginInstance");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PPluginInstance");
        return false;
    }

    if ((PPluginInstanceMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PPluginInstance has different type");
        return false;
    }

    (*(__v)) = static_cast<PPluginInstanceChild*>(listener);
    return true;
}

void
PPluginInstanceChild::Write(
        const OptionalShmem& __v,
        Message* __msg)
{
    typedef OptionalShmem __type;
    Write(int((__v).type()), __msg);

    switch ((__v).type()) {
    case __type::TShmem:
        {
            Write((__v).get_Shmem(), __msg);
            return;
        }
    case __type::Tnull_t:
        {
            Write((__v).get_null_t(), __msg);
            return;
        }
    default:
        {
            NS_RUNTIMEABORT("unknown union type");
            return;
        }
    }
}

bool
PPluginInstanceChild::Read(
        OptionalShmem* __v,
        const Message* __msg,
        void** __iter)
{
    typedef OptionalShmem __type;
    int type;
    if ((!(Read((&(type)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }

    switch (type) {
    case __type::TShmem:
        {
            Shmem tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_Shmem())), __msg, __iter);
        }
    case __type::Tnull_t:
        {
            null_t tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_null_t())), __msg, __iter);
        }
    default:
        {
            mozilla::ipc::ProtocolErrorBreakpoint("unknown union type");
            return false;
        }
    }
}

void
PPluginInstanceChild::Write(
        PStreamNotifyChild* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PPluginInstanceChild::Read(
        PStreamNotifyChild** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PPluginInstance");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PStreamNotify");
        return false;
    }

    if ((PStreamNotifyMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PStreamNotify has different type");
        return false;
    }

    (*(__v)) = static_cast<PStreamNotifyChild*>(listener);
    return true;
}

void
PPluginInstanceChild::Write(
        const AsyncSurfaceDescriptor& __v,
        Message* __msg)
{
    typedef AsyncSurfaceDescriptor __type;
    Write(int((__v).type()), __msg);

    switch ((__v).type()) {
    case __type::TShmem:
        {
            Write((__v).get_Shmem(), __msg);
            return;
        }
    case __type::TDXGISharedSurfaceHandle:
        {
            Write((__v).get_DXGISharedSurfaceHandle(), __msg);
            return;
        }
    default:
        {
            NS_RUNTIMEABORT("unknown union type");
            return;
        }
    }
}

bool
PPluginInstanceChild::Read(
        AsyncSurfaceDescriptor* __v,
        const Message* __msg,
        void** __iter)
{
    typedef AsyncSurfaceDescriptor __type;
    int type;
    if ((!(Read((&(type)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }

    switch (type) {
    case __type::TShmem:
        {
            Shmem tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_Shmem())), __msg, __iter);
        }
    case __type::TDXGISharedSurfaceHandle:
        {
            DXGISharedSurfaceHandle tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_DXGISharedSurfaceHandle())), __msg, __iter);
        }
    default:
        {
            mozilla::ipc::ProtocolErrorBreakpoint("unknown union type");
            return false;
        }
    }
}

void
PPluginInstanceChild::Write(
        PPluginScriptableObjectChild* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PPluginInstanceChild::Read(
        PPluginScriptableObjectChild** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PPluginInstance");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PPluginScriptableObject");
        return false;
    }

    if ((PPluginScriptableObjectMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PPluginScriptableObject has different type");
        return false;
    }

    (*(__v)) = static_cast<PPluginScriptableObjectChild*>(listener);
    return true;
}



} // namespace plugins
} // namespace mozilla
