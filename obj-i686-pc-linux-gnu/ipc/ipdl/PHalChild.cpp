//
// Automatically generated by ipdlc.
// Edit at your own risk
//


#include "mozilla/hal_sandbox/PHalChild.h"

#include "mozilla/dom/PContentChild.h"
#include "mozilla/dom/PBrowserChild.h"

typedef IPC::Message Message;
typedef mozilla::ipc::RPCChannel Channel;
typedef mozilla::ipc::RPCChannel::RPCListener ChannelListener;
typedef base::ProcessHandle ProcessHandle;
typedef mozilla::ipc::AsyncChannel AsyncChannel;
typedef mozilla::ipc::SharedMemory SharedMemory;
typedef mozilla::ipc::Trigger Trigger;
typedef mozilla::ipc::ActorHandle ActorHandle;
typedef mozilla::hal::BatteryInformation BatteryInformation;
typedef mozilla::hal::FMRadioCountry FMRadioCountry;
typedef mozilla::hal::FMRadioOperation FMRadioOperation;
typedef mozilla::hal::FMRadioOperationInformation FMRadioOperationInformation;
typedef mozilla::hal::FMRadioOperationStatus FMRadioOperationStatus;
typedef mozilla::hal::FMRadioSettings FMRadioSettings;
typedef mozilla::ipc::FileDescriptor FileDescriptor;
typedef mozilla::hal::FlashMode FlashMode;
typedef mozilla::hal::LightConfiguration LightConfiguration;
typedef mozilla::hal::LightMode LightMode;
typedef mozilla::hal::LightType LightType;
typedef mozilla::hal::NetworkInformation NetworkInformation;
typedef mozilla::hal::ProcessPriority ProcessPriority;
typedef mozilla::hal::ScreenConfiguration ScreenConfiguration;
typedef mozilla::dom::ScreenOrientation ScreenOrientation;
typedef mozilla::hal::SensorAccuracyType SensorAccuracyType;
typedef mozilla::hal::SensorData SensorData;
typedef mozilla::hal::SensorType SensorType;
typedef mozilla::ipc::Shmem Shmem;
typedef mozilla::hal::SwitchDevice SwitchDevice;
typedef mozilla::hal::SwitchEvent SwitchEvent;
typedef mozilla::hal::SwitchState SwitchState;
typedef mozilla::hal::SystemTimezoneChangeInformation SystemTimezoneChangeInformation;
typedef mozilla::hal::WakeLockControl WakeLockControl;
typedef mozilla::hal::WakeLockInformation WakeLockInformation;
using mozilla::dom::PContentChild;
using mozilla::dom::PBrowserChild;

namespace mozilla {
namespace hal_sandbox {


void
PHalChild::ActorDestroy(ActorDestroyReason why)
{
}

PHalChild::PHalChild() :
    mId(0),
    mState(PHal::__Dead)
{
    MOZ_COUNT_CTOR(PHalChild);
}

PHalChild::~PHalChild()
{
    MOZ_COUNT_DTOR(PHalChild);
}

PContentChild*
PHalChild::Manager() const
{
    return static_cast<PContentChild*>(mManager);
}

PHal::State
PHalChild::state()
{
    return mState;
}

bool
PHalChild::SendVibrate(
        const InfallibleTArray<uint32_t>& pattern,
        const InfallibleTArray<uint64_t>& id,
        PBrowserChild* browser)
{
    PHal::Msg_Vibrate* __msg = new PHal::Msg_Vibrate();

    Write(pattern, __msg);
    Write(id, __msg);
    Write(browser, __msg, false);

    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PHalChild] Sending ", stderr);
    }
    if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_Vibrate__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

bool
PHalChild::SendCancelVibrate(
        const InfallibleTArray<uint64_t>& id,
        PBrowserChild* browser)
{
    PHal::Msg_CancelVibrate* __msg = new PHal::Msg_CancelVibrate();

    Write(id, __msg);
    Write(browser, __msg, false);

    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PHalChild] Sending ", stderr);
    }
    if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_CancelVibrate__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

bool
PHalChild::SendEnableBatteryNotifications()
{
    PHal::Msg_EnableBatteryNotifications* __msg = new PHal::Msg_EnableBatteryNotifications();


    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PHalChild] Sending ", stderr);
    }
    if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_EnableBatteryNotifications__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

bool
PHalChild::SendDisableBatteryNotifications()
{
    PHal::Msg_DisableBatteryNotifications* __msg = new PHal::Msg_DisableBatteryNotifications();


    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PHalChild] Sending ", stderr);
    }
    if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_DisableBatteryNotifications__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

bool
PHalChild::SendGetCurrentBatteryInformation(BatteryInformation* aBatteryInfo)
{
    PHal::Msg_GetCurrentBatteryInformation* __msg = new PHal::Msg_GetCurrentBatteryInformation();


    (__msg)->set_routing_id(mId);
    (__msg)->set_sync();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PHalChild] Sending ", stderr);
    }
    if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_GetCurrentBatteryInformation__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PHal::Reply_GetCurrentBatteryInformation*>((&(__reply))))->Log("[PHalChild] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(aBatteryInfo, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    (__reply).EndRead(__iter);

    return true;
}

bool
PHalChild::SendEnableNetworkNotifications()
{
    PHal::Msg_EnableNetworkNotifications* __msg = new PHal::Msg_EnableNetworkNotifications();


    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PHalChild] Sending ", stderr);
    }
    if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_EnableNetworkNotifications__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

bool
PHalChild::SendDisableNetworkNotifications()
{
    PHal::Msg_DisableNetworkNotifications* __msg = new PHal::Msg_DisableNetworkNotifications();


    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PHalChild] Sending ", stderr);
    }
    if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_DisableNetworkNotifications__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

bool
PHalChild::SendGetCurrentNetworkInformation(NetworkInformation* aNetworkInfo)
{
    PHal::Msg_GetCurrentNetworkInformation* __msg = new PHal::Msg_GetCurrentNetworkInformation();


    (__msg)->set_routing_id(mId);
    (__msg)->set_sync();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PHalChild] Sending ", stderr);
    }
    if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_GetCurrentNetworkInformation__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PHal::Reply_GetCurrentNetworkInformation*>((&(__reply))))->Log("[PHalChild] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(aNetworkInfo, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    (__reply).EndRead(__iter);

    return true;
}

bool
PHalChild::SendGetScreenEnabled(bool* enabled)
{
    PHal::Msg_GetScreenEnabled* __msg = new PHal::Msg_GetScreenEnabled();


    (__msg)->set_routing_id(mId);
    (__msg)->set_sync();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PHalChild] Sending ", stderr);
    }
    if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_GetScreenEnabled__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PHal::Reply_GetScreenEnabled*>((&(__reply))))->Log("[PHalChild] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(enabled, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    (__reply).EndRead(__iter);

    return true;
}

bool
PHalChild::SendSetScreenEnabled(const bool& enabled)
{
    PHal::Msg_SetScreenEnabled* __msg = new PHal::Msg_SetScreenEnabled();

    Write(enabled, __msg);

    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PHalChild] Sending ", stderr);
    }
    if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_SetScreenEnabled__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

bool
PHalChild::SendGetCpuSleepAllowed(bool* allowed)
{
    PHal::Msg_GetCpuSleepAllowed* __msg = new PHal::Msg_GetCpuSleepAllowed();


    (__msg)->set_routing_id(mId);
    (__msg)->set_sync();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PHalChild] Sending ", stderr);
    }
    if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_GetCpuSleepAllowed__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PHal::Reply_GetCpuSleepAllowed*>((&(__reply))))->Log("[PHalChild] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(allowed, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    (__reply).EndRead(__iter);

    return true;
}

bool
PHalChild::SendSetCpuSleepAllowed(const bool& allowed)
{
    PHal::Msg_SetCpuSleepAllowed* __msg = new PHal::Msg_SetCpuSleepAllowed();

    Write(allowed, __msg);

    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PHalChild] Sending ", stderr);
    }
    if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_SetCpuSleepAllowed__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

bool
PHalChild::SendGetScreenBrightness(double* brightness)
{
    PHal::Msg_GetScreenBrightness* __msg = new PHal::Msg_GetScreenBrightness();


    (__msg)->set_routing_id(mId);
    (__msg)->set_sync();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PHalChild] Sending ", stderr);
    }
    if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_GetScreenBrightness__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PHal::Reply_GetScreenBrightness*>((&(__reply))))->Log("[PHalChild] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(brightness, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    (__reply).EndRead(__iter);

    return true;
}

bool
PHalChild::SendSetScreenBrightness(const double& brightness)
{
    PHal::Msg_SetScreenBrightness* __msg = new PHal::Msg_SetScreenBrightness();

    Write(brightness, __msg);

    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PHalChild] Sending ", stderr);
    }
    if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_SetScreenBrightness__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

bool
PHalChild::SendAdjustSystemClock(const int64_t& aDeltaMilliseconds)
{
    PHal::Msg_AdjustSystemClock* __msg = new PHal::Msg_AdjustSystemClock();

    Write(aDeltaMilliseconds, __msg);

    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PHalChild] Sending ", stderr);
    }
    if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_AdjustSystemClock__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

bool
PHalChild::SendSetTimezone(const nsCString& aTimezoneSpec)
{
    PHal::Msg_SetTimezone* __msg = new PHal::Msg_SetTimezone();

    Write(aTimezoneSpec, __msg);

    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PHalChild] Sending ", stderr);
    }
    if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_SetTimezone__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

bool
PHalChild::SendGetTimezone(nsCString* aTimezoneSpec)
{
    PHal::Msg_GetTimezone* __msg = new PHal::Msg_GetTimezone();


    (__msg)->set_routing_id(mId);
    (__msg)->set_sync();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PHalChild] Sending ", stderr);
    }
    if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_GetTimezone__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PHal::Reply_GetTimezone*>((&(__reply))))->Log("[PHalChild] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(aTimezoneSpec, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    (__reply).EndRead(__iter);

    return true;
}

bool
PHalChild::SendEnableSystemClockChangeNotifications()
{
    PHal::Msg_EnableSystemClockChangeNotifications* __msg = new PHal::Msg_EnableSystemClockChangeNotifications();


    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PHalChild] Sending ", stderr);
    }
    if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_EnableSystemClockChangeNotifications__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

bool
PHalChild::SendDisableSystemClockChangeNotifications()
{
    PHal::Msg_DisableSystemClockChangeNotifications* __msg = new PHal::Msg_DisableSystemClockChangeNotifications();


    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PHalChild] Sending ", stderr);
    }
    if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_DisableSystemClockChangeNotifications__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

bool
PHalChild::SendEnableSystemTimezoneChangeNotifications()
{
    PHal::Msg_EnableSystemTimezoneChangeNotifications* __msg = new PHal::Msg_EnableSystemTimezoneChangeNotifications();


    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PHalChild] Sending ", stderr);
    }
    if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_EnableSystemTimezoneChangeNotifications__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

bool
PHalChild::SendDisableSystemTimezoneChangeNotifications()
{
    PHal::Msg_DisableSystemTimezoneChangeNotifications* __msg = new PHal::Msg_DisableSystemTimezoneChangeNotifications();


    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PHalChild] Sending ", stderr);
    }
    if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_DisableSystemTimezoneChangeNotifications__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

bool
PHalChild::SendSetLight(
        const LightType& light,
        const LightConfiguration& aConfig,
        bool* status)
{
    PHal::Msg_SetLight* __msg = new PHal::Msg_SetLight();

    Write(light, __msg);
    Write(aConfig, __msg);

    (__msg)->set_routing_id(mId);
    (__msg)->set_sync();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PHalChild] Sending ", stderr);
    }
    if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_SetLight__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PHal::Reply_SetLight*>((&(__reply))))->Log("[PHalChild] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(status, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    (__reply).EndRead(__iter);

    return true;
}

bool
PHalChild::SendGetLight(
        const LightType& light,
        LightConfiguration* aConfig,
        bool* status)
{
    PHal::Msg_GetLight* __msg = new PHal::Msg_GetLight();

    Write(light, __msg);

    (__msg)->set_routing_id(mId);
    (__msg)->set_sync();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PHalChild] Sending ", stderr);
    }
    if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_GetLight__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PHal::Reply_GetLight*>((&(__reply))))->Log("[PHalChild] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(aConfig, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read(status, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    (__reply).EndRead(__iter);

    return true;
}

bool
PHalChild::SendModifyWakeLock(
        const nsString& aTopic,
        const WakeLockControl& aLockAdjust,
        const WakeLockControl& aHiddenAdjust,
        const uint64_t& aProcessID)
{
    PHal::Msg_ModifyWakeLock* __msg = new PHal::Msg_ModifyWakeLock();

    Write(aTopic, __msg);
    Write(aLockAdjust, __msg);
    Write(aHiddenAdjust, __msg);
    Write(aProcessID, __msg);

    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PHalChild] Sending ", stderr);
    }
    if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_ModifyWakeLock__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

bool
PHalChild::SendEnableWakeLockNotifications()
{
    PHal::Msg_EnableWakeLockNotifications* __msg = new PHal::Msg_EnableWakeLockNotifications();


    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PHalChild] Sending ", stderr);
    }
    if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_EnableWakeLockNotifications__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

bool
PHalChild::SendDisableWakeLockNotifications()
{
    PHal::Msg_DisableWakeLockNotifications* __msg = new PHal::Msg_DisableWakeLockNotifications();


    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PHalChild] Sending ", stderr);
    }
    if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_DisableWakeLockNotifications__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

bool
PHalChild::SendGetWakeLockInfo(
        const nsString& aTopic,
        WakeLockInformation* aWakeLockInfo)
{
    PHal::Msg_GetWakeLockInfo* __msg = new PHal::Msg_GetWakeLockInfo();

    Write(aTopic, __msg);

    (__msg)->set_routing_id(mId);
    (__msg)->set_sync();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PHalChild] Sending ", stderr);
    }
    if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_GetWakeLockInfo__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PHal::Reply_GetWakeLockInfo*>((&(__reply))))->Log("[PHalChild] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(aWakeLockInfo, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    (__reply).EndRead(__iter);

    return true;
}

bool
PHalChild::SendEnableScreenConfigurationNotifications()
{
    PHal::Msg_EnableScreenConfigurationNotifications* __msg = new PHal::Msg_EnableScreenConfigurationNotifications();


    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PHalChild] Sending ", stderr);
    }
    if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_EnableScreenConfigurationNotifications__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

bool
PHalChild::SendDisableScreenConfigurationNotifications()
{
    PHal::Msg_DisableScreenConfigurationNotifications* __msg = new PHal::Msg_DisableScreenConfigurationNotifications();


    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PHalChild] Sending ", stderr);
    }
    if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_DisableScreenConfigurationNotifications__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

bool
PHalChild::SendGetCurrentScreenConfiguration(ScreenConfiguration* aScreenConfiguration)
{
    PHal::Msg_GetCurrentScreenConfiguration* __msg = new PHal::Msg_GetCurrentScreenConfiguration();


    (__msg)->set_routing_id(mId);
    (__msg)->set_sync();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PHalChild] Sending ", stderr);
    }
    if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_GetCurrentScreenConfiguration__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PHal::Reply_GetCurrentScreenConfiguration*>((&(__reply))))->Log("[PHalChild] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(aScreenConfiguration, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    (__reply).EndRead(__iter);

    return true;
}

bool
PHalChild::SendLockScreenOrientation(
        const ScreenOrientation& aOrientation,
        bool* allowed)
{
    PHal::Msg_LockScreenOrientation* __msg = new PHal::Msg_LockScreenOrientation();

    Write(aOrientation, __msg);

    (__msg)->set_routing_id(mId);
    (__msg)->set_sync();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PHalChild] Sending ", stderr);
    }
    if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_LockScreenOrientation__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PHal::Reply_LockScreenOrientation*>((&(__reply))))->Log("[PHalChild] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(allowed, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    (__reply).EndRead(__iter);

    return true;
}

bool
PHalChild::SendUnlockScreenOrientation()
{
    PHal::Msg_UnlockScreenOrientation* __msg = new PHal::Msg_UnlockScreenOrientation();


    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PHalChild] Sending ", stderr);
    }
    if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_UnlockScreenOrientation__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

bool
PHalChild::SendEnableSwitchNotifications(const SwitchDevice& aDevice)
{
    PHal::Msg_EnableSwitchNotifications* __msg = new PHal::Msg_EnableSwitchNotifications();

    Write(aDevice, __msg);

    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PHalChild] Sending ", stderr);
    }
    if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_EnableSwitchNotifications__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

bool
PHalChild::SendDisableSwitchNotifications(const SwitchDevice& aDevice)
{
    PHal::Msg_DisableSwitchNotifications* __msg = new PHal::Msg_DisableSwitchNotifications();

    Write(aDevice, __msg);

    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PHalChild] Sending ", stderr);
    }
    if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_DisableSwitchNotifications__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

bool
PHalChild::SendGetCurrentSwitchState(
        const SwitchDevice& aDevice,
        SwitchState* aState)
{
    PHal::Msg_GetCurrentSwitchState* __msg = new PHal::Msg_GetCurrentSwitchState();

    Write(aDevice, __msg);

    (__msg)->set_routing_id(mId);
    (__msg)->set_sync();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PHalChild] Sending ", stderr);
    }
    if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_GetCurrentSwitchState__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PHal::Reply_GetCurrentSwitchState*>((&(__reply))))->Log("[PHalChild] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(aState, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    (__reply).EndRead(__iter);

    return true;
}

bool
PHalChild::SendSetProcessPriority(
        const int& aPid,
        const ProcessPriority& aPriority)
{
    PHal::Msg_SetProcessPriority* __msg = new PHal::Msg_SetProcessPriority();

    Write(aPid, __msg);
    Write(aPriority, __msg);

    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PHalChild] Sending ", stderr);
    }
    if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_SetProcessPriority__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

bool
PHalChild::SendFactoryReset()
{
    PHal::Msg_FactoryReset* __msg = new PHal::Msg_FactoryReset();


    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PHalChild] Sending ", stderr);
    }
    if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_FactoryReset__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

bool
PHalChild::SendEnableSensorNotifications(const SensorType& aSensor)
{
    PHal::Msg_EnableSensorNotifications* __msg = new PHal::Msg_EnableSensorNotifications();

    Write(aSensor, __msg);

    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PHalChild] Sending ", stderr);
    }
    if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_EnableSensorNotifications__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

bool
PHalChild::SendDisableSensorNotifications(const SensorType& aSensor)
{
    PHal::Msg_DisableSensorNotifications* __msg = new PHal::Msg_DisableSensorNotifications();

    Write(aSensor, __msg);

    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PHalChild] Sending ", stderr);
    }
    if ((!(PHal::Transition(mState, Trigger(Trigger::Recv, PHal::Msg_DisableSensorNotifications__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

bool
PHalChild::Send__delete__(PHalChild* actor)
{
    if ((!(actor))) {
        return false;
    }

    if ((!(actor))) {
        return false;
    }

    PHal::Msg___delete__* __msg = new PHal::Msg___delete__();

    (actor)->Write(actor, __msg, false);

    (__msg)->set_routing_id((actor)->mId);


    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PHalChild] Sending ", stderr);
    }
    if ((!(PHal::Transition((actor)->mState, Trigger(Trigger::Recv, PHal::Msg___delete____ID), (&((actor)->mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = ((actor)->mChannel)->Send(__msg);

    (actor)->DestroySubtree(Deletion);
    (actor)->DeallocSubtree();
    ((actor)->mManager)->RemoveManagee(PHalMsgStart, actor);
    return __sendok;
}

int32_t
PHalChild::Register(ChannelListener* aRouted)
{
    return (mManager)->Register(aRouted);
}

int32_t
PHalChild::RegisterID(
        ChannelListener* aRouted,
        int32_t aId)
{
    return (mManager)->RegisterID(aRouted, aId);
}

ChannelListener*
PHalChild::Lookup(int32_t aId)
{
    return (mManager)->Lookup(aId);
}

void
PHalChild::Unregister(int32_t aId)
{
    return (mManager)->Unregister(aId);
}

void
PHalChild::RemoveManagee(
        int32_t aProtocolId,
        ChannelListener* aListener)
{
    NS_RUNTIMEABORT("unreached");
    return;
}

Shmem::SharedMemory*
PHalChild::CreateSharedMemory(
        size_t aSize,
        Shmem::SharedMemory::SharedMemoryType aType,
        bool aUnsafe,
        Shmem::id_t* aId)
{
    return (mManager)->CreateSharedMemory(aSize, aType, aUnsafe, aId);
}

bool
PHalChild::AdoptSharedMemory(
        Shmem::SharedMemory* segment,
        Shmem::id_t* aId)
{
    return (mManager)->AdoptSharedMemory(segment, aId);
}

Shmem::SharedMemory*
PHalChild::LookupSharedMemory(Shmem::id_t aId)
{
    return (mManager)->LookupSharedMemory(aId);
}

bool
PHalChild::IsTrackingSharedMemory(Shmem::SharedMemory* segment)
{
    return (mManager)->IsTrackingSharedMemory(segment);
}

bool
PHalChild::DestroySharedMemory(Shmem& shmem)
{
    return (mManager)->DestroySharedMemory(shmem);
}

ProcessHandle
PHalChild::OtherProcess() const
{
    return (mManager)->OtherProcess();
}

AsyncChannel*
PHalChild::GetIPCChannel()
{
    return mChannel;
}

PHalChild::Result
PHalChild::OnMessageReceived(const Message& __msg)
{
    switch ((__msg).type()) {
    case PHal::Msg_NotifyBatteryChange__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PHal::Msg_NotifyBatteryChange");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PHal::Msg_NotifyBatteryChange*>((&(__msg))))->Log("[PHalChild] Received ", stderr);
            }

            void* __iter = 0;
            BatteryInformation aBatteryInfo;

            if ((!(Read((&(aBatteryInfo)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PHal::Transition(mState, Trigger(Trigger::Send, PHal::Msg_NotifyBatteryChange__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvNotifyBatteryChange(aBatteryInfo)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for NotifyBatteryChange returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PHal::Msg_NotifyNetworkChange__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PHal::Msg_NotifyNetworkChange");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PHal::Msg_NotifyNetworkChange*>((&(__msg))))->Log("[PHalChild] Received ", stderr);
            }

            void* __iter = 0;
            NetworkInformation aNetworkInfo;

            if ((!(Read((&(aNetworkInfo)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PHal::Transition(mState, Trigger(Trigger::Send, PHal::Msg_NotifyNetworkChange__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvNotifyNetworkChange(aNetworkInfo)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for NotifyNetworkChange returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PHal::Msg_NotifyWakeLockChange__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PHal::Msg_NotifyWakeLockChange");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PHal::Msg_NotifyWakeLockChange*>((&(__msg))))->Log("[PHalChild] Received ", stderr);
            }

            void* __iter = 0;
            WakeLockInformation aWakeLockInfo;

            if ((!(Read((&(aWakeLockInfo)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PHal::Transition(mState, Trigger(Trigger::Send, PHal::Msg_NotifyWakeLockChange__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvNotifyWakeLockChange(aWakeLockInfo)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for NotifyWakeLockChange returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PHal::Msg_NotifyScreenConfigurationChange__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PHal::Msg_NotifyScreenConfigurationChange");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PHal::Msg_NotifyScreenConfigurationChange*>((&(__msg))))->Log("[PHalChild] Received ", stderr);
            }

            void* __iter = 0;
            ScreenConfiguration aScreenOrientation;

            if ((!(Read((&(aScreenOrientation)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PHal::Transition(mState, Trigger(Trigger::Send, PHal::Msg_NotifyScreenConfigurationChange__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvNotifyScreenConfigurationChange(aScreenOrientation)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for NotifyScreenConfigurationChange returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PHal::Msg_NotifySwitchChange__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PHal::Msg_NotifySwitchChange");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PHal::Msg_NotifySwitchChange*>((&(__msg))))->Log("[PHalChild] Received ", stderr);
            }

            void* __iter = 0;
            SwitchEvent aEvent;

            if ((!(Read((&(aEvent)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PHal::Transition(mState, Trigger(Trigger::Send, PHal::Msg_NotifySwitchChange__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvNotifySwitchChange(aEvent)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for NotifySwitchChange returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PHal::Msg_NotifySystemClockChange__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PHal::Msg_NotifySystemClockChange");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PHal::Msg_NotifySystemClockChange*>((&(__msg))))->Log("[PHalChild] Received ", stderr);
            }

            void* __iter = 0;
            int64_t aClockDeltaMS;

            if ((!(Read((&(aClockDeltaMS)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PHal::Transition(mState, Trigger(Trigger::Send, PHal::Msg_NotifySystemClockChange__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvNotifySystemClockChange(aClockDeltaMS)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for NotifySystemClockChange returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PHal::Msg_NotifySystemTimezoneChange__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PHal::Msg_NotifySystemTimezoneChange");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PHal::Msg_NotifySystemTimezoneChange*>((&(__msg))))->Log("[PHalChild] Received ", stderr);
            }

            void* __iter = 0;
            SystemTimezoneChangeInformation aSystemTimezoneChangeInfo;

            if ((!(Read((&(aSystemTimezoneChangeInfo)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PHal::Transition(mState, Trigger(Trigger::Send, PHal::Msg_NotifySystemTimezoneChange__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvNotifySystemTimezoneChange(aSystemTimezoneChangeInfo)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for NotifySystemTimezoneChange returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PHal::Msg_NotifySensorChange__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PHal::Msg_NotifySensorChange");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PHal::Msg_NotifySensorChange*>((&(__msg))))->Log("[PHalChild] Received ", stderr);
            }

            void* __iter = 0;
            SensorData aSensorData;

            if ((!(Read((&(aSensorData)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PHal::Transition(mState, Trigger(Trigger::Send, PHal::Msg_NotifySensorChange__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvNotifySensorChange(aSensorData)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for NotifySensorChange returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PHal::Reply___delete____ID:
        {
            return MsgProcessed;
        }
    default:
        {
            return MsgNotKnown;
        }
    }
}

PHalChild::Result
PHalChild::OnMessageReceived(
        const Message& __msg,
        Message*& __reply)
{
    return MsgNotKnown;
}

PHalChild::Result
PHalChild::OnCallReceived(
        const Message& __msg,
        Message*& __reply)
{
    return MsgNotKnown;
}

void
PHalChild::OnProcessingError(Result code)
{
    NS_RUNTIMEABORT("`OnProcessingError' called on non-toplevel actor");
}

int32_t
PHalChild::GetProtocolTypeId()
{
    return PHalMsgStart;
}

bool
PHalChild::OnReplyTimeout()
{
    NS_RUNTIMEABORT("`OnReplyTimeout' called on non-toplevel actor");
    return false;
}

void
PHalChild::OnChannelClose()
{
    NS_RUNTIMEABORT("`OnClose' called on non-toplevel actor");
}

void
PHalChild::OnChannelError()
{
    NS_RUNTIMEABORT("`OnError' called on non-toplevel actor");
}

void
PHalChild::OnChannelConnected(int32_t pid)
{
    NS_RUNTIMEABORT("'OnConnected' called on non-toplevel actor");
}

bool
PHalChild::AllocShmem(
        size_t aSize,
        Shmem::SharedMemory::SharedMemoryType aType,
        Shmem* aMem)
{
    Shmem::id_t aId;
    nsAutoPtr<Shmem::SharedMemory> rawmem(CreateSharedMemory(aSize, aType, false, (&(aId))));
    if ((!(rawmem))) {
        return false;
    }

    (*(aMem)) = Shmem(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(), (rawmem).forget(), aId);
    return true;
}

bool
PHalChild::AllocUnsafeShmem(
        size_t aSize,
        Shmem::SharedMemory::SharedMemoryType aType,
        Shmem* aMem)
{
    Shmem::id_t aId;
    nsAutoPtr<Shmem::SharedMemory> rawmem(CreateSharedMemory(aSize, aType, true, (&(aId))));
    if ((!(rawmem))) {
        return false;
    }

    (*(aMem)) = Shmem(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(), (rawmem).forget(), aId);
    return true;
}

bool
PHalChild::AdoptShmem(
        Shmem& aMem,
        Shmem* aOutMem)
{
    Shmem::SharedMemory* rawmem = (aMem).Segment(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead());
    if (((!(rawmem))) || (IsTrackingSharedMemory(rawmem))) {
        NS_RUNTIMEABORT("bad Shmem");
    }

    Shmem::id_t aId;
    if ((!(AdoptSharedMemory(rawmem, (&(aId)))))) {
        return false;
    }

    (*(aOutMem)) = Shmem(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(), rawmem, aId);
    return true;
}

bool
PHalChild::DeallocShmem(Shmem& aMem)
{
    bool ok = DestroySharedMemory(aMem);
    (aMem).forget(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead());
    return ok;
}

void
PHalChild::FatalError(const char* const msg) const
{
    // Virtual method to prevent inlining.
    // This give us better error reporting.
    // See bug 589371

    NS_ERROR("IPDL error:");
    NS_ERROR(msg);
    mozilla::ipc::ProtocolErrorBreakpoint(msg);

    NS_RUNTIMEABORT("[PHalChild] abort()ing as a result");
}

void
PHalChild::DestroySubtree(ActorDestroyReason why)
{
    // Unregister from our manager.
    Unregister(mId);
    mId = 1;

    // Finally, destroy "us".
    ActorDestroy(why);
}

void
PHalChild::DeallocSubtree()
{
}

void
PHalChild::Write(
        const SwitchEvent& __v,
        Message* __msg)
{
    Write((__v).device(), __msg);
    Write((__v).status(), __msg);
}

bool
PHalChild::Read(
        SwitchEvent* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->device())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->status())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PHalChild::Write(
        const LightConfiguration& __v,
        Message* __msg)
{
    Write((__v).light(), __msg);
    Write((__v).mode(), __msg);
    Write((__v).flash(), __msg);
    Write((__v).flashOnMS(), __msg);
    Write((__v).flashOffMS(), __msg);
    Write((__v).color(), __msg);
}

bool
PHalChild::Read(
        LightConfiguration* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->light())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->mode())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->flash())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->flashOnMS())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->flashOffMS())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->color())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PHalChild::Write(
        PBrowserChild* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PHalChild::Read(
        PBrowserChild** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PHal");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PBrowser");
        return false;
    }

    if ((PBrowserMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PBrowser has different type");
        return false;
    }

    (*(__v)) = static_cast<PBrowserChild*>(listener);
    return true;
}

void
PHalChild::Write(
        const ScreenConfiguration& __v,
        Message* __msg)
{
    Write((__v).rect(), __msg);
    Write((__v).orientation(), __msg);
    Write((__v).colorDepth(), __msg);
    Write((__v).pixelDepth(), __msg);
}

bool
PHalChild::Read(
        ScreenConfiguration* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->rect())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->orientation())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->colorDepth())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->pixelDepth())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PHalChild::Write(
        const BatteryInformation& __v,
        Message* __msg)
{
    Write((__v).level(), __msg);
    Write((__v).charging(), __msg);
    Write((__v).remainingTime(), __msg);
}

bool
PHalChild::Read(
        BatteryInformation* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->level())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->charging())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->remainingTime())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PHalChild::Write(
        const WakeLockInformation& __v,
        Message* __msg)
{
    Write((__v).numLocks(), __msg);
    Write((__v).numHidden(), __msg);
    Write((__v).topic(), __msg);
}

bool
PHalChild::Read(
        WakeLockInformation* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->numLocks())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->numHidden())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->topic())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PHalChild::Write(
        const NetworkInformation& __v,
        Message* __msg)
{
    Write((__v).bandwidth(), __msg);
    Write((__v).canBeMetered(), __msg);
}

bool
PHalChild::Read(
        NetworkInformation* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->bandwidth())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->canBeMetered())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PHalChild::Write(
        const SystemTimezoneChangeInformation& __v,
        Message* __msg)
{
    Write((__v).oldTimezoneOffsetMinutes(), __msg);
    Write((__v).newTimezoneOffsetMinutes(), __msg);
}

bool
PHalChild::Read(
        SystemTimezoneChangeInformation* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->oldTimezoneOffsetMinutes())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->newTimezoneOffsetMinutes())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PHalChild::Write(
        const SensorData& __v,
        Message* __msg)
{
    Write((__v).sensor(), __msg);
    Write((__v).timestamp(), __msg);
    Write((__v).values(), __msg);
    Write((__v).accuracy(), __msg);
}

bool
PHalChild::Read(
        SensorData* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->sensor())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->timestamp())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->values())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->accuracy())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PHalChild::Write(
        PHalChild* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PHalChild::Read(
        PHalChild** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PHal");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PHal");
        return false;
    }

    if ((PHalMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PHal has different type");
        return false;
    }

    (*(__v)) = static_cast<PHalChild*>(listener);
    return true;
}



} // namespace hal_sandbox
} // namespace mozilla
