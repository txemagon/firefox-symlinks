//
// Automatically generated by ipdlc.
// Edit at your own risk
//


#include "mozilla/dom/devicestorage/PDeviceStorageRequest.h"

namespace mozilla {
namespace dom {
namespace devicestorage {
namespace PDeviceStorageRequest {

bool
Transition(
        State from,
        mozilla::ipc::Trigger trigger,
        State* next)
{
    switch (from) {
    case __Null:
    case __Error:
        if ((Msg___delete____ID) == ((trigger).mMsg)) {
            (*(next)) = __Dead;
            return true;
        }
        return (__Null) == (from);
    case __Dead:
        NS_RUNTIMEABORT("__delete__()d actor");
        return false;
    case __Dying:
        NS_RUNTIMEABORT("__delete__()d (and unexpectedly dying) actor");
        return false;
    default:
        NS_RUNTIMEABORT("corrupted actor state");
        return false;
    }
    (*(next)) = __Error;
    return false;
}

} // namespace PDeviceStorageRequest
} // namespace devicestorage
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct ErrorResponse|
//
namespace mozilla {
namespace dom {
namespace devicestorage {
ErrorResponse::ErrorResponse()
{
    Init();
}

ErrorResponse::~ErrorResponse()
{
}

bool
ErrorResponse::operator==(const ErrorResponse& _o) const
{
    if ((!((error()) == ((_o).error())))) {
        return false;
    }
    return true;
}

void
ErrorResponse::Init()
{
}

void
ErrorResponse::Assign(const nsString& _error)
{
    error_ = _error;
}

} // namespace devicestorage
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct SuccessResponse|
//
namespace mozilla {
namespace dom {
namespace devicestorage {
SuccessResponse::~SuccessResponse()
{
}

bool
SuccessResponse::operator==(const SuccessResponse& _o) const
{
    return true;
}

void
SuccessResponse::Init()
{
}

void
SuccessResponse::Assign()
{
}

} // namespace devicestorage
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct BlobResponse|
//
namespace mozilla {
namespace dom {
namespace devicestorage {
BlobResponse::BlobResponse()
{
    Init();
}

BlobResponse::~BlobResponse()
{
}

bool
BlobResponse::operator==(const BlobResponse& _o) const
{
    if ((!((blobParent()) == ((_o).blobParent())))) {
        return false;
    }
    if ((!((blobChild()) == ((_o).blobChild())))) {
        return false;
    }
    return true;
}

void
BlobResponse::Init()
{
    blobParent_ = 0;
    blobChild_ = 0;
}

void
BlobResponse::Assign(
        PBlobParent* _blobParent,
        PBlobChild* _blobChild)
{
    blobParent_ = _blobParent;
    blobChild_ = _blobChild;
}

} // namespace devicestorage
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct DeviceStorageFileValue|
//
namespace mozilla {
namespace dom {
namespace devicestorage {
DeviceStorageFileValue::DeviceStorageFileValue()
{
    Init();
}

DeviceStorageFileValue::~DeviceStorageFileValue()
{
}

bool
DeviceStorageFileValue::operator==(const DeviceStorageFileValue& _o) const
{
    if ((!((type()) == ((_o).type())))) {
        return false;
    }
    if ((!((name()) == ((_o).name())))) {
        return false;
    }
    if ((!((fullpath()) == ((_o).fullpath())))) {
        return false;
    }
    return true;
}

void
DeviceStorageFileValue::Init()
{
}

void
DeviceStorageFileValue::Assign(
        const nsString& _type,
        const nsString& _name,
        const nsString& _fullpath)
{
    type_ = _type;
    name_ = _name;
    fullpath_ = _fullpath;
}

} // namespace devicestorage
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct EnumerationResponse|
//
namespace mozilla {
namespace dom {
namespace devicestorage {
EnumerationResponse::EnumerationResponse()
{
    Init();
}

EnumerationResponse::~EnumerationResponse()
{
}

bool
EnumerationResponse::operator==(const EnumerationResponse& _o) const
{
    if ((!((paths()) == ((_o).paths())))) {
        return false;
    }
    return true;
}

void
EnumerationResponse::Init()
{
}

void
EnumerationResponse::Assign(const InfallibleTArray<DeviceStorageFileValue>& _paths)
{
    paths_ = _paths;
}

} // namespace devicestorage
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct StatStorageResponse|
//
namespace mozilla {
namespace dom {
namespace devicestorage {
StatStorageResponse::StatStorageResponse()
{
    Init();
}

StatStorageResponse::~StatStorageResponse()
{
}

bool
StatStorageResponse::operator==(const StatStorageResponse& _o) const
{
    if ((!((freeBytes()) == ((_o).freeBytes())))) {
        return false;
    }
    if ((!((totalBytes()) == ((_o).totalBytes())))) {
        return false;
    }
    if ((!((mountState()) == ((_o).mountState())))) {
        return false;
    }
    return true;
}

void
StatStorageResponse::Init()
{
}

void
StatStorageResponse::Assign(
        const int64_t& _freeBytes,
        const int64_t& _totalBytes,
        const nsString& _mountState)
{
    freeBytes_ = _freeBytes;
    totalBytes_ = _totalBytes;
    mountState_ = _mountState;
}

} // namespace devicestorage
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |union DeviceStorageResponseValue|
//
namespace mozilla {
namespace dom {
namespace devicestorage {
bool
DeviceStorageResponseValue::MaybeDestroy(Type aNewType)
{
    if ((mType) == (T__None)) {
        return true;
    }
    if ((mType) == (aNewType)) {
        return false;
    }
    switch (mType) {
    case TErrorResponse:
        {
            (ptr_ErrorResponse())->~ErrorResponse__tdef();
            break;
        }
    case TSuccessResponse:
        {
            (ptr_SuccessResponse())->~SuccessResponse__tdef();
            break;
        }
    case TBlobResponse:
        {
            (ptr_BlobResponse())->~BlobResponse__tdef();
            break;
        }
    case TEnumerationResponse:
        {
            (ptr_EnumerationResponse())->~EnumerationResponse__tdef();
            break;
        }
    case TStatStorageResponse:
        {
            (ptr_StatStorageResponse())->~StatStorageResponse__tdef();
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("not reached");
            break;
        }
    }
    return true;
}

DeviceStorageResponseValue::DeviceStorageResponseValue(const ErrorResponse& aOther)
{
    new (ptr_ErrorResponse()) ErrorResponse(aOther);
    mType = TErrorResponse;
}

DeviceStorageResponseValue::DeviceStorageResponseValue(const SuccessResponse& aOther)
{
    new (ptr_SuccessResponse()) SuccessResponse(aOther);
    mType = TSuccessResponse;
}

DeviceStorageResponseValue::DeviceStorageResponseValue(const BlobResponse& aOther)
{
    new (ptr_BlobResponse()) BlobResponse(aOther);
    mType = TBlobResponse;
}

DeviceStorageResponseValue::DeviceStorageResponseValue(const EnumerationResponse& aOther)
{
    new (ptr_EnumerationResponse()) EnumerationResponse(aOther);
    mType = TEnumerationResponse;
}

DeviceStorageResponseValue::DeviceStorageResponseValue(const StatStorageResponse& aOther)
{
    new (ptr_StatStorageResponse()) StatStorageResponse(aOther);
    mType = TStatStorageResponse;
}

DeviceStorageResponseValue::DeviceStorageResponseValue(const DeviceStorageResponseValue& aOther)
{
    (aOther).AssertSanity();
    switch ((aOther).type()) {
    case TErrorResponse:
        {
            new (ptr_ErrorResponse()) ErrorResponse((aOther).get_ErrorResponse());
            break;
        }
    case TSuccessResponse:
        {
            new (ptr_SuccessResponse()) SuccessResponse((aOther).get_SuccessResponse());
            break;
        }
    case TBlobResponse:
        {
            new (ptr_BlobResponse()) BlobResponse((aOther).get_BlobResponse());
            break;
        }
    case TEnumerationResponse:
        {
            new (ptr_EnumerationResponse()) EnumerationResponse((aOther).get_EnumerationResponse());
            break;
        }
    case TStatStorageResponse:
        {
            new (ptr_StatStorageResponse()) StatStorageResponse((aOther).get_StatStorageResponse());
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return;
        }
    }
    mType = (aOther).type();
}

DeviceStorageResponseValue::~DeviceStorageResponseValue()
{
    MaybeDestroy(T__None);
}

DeviceStorageResponseValue&
DeviceStorageResponseValue::operator=(const ErrorResponse& aRhs)
{
    if (MaybeDestroy(TErrorResponse)) {
        new (ptr_ErrorResponse()) ErrorResponse;
    }
    (*(ptr_ErrorResponse())) = aRhs;
    mType = TErrorResponse;
    return (*(this));
}

DeviceStorageResponseValue&
DeviceStorageResponseValue::operator=(const SuccessResponse& aRhs)
{
    if (MaybeDestroy(TSuccessResponse)) {
        new (ptr_SuccessResponse()) SuccessResponse;
    }
    (*(ptr_SuccessResponse())) = aRhs;
    mType = TSuccessResponse;
    return (*(this));
}

DeviceStorageResponseValue&
DeviceStorageResponseValue::operator=(const BlobResponse& aRhs)
{
    if (MaybeDestroy(TBlobResponse)) {
        new (ptr_BlobResponse()) BlobResponse;
    }
    (*(ptr_BlobResponse())) = aRhs;
    mType = TBlobResponse;
    return (*(this));
}

DeviceStorageResponseValue&
DeviceStorageResponseValue::operator=(const EnumerationResponse& aRhs)
{
    if (MaybeDestroy(TEnumerationResponse)) {
        new (ptr_EnumerationResponse()) EnumerationResponse;
    }
    (*(ptr_EnumerationResponse())) = aRhs;
    mType = TEnumerationResponse;
    return (*(this));
}

DeviceStorageResponseValue&
DeviceStorageResponseValue::operator=(const StatStorageResponse& aRhs)
{
    if (MaybeDestroy(TStatStorageResponse)) {
        new (ptr_StatStorageResponse()) StatStorageResponse;
    }
    (*(ptr_StatStorageResponse())) = aRhs;
    mType = TStatStorageResponse;
    return (*(this));
}

DeviceStorageResponseValue&
DeviceStorageResponseValue::operator=(const DeviceStorageResponseValue& aRhs)
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case TErrorResponse:
        {
            if (MaybeDestroy(t)) {
                new (ptr_ErrorResponse()) ErrorResponse;
            }
            (*(ptr_ErrorResponse())) = (aRhs).get_ErrorResponse();
            break;
        }
    case TSuccessResponse:
        {
            if (MaybeDestroy(t)) {
                new (ptr_SuccessResponse()) SuccessResponse;
            }
            (*(ptr_SuccessResponse())) = (aRhs).get_SuccessResponse();
            break;
        }
    case TBlobResponse:
        {
            if (MaybeDestroy(t)) {
                new (ptr_BlobResponse()) BlobResponse;
            }
            (*(ptr_BlobResponse())) = (aRhs).get_BlobResponse();
            break;
        }
    case TEnumerationResponse:
        {
            if (MaybeDestroy(t)) {
                new (ptr_EnumerationResponse()) EnumerationResponse;
            }
            (*(ptr_EnumerationResponse())) = (aRhs).get_EnumerationResponse();
            break;
        }
    case TStatStorageResponse:
        {
            if (MaybeDestroy(t)) {
                new (ptr_StatStorageResponse()) StatStorageResponse;
            }
            (*(ptr_StatStorageResponse())) = (aRhs).get_StatStorageResponse();
            break;
        }
    case T__None:
        {
            MaybeDestroy(t);
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            break;
        }
    }
    mType = t;
    return (*(this));
}

bool
DeviceStorageResponseValue::operator==(const ErrorResponse& aRhs) const
{
    return (get_ErrorResponse()) == (aRhs);
}

bool
DeviceStorageResponseValue::operator==(const SuccessResponse& aRhs) const
{
    return (get_SuccessResponse()) == (aRhs);
}

bool
DeviceStorageResponseValue::operator==(const BlobResponse& aRhs) const
{
    return (get_BlobResponse()) == (aRhs);
}

bool
DeviceStorageResponseValue::operator==(const EnumerationResponse& aRhs) const
{
    return (get_EnumerationResponse()) == (aRhs);
}

bool
DeviceStorageResponseValue::operator==(const StatStorageResponse& aRhs) const
{
    return (get_StatStorageResponse()) == (aRhs);
}

bool
DeviceStorageResponseValue::operator==(const DeviceStorageResponseValue& aRhs) const
{
    if ((type()) != ((aRhs).type())) {
        return false;
    }

    switch (type()) {
    case TErrorResponse:
        {
            return (get_ErrorResponse()) == ((aRhs).get_ErrorResponse());
        }
    case TSuccessResponse:
        {
            return (get_SuccessResponse()) == ((aRhs).get_SuccessResponse());
        }
    case TBlobResponse:
        {
            return (get_BlobResponse()) == ((aRhs).get_BlobResponse());
        }
    case TEnumerationResponse:
        {
            return (get_EnumerationResponse()) == ((aRhs).get_EnumerationResponse());
        }
    case TStatStorageResponse:
        {
            return (get_StatStorageResponse()) == ((aRhs).get_StatStorageResponse());
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return false;
        }
    }
}

} // namespace devicestorage
} // namespace dom
} // namespace mozilla
