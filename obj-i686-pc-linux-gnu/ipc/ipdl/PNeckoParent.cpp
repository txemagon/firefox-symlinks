//
// Automatically generated by ipdlc.
// Edit at your own risk
//


#include "mozilla/net/PNeckoParent.h"

#include "mozilla/dom/PContentParent.h"
#include "mozilla/net/PHttpChannelParent.h"
#include "mozilla/net/PCookieServiceParent.h"
#include "mozilla/dom/PBrowserParent.h"
#include "mozilla/net/PWyciwygChannelParent.h"
#include "mozilla/net/PFTPChannelParent.h"
#include "mozilla/net/PWebSocketParent.h"
#include "mozilla/net/PTCPSocketParent.h"
#include "mozilla/net/PRemoteOpenFileParent.h"

typedef IPC::Message Message;
typedef mozilla::ipc::RPCChannel Channel;
typedef mozilla::ipc::RPCChannel::RPCListener ChannelListener;
typedef base::ProcessHandle ProcessHandle;
typedef mozilla::ipc::AsyncChannel AsyncChannel;
typedef mozilla::ipc::SharedMemory SharedMemory;
typedef mozilla::ipc::Trigger Trigger;
typedef mozilla::ipc::ActorHandle ActorHandle;
typedef mozilla::ipc::FileDescriptor FileDescriptor;
typedef mozilla::ipc::GenericURIParams GenericURIParams;
typedef mozilla::ipc::JARURIParams JARURIParams;
typedef mozilla::ipc::OptionalURIParams OptionalURIParams;
typedef IPC::SerializedLoadContext SerializedLoadContext;
typedef mozilla::ipc::Shmem Shmem;
typedef mozilla::ipc::SimpleURIParams SimpleURIParams;
typedef mozilla::ipc::StandardURLParams StandardURLParams;
typedef mozilla::ipc::StandardURLSegment StandardURLSegment;
typedef mozilla::ipc::URIParams URIParams;
typedef mozilla::void_t void_t;
using mozilla::dom::PContentParent;
using mozilla::net::PHttpChannelParent;
using mozilla::net::PCookieServiceParent;
using mozilla::dom::PBrowserParent;
using mozilla::net::PWyciwygChannelParent;
using mozilla::net::PFTPChannelParent;
using mozilla::net::PWebSocketParent;
using mozilla::net::PTCPSocketParent;
using mozilla::net::PRemoteOpenFileParent;

namespace mozilla {
namespace net {


bool
PNeckoParent::Recv__delete__()
{
    return true;
}

bool
PNeckoParent::RecvPCookieServiceConstructor(PCookieServiceParent* actor)
{
    return true;
}

bool
PNeckoParent::RecvPHttpChannelConstructor(
        PHttpChannelParent* actor,
        PBrowserParent* browser,
        const SerializedLoadContext& loadContext)
{
    return true;
}

bool
PNeckoParent::RecvPWyciwygChannelConstructor(PWyciwygChannelParent* actor)
{
    return true;
}

bool
PNeckoParent::RecvPFTPChannelConstructor(
        PFTPChannelParent* actor,
        PBrowserParent* browser,
        const SerializedLoadContext& loadContext)
{
    return true;
}

bool
PNeckoParent::RecvPWebSocketConstructor(
        PWebSocketParent* actor,
        PBrowserParent* browser,
        const SerializedLoadContext& loadContext)
{
    return true;
}

bool
PNeckoParent::RecvPTCPSocketConstructor(
        PTCPSocketParent* actor,
        const nsString& host,
        const uint16_t& port,
        const bool& useSSL,
        const nsString& binaryType,
        PBrowserParent* browser)
{
    return true;
}

bool
PNeckoParent::RecvPRemoteOpenFileConstructor(
        PRemoteOpenFileParent* actor,
        const URIParams& fileuri,
        PBrowserParent* browser)
{
    return true;
}

void
PNeckoParent::ActorDestroy(ActorDestroyReason why)
{
}

PNeckoParent::PNeckoParent() :
    mId(0),
    mState(PNecko::__Dead)
{
    MOZ_COUNT_CTOR(PNeckoParent);
}

PNeckoParent::~PNeckoParent()
{
    MOZ_COUNT_DTOR(PNeckoParent);
}

PContentParent*
PNeckoParent::Manager() const
{
    return static_cast<PContentParent*>(mManager);
}

void
PNeckoParent::ManagedPHttpChannelParent(InfallibleTArray<PHttpChannelParent*>& aArr) const
{
    aArr = mManagedPHttpChannelParent;
}

const InfallibleTArray<PHttpChannelParent*>&
PNeckoParent::ManagedPHttpChannelParent() const
{
    return mManagedPHttpChannelParent;
}

void
PNeckoParent::ManagedPCookieServiceParent(InfallibleTArray<PCookieServiceParent*>& aArr) const
{
    aArr = mManagedPCookieServiceParent;
}

const InfallibleTArray<PCookieServiceParent*>&
PNeckoParent::ManagedPCookieServiceParent() const
{
    return mManagedPCookieServiceParent;
}

void
PNeckoParent::ManagedPWyciwygChannelParent(InfallibleTArray<PWyciwygChannelParent*>& aArr) const
{
    aArr = mManagedPWyciwygChannelParent;
}

const InfallibleTArray<PWyciwygChannelParent*>&
PNeckoParent::ManagedPWyciwygChannelParent() const
{
    return mManagedPWyciwygChannelParent;
}

void
PNeckoParent::ManagedPFTPChannelParent(InfallibleTArray<PFTPChannelParent*>& aArr) const
{
    aArr = mManagedPFTPChannelParent;
}

const InfallibleTArray<PFTPChannelParent*>&
PNeckoParent::ManagedPFTPChannelParent() const
{
    return mManagedPFTPChannelParent;
}

void
PNeckoParent::ManagedPWebSocketParent(InfallibleTArray<PWebSocketParent*>& aArr) const
{
    aArr = mManagedPWebSocketParent;
}

const InfallibleTArray<PWebSocketParent*>&
PNeckoParent::ManagedPWebSocketParent() const
{
    return mManagedPWebSocketParent;
}

void
PNeckoParent::ManagedPTCPSocketParent(InfallibleTArray<PTCPSocketParent*>& aArr) const
{
    aArr = mManagedPTCPSocketParent;
}

const InfallibleTArray<PTCPSocketParent*>&
PNeckoParent::ManagedPTCPSocketParent() const
{
    return mManagedPTCPSocketParent;
}

void
PNeckoParent::ManagedPRemoteOpenFileParent(InfallibleTArray<PRemoteOpenFileParent*>& aArr) const
{
    aArr = mManagedPRemoteOpenFileParent;
}

const InfallibleTArray<PRemoteOpenFileParent*>&
PNeckoParent::ManagedPRemoteOpenFileParent() const
{
    return mManagedPRemoteOpenFileParent;
}

PNecko::State
PNeckoParent::state()
{
    return mState;
}

int32_t
PNeckoParent::Register(ChannelListener* aRouted)
{
    return (mManager)->Register(aRouted);
}

int32_t
PNeckoParent::RegisterID(
        ChannelListener* aRouted,
        int32_t aId)
{
    return (mManager)->RegisterID(aRouted, aId);
}

ChannelListener*
PNeckoParent::Lookup(int32_t aId)
{
    return (mManager)->Lookup(aId);
}

void
PNeckoParent::Unregister(int32_t aId)
{
    return (mManager)->Unregister(aId);
}

void
PNeckoParent::RemoveManagee(
        int32_t aProtocolId,
        ChannelListener* aListener)
{
    switch (aProtocolId) {
    case PHttpChannelMsgStart:
        {
            PHttpChannelParent* actor = static_cast<PHttpChannelParent*>(aListener);
            NS_ABORT_IF_FALSE(((mManagedPHttpChannelParent).NoIndex) != ((mManagedPHttpChannelParent).BinaryIndexOf(actor)), "actor not managed by this!");

            (mManagedPHttpChannelParent).RemoveElementSorted(actor);
            DeallocPHttpChannel(actor);
            return;
        }
    case PCookieServiceMsgStart:
        {
            PCookieServiceParent* actor = static_cast<PCookieServiceParent*>(aListener);
            NS_ABORT_IF_FALSE(((mManagedPCookieServiceParent).NoIndex) != ((mManagedPCookieServiceParent).BinaryIndexOf(actor)), "actor not managed by this!");

            (mManagedPCookieServiceParent).RemoveElementSorted(actor);
            DeallocPCookieService(actor);
            return;
        }
    case PWyciwygChannelMsgStart:
        {
            PWyciwygChannelParent* actor = static_cast<PWyciwygChannelParent*>(aListener);
            NS_ABORT_IF_FALSE(((mManagedPWyciwygChannelParent).NoIndex) != ((mManagedPWyciwygChannelParent).BinaryIndexOf(actor)), "actor not managed by this!");

            (mManagedPWyciwygChannelParent).RemoveElementSorted(actor);
            DeallocPWyciwygChannel(actor);
            return;
        }
    case PFTPChannelMsgStart:
        {
            PFTPChannelParent* actor = static_cast<PFTPChannelParent*>(aListener);
            NS_ABORT_IF_FALSE(((mManagedPFTPChannelParent).NoIndex) != ((mManagedPFTPChannelParent).BinaryIndexOf(actor)), "actor not managed by this!");

            (mManagedPFTPChannelParent).RemoveElementSorted(actor);
            DeallocPFTPChannel(actor);
            return;
        }
    case PWebSocketMsgStart:
        {
            PWebSocketParent* actor = static_cast<PWebSocketParent*>(aListener);
            NS_ABORT_IF_FALSE(((mManagedPWebSocketParent).NoIndex) != ((mManagedPWebSocketParent).BinaryIndexOf(actor)), "actor not managed by this!");

            (mManagedPWebSocketParent).RemoveElementSorted(actor);
            DeallocPWebSocket(actor);
            return;
        }
    case PTCPSocketMsgStart:
        {
            PTCPSocketParent* actor = static_cast<PTCPSocketParent*>(aListener);
            NS_ABORT_IF_FALSE(((mManagedPTCPSocketParent).NoIndex) != ((mManagedPTCPSocketParent).BinaryIndexOf(actor)), "actor not managed by this!");

            (mManagedPTCPSocketParent).RemoveElementSorted(actor);
            DeallocPTCPSocket(actor);
            return;
        }
    case PRemoteOpenFileMsgStart:
        {
            PRemoteOpenFileParent* actor = static_cast<PRemoteOpenFileParent*>(aListener);
            NS_ABORT_IF_FALSE(((mManagedPRemoteOpenFileParent).NoIndex) != ((mManagedPRemoteOpenFileParent).BinaryIndexOf(actor)), "actor not managed by this!");

            (mManagedPRemoteOpenFileParent).RemoveElementSorted(actor);
            DeallocPRemoteOpenFile(actor);
            return;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return;
        }
    }
}

Shmem::SharedMemory*
PNeckoParent::CreateSharedMemory(
        size_t aSize,
        Shmem::SharedMemory::SharedMemoryType aType,
        bool aUnsafe,
        Shmem::id_t* aId)
{
    return (mManager)->CreateSharedMemory(aSize, aType, aUnsafe, aId);
}

bool
PNeckoParent::AdoptSharedMemory(
        Shmem::SharedMemory* segment,
        Shmem::id_t* aId)
{
    return (mManager)->AdoptSharedMemory(segment, aId);
}

Shmem::SharedMemory*
PNeckoParent::LookupSharedMemory(Shmem::id_t aId)
{
    return (mManager)->LookupSharedMemory(aId);
}

bool
PNeckoParent::IsTrackingSharedMemory(Shmem::SharedMemory* segment)
{
    return (mManager)->IsTrackingSharedMemory(segment);
}

bool
PNeckoParent::DestroySharedMemory(Shmem& shmem)
{
    return (mManager)->DestroySharedMemory(shmem);
}

ProcessHandle
PNeckoParent::OtherProcess() const
{
    return (mManager)->OtherProcess();
}

AsyncChannel*
PNeckoParent::GetIPCChannel()
{
    return mChannel;
}

PNeckoParent::Result
PNeckoParent::OnMessageReceived(const Message& __msg)
{
    switch ((__msg).type()) {
    case PNecko::Msg___delete____ID:
        {
            (const_cast<Message&>(__msg)).set_name("PNecko::Msg___delete__");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PNecko::Msg___delete__*>((&(__msg))))->Log("[PNeckoParent] Received ", stderr);
            }

            void* __iter = 0;
            PNeckoParent* actor;

            if ((!(Read((&(actor)), (&(__msg)), (&(__iter)), false)))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PNecko::Transition(mState, Trigger(Trigger::Recv, PNecko::Msg___delete____ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(Recv__delete__()))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for __delete__ returned error code");
                return MsgProcessingError;
            }

            (actor)->DestroySubtree(Deletion);
            (actor)->DeallocSubtree();
            ((actor)->mManager)->RemoveManagee(PNeckoMsgStart, actor);


            return MsgProcessed;
        }
    case PNecko::Msg_PCookieServiceConstructor__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PNecko::Msg_PCookieServiceConstructor");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PNecko::Msg_PCookieServiceConstructor*>((&(__msg))))->Log("[PNeckoParent] Received ", stderr);
            }

            void* __iter = 0;
            ActorHandle __handle;
            PCookieServiceParent* actor;

            if ((!(Read((&(__handle)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PNecko::Transition(mState, Trigger(Trigger::Recv, PNecko::Msg_PCookieServiceConstructor__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            actor = AllocPCookieService();
            if ((!(actor))) {
                return MsgValueError;
            }
            (actor)->mId = RegisterID(actor, (__handle).mId);
            (actor)->mManager = this;
            (actor)->mChannel = mChannel;
            (mManagedPCookieServiceParent).InsertElementSorted(actor);
            (actor)->mState = mozilla::net::PCookieService::__Start;

            if ((!(RecvPCookieServiceConstructor(actor)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for PCookieService returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PNecko::Msg_PHttpChannelConstructor__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PNecko::Msg_PHttpChannelConstructor");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PNecko::Msg_PHttpChannelConstructor*>((&(__msg))))->Log("[PNeckoParent] Received ", stderr);
            }

            void* __iter = 0;
            ActorHandle __handle;
            PHttpChannelParent* actor;
            PBrowserParent* browser;
            SerializedLoadContext loadContext;

            if ((!(Read((&(__handle)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(browser)), (&(__msg)), (&(__iter)), true)))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(loadContext)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PNecko::Transition(mState, Trigger(Trigger::Recv, PNecko::Msg_PHttpChannelConstructor__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            actor = AllocPHttpChannel(browser, loadContext);
            if ((!(actor))) {
                return MsgValueError;
            }
            (actor)->mId = RegisterID(actor, (__handle).mId);
            (actor)->mManager = this;
            (actor)->mChannel = mChannel;
            (mManagedPHttpChannelParent).InsertElementSorted(actor);
            (actor)->mState = mozilla::net::PHttpChannel::__Start;

            if ((!(RecvPHttpChannelConstructor(actor, browser, loadContext)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for PHttpChannel returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PNecko::Msg_PWyciwygChannelConstructor__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PNecko::Msg_PWyciwygChannelConstructor");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PNecko::Msg_PWyciwygChannelConstructor*>((&(__msg))))->Log("[PNeckoParent] Received ", stderr);
            }

            void* __iter = 0;
            ActorHandle __handle;
            PWyciwygChannelParent* actor;

            if ((!(Read((&(__handle)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PNecko::Transition(mState, Trigger(Trigger::Recv, PNecko::Msg_PWyciwygChannelConstructor__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            actor = AllocPWyciwygChannel();
            if ((!(actor))) {
                return MsgValueError;
            }
            (actor)->mId = RegisterID(actor, (__handle).mId);
            (actor)->mManager = this;
            (actor)->mChannel = mChannel;
            (mManagedPWyciwygChannelParent).InsertElementSorted(actor);
            (actor)->mState = mozilla::net::PWyciwygChannel::__Start;

            if ((!(RecvPWyciwygChannelConstructor(actor)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for PWyciwygChannel returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PNecko::Msg_PFTPChannelConstructor__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PNecko::Msg_PFTPChannelConstructor");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PNecko::Msg_PFTPChannelConstructor*>((&(__msg))))->Log("[PNeckoParent] Received ", stderr);
            }

            void* __iter = 0;
            ActorHandle __handle;
            PFTPChannelParent* actor;
            PBrowserParent* browser;
            SerializedLoadContext loadContext;

            if ((!(Read((&(__handle)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(browser)), (&(__msg)), (&(__iter)), false)))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(loadContext)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PNecko::Transition(mState, Trigger(Trigger::Recv, PNecko::Msg_PFTPChannelConstructor__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            actor = AllocPFTPChannel(browser, loadContext);
            if ((!(actor))) {
                return MsgValueError;
            }
            (actor)->mId = RegisterID(actor, (__handle).mId);
            (actor)->mManager = this;
            (actor)->mChannel = mChannel;
            (mManagedPFTPChannelParent).InsertElementSorted(actor);
            (actor)->mState = mozilla::net::PFTPChannel::__Start;

            if ((!(RecvPFTPChannelConstructor(actor, browser, loadContext)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for PFTPChannel returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PNecko::Msg_PWebSocketConstructor__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PNecko::Msg_PWebSocketConstructor");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PNecko::Msg_PWebSocketConstructor*>((&(__msg))))->Log("[PNeckoParent] Received ", stderr);
            }

            void* __iter = 0;
            ActorHandle __handle;
            PWebSocketParent* actor;
            PBrowserParent* browser;
            SerializedLoadContext loadContext;

            if ((!(Read((&(__handle)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(browser)), (&(__msg)), (&(__iter)), false)))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(loadContext)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PNecko::Transition(mState, Trigger(Trigger::Recv, PNecko::Msg_PWebSocketConstructor__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            actor = AllocPWebSocket(browser, loadContext);
            if ((!(actor))) {
                return MsgValueError;
            }
            (actor)->mId = RegisterID(actor, (__handle).mId);
            (actor)->mManager = this;
            (actor)->mChannel = mChannel;
            (mManagedPWebSocketParent).InsertElementSorted(actor);
            (actor)->mState = mozilla::net::PWebSocket::__Start;

            if ((!(RecvPWebSocketConstructor(actor, browser, loadContext)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for PWebSocket returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PNecko::Msg_PTCPSocketConstructor__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PNecko::Msg_PTCPSocketConstructor");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PNecko::Msg_PTCPSocketConstructor*>((&(__msg))))->Log("[PNeckoParent] Received ", stderr);
            }

            void* __iter = 0;
            ActorHandle __handle;
            PTCPSocketParent* actor;
            nsString host;
            uint16_t port;
            bool useSSL;
            nsString binaryType;
            PBrowserParent* browser;

            if ((!(Read((&(__handle)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(host)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(port)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(useSSL)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(binaryType)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(browser)), (&(__msg)), (&(__iter)), true)))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PNecko::Transition(mState, Trigger(Trigger::Recv, PNecko::Msg_PTCPSocketConstructor__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            actor = AllocPTCPSocket(host, port, useSSL, binaryType, browser);
            if ((!(actor))) {
                return MsgValueError;
            }
            (actor)->mId = RegisterID(actor, (__handle).mId);
            (actor)->mManager = this;
            (actor)->mChannel = mChannel;
            (mManagedPTCPSocketParent).InsertElementSorted(actor);
            (actor)->mState = mozilla::net::PTCPSocket::__Start;

            if ((!(RecvPTCPSocketConstructor(actor, host, port, useSSL, binaryType, browser)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for PTCPSocket returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PNecko::Msg_PRemoteOpenFileConstructor__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PNecko::Msg_PRemoteOpenFileConstructor");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PNecko::Msg_PRemoteOpenFileConstructor*>((&(__msg))))->Log("[PNeckoParent] Received ", stderr);
            }

            void* __iter = 0;
            ActorHandle __handle;
            PRemoteOpenFileParent* actor;
            URIParams fileuri;
            PBrowserParent* browser;

            if ((!(Read((&(__handle)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(fileuri)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(browser)), (&(__msg)), (&(__iter)), true)))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PNecko::Transition(mState, Trigger(Trigger::Recv, PNecko::Msg_PRemoteOpenFileConstructor__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            actor = AllocPRemoteOpenFile(fileuri, browser);
            if ((!(actor))) {
                return MsgValueError;
            }
            (actor)->mId = RegisterID(actor, (__handle).mId);
            (actor)->mManager = this;
            (actor)->mChannel = mChannel;
            (mManagedPRemoteOpenFileParent).InsertElementSorted(actor);
            (actor)->mState = mozilla::net::PRemoteOpenFile::__Start;

            if ((!(RecvPRemoteOpenFileConstructor(actor, fileuri, browser)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for PRemoteOpenFile returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PNecko::Msg_HTMLDNSPrefetch__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PNecko::Msg_HTMLDNSPrefetch");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PNecko::Msg_HTMLDNSPrefetch*>((&(__msg))))->Log("[PNeckoParent] Received ", stderr);
            }

            void* __iter = 0;
            nsString hostname;
            uint16_t flags;

            if ((!(Read((&(hostname)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(flags)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PNecko::Transition(mState, Trigger(Trigger::Recv, PNecko::Msg_HTMLDNSPrefetch__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvHTMLDNSPrefetch(hostname, flags)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for HTMLDNSPrefetch returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PNecko::Msg_CancelHTMLDNSPrefetch__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PNecko::Msg_CancelHTMLDNSPrefetch");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PNecko::Msg_CancelHTMLDNSPrefetch*>((&(__msg))))->Log("[PNeckoParent] Received ", stderr);
            }

            void* __iter = 0;
            nsString hostname;
            uint16_t flags;
            nsresult reason;

            if ((!(Read((&(hostname)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(flags)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(reason)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PNecko::Transition(mState, Trigger(Trigger::Recv, PNecko::Msg_CancelHTMLDNSPrefetch__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvCancelHTMLDNSPrefetch(hostname, flags, reason)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for CancelHTMLDNSPrefetch returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    default:
        {
            return MsgNotKnown;
        }
    }
}

PNeckoParent::Result
PNeckoParent::OnMessageReceived(
        const Message& __msg,
        Message*& __reply)
{
    return MsgNotKnown;
}

PNeckoParent::Result
PNeckoParent::OnCallReceived(
        const Message& __msg,
        Message*& __reply)
{
    return MsgNotKnown;
}

void
PNeckoParent::OnProcessingError(Result code)
{
    NS_RUNTIMEABORT("`OnProcessingError' called on non-toplevel actor");
}

int32_t
PNeckoParent::GetProtocolTypeId()
{
    return PNeckoMsgStart;
}

bool
PNeckoParent::OnReplyTimeout()
{
    NS_RUNTIMEABORT("`OnReplyTimeout' called on non-toplevel actor");
    return false;
}

void
PNeckoParent::OnChannelClose()
{
    NS_RUNTIMEABORT("`OnClose' called on non-toplevel actor");
}

void
PNeckoParent::OnChannelError()
{
    NS_RUNTIMEABORT("`OnError' called on non-toplevel actor");
}

void
PNeckoParent::OnChannelConnected(int32_t pid)
{
    NS_RUNTIMEABORT("'OnConnected' called on non-toplevel actor");
}

bool
PNeckoParent::AllocShmem(
        size_t aSize,
        Shmem::SharedMemory::SharedMemoryType aType,
        Shmem* aMem)
{
    Shmem::id_t aId;
    nsAutoPtr<Shmem::SharedMemory> rawmem(CreateSharedMemory(aSize, aType, false, (&(aId))));
    if ((!(rawmem))) {
        return false;
    }

    (*(aMem)) = Shmem(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(), (rawmem).forget(), aId);
    return true;
}

bool
PNeckoParent::AllocUnsafeShmem(
        size_t aSize,
        Shmem::SharedMemory::SharedMemoryType aType,
        Shmem* aMem)
{
    Shmem::id_t aId;
    nsAutoPtr<Shmem::SharedMemory> rawmem(CreateSharedMemory(aSize, aType, true, (&(aId))));
    if ((!(rawmem))) {
        return false;
    }

    (*(aMem)) = Shmem(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(), (rawmem).forget(), aId);
    return true;
}

bool
PNeckoParent::AdoptShmem(
        Shmem& aMem,
        Shmem* aOutMem)
{
    Shmem::SharedMemory* rawmem = (aMem).Segment(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead());
    if (((!(rawmem))) || (IsTrackingSharedMemory(rawmem))) {
        NS_RUNTIMEABORT("bad Shmem");
    }

    Shmem::id_t aId;
    if ((!(AdoptSharedMemory(rawmem, (&(aId)))))) {
        return false;
    }

    (*(aOutMem)) = Shmem(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(), rawmem, aId);
    return true;
}

bool
PNeckoParent::DeallocShmem(Shmem& aMem)
{
    bool ok = DestroySharedMemory(aMem);
    (aMem).forget(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead());
    return ok;
}

void
PNeckoParent::FatalError(const char* const msg) const
{
    // Virtual method to prevent inlining.
    // This give us better error reporting.
    // See bug 589371

    NS_ERROR("IPDL error:");
    NS_ERROR(msg);
    mozilla::ipc::ProtocolErrorBreakpoint(msg);

    NS_ERROR("[PNeckoParent] killing child side as a result");

    if ((!(base::KillProcess(OtherProcess(), base::PROCESS_END_KILLED_BY_USER, false)))) {
        NS_ERROR("  may have failed to kill child!");
    }
}

void
PNeckoParent::DestroySubtree(ActorDestroyReason why)
{
    // Unregister from our manager.
    Unregister(mId);
    mId = 1;

    ActorDestroyReason subtreewhy = (((why) == (Deletion)) || ((why) == (FailedConstructor)) ? AncestorDeletion : why);

    {
        // Recursively shutting down PHttpChannel kids
        InfallibleTArray<PHttpChannelParent*> kids(mManagedPHttpChannelParent);
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DestroySubtree(subtreewhy);
        }
    }
    {
        // Recursively shutting down PCookieService kids
        InfallibleTArray<PCookieServiceParent*> kids(mManagedPCookieServiceParent);
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DestroySubtree(subtreewhy);
        }
    }
    {
        // Recursively shutting down PWyciwygChannel kids
        InfallibleTArray<PWyciwygChannelParent*> kids(mManagedPWyciwygChannelParent);
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DestroySubtree(subtreewhy);
        }
    }
    {
        // Recursively shutting down PFTPChannel kids
        InfallibleTArray<PFTPChannelParent*> kids(mManagedPFTPChannelParent);
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DestroySubtree(subtreewhy);
        }
    }
    {
        // Recursively shutting down PWebSocket kids
        InfallibleTArray<PWebSocketParent*> kids(mManagedPWebSocketParent);
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DestroySubtree(subtreewhy);
        }
    }
    {
        // Recursively shutting down PTCPSocket kids
        InfallibleTArray<PTCPSocketParent*> kids(mManagedPTCPSocketParent);
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DestroySubtree(subtreewhy);
        }
    }
    {
        // Recursively shutting down PRemoteOpenFile kids
        InfallibleTArray<PRemoteOpenFileParent*> kids(mManagedPRemoteOpenFileParent);
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DestroySubtree(subtreewhy);
        }
    }

    // Finally, destroy "us".
    ActorDestroy(why);
}

void
PNeckoParent::DeallocSubtree()
{
    {
        // Recursively deleting PHttpChannel kids
        InfallibleTArray<PHttpChannelParent*>& kids = mManagedPHttpChannelParent;
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DeallocSubtree();
        }

        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            DeallocPHttpChannel(kids[i]);
        }
        (mManagedPHttpChannelParent).Clear();
    }
    {
        // Recursively deleting PCookieService kids
        InfallibleTArray<PCookieServiceParent*>& kids = mManagedPCookieServiceParent;
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DeallocSubtree();
        }

        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            DeallocPCookieService(kids[i]);
        }
        (mManagedPCookieServiceParent).Clear();
    }
    {
        // Recursively deleting PWyciwygChannel kids
        InfallibleTArray<PWyciwygChannelParent*>& kids = mManagedPWyciwygChannelParent;
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DeallocSubtree();
        }

        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            DeallocPWyciwygChannel(kids[i]);
        }
        (mManagedPWyciwygChannelParent).Clear();
    }
    {
        // Recursively deleting PFTPChannel kids
        InfallibleTArray<PFTPChannelParent*>& kids = mManagedPFTPChannelParent;
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DeallocSubtree();
        }

        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            DeallocPFTPChannel(kids[i]);
        }
        (mManagedPFTPChannelParent).Clear();
    }
    {
        // Recursively deleting PWebSocket kids
        InfallibleTArray<PWebSocketParent*>& kids = mManagedPWebSocketParent;
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DeallocSubtree();
        }

        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            DeallocPWebSocket(kids[i]);
        }
        (mManagedPWebSocketParent).Clear();
    }
    {
        // Recursively deleting PTCPSocket kids
        InfallibleTArray<PTCPSocketParent*>& kids = mManagedPTCPSocketParent;
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DeallocSubtree();
        }

        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            DeallocPTCPSocket(kids[i]);
        }
        (mManagedPTCPSocketParent).Clear();
    }
    {
        // Recursively deleting PRemoteOpenFile kids
        InfallibleTArray<PRemoteOpenFileParent*>& kids = mManagedPRemoteOpenFileParent;
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DeallocSubtree();
        }

        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            DeallocPRemoteOpenFile(kids[i]);
        }
        (mManagedPRemoteOpenFileParent).Clear();
    }
}

void
PNeckoParent::Write(
        PHttpChannelParent* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PNeckoParent::Read(
        PHttpChannelParent** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PNecko");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PHttpChannel");
        return false;
    }

    if ((PHttpChannelMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PHttpChannel has different type");
        return false;
    }

    (*(__v)) = static_cast<PHttpChannelParent*>(listener);
    return true;
}

void
PNeckoParent::Write(
        PWyciwygChannelParent* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PNeckoParent::Read(
        PWyciwygChannelParent** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PNecko");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PWyciwygChannel");
        return false;
    }

    if ((PWyciwygChannelMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PWyciwygChannel has different type");
        return false;
    }

    (*(__v)) = static_cast<PWyciwygChannelParent*>(listener);
    return true;
}

void
PNeckoParent::Write(
        PBrowserParent* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PNeckoParent::Read(
        PBrowserParent** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PNecko");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PBrowser");
        return false;
    }

    if ((PBrowserMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PBrowser has different type");
        return false;
    }

    (*(__v)) = static_cast<PBrowserParent*>(listener);
    return true;
}

void
PNeckoParent::Write(
        PTCPSocketParent* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PNeckoParent::Read(
        PTCPSocketParent** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PNecko");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PTCPSocket");
        return false;
    }

    if ((PTCPSocketMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PTCPSocket has different type");
        return false;
    }

    (*(__v)) = static_cast<PTCPSocketParent*>(listener);
    return true;
}

void
PNeckoParent::Write(
        PRemoteOpenFileParent* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PNeckoParent::Read(
        PRemoteOpenFileParent** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PNecko");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PRemoteOpenFile");
        return false;
    }

    if ((PRemoteOpenFileMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PRemoteOpenFile has different type");
        return false;
    }

    (*(__v)) = static_cast<PRemoteOpenFileParent*>(listener);
    return true;
}

void
PNeckoParent::Write(
        const StandardURLSegment& __v,
        Message* __msg)
{
    Write((__v).position(), __msg);
    Write((__v).length(), __msg);
}

bool
PNeckoParent::Read(
        StandardURLSegment* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->position())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->length())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PNeckoParent::Write(
        const StandardURLParams& __v,
        Message* __msg)
{
    Write((__v).urlType(), __msg);
    Write((__v).port(), __msg);
    Write((__v).defaultPort(), __msg);
    Write((__v).spec(), __msg);
    Write((__v).scheme(), __msg);
    Write((__v).authority(), __msg);
    Write((__v).username(), __msg);
    Write((__v).password(), __msg);
    Write((__v).host(), __msg);
    Write((__v).path(), __msg);
    Write((__v).filePath(), __msg);
    Write((__v).directory(), __msg);
    Write((__v).baseName(), __msg);
    Write((__v).extension(), __msg);
    Write((__v).query(), __msg);
    Write((__v).ref(), __msg);
    Write((__v).originCharset(), __msg);
    Write((__v).isMutable(), __msg);
    Write((__v).supportsFileURL(), __msg);
    Write((__v).hostEncoding(), __msg);
}

bool
PNeckoParent::Read(
        StandardURLParams* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->urlType())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->port())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->defaultPort())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->spec())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->scheme())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->authority())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->username())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->password())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->host())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->path())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->filePath())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->directory())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->baseName())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->extension())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->query())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->ref())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->originCharset())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->isMutable())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->supportsFileURL())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->hostEncoding())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PNeckoParent::Write(
        PNeckoParent* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PNeckoParent::Read(
        PNeckoParent** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PNecko");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PNecko");
        return false;
    }

    if ((PNeckoMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PNecko has different type");
        return false;
    }

    (*(__v)) = static_cast<PNeckoParent*>(listener);
    return true;
}

void
PNeckoParent::Write(
        const JARURIParams& __v,
        Message* __msg)
{
    Write((__v).jarFile(), __msg);
    Write((__v).jarEntry(), __msg);
    Write((__v).charset(), __msg);
}

bool
PNeckoParent::Read(
        JARURIParams* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->jarFile())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->jarEntry())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->charset())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PNeckoParent::Write(
        const URIParams& __v,
        Message* __msg)
{
    typedef URIParams __type;
    Write(int((__v).type()), __msg);

    switch ((__v).type()) {
    case __type::TSimpleURIParams:
        {
            Write((__v).get_SimpleURIParams(), __msg);
            return;
        }
    case __type::TStandardURLParams:
        {
            Write((__v).get_StandardURLParams(), __msg);
            return;
        }
    case __type::TJARURIParams:
        {
            Write((__v).get_JARURIParams(), __msg);
            return;
        }
    case __type::TGenericURIParams:
        {
            Write((__v).get_GenericURIParams(), __msg);
            return;
        }
    default:
        {
            NS_RUNTIMEABORT("unknown union type");
            return;
        }
    }
}

bool
PNeckoParent::Read(
        URIParams* __v,
        const Message* __msg,
        void** __iter)
{
    typedef URIParams __type;
    int type;
    if ((!(Read((&(type)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }

    switch (type) {
    case __type::TSimpleURIParams:
        {
            SimpleURIParams tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_SimpleURIParams())), __msg, __iter);
        }
    case __type::TStandardURLParams:
        {
            StandardURLParams tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_StandardURLParams())), __msg, __iter);
        }
    case __type::TJARURIParams:
        {
            JARURIParams tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_JARURIParams())), __msg, __iter);
        }
    case __type::TGenericURIParams:
        {
            GenericURIParams tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_GenericURIParams())), __msg, __iter);
        }
    default:
        {
            mozilla::ipc::ProtocolErrorBreakpoint("unknown union type");
            return false;
        }
    }
}

void
PNeckoParent::Write(
        PFTPChannelParent* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PNeckoParent::Read(
        PFTPChannelParent** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PNecko");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PFTPChannel");
        return false;
    }

    if ((PFTPChannelMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PFTPChannel has different type");
        return false;
    }

    (*(__v)) = static_cast<PFTPChannelParent*>(listener);
    return true;
}

void
PNeckoParent::Write(
        PWebSocketParent* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PNeckoParent::Read(
        PWebSocketParent** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PNecko");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PWebSocket");
        return false;
    }

    if ((PWebSocketMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PWebSocket has different type");
        return false;
    }

    (*(__v)) = static_cast<PWebSocketParent*>(listener);
    return true;
}

void
PNeckoParent::Write(
        const SimpleURIParams& __v,
        Message* __msg)
{
    Write((__v).scheme(), __msg);
    Write((__v).path(), __msg);
    Write((__v).ref(), __msg);
    Write((__v).isMutable(), __msg);
}

bool
PNeckoParent::Read(
        SimpleURIParams* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->scheme())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->path())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->ref())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->isMutable())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PNeckoParent::Write(
        PCookieServiceParent* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PNeckoParent::Read(
        PCookieServiceParent** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PNecko");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PCookieService");
        return false;
    }

    if ((PCookieServiceMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PCookieService has different type");
        return false;
    }

    (*(__v)) = static_cast<PCookieServiceParent*>(listener);
    return true;
}

void
PNeckoParent::Write(
        const GenericURIParams& __v,
        Message* __msg)
{
    Write((__v).spec(), __msg);
    Write((__v).charset(), __msg);
}

bool
PNeckoParent::Read(
        GenericURIParams* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->spec())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->charset())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}



} // namespace net
} // namespace mozilla
