//
// Automatically generated by ipdlc.
// Edit at your own risk
//


#include "mozilla/dom/PContent.h"

namespace mozilla {
namespace dom {
namespace PContent {

bool
Transition(
        State from,
        mozilla::ipc::Trigger trigger,
        State* next)
{
    switch (from) {
    case __Null:
    case __Error:
        return (__Null) == (from);
    case __Dead:
        NS_RUNTIMEABORT("__delete__()d actor");
        return false;
    case __Dying:
        NS_RUNTIMEABORT("__delete__()d (and unexpectedly dying) actor");
        return false;
    default:
        NS_RUNTIMEABORT("corrupted actor state");
        return false;
    }
    (*(next)) = __Error;
    return false;
}

} // namespace PContent
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct StorageClone|
//
namespace mozilla {
namespace dom {
StorageClone::StorageClone()
{
    Init();
}

StorageClone::~StorageClone()
{
}

bool
StorageClone::operator==(const StorageClone& _o) const
{
    if ((!((actorParent()) == ((_o).actorParent())))) {
        return false;
    }
    if ((!((actorChild()) == ((_o).actorChild())))) {
        return false;
    }
    if ((!((callerSecure()) == ((_o).callerSecure())))) {
        return false;
    }
    return true;
}

void
StorageClone::Init()
{
    actorParent_ = 0;
    actorChild_ = 0;
}

void
StorageClone::Assign(
        PStorageParent* _actorParent,
        PStorageChild* _actorChild,
        const bool& _callerSecure)
{
    actorParent_ = _actorParent;
    actorChild_ = _actorChild;
    callerSecure_ = _callerSecure;
}

} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |union StorageConstructData|
//
namespace mozilla {
namespace dom {
bool
StorageConstructData::MaybeDestroy(Type aNewType)
{
    if ((mType) == (T__None)) {
        return true;
    }
    if ((mType) == (aNewType)) {
        return false;
    }
    switch (mType) {
    case Tnull_t:
        {
            (ptr_null_t())->~null_t__tdef();
            break;
        }
    case TStorageClone:
        {
            (ptr_StorageClone())->~StorageClone__tdef();
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("not reached");
            break;
        }
    }
    return true;
}

StorageConstructData::StorageConstructData(const null_t& aOther)
{
    new (ptr_null_t()) null_t(aOther);
    mType = Tnull_t;
}

StorageConstructData::StorageConstructData(const StorageClone& aOther)
{
    new (ptr_StorageClone()) StorageClone(aOther);
    mType = TStorageClone;
}

StorageConstructData::StorageConstructData(const StorageConstructData& aOther)
{
    (aOther).AssertSanity();
    switch ((aOther).type()) {
    case Tnull_t:
        {
            new (ptr_null_t()) null_t((aOther).get_null_t());
            break;
        }
    case TStorageClone:
        {
            new (ptr_StorageClone()) StorageClone((aOther).get_StorageClone());
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return;
        }
    }
    mType = (aOther).type();
}

StorageConstructData::~StorageConstructData()
{
    MaybeDestroy(T__None);
}

StorageConstructData&
StorageConstructData::operator=(const null_t& aRhs)
{
    if (MaybeDestroy(Tnull_t)) {
        new (ptr_null_t()) null_t;
    }
    (*(ptr_null_t())) = aRhs;
    mType = Tnull_t;
    return (*(this));
}

StorageConstructData&
StorageConstructData::operator=(const StorageClone& aRhs)
{
    if (MaybeDestroy(TStorageClone)) {
        new (ptr_StorageClone()) StorageClone;
    }
    (*(ptr_StorageClone())) = aRhs;
    mType = TStorageClone;
    return (*(this));
}

StorageConstructData&
StorageConstructData::operator=(const StorageConstructData& aRhs)
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case Tnull_t:
        {
            if (MaybeDestroy(t)) {
                new (ptr_null_t()) null_t;
            }
            (*(ptr_null_t())) = (aRhs).get_null_t();
            break;
        }
    case TStorageClone:
        {
            if (MaybeDestroy(t)) {
                new (ptr_StorageClone()) StorageClone;
            }
            (*(ptr_StorageClone())) = (aRhs).get_StorageClone();
            break;
        }
    case T__None:
        {
            MaybeDestroy(t);
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            break;
        }
    }
    mType = t;
    return (*(this));
}

bool
StorageConstructData::operator==(const null_t& aRhs) const
{
    return (get_null_t()) == (aRhs);
}

bool
StorageConstructData::operator==(const StorageClone& aRhs) const
{
    return (get_StorageClone()) == (aRhs);
}

bool
StorageConstructData::operator==(const StorageConstructData& aRhs) const
{
    if ((type()) != ((aRhs).type())) {
        return false;
    }

    switch (type()) {
    case Tnull_t:
        {
            return (get_null_t()) == ((aRhs).get_null_t());
        }
    case TStorageClone:
        {
            return (get_StorageClone()) == ((aRhs).get_StorageClone());
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return false;
        }
    }
}

} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct FontListEntry|
//
namespace mozilla {
namespace dom {
FontListEntry::FontListEntry()
{
    Init();
}

FontListEntry::~FontListEntry()
{
}

bool
FontListEntry::operator==(const FontListEntry& _o) const
{
    if ((!((familyName()) == ((_o).familyName())))) {
        return false;
    }
    if ((!((faceName()) == ((_o).faceName())))) {
        return false;
    }
    if ((!((filepath()) == ((_o).filepath())))) {
        return false;
    }
    if ((!((weight()) == ((_o).weight())))) {
        return false;
    }
    if ((!((stretch()) == ((_o).stretch())))) {
        return false;
    }
    if ((!((italic()) == ((_o).italic())))) {
        return false;
    }
    if ((!((index()) == ((_o).index())))) {
        return false;
    }
    return true;
}

void
FontListEntry::Init()
{
}

void
FontListEntry::Assign(
        const nsString& _familyName,
        const nsString& _faceName,
        const nsCString& _filepath,
        const uint16_t& _weight,
        const int16_t& _stretch,
        const uint8_t& _italic,
        const uint8_t& _index)
{
    familyName_ = _familyName;
    faceName_ = _faceName;
    filepath_ = _filepath;
    weight_ = _weight;
    stretch_ = _stretch;
    italic_ = _italic;
    index_ = _index;
}

} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct DeviceStorageStatParams|
//
namespace mozilla {
namespace dom {
DeviceStorageStatParams::DeviceStorageStatParams()
{
    Init();
}

DeviceStorageStatParams::~DeviceStorageStatParams()
{
}

bool
DeviceStorageStatParams::operator==(const DeviceStorageStatParams& _o) const
{
    if ((!((type()) == ((_o).type())))) {
        return false;
    }
    if ((!((fullpath()) == ((_o).fullpath())))) {
        return false;
    }
    return true;
}

void
DeviceStorageStatParams::Init()
{
}

void
DeviceStorageStatParams::Assign(
        const nsString& _type,
        const nsString& _fullpath)
{
    type_ = _type;
    fullpath_ = _fullpath;
}

} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct DeviceStorageAddParams|
//
namespace mozilla {
namespace dom {
DeviceStorageAddParams::DeviceStorageAddParams()
{
    Init();
}

DeviceStorageAddParams::~DeviceStorageAddParams()
{
}

bool
DeviceStorageAddParams::operator==(const DeviceStorageAddParams& _o) const
{
    if ((!((type()) == ((_o).type())))) {
        return false;
    }
    if ((!((blobParent()) == ((_o).blobParent())))) {
        return false;
    }
    if ((!((blobChild()) == ((_o).blobChild())))) {
        return false;
    }
    if ((!((name()) == ((_o).name())))) {
        return false;
    }
    if ((!((fullpath()) == ((_o).fullpath())))) {
        return false;
    }
    return true;
}

void
DeviceStorageAddParams::Init()
{
    blobParent_ = 0;
    blobChild_ = 0;
}

void
DeviceStorageAddParams::Assign(
        const nsString& _type,
        PBlobParent* _blobParent,
        PBlobChild* _blobChild,
        const nsString& _name,
        const nsString& _fullpath)
{
    type_ = _type;
    blobParent_ = _blobParent;
    blobChild_ = _blobChild;
    name_ = _name;
    fullpath_ = _fullpath;
}

} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct DeviceStorageGetParams|
//
namespace mozilla {
namespace dom {
DeviceStorageGetParams::DeviceStorageGetParams()
{
    Init();
}

DeviceStorageGetParams::~DeviceStorageGetParams()
{
}

bool
DeviceStorageGetParams::operator==(const DeviceStorageGetParams& _o) const
{
    if ((!((type()) == ((_o).type())))) {
        return false;
    }
    if ((!((name()) == ((_o).name())))) {
        return false;
    }
    if ((!((fullpath()) == ((_o).fullpath())))) {
        return false;
    }
    return true;
}

void
DeviceStorageGetParams::Init()
{
}

void
DeviceStorageGetParams::Assign(
        const nsString& _type,
        const nsString& _name,
        const nsString& _fullpath)
{
    type_ = _type;
    name_ = _name;
    fullpath_ = _fullpath;
}

} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct DeviceStorageDeleteParams|
//
namespace mozilla {
namespace dom {
DeviceStorageDeleteParams::DeviceStorageDeleteParams()
{
    Init();
}

DeviceStorageDeleteParams::~DeviceStorageDeleteParams()
{
}

bool
DeviceStorageDeleteParams::operator==(const DeviceStorageDeleteParams& _o) const
{
    if ((!((type()) == ((_o).type())))) {
        return false;
    }
    if ((!((fullpath()) == ((_o).fullpath())))) {
        return false;
    }
    return true;
}

void
DeviceStorageDeleteParams::Init()
{
}

void
DeviceStorageDeleteParams::Assign(
        const nsString& _type,
        const nsString& _fullpath)
{
    type_ = _type;
    fullpath_ = _fullpath;
}

} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct DeviceStorageEnumerationParams|
//
namespace mozilla {
namespace dom {
DeviceStorageEnumerationParams::DeviceStorageEnumerationParams()
{
    Init();
}

DeviceStorageEnumerationParams::~DeviceStorageEnumerationParams()
{
}

bool
DeviceStorageEnumerationParams::operator==(const DeviceStorageEnumerationParams& _o) const
{
    if ((!((type()) == ((_o).type())))) {
        return false;
    }
    if ((!((fullpath()) == ((_o).fullpath())))) {
        return false;
    }
    if ((!((since()) == ((_o).since())))) {
        return false;
    }
    return true;
}

void
DeviceStorageEnumerationParams::Init()
{
}

void
DeviceStorageEnumerationParams::Assign(
        const nsString& _type,
        const nsString& _fullpath,
        const uint64_t& _since)
{
    type_ = _type;
    fullpath_ = _fullpath;
    since_ = _since;
}

} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |union DeviceStorageParams|
//
namespace mozilla {
namespace dom {
bool
DeviceStorageParams::MaybeDestroy(Type aNewType)
{
    if ((mType) == (T__None)) {
        return true;
    }
    if ((mType) == (aNewType)) {
        return false;
    }
    switch (mType) {
    case TDeviceStorageAddParams:
        {
            (ptr_DeviceStorageAddParams())->~DeviceStorageAddParams__tdef();
            break;
        }
    case TDeviceStorageGetParams:
        {
            (ptr_DeviceStorageGetParams())->~DeviceStorageGetParams__tdef();
            break;
        }
    case TDeviceStorageDeleteParams:
        {
            (ptr_DeviceStorageDeleteParams())->~DeviceStorageDeleteParams__tdef();
            break;
        }
    case TDeviceStorageEnumerationParams:
        {
            (ptr_DeviceStorageEnumerationParams())->~DeviceStorageEnumerationParams__tdef();
            break;
        }
    case TDeviceStorageStatParams:
        {
            (ptr_DeviceStorageStatParams())->~DeviceStorageStatParams__tdef();
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("not reached");
            break;
        }
    }
    return true;
}

DeviceStorageParams::DeviceStorageParams(const DeviceStorageAddParams& aOther)
{
    new (ptr_DeviceStorageAddParams()) DeviceStorageAddParams(aOther);
    mType = TDeviceStorageAddParams;
}

DeviceStorageParams::DeviceStorageParams(const DeviceStorageGetParams& aOther)
{
    new (ptr_DeviceStorageGetParams()) DeviceStorageGetParams(aOther);
    mType = TDeviceStorageGetParams;
}

DeviceStorageParams::DeviceStorageParams(const DeviceStorageDeleteParams& aOther)
{
    new (ptr_DeviceStorageDeleteParams()) DeviceStorageDeleteParams(aOther);
    mType = TDeviceStorageDeleteParams;
}

DeviceStorageParams::DeviceStorageParams(const DeviceStorageEnumerationParams& aOther)
{
    new (ptr_DeviceStorageEnumerationParams()) DeviceStorageEnumerationParams(aOther);
    mType = TDeviceStorageEnumerationParams;
}

DeviceStorageParams::DeviceStorageParams(const DeviceStorageStatParams& aOther)
{
    new (ptr_DeviceStorageStatParams()) DeviceStorageStatParams(aOther);
    mType = TDeviceStorageStatParams;
}

DeviceStorageParams::DeviceStorageParams(const DeviceStorageParams& aOther)
{
    (aOther).AssertSanity();
    switch ((aOther).type()) {
    case TDeviceStorageAddParams:
        {
            new (ptr_DeviceStorageAddParams()) DeviceStorageAddParams((aOther).get_DeviceStorageAddParams());
            break;
        }
    case TDeviceStorageGetParams:
        {
            new (ptr_DeviceStorageGetParams()) DeviceStorageGetParams((aOther).get_DeviceStorageGetParams());
            break;
        }
    case TDeviceStorageDeleteParams:
        {
            new (ptr_DeviceStorageDeleteParams()) DeviceStorageDeleteParams((aOther).get_DeviceStorageDeleteParams());
            break;
        }
    case TDeviceStorageEnumerationParams:
        {
            new (ptr_DeviceStorageEnumerationParams()) DeviceStorageEnumerationParams((aOther).get_DeviceStorageEnumerationParams());
            break;
        }
    case TDeviceStorageStatParams:
        {
            new (ptr_DeviceStorageStatParams()) DeviceStorageStatParams((aOther).get_DeviceStorageStatParams());
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return;
        }
    }
    mType = (aOther).type();
}

DeviceStorageParams::~DeviceStorageParams()
{
    MaybeDestroy(T__None);
}

DeviceStorageParams&
DeviceStorageParams::operator=(const DeviceStorageAddParams& aRhs)
{
    if (MaybeDestroy(TDeviceStorageAddParams)) {
        new (ptr_DeviceStorageAddParams()) DeviceStorageAddParams;
    }
    (*(ptr_DeviceStorageAddParams())) = aRhs;
    mType = TDeviceStorageAddParams;
    return (*(this));
}

DeviceStorageParams&
DeviceStorageParams::operator=(const DeviceStorageGetParams& aRhs)
{
    if (MaybeDestroy(TDeviceStorageGetParams)) {
        new (ptr_DeviceStorageGetParams()) DeviceStorageGetParams;
    }
    (*(ptr_DeviceStorageGetParams())) = aRhs;
    mType = TDeviceStorageGetParams;
    return (*(this));
}

DeviceStorageParams&
DeviceStorageParams::operator=(const DeviceStorageDeleteParams& aRhs)
{
    if (MaybeDestroy(TDeviceStorageDeleteParams)) {
        new (ptr_DeviceStorageDeleteParams()) DeviceStorageDeleteParams;
    }
    (*(ptr_DeviceStorageDeleteParams())) = aRhs;
    mType = TDeviceStorageDeleteParams;
    return (*(this));
}

DeviceStorageParams&
DeviceStorageParams::operator=(const DeviceStorageEnumerationParams& aRhs)
{
    if (MaybeDestroy(TDeviceStorageEnumerationParams)) {
        new (ptr_DeviceStorageEnumerationParams()) DeviceStorageEnumerationParams;
    }
    (*(ptr_DeviceStorageEnumerationParams())) = aRhs;
    mType = TDeviceStorageEnumerationParams;
    return (*(this));
}

DeviceStorageParams&
DeviceStorageParams::operator=(const DeviceStorageStatParams& aRhs)
{
    if (MaybeDestroy(TDeviceStorageStatParams)) {
        new (ptr_DeviceStorageStatParams()) DeviceStorageStatParams;
    }
    (*(ptr_DeviceStorageStatParams())) = aRhs;
    mType = TDeviceStorageStatParams;
    return (*(this));
}

DeviceStorageParams&
DeviceStorageParams::operator=(const DeviceStorageParams& aRhs)
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case TDeviceStorageAddParams:
        {
            if (MaybeDestroy(t)) {
                new (ptr_DeviceStorageAddParams()) DeviceStorageAddParams;
            }
            (*(ptr_DeviceStorageAddParams())) = (aRhs).get_DeviceStorageAddParams();
            break;
        }
    case TDeviceStorageGetParams:
        {
            if (MaybeDestroy(t)) {
                new (ptr_DeviceStorageGetParams()) DeviceStorageGetParams;
            }
            (*(ptr_DeviceStorageGetParams())) = (aRhs).get_DeviceStorageGetParams();
            break;
        }
    case TDeviceStorageDeleteParams:
        {
            if (MaybeDestroy(t)) {
                new (ptr_DeviceStorageDeleteParams()) DeviceStorageDeleteParams;
            }
            (*(ptr_DeviceStorageDeleteParams())) = (aRhs).get_DeviceStorageDeleteParams();
            break;
        }
    case TDeviceStorageEnumerationParams:
        {
            if (MaybeDestroy(t)) {
                new (ptr_DeviceStorageEnumerationParams()) DeviceStorageEnumerationParams;
            }
            (*(ptr_DeviceStorageEnumerationParams())) = (aRhs).get_DeviceStorageEnumerationParams();
            break;
        }
    case TDeviceStorageStatParams:
        {
            if (MaybeDestroy(t)) {
                new (ptr_DeviceStorageStatParams()) DeviceStorageStatParams;
            }
            (*(ptr_DeviceStorageStatParams())) = (aRhs).get_DeviceStorageStatParams();
            break;
        }
    case T__None:
        {
            MaybeDestroy(t);
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            break;
        }
    }
    mType = t;
    return (*(this));
}

bool
DeviceStorageParams::operator==(const DeviceStorageAddParams& aRhs) const
{
    return (get_DeviceStorageAddParams()) == (aRhs);
}

bool
DeviceStorageParams::operator==(const DeviceStorageGetParams& aRhs) const
{
    return (get_DeviceStorageGetParams()) == (aRhs);
}

bool
DeviceStorageParams::operator==(const DeviceStorageDeleteParams& aRhs) const
{
    return (get_DeviceStorageDeleteParams()) == (aRhs);
}

bool
DeviceStorageParams::operator==(const DeviceStorageEnumerationParams& aRhs) const
{
    return (get_DeviceStorageEnumerationParams()) == (aRhs);
}

bool
DeviceStorageParams::operator==(const DeviceStorageStatParams& aRhs) const
{
    return (get_DeviceStorageStatParams()) == (aRhs);
}

bool
DeviceStorageParams::operator==(const DeviceStorageParams& aRhs) const
{
    if ((type()) != ((aRhs).type())) {
        return false;
    }

    switch (type()) {
    case TDeviceStorageAddParams:
        {
            return (get_DeviceStorageAddParams()) == ((aRhs).get_DeviceStorageAddParams());
        }
    case TDeviceStorageGetParams:
        {
            return (get_DeviceStorageGetParams()) == ((aRhs).get_DeviceStorageGetParams());
        }
    case TDeviceStorageDeleteParams:
        {
            return (get_DeviceStorageDeleteParams()) == ((aRhs).get_DeviceStorageDeleteParams());
        }
    case TDeviceStorageEnumerationParams:
        {
            return (get_DeviceStorageEnumerationParams()) == ((aRhs).get_DeviceStorageEnumerationParams());
        }
    case TDeviceStorageStatParams:
        {
            return (get_DeviceStorageStatParams()) == ((aRhs).get_DeviceStorageStatParams());
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return false;
        }
    }
}

} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct SlicedBlobConstructorParams|
//
namespace mozilla {
namespace dom {
SlicedBlobConstructorParams::SlicedBlobConstructorParams()
{
    Init();
}

SlicedBlobConstructorParams::~SlicedBlobConstructorParams()
{
}

bool
SlicedBlobConstructorParams::operator==(const SlicedBlobConstructorParams& _o) const
{
    if ((!((sourceParent()) == ((_o).sourceParent())))) {
        return false;
    }
    if ((!((sourceChild()) == ((_o).sourceChild())))) {
        return false;
    }
    if ((!((begin()) == ((_o).begin())))) {
        return false;
    }
    if ((!((end()) == ((_o).end())))) {
        return false;
    }
    if ((!((contentType()) == ((_o).contentType())))) {
        return false;
    }
    return true;
}

void
SlicedBlobConstructorParams::Init()
{
    sourceParent_ = 0;
    sourceChild_ = 0;
}

void
SlicedBlobConstructorParams::Assign(
        PBlobParent* _sourceParent,
        PBlobChild* _sourceChild,
        const uint64_t& _begin,
        const uint64_t& _end,
        const nsString& _contentType)
{
    sourceParent_ = _sourceParent;
    sourceChild_ = _sourceChild;
    begin_ = _begin;
    end_ = _end;
    contentType_ = _contentType;
}

} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct MysteryBlobConstructorParams|
//
namespace mozilla {
namespace dom {
MysteryBlobConstructorParams::~MysteryBlobConstructorParams()
{
}

bool
MysteryBlobConstructorParams::operator==(const MysteryBlobConstructorParams& _o) const
{
    return true;
}

void
MysteryBlobConstructorParams::Init()
{
}

void
MysteryBlobConstructorParams::Assign()
{
}

} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |union BlobConstructorParams|
//
namespace mozilla {
namespace dom {
bool
BlobConstructorParams::MaybeDestroy(Type aNewType)
{
    if ((mType) == (T__None)) {
        return true;
    }
    if ((mType) == (aNewType)) {
        return false;
    }
    switch (mType) {
    case TNormalBlobConstructorParams:
        {
            (ptr_NormalBlobConstructorParams())->~NormalBlobConstructorParams__tdef();
            break;
        }
    case TFileBlobConstructorParams:
        {
            (ptr_FileBlobConstructorParams())->~FileBlobConstructorParams__tdef();
            break;
        }
    case TSlicedBlobConstructorParams:
        {
            (ptr_SlicedBlobConstructorParams())->~SlicedBlobConstructorParams__tdef();
            break;
        }
    case TMysteryBlobConstructorParams:
        {
            (ptr_MysteryBlobConstructorParams())->~MysteryBlobConstructorParams__tdef();
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("not reached");
            break;
        }
    }
    return true;
}

BlobConstructorParams::BlobConstructorParams(const NormalBlobConstructorParams& aOther)
{
    new (ptr_NormalBlobConstructorParams()) NormalBlobConstructorParams(aOther);
    mType = TNormalBlobConstructorParams;
}

BlobConstructorParams::BlobConstructorParams(const FileBlobConstructorParams& aOther)
{
    new (ptr_FileBlobConstructorParams()) FileBlobConstructorParams(aOther);
    mType = TFileBlobConstructorParams;
}

BlobConstructorParams::BlobConstructorParams(const SlicedBlobConstructorParams& aOther)
{
    new (ptr_SlicedBlobConstructorParams()) SlicedBlobConstructorParams(aOther);
    mType = TSlicedBlobConstructorParams;
}

BlobConstructorParams::BlobConstructorParams(const MysteryBlobConstructorParams& aOther)
{
    new (ptr_MysteryBlobConstructorParams()) MysteryBlobConstructorParams(aOther);
    mType = TMysteryBlobConstructorParams;
}

BlobConstructorParams::BlobConstructorParams(const BlobConstructorParams& aOther)
{
    (aOther).AssertSanity();
    switch ((aOther).type()) {
    case TNormalBlobConstructorParams:
        {
            new (ptr_NormalBlobConstructorParams()) NormalBlobConstructorParams((aOther).get_NormalBlobConstructorParams());
            break;
        }
    case TFileBlobConstructorParams:
        {
            new (ptr_FileBlobConstructorParams()) FileBlobConstructorParams((aOther).get_FileBlobConstructorParams());
            break;
        }
    case TSlicedBlobConstructorParams:
        {
            new (ptr_SlicedBlobConstructorParams()) SlicedBlobConstructorParams((aOther).get_SlicedBlobConstructorParams());
            break;
        }
    case TMysteryBlobConstructorParams:
        {
            new (ptr_MysteryBlobConstructorParams()) MysteryBlobConstructorParams((aOther).get_MysteryBlobConstructorParams());
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return;
        }
    }
    mType = (aOther).type();
}

BlobConstructorParams::~BlobConstructorParams()
{
    MaybeDestroy(T__None);
}

BlobConstructorParams&
BlobConstructorParams::operator=(const NormalBlobConstructorParams& aRhs)
{
    if (MaybeDestroy(TNormalBlobConstructorParams)) {
        new (ptr_NormalBlobConstructorParams()) NormalBlobConstructorParams;
    }
    (*(ptr_NormalBlobConstructorParams())) = aRhs;
    mType = TNormalBlobConstructorParams;
    return (*(this));
}

BlobConstructorParams&
BlobConstructorParams::operator=(const FileBlobConstructorParams& aRhs)
{
    if (MaybeDestroy(TFileBlobConstructorParams)) {
        new (ptr_FileBlobConstructorParams()) FileBlobConstructorParams;
    }
    (*(ptr_FileBlobConstructorParams())) = aRhs;
    mType = TFileBlobConstructorParams;
    return (*(this));
}

BlobConstructorParams&
BlobConstructorParams::operator=(const SlicedBlobConstructorParams& aRhs)
{
    if (MaybeDestroy(TSlicedBlobConstructorParams)) {
        new (ptr_SlicedBlobConstructorParams()) SlicedBlobConstructorParams;
    }
    (*(ptr_SlicedBlobConstructorParams())) = aRhs;
    mType = TSlicedBlobConstructorParams;
    return (*(this));
}

BlobConstructorParams&
BlobConstructorParams::operator=(const MysteryBlobConstructorParams& aRhs)
{
    if (MaybeDestroy(TMysteryBlobConstructorParams)) {
        new (ptr_MysteryBlobConstructorParams()) MysteryBlobConstructorParams;
    }
    (*(ptr_MysteryBlobConstructorParams())) = aRhs;
    mType = TMysteryBlobConstructorParams;
    return (*(this));
}

BlobConstructorParams&
BlobConstructorParams::operator=(const BlobConstructorParams& aRhs)
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case TNormalBlobConstructorParams:
        {
            if (MaybeDestroy(t)) {
                new (ptr_NormalBlobConstructorParams()) NormalBlobConstructorParams;
            }
            (*(ptr_NormalBlobConstructorParams())) = (aRhs).get_NormalBlobConstructorParams();
            break;
        }
    case TFileBlobConstructorParams:
        {
            if (MaybeDestroy(t)) {
                new (ptr_FileBlobConstructorParams()) FileBlobConstructorParams;
            }
            (*(ptr_FileBlobConstructorParams())) = (aRhs).get_FileBlobConstructorParams();
            break;
        }
    case TSlicedBlobConstructorParams:
        {
            if (MaybeDestroy(t)) {
                new (ptr_SlicedBlobConstructorParams()) SlicedBlobConstructorParams;
            }
            (*(ptr_SlicedBlobConstructorParams())) = (aRhs).get_SlicedBlobConstructorParams();
            break;
        }
    case TMysteryBlobConstructorParams:
        {
            if (MaybeDestroy(t)) {
                new (ptr_MysteryBlobConstructorParams()) MysteryBlobConstructorParams;
            }
            (*(ptr_MysteryBlobConstructorParams())) = (aRhs).get_MysteryBlobConstructorParams();
            break;
        }
    case T__None:
        {
            MaybeDestroy(t);
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            break;
        }
    }
    mType = t;
    return (*(this));
}

bool
BlobConstructorParams::operator==(const NormalBlobConstructorParams& aRhs) const
{
    return (get_NormalBlobConstructorParams()) == (aRhs);
}

bool
BlobConstructorParams::operator==(const FileBlobConstructorParams& aRhs) const
{
    return (get_FileBlobConstructorParams()) == (aRhs);
}

bool
BlobConstructorParams::operator==(const SlicedBlobConstructorParams& aRhs) const
{
    return (get_SlicedBlobConstructorParams()) == (aRhs);
}

bool
BlobConstructorParams::operator==(const MysteryBlobConstructorParams& aRhs) const
{
    return (get_MysteryBlobConstructorParams()) == (aRhs);
}

bool
BlobConstructorParams::operator==(const BlobConstructorParams& aRhs) const
{
    if ((type()) != ((aRhs).type())) {
        return false;
    }

    switch (type()) {
    case TNormalBlobConstructorParams:
        {
            return (get_NormalBlobConstructorParams()) == ((aRhs).get_NormalBlobConstructorParams());
        }
    case TFileBlobConstructorParams:
        {
            return (get_FileBlobConstructorParams()) == ((aRhs).get_FileBlobConstructorParams());
        }
    case TSlicedBlobConstructorParams:
        {
            return (get_SlicedBlobConstructorParams()) == ((aRhs).get_SlicedBlobConstructorParams());
        }
    case TMysteryBlobConstructorParams:
        {
            return (get_MysteryBlobConstructorParams()) == ((aRhs).get_MysteryBlobConstructorParams());
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return false;
        }
    }
}

} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct PopupIPCTabContext|
//
namespace mozilla {
namespace dom {
PopupIPCTabContext::PopupIPCTabContext()
{
    Init();
}

PopupIPCTabContext::~PopupIPCTabContext()
{
}

bool
PopupIPCTabContext::operator==(const PopupIPCTabContext& _o) const
{
    if ((!((openerParent()) == ((_o).openerParent())))) {
        return false;
    }
    if ((!((openerChild()) == ((_o).openerChild())))) {
        return false;
    }
    if ((!((isBrowserElement()) == ((_o).isBrowserElement())))) {
        return false;
    }
    return true;
}

void
PopupIPCTabContext::Init()
{
    openerParent_ = 0;
    openerChild_ = 0;
}

void
PopupIPCTabContext::Assign(
        PBrowserParent* _openerParent,
        PBrowserChild* _openerChild,
        const bool& _isBrowserElement)
{
    openerParent_ = _openerParent;
    openerChild_ = _openerChild;
    isBrowserElement_ = _isBrowserElement;
}

} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct AppFrameIPCTabContext|
//
namespace mozilla {
namespace dom {
AppFrameIPCTabContext::AppFrameIPCTabContext()
{
    Init();
}

AppFrameIPCTabContext::~AppFrameIPCTabContext()
{
}

bool
AppFrameIPCTabContext::operator==(const AppFrameIPCTabContext& _o) const
{
    if ((!((ownAppId()) == ((_o).ownAppId())))) {
        return false;
    }
    if ((!((appFrameOwnerAppId()) == ((_o).appFrameOwnerAppId())))) {
        return false;
    }
    return true;
}

void
AppFrameIPCTabContext::Init()
{
}

void
AppFrameIPCTabContext::Assign(
        const uint32_t& _ownAppId,
        const uint32_t& _appFrameOwnerAppId)
{
    ownAppId_ = _ownAppId;
    appFrameOwnerAppId_ = _appFrameOwnerAppId;
}

} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct BrowserFrameIPCTabContext|
//
namespace mozilla {
namespace dom {
BrowserFrameIPCTabContext::BrowserFrameIPCTabContext()
{
    Init();
}

BrowserFrameIPCTabContext::~BrowserFrameIPCTabContext()
{
}

bool
BrowserFrameIPCTabContext::operator==(const BrowserFrameIPCTabContext& _o) const
{
    if ((!((browserFrameOwnerAppId()) == ((_o).browserFrameOwnerAppId())))) {
        return false;
    }
    return true;
}

void
BrowserFrameIPCTabContext::Init()
{
}

void
BrowserFrameIPCTabContext::Assign(const uint32_t& _browserFrameOwnerAppId)
{
    browserFrameOwnerAppId_ = _browserFrameOwnerAppId;
}

} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct VanillaFrameIPCTabContext|
//
namespace mozilla {
namespace dom {
VanillaFrameIPCTabContext::~VanillaFrameIPCTabContext()
{
}

bool
VanillaFrameIPCTabContext::operator==(const VanillaFrameIPCTabContext& _o) const
{
    return true;
}

void
VanillaFrameIPCTabContext::Init()
{
}

void
VanillaFrameIPCTabContext::Assign()
{
}

} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |union IPCTabAppBrowserContext|
//
namespace mozilla {
namespace dom {
bool
IPCTabAppBrowserContext::MaybeDestroy(Type aNewType)
{
    if ((mType) == (T__None)) {
        return true;
    }
    if ((mType) == (aNewType)) {
        return false;
    }
    switch (mType) {
    case TPopupIPCTabContext:
        {
            (ptr_PopupIPCTabContext())->~PopupIPCTabContext__tdef();
            break;
        }
    case TAppFrameIPCTabContext:
        {
            (ptr_AppFrameIPCTabContext())->~AppFrameIPCTabContext__tdef();
            break;
        }
    case TBrowserFrameIPCTabContext:
        {
            (ptr_BrowserFrameIPCTabContext())->~BrowserFrameIPCTabContext__tdef();
            break;
        }
    case TVanillaFrameIPCTabContext:
        {
            (ptr_VanillaFrameIPCTabContext())->~VanillaFrameIPCTabContext__tdef();
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("not reached");
            break;
        }
    }
    return true;
}

IPCTabAppBrowserContext::IPCTabAppBrowserContext(const PopupIPCTabContext& aOther)
{
    new (ptr_PopupIPCTabContext()) PopupIPCTabContext(aOther);
    mType = TPopupIPCTabContext;
}

IPCTabAppBrowserContext::IPCTabAppBrowserContext(const AppFrameIPCTabContext& aOther)
{
    new (ptr_AppFrameIPCTabContext()) AppFrameIPCTabContext(aOther);
    mType = TAppFrameIPCTabContext;
}

IPCTabAppBrowserContext::IPCTabAppBrowserContext(const BrowserFrameIPCTabContext& aOther)
{
    new (ptr_BrowserFrameIPCTabContext()) BrowserFrameIPCTabContext(aOther);
    mType = TBrowserFrameIPCTabContext;
}

IPCTabAppBrowserContext::IPCTabAppBrowserContext(const VanillaFrameIPCTabContext& aOther)
{
    new (ptr_VanillaFrameIPCTabContext()) VanillaFrameIPCTabContext(aOther);
    mType = TVanillaFrameIPCTabContext;
}

IPCTabAppBrowserContext::IPCTabAppBrowserContext(const IPCTabAppBrowserContext& aOther)
{
    (aOther).AssertSanity();
    switch ((aOther).type()) {
    case TPopupIPCTabContext:
        {
            new (ptr_PopupIPCTabContext()) PopupIPCTabContext((aOther).get_PopupIPCTabContext());
            break;
        }
    case TAppFrameIPCTabContext:
        {
            new (ptr_AppFrameIPCTabContext()) AppFrameIPCTabContext((aOther).get_AppFrameIPCTabContext());
            break;
        }
    case TBrowserFrameIPCTabContext:
        {
            new (ptr_BrowserFrameIPCTabContext()) BrowserFrameIPCTabContext((aOther).get_BrowserFrameIPCTabContext());
            break;
        }
    case TVanillaFrameIPCTabContext:
        {
            new (ptr_VanillaFrameIPCTabContext()) VanillaFrameIPCTabContext((aOther).get_VanillaFrameIPCTabContext());
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return;
        }
    }
    mType = (aOther).type();
}

IPCTabAppBrowserContext::~IPCTabAppBrowserContext()
{
    MaybeDestroy(T__None);
}

IPCTabAppBrowserContext&
IPCTabAppBrowserContext::operator=(const PopupIPCTabContext& aRhs)
{
    if (MaybeDestroy(TPopupIPCTabContext)) {
        new (ptr_PopupIPCTabContext()) PopupIPCTabContext;
    }
    (*(ptr_PopupIPCTabContext())) = aRhs;
    mType = TPopupIPCTabContext;
    return (*(this));
}

IPCTabAppBrowserContext&
IPCTabAppBrowserContext::operator=(const AppFrameIPCTabContext& aRhs)
{
    if (MaybeDestroy(TAppFrameIPCTabContext)) {
        new (ptr_AppFrameIPCTabContext()) AppFrameIPCTabContext;
    }
    (*(ptr_AppFrameIPCTabContext())) = aRhs;
    mType = TAppFrameIPCTabContext;
    return (*(this));
}

IPCTabAppBrowserContext&
IPCTabAppBrowserContext::operator=(const BrowserFrameIPCTabContext& aRhs)
{
    if (MaybeDestroy(TBrowserFrameIPCTabContext)) {
        new (ptr_BrowserFrameIPCTabContext()) BrowserFrameIPCTabContext;
    }
    (*(ptr_BrowserFrameIPCTabContext())) = aRhs;
    mType = TBrowserFrameIPCTabContext;
    return (*(this));
}

IPCTabAppBrowserContext&
IPCTabAppBrowserContext::operator=(const VanillaFrameIPCTabContext& aRhs)
{
    if (MaybeDestroy(TVanillaFrameIPCTabContext)) {
        new (ptr_VanillaFrameIPCTabContext()) VanillaFrameIPCTabContext;
    }
    (*(ptr_VanillaFrameIPCTabContext())) = aRhs;
    mType = TVanillaFrameIPCTabContext;
    return (*(this));
}

IPCTabAppBrowserContext&
IPCTabAppBrowserContext::operator=(const IPCTabAppBrowserContext& aRhs)
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case TPopupIPCTabContext:
        {
            if (MaybeDestroy(t)) {
                new (ptr_PopupIPCTabContext()) PopupIPCTabContext;
            }
            (*(ptr_PopupIPCTabContext())) = (aRhs).get_PopupIPCTabContext();
            break;
        }
    case TAppFrameIPCTabContext:
        {
            if (MaybeDestroy(t)) {
                new (ptr_AppFrameIPCTabContext()) AppFrameIPCTabContext;
            }
            (*(ptr_AppFrameIPCTabContext())) = (aRhs).get_AppFrameIPCTabContext();
            break;
        }
    case TBrowserFrameIPCTabContext:
        {
            if (MaybeDestroy(t)) {
                new (ptr_BrowserFrameIPCTabContext()) BrowserFrameIPCTabContext;
            }
            (*(ptr_BrowserFrameIPCTabContext())) = (aRhs).get_BrowserFrameIPCTabContext();
            break;
        }
    case TVanillaFrameIPCTabContext:
        {
            if (MaybeDestroy(t)) {
                new (ptr_VanillaFrameIPCTabContext()) VanillaFrameIPCTabContext;
            }
            (*(ptr_VanillaFrameIPCTabContext())) = (aRhs).get_VanillaFrameIPCTabContext();
            break;
        }
    case T__None:
        {
            MaybeDestroy(t);
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            break;
        }
    }
    mType = t;
    return (*(this));
}

bool
IPCTabAppBrowserContext::operator==(const PopupIPCTabContext& aRhs) const
{
    return (get_PopupIPCTabContext()) == (aRhs);
}

bool
IPCTabAppBrowserContext::operator==(const AppFrameIPCTabContext& aRhs) const
{
    return (get_AppFrameIPCTabContext()) == (aRhs);
}

bool
IPCTabAppBrowserContext::operator==(const BrowserFrameIPCTabContext& aRhs) const
{
    return (get_BrowserFrameIPCTabContext()) == (aRhs);
}

bool
IPCTabAppBrowserContext::operator==(const VanillaFrameIPCTabContext& aRhs) const
{
    return (get_VanillaFrameIPCTabContext()) == (aRhs);
}

bool
IPCTabAppBrowserContext::operator==(const IPCTabAppBrowserContext& aRhs) const
{
    if ((type()) != ((aRhs).type())) {
        return false;
    }

    switch (type()) {
    case TPopupIPCTabContext:
        {
            return (get_PopupIPCTabContext()) == ((aRhs).get_PopupIPCTabContext());
        }
    case TAppFrameIPCTabContext:
        {
            return (get_AppFrameIPCTabContext()) == ((aRhs).get_AppFrameIPCTabContext());
        }
    case TBrowserFrameIPCTabContext:
        {
            return (get_BrowserFrameIPCTabContext()) == ((aRhs).get_BrowserFrameIPCTabContext());
        }
    case TVanillaFrameIPCTabContext:
        {
            return (get_VanillaFrameIPCTabContext()) == ((aRhs).get_VanillaFrameIPCTabContext());
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return false;
        }
    }
}

} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct IPCTabContext|
//
namespace mozilla {
namespace dom {
IPCTabContext::IPCTabContext()
{
    Init();
}

IPCTabContext::~IPCTabContext()
{
}

bool
IPCTabContext::operator==(const IPCTabContext& _o) const
{
    if ((!((appBrowserContext()) == ((_o).appBrowserContext())))) {
        return false;
    }
    if ((!((scrollingBehavior()) == ((_o).scrollingBehavior())))) {
        return false;
    }
    return true;
}

void
IPCTabContext::Init()
{
}

void
IPCTabContext::Assign(
        const IPCTabAppBrowserContext& _appBrowserContext,
        const ScrollingBehavior& _scrollingBehavior)
{
    appBrowserContext_ = _appBrowserContext;
    scrollingBehavior_ = _scrollingBehavior;
}

} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |union PrefValue|
//
namespace mozilla {
namespace dom {
bool
PrefValue::MaybeDestroy(Type aNewType)
{
    if ((mType) == (T__None)) {
        return true;
    }
    if ((mType) == (aNewType)) {
        return false;
    }
    switch (mType) {
    case TnsCString:
        {
            (ptr_nsCString())->~nsCString__tdef();
            break;
        }
    case Tint32_t:
        {
            (ptr_int32_t())->~int32_t__tdef();
            break;
        }
    case Tbool:
        {
            (ptr_bool())->~bool__tdef();
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("not reached");
            break;
        }
    }
    return true;
}

PrefValue::PrefValue(const nsCString& aOther)
{
    new (ptr_nsCString()) nsCString(aOther);
    mType = TnsCString;
}

PrefValue::PrefValue(const int32_t& aOther)
{
    new (ptr_int32_t()) int32_t(aOther);
    mType = Tint32_t;
}

PrefValue::PrefValue(const bool& aOther)
{
    new (ptr_bool()) bool(aOther);
    mType = Tbool;
}

PrefValue::PrefValue(const PrefValue& aOther)
{
    (aOther).AssertSanity();
    switch ((aOther).type()) {
    case TnsCString:
        {
            new (ptr_nsCString()) nsCString((aOther).get_nsCString());
            break;
        }
    case Tint32_t:
        {
            new (ptr_int32_t()) int32_t((aOther).get_int32_t());
            break;
        }
    case Tbool:
        {
            new (ptr_bool()) bool((aOther).get_bool());
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return;
        }
    }
    mType = (aOther).type();
}

PrefValue::~PrefValue()
{
    MaybeDestroy(T__None);
}

PrefValue&
PrefValue::operator=(const nsCString& aRhs)
{
    if (MaybeDestroy(TnsCString)) {
        new (ptr_nsCString()) nsCString;
    }
    (*(ptr_nsCString())) = aRhs;
    mType = TnsCString;
    return (*(this));
}

PrefValue&
PrefValue::operator=(const int32_t& aRhs)
{
    if (MaybeDestroy(Tint32_t)) {
        new (ptr_int32_t()) int32_t;
    }
    (*(ptr_int32_t())) = aRhs;
    mType = Tint32_t;
    return (*(this));
}

PrefValue&
PrefValue::operator=(const bool& aRhs)
{
    if (MaybeDestroy(Tbool)) {
        new (ptr_bool()) bool;
    }
    (*(ptr_bool())) = aRhs;
    mType = Tbool;
    return (*(this));
}

PrefValue&
PrefValue::operator=(const PrefValue& aRhs)
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case TnsCString:
        {
            if (MaybeDestroy(t)) {
                new (ptr_nsCString()) nsCString;
            }
            (*(ptr_nsCString())) = (aRhs).get_nsCString();
            break;
        }
    case Tint32_t:
        {
            if (MaybeDestroy(t)) {
                new (ptr_int32_t()) int32_t;
            }
            (*(ptr_int32_t())) = (aRhs).get_int32_t();
            break;
        }
    case Tbool:
        {
            if (MaybeDestroy(t)) {
                new (ptr_bool()) bool;
            }
            (*(ptr_bool())) = (aRhs).get_bool();
            break;
        }
    case T__None:
        {
            MaybeDestroy(t);
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            break;
        }
    }
    mType = t;
    return (*(this));
}

bool
PrefValue::operator==(const nsCString& aRhs) const
{
    return (get_nsCString()) == (aRhs);
}

bool
PrefValue::operator==(const int32_t& aRhs) const
{
    return (get_int32_t()) == (aRhs);
}

bool
PrefValue::operator==(const bool& aRhs) const
{
    return (get_bool()) == (aRhs);
}

bool
PrefValue::operator==(const PrefValue& aRhs) const
{
    if ((type()) != ((aRhs).type())) {
        return false;
    }

    switch (type()) {
    case TnsCString:
        {
            return (get_nsCString()) == ((aRhs).get_nsCString());
        }
    case Tint32_t:
        {
            return (get_int32_t()) == ((aRhs).get_int32_t());
        }
    case Tbool:
        {
            return (get_bool()) == ((aRhs).get_bool());
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return false;
        }
    }
}

} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |union MaybePrefValue|
//
namespace mozilla {
namespace dom {
bool
MaybePrefValue::MaybeDestroy(Type aNewType)
{
    if ((mType) == (T__None)) {
        return true;
    }
    if ((mType) == (aNewType)) {
        return false;
    }
    switch (mType) {
    case TPrefValue:
        {
            (ptr_PrefValue())->~PrefValue__tdef();
            break;
        }
    case Tnull_t:
        {
            (ptr_null_t())->~null_t__tdef();
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("not reached");
            break;
        }
    }
    return true;
}

MaybePrefValue::MaybePrefValue(const PrefValue& aOther)
{
    new (ptr_PrefValue()) PrefValue(aOther);
    mType = TPrefValue;
}

MaybePrefValue::MaybePrefValue(const null_t& aOther)
{
    new (ptr_null_t()) null_t(aOther);
    mType = Tnull_t;
}

MaybePrefValue::MaybePrefValue(const MaybePrefValue& aOther)
{
    (aOther).AssertSanity();
    switch ((aOther).type()) {
    case TPrefValue:
        {
            new (ptr_PrefValue()) PrefValue((aOther).get_PrefValue());
            break;
        }
    case Tnull_t:
        {
            new (ptr_null_t()) null_t((aOther).get_null_t());
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return;
        }
    }
    mType = (aOther).type();
}

MaybePrefValue::~MaybePrefValue()
{
    MaybeDestroy(T__None);
}

MaybePrefValue&
MaybePrefValue::operator=(const PrefValue& aRhs)
{
    if (MaybeDestroy(TPrefValue)) {
        new (ptr_PrefValue()) PrefValue;
    }
    (*(ptr_PrefValue())) = aRhs;
    mType = TPrefValue;
    return (*(this));
}

MaybePrefValue&
MaybePrefValue::operator=(const null_t& aRhs)
{
    if (MaybeDestroy(Tnull_t)) {
        new (ptr_null_t()) null_t;
    }
    (*(ptr_null_t())) = aRhs;
    mType = Tnull_t;
    return (*(this));
}

MaybePrefValue&
MaybePrefValue::operator=(const MaybePrefValue& aRhs)
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case TPrefValue:
        {
            if (MaybeDestroy(t)) {
                new (ptr_PrefValue()) PrefValue;
            }
            (*(ptr_PrefValue())) = (aRhs).get_PrefValue();
            break;
        }
    case Tnull_t:
        {
            if (MaybeDestroy(t)) {
                new (ptr_null_t()) null_t;
            }
            (*(ptr_null_t())) = (aRhs).get_null_t();
            break;
        }
    case T__None:
        {
            MaybeDestroy(t);
            break;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            break;
        }
    }
    mType = t;
    return (*(this));
}

bool
MaybePrefValue::operator==(const PrefValue& aRhs) const
{
    return (get_PrefValue()) == (aRhs);
}

bool
MaybePrefValue::operator==(const null_t& aRhs) const
{
    return (get_null_t()) == (aRhs);
}

bool
MaybePrefValue::operator==(const MaybePrefValue& aRhs) const
{
    if ((type()) != ((aRhs).type())) {
        return false;
    }

    switch (type()) {
    case TPrefValue:
        {
            return (get_PrefValue()) == ((aRhs).get_PrefValue());
        }
    case Tnull_t:
        {
            return (get_null_t()) == ((aRhs).get_null_t());
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return false;
        }
    }
}

} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct PrefSetting|
//
namespace mozilla {
namespace dom {
PrefSetting::PrefSetting()
{
    Init();
}

PrefSetting::~PrefSetting()
{
}

bool
PrefSetting::operator==(const PrefSetting& _o) const
{
    if ((!((name()) == ((_o).name())))) {
        return false;
    }
    if ((!((defaultValue()) == ((_o).defaultValue())))) {
        return false;
    }
    if ((!((userValue()) == ((_o).userValue())))) {
        return false;
    }
    return true;
}

void
PrefSetting::Init()
{
}

void
PrefSetting::Assign(
        const nsCString& _name,
        const MaybePrefValue& _defaultValue,
        const MaybePrefValue& _userValue)
{
    name_ = _name;
    defaultValue_ = _defaultValue;
    userValue_ = _userValue;
}

} // namespace dom
} // namespace mozilla
