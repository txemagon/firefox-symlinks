//
// Automatically generated by ipdlc.
// Edit at your own risk
//


#include "mozilla/dom/PBrowserChild.h"

#include "mozilla/dom/PBlobChild.h"
#include "mozilla/dom/PContentChild.h"
#include "mozilla/dom/PContentDialogChild.h"
#include "mozilla/ipc/PDocumentRendererChild.h"
#include "mozilla/dom/PContentPermissionRequestChild.h"
#include "mozilla/layout/PRenderFrameChild.h"
#include "mozilla/docshell/POfflineCacheUpdateChild.h"
#include "mozilla/dom/indexedDB/PIndexedDBChild.h"

typedef IPC::Message Message;
typedef mozilla::ipc::RPCChannel Channel;
typedef mozilla::ipc::RPCChannel::RPCListener ChannelListener;
typedef base::ProcessHandle ProcessHandle;
typedef mozilla::ipc::AsyncChannel AsyncChannel;
typedef mozilla::ipc::SharedMemory SharedMemory;
typedef mozilla::ipc::Trigger Trigger;
typedef mozilla::ipc::ActorHandle ActorHandle;
typedef mozilla::dom::ClonedMessageData ClonedMessageData;
typedef mozilla::dom::FileBlobConstructorParams FileBlobConstructorParams;
typedef mozilla::ipc::FileDescriptor FileDescriptor;
typedef mozilla::layers::FrameMetrics FrameMetrics;
typedef mozilla::ipc::GenericURIParams GenericURIParams;
typedef mozilla::ipc::JARURIParams JARURIParams;
typedef mozilla::layers::LayersBackend LayersBackend;
typedef mozilla::dom::NormalBlobConstructorParams NormalBlobConstructorParams;
typedef mozilla::ipc::OptionalURIParams OptionalURIParams;
typedef IPC::Principal Principal;
typedef mozilla::dom::ScreenOrientation ScreenOrientation;
typedef mozilla::layout::ScrollingBehavior ScrollingBehavior;
typedef mozilla::SerializedStructuredCloneBuffer SerializedStructuredCloneBuffer;
typedef mozilla::ipc::Shmem Shmem;
typedef mozilla::ipc::SimpleURIParams SimpleURIParams;
typedef mozilla::ipc::StandardURLParams StandardURLParams;
typedef mozilla::ipc::StandardURLSegment StandardURLSegment;
typedef mozilla::ipc::URIParams URIParams;
typedef mozilla::widget::WheelEvent WheelEvent;
typedef mozilla::WindowsHandle WindowsHandle;
typedef mozilla::void_t void_t;
using mozilla::dom::PBlobChild;
using mozilla::dom::PContentChild;
using mozilla::dom::PContentDialogChild;
using mozilla::ipc::PDocumentRendererChild;
using mozilla::dom::PContentPermissionRequestChild;
using mozilla::layout::PRenderFrameChild;
using mozilla::docshell::POfflineCacheUpdateChild;
using mozilla::dom::indexedDB::PIndexedDBChild;

namespace mozilla {
namespace dom {


bool
PBrowserChild::RecvPDocumentRendererConstructor(
        PDocumentRendererChild* actor,
        const nsRect& documentRect,
        const gfxMatrix& transform,
        const nsString& bgcolor,
        const uint32_t& renderFlags,
        const bool& flushLayout,
        const nsIntSize& renderSize)
{
    return true;
}

void
PBrowserChild::ActorDestroy(ActorDestroyReason why)
{
}

PBrowserChild::PBrowserChild() :
    mId(0),
    mState(PBrowser::__Dead)
{
    MOZ_COUNT_CTOR(PBrowserChild);
}

PBrowserChild::~PBrowserChild()
{
    MOZ_COUNT_DTOR(PBrowserChild);
}

PContentChild*
PBrowserChild::Manager() const
{
    return static_cast<PContentChild*>(mManager);
}

void
PBrowserChild::ManagedPContentDialogChild(InfallibleTArray<PContentDialogChild*>& aArr) const
{
    aArr = mManagedPContentDialogChild;
}

const InfallibleTArray<PContentDialogChild*>&
PBrowserChild::ManagedPContentDialogChild() const
{
    return mManagedPContentDialogChild;
}

void
PBrowserChild::ManagedPDocumentRendererChild(InfallibleTArray<PDocumentRendererChild*>& aArr) const
{
    aArr = mManagedPDocumentRendererChild;
}

const InfallibleTArray<PDocumentRendererChild*>&
PBrowserChild::ManagedPDocumentRendererChild() const
{
    return mManagedPDocumentRendererChild;
}

void
PBrowserChild::ManagedPContentPermissionRequestChild(InfallibleTArray<PContentPermissionRequestChild*>& aArr) const
{
    aArr = mManagedPContentPermissionRequestChild;
}

const InfallibleTArray<PContentPermissionRequestChild*>&
PBrowserChild::ManagedPContentPermissionRequestChild() const
{
    return mManagedPContentPermissionRequestChild;
}

void
PBrowserChild::ManagedPRenderFrameChild(InfallibleTArray<PRenderFrameChild*>& aArr) const
{
    aArr = mManagedPRenderFrameChild;
}

const InfallibleTArray<PRenderFrameChild*>&
PBrowserChild::ManagedPRenderFrameChild() const
{
    return mManagedPRenderFrameChild;
}

void
PBrowserChild::ManagedPOfflineCacheUpdateChild(InfallibleTArray<POfflineCacheUpdateChild*>& aArr) const
{
    aArr = mManagedPOfflineCacheUpdateChild;
}

const InfallibleTArray<POfflineCacheUpdateChild*>&
PBrowserChild::ManagedPOfflineCacheUpdateChild() const
{
    return mManagedPOfflineCacheUpdateChild;
}

void
PBrowserChild::ManagedPIndexedDBChild(InfallibleTArray<PIndexedDBChild*>& aArr) const
{
    aArr = mManagedPIndexedDBChild;
}

const InfallibleTArray<PIndexedDBChild*>&
PBrowserChild::ManagedPIndexedDBChild() const
{
    return mManagedPIndexedDBChild;
}

PBrowser::State
PBrowserChild::state()
{
    return mState;
}

bool
PBrowserChild::SendAsyncMessage(
        const nsString& aMessage,
        const ClonedMessageData& aData)
{
    PBrowser::Msg_AsyncMessage* __msg = new PBrowser::Msg_AsyncMessage();

    Write(aMessage, __msg);
    Write(aData, __msg);

    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PBrowserChild] Sending ", stderr);
    }
    if ((!(PBrowser::Transition(mState, Trigger(Trigger::Recv, PBrowser::Msg_AsyncMessage__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

bool
PBrowserChild::SendMoveFocus(const bool& forward)
{
    PBrowser::Msg_MoveFocus* __msg = new PBrowser::Msg_MoveFocus();

    Write(forward, __msg);

    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PBrowserChild] Sending ", stderr);
    }
    if ((!(PBrowser::Transition(mState, Trigger(Trigger::Recv, PBrowser::Msg_MoveFocus__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

bool
PBrowserChild::SendEvent(const RemoteDOMEvent& aEvent)
{
    PBrowser::Msg_Event* __msg = new PBrowser::Msg_Event();

    Write(aEvent, __msg);

    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PBrowserChild] Sending ", stderr);
    }
    if ((!(PBrowser::Transition(mState, Trigger(Trigger::Recv, PBrowser::Msg_Event__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

bool
PBrowserChild::CallCreateWindow(PBrowserChild** window)
{
    PBrowser::Msg_CreateWindow* __msg = new PBrowser::Msg_CreateWindow();


    (__msg)->set_routing_id(mId);
    (__msg)->set_rpc();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PBrowserChild] Sending ", stderr);
    }
    if ((!(PBrowser::Transition(mState, Trigger(Trigger::Recv, PBrowser::Msg_CreateWindow__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Call(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PBrowser::Reply_CreateWindow*>((&(__reply))))->Log("[PBrowserChild] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(window, (&(__reply)), (&(__iter)), false)))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    (__reply).EndRead(__iter);

    return true;
}

bool
PBrowserChild::SendSyncMessage(
        const nsString& aMessage,
        const ClonedMessageData& aData,
        InfallibleTArray<nsString>* retval)
{
    PBrowser::Msg_SyncMessage* __msg = new PBrowser::Msg_SyncMessage();

    Write(aMessage, __msg);
    Write(aData, __msg);

    (__msg)->set_routing_id(mId);
    (__msg)->set_sync();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PBrowserChild] Sending ", stderr);
    }
    if ((!(PBrowser::Transition(mState, Trigger(Trigger::Recv, PBrowser::Msg_SyncMessage__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PBrowser::Reply_SyncMessage*>((&(__reply))))->Log("[PBrowserChild] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(retval, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    (__reply).EndRead(__iter);

    return true;
}

bool
PBrowserChild::SendNotifyIMEFocus(
        const bool& focus,
        nsIMEUpdatePreference* preference,
        uint32_t* seqno)
{
    PBrowser::Msg_NotifyIMEFocus* __msg = new PBrowser::Msg_NotifyIMEFocus();

    Write(focus, __msg);

    (__msg)->set_routing_id(mId);
    (__msg)->set_sync();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PBrowserChild] Sending ", stderr);
    }
    if ((!(PBrowser::Transition(mState, Trigger(Trigger::Recv, PBrowser::Msg_NotifyIMEFocus__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PBrowser::Reply_NotifyIMEFocus*>((&(__reply))))->Log("[PBrowserChild] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(preference, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read(seqno, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    (__reply).EndRead(__iter);

    return true;
}

bool
PBrowserChild::SendNotifyIMETextChange(
        const uint32_t& offset,
        const uint32_t& end,
        const uint32_t& newEnd)
{
    PBrowser::Msg_NotifyIMETextChange* __msg = new PBrowser::Msg_NotifyIMETextChange();

    Write(offset, __msg);
    Write(end, __msg);
    Write(newEnd, __msg);

    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PBrowserChild] Sending ", stderr);
    }
    if ((!(PBrowser::Transition(mState, Trigger(Trigger::Recv, PBrowser::Msg_NotifyIMETextChange__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

bool
PBrowserChild::SendNotifyIMESelection(
        const uint32_t& seqno,
        const uint32_t& anchor,
        const uint32_t& focus)
{
    PBrowser::Msg_NotifyIMESelection* __msg = new PBrowser::Msg_NotifyIMESelection();

    Write(seqno, __msg);
    Write(anchor, __msg);
    Write(focus, __msg);

    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PBrowserChild] Sending ", stderr);
    }
    if ((!(PBrowser::Transition(mState, Trigger(Trigger::Recv, PBrowser::Msg_NotifyIMESelection__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

bool
PBrowserChild::SendNotifyIMETextHint(const nsString& text)
{
    PBrowser::Msg_NotifyIMETextHint* __msg = new PBrowser::Msg_NotifyIMETextHint();

    Write(text, __msg);

    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PBrowserChild] Sending ", stderr);
    }
    if ((!(PBrowser::Transition(mState, Trigger(Trigger::Recv, PBrowser::Msg_NotifyIMETextHint__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

bool
PBrowserChild::SendEndIMEComposition(
        const bool& cancel,
        nsString* composition)
{
    PBrowser::Msg_EndIMEComposition* __msg = new PBrowser::Msg_EndIMEComposition();

    Write(cancel, __msg);

    (__msg)->set_routing_id(mId);
    (__msg)->set_sync();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PBrowserChild] Sending ", stderr);
    }
    if ((!(PBrowser::Transition(mState, Trigger(Trigger::Recv, PBrowser::Msg_EndIMEComposition__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PBrowser::Reply_EndIMEComposition*>((&(__reply))))->Log("[PBrowserChild] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(composition, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    (__reply).EndRead(__iter);

    return true;
}

bool
PBrowserChild::SendGetInputContext(
        int32_t* IMEEnabled,
        int32_t* IMEOpen,
        intptr_t* NativeIMEContext)
{
    PBrowser::Msg_GetInputContext* __msg = new PBrowser::Msg_GetInputContext();


    (__msg)->set_routing_id(mId);
    (__msg)->set_sync();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PBrowserChild] Sending ", stderr);
    }
    if ((!(PBrowser::Transition(mState, Trigger(Trigger::Recv, PBrowser::Msg_GetInputContext__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PBrowser::Reply_GetInputContext*>((&(__reply))))->Log("[PBrowserChild] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(IMEEnabled, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read(IMEOpen, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read(NativeIMEContext, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    (__reply).EndRead(__iter);

    return true;
}

bool
PBrowserChild::SendSetInputContext(
        const int32_t& IMEEnabled,
        const int32_t& IMEOpen,
        const nsString& type,
        const nsString& inputmode,
        const nsString& actionHint,
        const int32_t& cause,
        const int32_t& focusChange)
{
    PBrowser::Msg_SetInputContext* __msg = new PBrowser::Msg_SetInputContext();

    Write(IMEEnabled, __msg);
    Write(IMEOpen, __msg);
    Write(type, __msg);
    Write(inputmode, __msg);
    Write(actionHint, __msg);
    Write(cause, __msg);
    Write(focusChange, __msg);

    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PBrowserChild] Sending ", stderr);
    }
    if ((!(PBrowser::Transition(mState, Trigger(Trigger::Recv, PBrowser::Msg_SetInputContext__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

bool
PBrowserChild::SendGetDPI(float* value)
{
    PBrowser::Msg_GetDPI* __msg = new PBrowser::Msg_GetDPI();


    (__msg)->set_routing_id(mId);
    (__msg)->set_sync();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PBrowserChild] Sending ", stderr);
    }
    if ((!(PBrowser::Transition(mState, Trigger(Trigger::Recv, PBrowser::Msg_GetDPI__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PBrowser::Reply_GetDPI*>((&(__reply))))->Log("[PBrowserChild] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(value, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    (__reply).EndRead(__iter);

    return true;
}

bool
PBrowserChild::SendGetWidgetNativeData(WindowsHandle* value)
{
    PBrowser::Msg_GetWidgetNativeData* __msg = new PBrowser::Msg_GetWidgetNativeData();


    (__msg)->set_routing_id(mId);
    (__msg)->set_sync();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PBrowserChild] Sending ", stderr);
    }
    if ((!(PBrowser::Transition(mState, Trigger(Trigger::Recv, PBrowser::Msg_GetWidgetNativeData__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PBrowser::Reply_GetWidgetNativeData*>((&(__reply))))->Log("[PBrowserChild] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(value, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    (__reply).EndRead(__iter);

    return true;
}

bool
PBrowserChild::SendSetCursor(const uint32_t& value)
{
    PBrowser::Msg_SetCursor* __msg = new PBrowser::Msg_SetCursor();

    Write(value, __msg);

    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PBrowserChild] Sending ", stderr);
    }
    if ((!(PBrowser::Transition(mState, Trigger(Trigger::Recv, PBrowser::Msg_SetCursor__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

bool
PBrowserChild::SendSetBackgroundColor(const nscolor& color)
{
    PBrowser::Msg_SetBackgroundColor* __msg = new PBrowser::Msg_SetBackgroundColor();

    Write(color, __msg);

    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PBrowserChild] Sending ", stderr);
    }
    if ((!(PBrowser::Transition(mState, Trigger(Trigger::Recv, PBrowser::Msg_SetBackgroundColor__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

PContentPermissionRequestChild*
PBrowserChild::SendPContentPermissionRequestConstructor(
        const nsCString& aType,
        const nsCString& aAccess,
        const Principal& principal)
{
    return SendPContentPermissionRequestConstructor(AllocPContentPermissionRequest(aType, aAccess, principal), aType, aAccess, principal);
}

PContentPermissionRequestChild*
PBrowserChild::SendPContentPermissionRequestConstructor(
        PContentPermissionRequestChild* actor,
        const nsCString& aType,
        const nsCString& aAccess,
        const Principal& principal)
{
    if ((!(actor))) {
        return 0;
    }
    (actor)->mId = Register(actor);
    (actor)->mManager = this;
    (actor)->mChannel = mChannel;
    (mManagedPContentPermissionRequestChild).InsertElementSorted(actor);
    (actor)->mState = mozilla::dom::PContentPermissionRequest::__Start;

    PBrowser::Msg_PContentPermissionRequestConstructor* __msg = new PBrowser::Msg_PContentPermissionRequestConstructor();

    Write(actor, __msg, false);
    Write(aType, __msg);
    Write(aAccess, __msg);
    Write(principal, __msg);

    (__msg)->set_routing_id(mId);


    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PBrowserChild] Sending ", stderr);
    }
    if ((!(PBrowser::Transition(mState, Trigger(Trigger::Recv, PBrowser::Msg_PContentPermissionRequestConstructor__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    if ((!(__sendok))) {
        (actor)->DestroySubtree(FailedConstructor);
        (actor)->DeallocSubtree();
        ((actor)->mManager)->RemoveManagee(PContentPermissionRequestMsgStart, actor);
        return 0;
    }
    return actor;
}

PContentDialogChild*
PBrowserChild::SendPContentDialogConstructor(
        const uint32_t& aType,
        const nsCString& aName,
        const nsCString& aFeatures,
        const InfallibleTArray<int32_t>& aIntParams,
        const InfallibleTArray<nsString>& aStringParams)
{
    return SendPContentDialogConstructor(AllocPContentDialog(aType, aName, aFeatures, aIntParams, aStringParams), aType, aName, aFeatures, aIntParams, aStringParams);
}

PContentDialogChild*
PBrowserChild::SendPContentDialogConstructor(
        PContentDialogChild* actor,
        const uint32_t& aType,
        const nsCString& aName,
        const nsCString& aFeatures,
        const InfallibleTArray<int32_t>& aIntParams,
        const InfallibleTArray<nsString>& aStringParams)
{
    if ((!(actor))) {
        return 0;
    }
    (actor)->mId = Register(actor);
    (actor)->mManager = this;
    (actor)->mChannel = mChannel;
    (mManagedPContentDialogChild).InsertElementSorted(actor);
    (actor)->mState = mozilla::dom::PContentDialog::__Start;

    PBrowser::Msg_PContentDialogConstructor* __msg = new PBrowser::Msg_PContentDialogConstructor();

    Write(actor, __msg, false);
    Write(aType, __msg);
    Write(aName, __msg);
    Write(aFeatures, __msg);
    Write(aIntParams, __msg);
    Write(aStringParams, __msg);

    (__msg)->set_routing_id(mId);


    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PBrowserChild] Sending ", stderr);
    }
    if ((!(PBrowser::Transition(mState, Trigger(Trigger::Recv, PBrowser::Msg_PContentDialogConstructor__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    if ((!(__sendok))) {
        (actor)->DestroySubtree(FailedConstructor);
        (actor)->DeallocSubtree();
        ((actor)->mManager)->RemoveManagee(PContentDialogMsgStart, actor);
        return 0;
    }
    return actor;
}

PRenderFrameChild*
PBrowserChild::SendPRenderFrameConstructor(
        ScrollingBehavior* scrolling,
        LayersBackend* backend,
        int32_t* maxTextureSize,
        uint64_t* layersId)
{
    return SendPRenderFrameConstructor(AllocPRenderFrame(scrolling, backend, maxTextureSize, layersId), scrolling, backend, maxTextureSize, layersId);
}

PRenderFrameChild*
PBrowserChild::SendPRenderFrameConstructor(
        PRenderFrameChild* actor,
        ScrollingBehavior* scrolling,
        LayersBackend* backend,
        int32_t* maxTextureSize,
        uint64_t* layersId)
{
    if ((!(actor))) {
        return 0;
    }
    (actor)->mId = Register(actor);
    (actor)->mManager = this;
    (actor)->mChannel = mChannel;
    (mManagedPRenderFrameChild).InsertElementSorted(actor);
    (actor)->mState = mozilla::layout::PRenderFrame::__Start;

    PBrowser::Msg_PRenderFrameConstructor* __msg = new PBrowser::Msg_PRenderFrameConstructor();

    Write(actor, __msg, false);

    (__msg)->set_routing_id(mId);
    (__msg)->set_sync();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PBrowserChild] Sending ", stderr);
    }
    if ((!(PBrowser::Transition(mState, Trigger(Trigger::Recv, PBrowser::Msg_PRenderFrameConstructor__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg, (&(__reply)));
    if ((!(__sendok))) {
        (actor)->DestroySubtree(FailedConstructor);
        (actor)->DeallocSubtree();
        ((actor)->mManager)->RemoveManagee(PRenderFrameMsgStart, actor);
        return 0;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PBrowser::Reply_PRenderFrameConstructor*>((&(__reply))))->Log("[PBrowserChild] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(scrolling, (&(__reply)), (&(__iter)))))) {
        if (true) {
            (actor)->DestroySubtree(FailedConstructor);
            (actor)->DeallocSubtree();
            ((actor)->mManager)->RemoveManagee(PRenderFrameMsgStart, actor);
            return 0;
        }
    }
    if ((!(Read(backend, (&(__reply)), (&(__iter)))))) {
        if (true) {
            (actor)->DestroySubtree(FailedConstructor);
            (actor)->DeallocSubtree();
            ((actor)->mManager)->RemoveManagee(PRenderFrameMsgStart, actor);
            return 0;
        }
    }
    if ((!(Read(maxTextureSize, (&(__reply)), (&(__iter)))))) {
        if (true) {
            (actor)->DestroySubtree(FailedConstructor);
            (actor)->DeallocSubtree();
            ((actor)->mManager)->RemoveManagee(PRenderFrameMsgStart, actor);
            return 0;
        }
    }
    if ((!(Read(layersId, (&(__reply)), (&(__iter)))))) {
        if (true) {
            (actor)->DestroySubtree(FailedConstructor);
            (actor)->DeallocSubtree();
            ((actor)->mManager)->RemoveManagee(PRenderFrameMsgStart, actor);
            return 0;
        }
    }
    (__reply).EndRead(__iter);
    return actor;
}

POfflineCacheUpdateChild*
PBrowserChild::SendPOfflineCacheUpdateConstructor(
        const URIParams& manifestURI,
        const URIParams& documentURI,
        const bool& stickDocument)
{
    return SendPOfflineCacheUpdateConstructor(AllocPOfflineCacheUpdate(manifestURI, documentURI, stickDocument), manifestURI, documentURI, stickDocument);
}

POfflineCacheUpdateChild*
PBrowserChild::SendPOfflineCacheUpdateConstructor(
        POfflineCacheUpdateChild* actor,
        const URIParams& manifestURI,
        const URIParams& documentURI,
        const bool& stickDocument)
{
    if ((!(actor))) {
        return 0;
    }
    (actor)->mId = Register(actor);
    (actor)->mManager = this;
    (actor)->mChannel = mChannel;
    (mManagedPOfflineCacheUpdateChild).InsertElementSorted(actor);
    (actor)->mState = mozilla::docshell::POfflineCacheUpdate::__Start;

    PBrowser::Msg_POfflineCacheUpdateConstructor* __msg = new PBrowser::Msg_POfflineCacheUpdateConstructor();

    Write(actor, __msg, false);
    Write(manifestURI, __msg);
    Write(documentURI, __msg);
    Write(stickDocument, __msg);

    (__msg)->set_routing_id(mId);


    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PBrowserChild] Sending ", stderr);
    }
    if ((!(PBrowser::Transition(mState, Trigger(Trigger::Recv, PBrowser::Msg_POfflineCacheUpdateConstructor__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    if ((!(__sendok))) {
        (actor)->DestroySubtree(FailedConstructor);
        (actor)->DeallocSubtree();
        ((actor)->mManager)->RemoveManagee(POfflineCacheUpdateMsgStart, actor);
        return 0;
    }
    return actor;
}

PIndexedDBChild*
PBrowserChild::SendPIndexedDBConstructor(
        const nsCString& asciiOrigin,
        bool* allowed)
{
    return SendPIndexedDBConstructor(AllocPIndexedDB(asciiOrigin, allowed), asciiOrigin, allowed);
}

PIndexedDBChild*
PBrowserChild::SendPIndexedDBConstructor(
        PIndexedDBChild* actor,
        const nsCString& asciiOrigin,
        bool* allowed)
{
    if ((!(actor))) {
        return 0;
    }
    (actor)->mId = Register(actor);
    (actor)->mManager = this;
    (actor)->mChannel = mChannel;
    (mManagedPIndexedDBChild).InsertElementSorted(actor);
    (actor)->mState = mozilla::dom::indexedDB::PIndexedDB::__Start;

    PBrowser::Msg_PIndexedDBConstructor* __msg = new PBrowser::Msg_PIndexedDBConstructor();

    Write(actor, __msg, false);
    Write(asciiOrigin, __msg);

    (__msg)->set_routing_id(mId);
    (__msg)->set_sync();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PBrowserChild] Sending ", stderr);
    }
    if ((!(PBrowser::Transition(mState, Trigger(Trigger::Recv, PBrowser::Msg_PIndexedDBConstructor__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg, (&(__reply)));
    if ((!(__sendok))) {
        (actor)->DestroySubtree(FailedConstructor);
        (actor)->DeallocSubtree();
        ((actor)->mManager)->RemoveManagee(PIndexedDBMsgStart, actor);
        return 0;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PBrowser::Reply_PIndexedDBConstructor*>((&(__reply))))->Log("[PBrowserChild] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(allowed, (&(__reply)), (&(__iter)))))) {
        if (true) {
            (actor)->DestroySubtree(FailedConstructor);
            (actor)->DeallocSubtree();
            ((actor)->mManager)->RemoveManagee(PIndexedDBMsgStart, actor);
            return 0;
        }
    }
    (__reply).EndRead(__iter);
    return actor;
}

bool
PBrowserChild::SendBrowserFrameOpenWindow(
        PBrowserChild* opener,
        const nsString& aURL,
        const nsString& aName,
        const nsString& aFeatures,
        bool* windowOpened)
{
    PBrowser::Msg_BrowserFrameOpenWindow* __msg = new PBrowser::Msg_BrowserFrameOpenWindow();

    Write(opener, __msg, false);
    Write(aURL, __msg);
    Write(aName, __msg);
    Write(aFeatures, __msg);

    (__msg)->set_routing_id(mId);
    (__msg)->set_sync();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PBrowserChild] Sending ", stderr);
    }
    if ((!(PBrowser::Transition(mState, Trigger(Trigger::Recv, PBrowser::Msg_BrowserFrameOpenWindow__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PBrowser::Reply_BrowserFrameOpenWindow*>((&(__reply))))->Log("[PBrowserChild] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(windowOpened, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    (__reply).EndRead(__iter);

    return true;
}

bool
PBrowserChild::SendZoomToRect(const gfxRect& aRect)
{
    PBrowser::Msg_ZoomToRect* __msg = new PBrowser::Msg_ZoomToRect();

    Write(aRect, __msg);

    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PBrowserChild] Sending ", stderr);
    }
    if ((!(PBrowser::Transition(mState, Trigger(Trigger::Recv, PBrowser::Msg_ZoomToRect__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

bool
PBrowserChild::SendContentReceivedTouch(const bool& aPreventDefault)
{
    PBrowser::Msg_ContentReceivedTouch* __msg = new PBrowser::Msg_ContentReceivedTouch();

    Write(aPreventDefault, __msg);

    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PBrowserChild] Sending ", stderr);
    }
    if ((!(PBrowser::Transition(mState, Trigger(Trigger::Recv, PBrowser::Msg_ContentReceivedTouch__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

bool
PBrowserChild::SendUpdateZoomConstraints(
        const bool& aAllowZoom,
        const float& aMinZoom,
        const float& aMaxZoom)
{
    PBrowser::Msg_UpdateZoomConstraints* __msg = new PBrowser::Msg_UpdateZoomConstraints();

    Write(aAllowZoom, __msg);
    Write(aMinZoom, __msg);
    Write(aMaxZoom, __msg);

    (__msg)->set_routing_id(mId);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PBrowserChild] Sending ", stderr);
    }
    if ((!(PBrowser::Transition(mState, Trigger(Trigger::Recv, PBrowser::Msg_UpdateZoomConstraints__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel)->Send(__msg);
    return __sendok;
}

bool
PBrowserChild::Send__delete__(PBrowserChild* actor)
{
    if ((!(actor))) {
        return false;
    }

    if ((!(actor))) {
        return false;
    }

    PBrowser::Msg___delete__* __msg = new PBrowser::Msg___delete__();

    (actor)->Write(actor, __msg, false);

    (__msg)->set_routing_id((actor)->mId);


    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PBrowserChild] Sending ", stderr);
    }
    if ((!(PBrowser::Transition((actor)->mState, Trigger(Trigger::Recv, PBrowser::Msg___delete____ID), (&((actor)->mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = ((actor)->mChannel)->Send(__msg);

    (actor)->DestroySubtree(Deletion);
    (actor)->DeallocSubtree();
    ((actor)->mManager)->RemoveManagee(PBrowserMsgStart, actor);
    return __sendok;
}

int32_t
PBrowserChild::Register(ChannelListener* aRouted)
{
    return (mManager)->Register(aRouted);
}

int32_t
PBrowserChild::RegisterID(
        ChannelListener* aRouted,
        int32_t aId)
{
    return (mManager)->RegisterID(aRouted, aId);
}

ChannelListener*
PBrowserChild::Lookup(int32_t aId)
{
    return (mManager)->Lookup(aId);
}

void
PBrowserChild::Unregister(int32_t aId)
{
    return (mManager)->Unregister(aId);
}

void
PBrowserChild::RemoveManagee(
        int32_t aProtocolId,
        ChannelListener* aListener)
{
    switch (aProtocolId) {
    case PContentDialogMsgStart:
        {
            PContentDialogChild* actor = static_cast<PContentDialogChild*>(aListener);
            NS_ABORT_IF_FALSE(((mManagedPContentDialogChild).NoIndex) != ((mManagedPContentDialogChild).BinaryIndexOf(actor)), "actor not managed by this!");

            (mManagedPContentDialogChild).RemoveElementSorted(actor);
            DeallocPContentDialog(actor);
            return;
        }
    case PDocumentRendererMsgStart:
        {
            PDocumentRendererChild* actor = static_cast<PDocumentRendererChild*>(aListener);
            NS_ABORT_IF_FALSE(((mManagedPDocumentRendererChild).NoIndex) != ((mManagedPDocumentRendererChild).BinaryIndexOf(actor)), "actor not managed by this!");

            (mManagedPDocumentRendererChild).RemoveElementSorted(actor);
            DeallocPDocumentRenderer(actor);
            return;
        }
    case PContentPermissionRequestMsgStart:
        {
            PContentPermissionRequestChild* actor = static_cast<PContentPermissionRequestChild*>(aListener);
            NS_ABORT_IF_FALSE(((mManagedPContentPermissionRequestChild).NoIndex) != ((mManagedPContentPermissionRequestChild).BinaryIndexOf(actor)), "actor not managed by this!");

            (mManagedPContentPermissionRequestChild).RemoveElementSorted(actor);
            DeallocPContentPermissionRequest(actor);
            return;
        }
    case PRenderFrameMsgStart:
        {
            PRenderFrameChild* actor = static_cast<PRenderFrameChild*>(aListener);
            NS_ABORT_IF_FALSE(((mManagedPRenderFrameChild).NoIndex) != ((mManagedPRenderFrameChild).BinaryIndexOf(actor)), "actor not managed by this!");

            (mManagedPRenderFrameChild).RemoveElementSorted(actor);
            DeallocPRenderFrame(actor);
            return;
        }
    case POfflineCacheUpdateMsgStart:
        {
            POfflineCacheUpdateChild* actor = static_cast<POfflineCacheUpdateChild*>(aListener);
            NS_ABORT_IF_FALSE(((mManagedPOfflineCacheUpdateChild).NoIndex) != ((mManagedPOfflineCacheUpdateChild).BinaryIndexOf(actor)), "actor not managed by this!");

            (mManagedPOfflineCacheUpdateChild).RemoveElementSorted(actor);
            DeallocPOfflineCacheUpdate(actor);
            return;
        }
    case PIndexedDBMsgStart:
        {
            PIndexedDBChild* actor = static_cast<PIndexedDBChild*>(aListener);
            NS_ABORT_IF_FALSE(((mManagedPIndexedDBChild).NoIndex) != ((mManagedPIndexedDBChild).BinaryIndexOf(actor)), "actor not managed by this!");

            (mManagedPIndexedDBChild).RemoveElementSorted(actor);
            DeallocPIndexedDB(actor);
            return;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return;
        }
    }
}

Shmem::SharedMemory*
PBrowserChild::CreateSharedMemory(
        size_t aSize,
        Shmem::SharedMemory::SharedMemoryType aType,
        bool aUnsafe,
        Shmem::id_t* aId)
{
    return (mManager)->CreateSharedMemory(aSize, aType, aUnsafe, aId);
}

bool
PBrowserChild::AdoptSharedMemory(
        Shmem::SharedMemory* segment,
        Shmem::id_t* aId)
{
    return (mManager)->AdoptSharedMemory(segment, aId);
}

Shmem::SharedMemory*
PBrowserChild::LookupSharedMemory(Shmem::id_t aId)
{
    return (mManager)->LookupSharedMemory(aId);
}

bool
PBrowserChild::IsTrackingSharedMemory(Shmem::SharedMemory* segment)
{
    return (mManager)->IsTrackingSharedMemory(segment);
}

bool
PBrowserChild::DestroySharedMemory(Shmem& shmem)
{
    return (mManager)->DestroySharedMemory(shmem);
}

ProcessHandle
PBrowserChild::OtherProcess() const
{
    return (mManager)->OtherProcess();
}

AsyncChannel*
PBrowserChild::GetIPCChannel()
{
    return mChannel;
}

PBrowserChild::Result
PBrowserChild::OnMessageReceived(const Message& __msg)
{
    switch ((__msg).type()) {
    case PBrowser::Msg_AsyncMessage__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PBrowser::Msg_AsyncMessage");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PBrowser::Msg_AsyncMessage*>((&(__msg))))->Log("[PBrowserChild] Received ", stderr);
            }

            void* __iter = 0;
            nsString aMessage;
            ClonedMessageData aData;

            if ((!(Read((&(aMessage)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(aData)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PBrowser::Transition(mState, Trigger(Trigger::Send, PBrowser::Msg_AsyncMessage__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvAsyncMessage(aMessage, aData)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for AsyncMessage returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBrowser::Reply_PContentPermissionRequestConstructor__ID:
        {
            return MsgProcessed;
        }
    case PBrowser::Reply_PContentDialogConstructor__ID:
        {
            return MsgProcessed;
        }
    case PBrowser::Reply_POfflineCacheUpdateConstructor__ID:
        {
            return MsgProcessed;
        }
    case PBrowser::Reply___delete____ID:
        {
            return MsgProcessed;
        }
    case PBrowser::Msg_Show__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PBrowser::Msg_Show");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PBrowser::Msg_Show*>((&(__msg))))->Log("[PBrowserChild] Received ", stderr);
            }

            void* __iter = 0;
            nsIntSize size;

            if ((!(Read((&(size)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PBrowser::Transition(mState, Trigger(Trigger::Send, PBrowser::Msg_Show__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvShow(size)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for Show returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBrowser::Msg_LoadURL__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PBrowser::Msg_LoadURL");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PBrowser::Msg_LoadURL*>((&(__msg))))->Log("[PBrowserChild] Received ", stderr);
            }

            void* __iter = 0;
            nsCString uri;

            if ((!(Read((&(uri)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PBrowser::Transition(mState, Trigger(Trigger::Send, PBrowser::Msg_LoadURL__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvLoadURL(uri)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for LoadURL returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBrowser::Msg_UpdateDimensions__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PBrowser::Msg_UpdateDimensions");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PBrowser::Msg_UpdateDimensions*>((&(__msg))))->Log("[PBrowserChild] Received ", stderr);
            }

            void* __iter = 0;
            nsRect rect;
            nsIntSize size;
            ScreenOrientation orientation;

            if ((!(Read((&(rect)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(size)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(orientation)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PBrowser::Transition(mState, Trigger(Trigger::Send, PBrowser::Msg_UpdateDimensions__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvUpdateDimensions(rect, size, orientation)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for UpdateDimensions returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBrowser::Msg_UpdateFrame__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PBrowser::Msg_UpdateFrame");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PBrowser::Msg_UpdateFrame*>((&(__msg))))->Log("[PBrowserChild] Received ", stderr);
            }

            void* __iter = 0;
            FrameMetrics frame;

            if ((!(Read((&(frame)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PBrowser::Transition(mState, Trigger(Trigger::Send, PBrowser::Msg_UpdateFrame__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvUpdateFrame(frame)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for UpdateFrame returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBrowser::Msg_HandleDoubleTap__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PBrowser::Msg_HandleDoubleTap");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PBrowser::Msg_HandleDoubleTap*>((&(__msg))))->Log("[PBrowserChild] Received ", stderr);
            }

            void* __iter = 0;
            nsIntPoint point;

            if ((!(Read((&(point)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PBrowser::Transition(mState, Trigger(Trigger::Send, PBrowser::Msg_HandleDoubleTap__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvHandleDoubleTap(point)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for HandleDoubleTap returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBrowser::Msg_HandleSingleTap__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PBrowser::Msg_HandleSingleTap");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PBrowser::Msg_HandleSingleTap*>((&(__msg))))->Log("[PBrowserChild] Received ", stderr);
            }

            void* __iter = 0;
            nsIntPoint point;

            if ((!(Read((&(point)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PBrowser::Transition(mState, Trigger(Trigger::Send, PBrowser::Msg_HandleSingleTap__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvHandleSingleTap(point)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for HandleSingleTap returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBrowser::Msg_HandleLongTap__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PBrowser::Msg_HandleLongTap");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PBrowser::Msg_HandleLongTap*>((&(__msg))))->Log("[PBrowserChild] Received ", stderr);
            }

            void* __iter = 0;
            nsIntPoint point;

            if ((!(Read((&(point)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PBrowser::Transition(mState, Trigger(Trigger::Send, PBrowser::Msg_HandleLongTap__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvHandleLongTap(point)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for HandleLongTap returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBrowser::Msg_Activate__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PBrowser::Msg_Activate");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PBrowser::Msg_Activate*>((&(__msg))))->Log("[PBrowserChild] Received ", stderr);
            }

            if ((!(PBrowser::Transition(mState, Trigger(Trigger::Send, PBrowser::Msg_Activate__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvActivate()))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for Activate returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBrowser::Msg_Deactivate__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PBrowser::Msg_Deactivate");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PBrowser::Msg_Deactivate*>((&(__msg))))->Log("[PBrowserChild] Received ", stderr);
            }

            if ((!(PBrowser::Transition(mState, Trigger(Trigger::Send, PBrowser::Msg_Deactivate__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvDeactivate()))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for Deactivate returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBrowser::Msg_MouseEvent__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PBrowser::Msg_MouseEvent");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PBrowser::Msg_MouseEvent*>((&(__msg))))->Log("[PBrowserChild] Received ", stderr);
            }

            void* __iter = 0;
            nsString aType;
            float aX;
            float aY;
            int32_t aButton;
            int32_t aClickCount;
            int32_t aModifiers;
            bool aIgnoreRootScrollFrame;

            if ((!(Read((&(aType)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(aX)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(aY)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(aButton)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(aClickCount)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(aModifiers)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(aIgnoreRootScrollFrame)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PBrowser::Transition(mState, Trigger(Trigger::Send, PBrowser::Msg_MouseEvent__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvMouseEvent(aType, aX, aY, aButton, aClickCount, aModifiers, aIgnoreRootScrollFrame)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for MouseEvent returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBrowser::Msg_RealMouseEvent__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PBrowser::Msg_RealMouseEvent");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PBrowser::Msg_RealMouseEvent*>((&(__msg))))->Log("[PBrowserChild] Received ", stderr);
            }

            void* __iter = 0;
            nsMouseEvent event;

            if ((!(Read((&(event)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PBrowser::Transition(mState, Trigger(Trigger::Send, PBrowser::Msg_RealMouseEvent__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvRealMouseEvent(event)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for RealMouseEvent returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBrowser::Msg_RealKeyEvent__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PBrowser::Msg_RealKeyEvent");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PBrowser::Msg_RealKeyEvent*>((&(__msg))))->Log("[PBrowserChild] Received ", stderr);
            }

            void* __iter = 0;
            nsKeyEvent event;

            if ((!(Read((&(event)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PBrowser::Transition(mState, Trigger(Trigger::Send, PBrowser::Msg_RealKeyEvent__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvRealKeyEvent(event)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for RealKeyEvent returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBrowser::Msg_MouseWheelEvent__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PBrowser::Msg_MouseWheelEvent");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PBrowser::Msg_MouseWheelEvent*>((&(__msg))))->Log("[PBrowserChild] Received ", stderr);
            }

            void* __iter = 0;
            WheelEvent event;

            if ((!(Read((&(event)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PBrowser::Transition(mState, Trigger(Trigger::Send, PBrowser::Msg_MouseWheelEvent__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvMouseWheelEvent(event)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for MouseWheelEvent returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBrowser::Msg_RealTouchEvent__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PBrowser::Msg_RealTouchEvent");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PBrowser::Msg_RealTouchEvent*>((&(__msg))))->Log("[PBrowserChild] Received ", stderr);
            }

            void* __iter = 0;
            nsTouchEvent event;

            if ((!(Read((&(event)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PBrowser::Transition(mState, Trigger(Trigger::Send, PBrowser::Msg_RealTouchEvent__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvRealTouchEvent(event)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for RealTouchEvent returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBrowser::Msg_RealTouchMoveEvent__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PBrowser::Msg_RealTouchMoveEvent");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PBrowser::Msg_RealTouchMoveEvent*>((&(__msg))))->Log("[PBrowserChild] Received ", stderr);
            }

            void* __iter = 0;
            nsTouchEvent event;

            if ((!(Read((&(event)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PBrowser::Transition(mState, Trigger(Trigger::Send, PBrowser::Msg_RealTouchMoveEvent__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvRealTouchMoveEvent(event)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for RealTouchMoveEvent returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBrowser::Msg_KeyEvent__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PBrowser::Msg_KeyEvent");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PBrowser::Msg_KeyEvent*>((&(__msg))))->Log("[PBrowserChild] Received ", stderr);
            }

            void* __iter = 0;
            nsString aType;
            int32_t aKeyCode;
            int32_t aCharCode;
            int32_t aModifiers;
            bool aPreventDefault;

            if ((!(Read((&(aType)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(aKeyCode)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(aCharCode)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(aModifiers)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(aPreventDefault)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PBrowser::Transition(mState, Trigger(Trigger::Send, PBrowser::Msg_KeyEvent__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvKeyEvent(aType, aKeyCode, aCharCode, aModifiers, aPreventDefault)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for KeyEvent returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBrowser::Msg_CompositionEvent__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PBrowser::Msg_CompositionEvent");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PBrowser::Msg_CompositionEvent*>((&(__msg))))->Log("[PBrowserChild] Received ", stderr);
            }

            void* __iter = 0;
            nsCompositionEvent event;

            if ((!(Read((&(event)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PBrowser::Transition(mState, Trigger(Trigger::Send, PBrowser::Msg_CompositionEvent__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvCompositionEvent(event)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for CompositionEvent returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBrowser::Msg_TextEvent__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PBrowser::Msg_TextEvent");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PBrowser::Msg_TextEvent*>((&(__msg))))->Log("[PBrowserChild] Received ", stderr);
            }

            void* __iter = 0;
            nsTextEvent event;

            if ((!(Read((&(event)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PBrowser::Transition(mState, Trigger(Trigger::Send, PBrowser::Msg_TextEvent__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvTextEvent(event)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for TextEvent returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBrowser::Msg_SelectionEvent__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PBrowser::Msg_SelectionEvent");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PBrowser::Msg_SelectionEvent*>((&(__msg))))->Log("[PBrowserChild] Received ", stderr);
            }

            void* __iter = 0;
            nsSelectionEvent event;

            if ((!(Read((&(event)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PBrowser::Transition(mState, Trigger(Trigger::Send, PBrowser::Msg_SelectionEvent__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvSelectionEvent(event)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for SelectionEvent returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBrowser::Msg_ActivateFrameEvent__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PBrowser::Msg_ActivateFrameEvent");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PBrowser::Msg_ActivateFrameEvent*>((&(__msg))))->Log("[PBrowserChild] Received ", stderr);
            }

            void* __iter = 0;
            nsString aType;
            bool capture;

            if ((!(Read((&(aType)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(capture)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PBrowser::Transition(mState, Trigger(Trigger::Send, PBrowser::Msg_ActivateFrameEvent__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvActivateFrameEvent(aType, capture)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for ActivateFrameEvent returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBrowser::Msg_LoadRemoteScript__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PBrowser::Msg_LoadRemoteScript");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PBrowser::Msg_LoadRemoteScript*>((&(__msg))))->Log("[PBrowserChild] Received ", stderr);
            }

            void* __iter = 0;
            nsString aURL;

            if ((!(Read((&(aURL)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PBrowser::Transition(mState, Trigger(Trigger::Send, PBrowser::Msg_LoadRemoteScript__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvLoadRemoteScript(aURL)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for LoadRemoteScript returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBrowser::Msg_PDocumentRendererConstructor__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PBrowser::Msg_PDocumentRendererConstructor");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PBrowser::Msg_PDocumentRendererConstructor*>((&(__msg))))->Log("[PBrowserChild] Received ", stderr);
            }

            void* __iter = 0;
            ActorHandle __handle;
            PDocumentRendererChild* actor;
            nsRect documentRect;
            gfxMatrix transform;
            nsString bgcolor;
            uint32_t renderFlags;
            bool flushLayout;
            nsIntSize renderSize;

            if ((!(Read((&(__handle)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(documentRect)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(transform)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(bgcolor)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(renderFlags)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(flushLayout)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(renderSize)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PBrowser::Transition(mState, Trigger(Trigger::Send, PBrowser::Msg_PDocumentRendererConstructor__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            actor = AllocPDocumentRenderer(documentRect, transform, bgcolor, renderFlags, flushLayout, renderSize);
            if ((!(actor))) {
                return MsgValueError;
            }
            (actor)->mId = RegisterID(actor, (__handle).mId);
            (actor)->mManager = this;
            (actor)->mChannel = mChannel;
            (mManagedPDocumentRendererChild).InsertElementSorted(actor);
            (actor)->mState = mozilla::ipc::PDocumentRenderer::__Start;

            if ((!(RecvPDocumentRendererConstructor(actor, documentRect, transform, bgcolor, renderFlags, flushLayout, renderSize)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for PDocumentRenderer returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBrowser::Msg_SetAppType__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PBrowser::Msg_SetAppType");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PBrowser::Msg_SetAppType*>((&(__msg))))->Log("[PBrowserChild] Received ", stderr);
            }

            void* __iter = 0;
            nsString appType;

            if ((!(Read((&(appType)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PBrowser::Transition(mState, Trigger(Trigger::Send, PBrowser::Msg_SetAppType__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvSetAppType(appType)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for SetAppType returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBrowser::Msg_Destroy__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PBrowser::Msg_Destroy");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PBrowser::Msg_Destroy*>((&(__msg))))->Log("[PBrowserChild] Received ", stderr);
            }

            if ((!(PBrowser::Transition(mState, Trigger(Trigger::Send, PBrowser::Msg_Destroy__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvDestroy()))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for Destroy returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    default:
        {
            return MsgNotKnown;
        }
    }
}

PBrowserChild::Result
PBrowserChild::OnMessageReceived(
        const Message& __msg,
        Message*& __reply)
{
    return MsgNotKnown;
}

PBrowserChild::Result
PBrowserChild::OnCallReceived(
        const Message& __msg,
        Message*& __reply)
{
    return MsgNotKnown;
}

void
PBrowserChild::OnProcessingError(Result code)
{
    NS_RUNTIMEABORT("`OnProcessingError' called on non-toplevel actor");
}

int32_t
PBrowserChild::GetProtocolTypeId()
{
    return PBrowserMsgStart;
}

bool
PBrowserChild::OnReplyTimeout()
{
    NS_RUNTIMEABORT("`OnReplyTimeout' called on non-toplevel actor");
    return false;
}

void
PBrowserChild::OnChannelClose()
{
    NS_RUNTIMEABORT("`OnClose' called on non-toplevel actor");
}

void
PBrowserChild::OnChannelError()
{
    NS_RUNTIMEABORT("`OnError' called on non-toplevel actor");
}

void
PBrowserChild::OnChannelConnected(int32_t pid)
{
    NS_RUNTIMEABORT("'OnConnected' called on non-toplevel actor");
}

bool
PBrowserChild::AllocShmem(
        size_t aSize,
        Shmem::SharedMemory::SharedMemoryType aType,
        Shmem* aMem)
{
    Shmem::id_t aId;
    nsAutoPtr<Shmem::SharedMemory> rawmem(CreateSharedMemory(aSize, aType, false, (&(aId))));
    if ((!(rawmem))) {
        return false;
    }

    (*(aMem)) = Shmem(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(), (rawmem).forget(), aId);
    return true;
}

bool
PBrowserChild::AllocUnsafeShmem(
        size_t aSize,
        Shmem::SharedMemory::SharedMemoryType aType,
        Shmem* aMem)
{
    Shmem::id_t aId;
    nsAutoPtr<Shmem::SharedMemory> rawmem(CreateSharedMemory(aSize, aType, true, (&(aId))));
    if ((!(rawmem))) {
        return false;
    }

    (*(aMem)) = Shmem(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(), (rawmem).forget(), aId);
    return true;
}

bool
PBrowserChild::AdoptShmem(
        Shmem& aMem,
        Shmem* aOutMem)
{
    Shmem::SharedMemory* rawmem = (aMem).Segment(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead());
    if (((!(rawmem))) || (IsTrackingSharedMemory(rawmem))) {
        NS_RUNTIMEABORT("bad Shmem");
    }

    Shmem::id_t aId;
    if ((!(AdoptSharedMemory(rawmem, (&(aId)))))) {
        return false;
    }

    (*(aOutMem)) = Shmem(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(), rawmem, aId);
    return true;
}

bool
PBrowserChild::DeallocShmem(Shmem& aMem)
{
    bool ok = DestroySharedMemory(aMem);
    (aMem).forget(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead());
    return ok;
}

void
PBrowserChild::FatalError(const char* const msg) const
{
    // Virtual method to prevent inlining.
    // This give us better error reporting.
    // See bug 589371

    NS_ERROR("IPDL error:");
    NS_ERROR(msg);
    mozilla::ipc::ProtocolErrorBreakpoint(msg);

    NS_RUNTIMEABORT("[PBrowserChild] abort()ing as a result");
}

void
PBrowserChild::DestroySubtree(ActorDestroyReason why)
{
    // Unregister from our manager.
    Unregister(mId);
    mId = 1;

    ActorDestroyReason subtreewhy = (((why) == (Deletion)) || ((why) == (FailedConstructor)) ? AncestorDeletion : why);

    {
        // Recursively shutting down PContentDialog kids
        InfallibleTArray<PContentDialogChild*> kids(mManagedPContentDialogChild);
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DestroySubtree(subtreewhy);
        }
    }
    {
        // Recursively shutting down PDocumentRenderer kids
        InfallibleTArray<PDocumentRendererChild*> kids(mManagedPDocumentRendererChild);
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DestroySubtree(subtreewhy);
        }
    }
    {
        // Recursively shutting down PContentPermissionRequest kids
        InfallibleTArray<PContentPermissionRequestChild*> kids(mManagedPContentPermissionRequestChild);
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DestroySubtree(subtreewhy);
        }
    }
    {
        // Recursively shutting down PRenderFrame kids
        InfallibleTArray<PRenderFrameChild*> kids(mManagedPRenderFrameChild);
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DestroySubtree(subtreewhy);
        }
    }
    {
        // Recursively shutting down POfflineCacheUpdate kids
        InfallibleTArray<POfflineCacheUpdateChild*> kids(mManagedPOfflineCacheUpdateChild);
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DestroySubtree(subtreewhy);
        }
    }
    {
        // Recursively shutting down PIndexedDB kids
        InfallibleTArray<PIndexedDBChild*> kids(mManagedPIndexedDBChild);
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DestroySubtree(subtreewhy);
        }
    }

    // Finally, destroy "us".
    ActorDestroy(why);
}

void
PBrowserChild::DeallocSubtree()
{
    {
        // Recursively deleting PContentDialog kids
        InfallibleTArray<PContentDialogChild*>& kids = mManagedPContentDialogChild;
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DeallocSubtree();
        }

        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            DeallocPContentDialog(kids[i]);
        }
        (mManagedPContentDialogChild).Clear();
    }
    {
        // Recursively deleting PDocumentRenderer kids
        InfallibleTArray<PDocumentRendererChild*>& kids = mManagedPDocumentRendererChild;
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DeallocSubtree();
        }

        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            DeallocPDocumentRenderer(kids[i]);
        }
        (mManagedPDocumentRendererChild).Clear();
    }
    {
        // Recursively deleting PContentPermissionRequest kids
        InfallibleTArray<PContentPermissionRequestChild*>& kids = mManagedPContentPermissionRequestChild;
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DeallocSubtree();
        }

        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            DeallocPContentPermissionRequest(kids[i]);
        }
        (mManagedPContentPermissionRequestChild).Clear();
    }
    {
        // Recursively deleting PRenderFrame kids
        InfallibleTArray<PRenderFrameChild*>& kids = mManagedPRenderFrameChild;
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DeallocSubtree();
        }

        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            DeallocPRenderFrame(kids[i]);
        }
        (mManagedPRenderFrameChild).Clear();
    }
    {
        // Recursively deleting POfflineCacheUpdate kids
        InfallibleTArray<POfflineCacheUpdateChild*>& kids = mManagedPOfflineCacheUpdateChild;
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DeallocSubtree();
        }

        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            DeallocPOfflineCacheUpdate(kids[i]);
        }
        (mManagedPOfflineCacheUpdateChild).Clear();
    }
    {
        // Recursively deleting PIndexedDB kids
        InfallibleTArray<PIndexedDBChild*>& kids = mManagedPIndexedDBChild;
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DeallocSubtree();
        }

        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            DeallocPIndexedDB(kids[i]);
        }
        (mManagedPIndexedDBChild).Clear();
    }
}

void
PBrowserChild::Write(
        const ClonedMessageData& __v,
        Message* __msg)
{
    Write((__v).data(), __msg);
    // skipping actor field that's meaningless on this side
    Write((__v).blobsChild(), __msg);
}

bool
PBrowserChild::Read(
        ClonedMessageData* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->data())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    // skipping actor field that's meaningless on this side
    if ((!(Read((&((__v)->blobsChild())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PBrowserChild::Write(
        PDocumentRendererChild* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PBrowserChild::Read(
        PDocumentRendererChild** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PBrowser");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PDocumentRenderer");
        return false;
    }

    if ((PDocumentRendererMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PDocumentRenderer has different type");
        return false;
    }

    (*(__v)) = static_cast<PDocumentRendererChild*>(listener);
    return true;
}

void
PBrowserChild::Write(
        PBrowserChild* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PBrowserChild::Read(
        PBrowserChild** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PBrowser");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PBrowser");
        return false;
    }

    if ((PBrowserMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PBrowser has different type");
        return false;
    }

    (*(__v)) = static_cast<PBrowserChild*>(listener);
    return true;
}

void
PBrowserChild::Write(
        PContentDialogChild* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PBrowserChild::Read(
        PContentDialogChild** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PBrowser");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PContentDialog");
        return false;
    }

    if ((PContentDialogMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PContentDialog has different type");
        return false;
    }

    (*(__v)) = static_cast<PContentDialogChild*>(listener);
    return true;
}

void
PBrowserChild::Write(
        const InfallibleTArray<PBlobChild*>& __v,
        Message* __msg)
{
    uint32_t length = (__v).Length();
    Write(length, __msg);

    for (uint32_t i = 0; (i) < (length); (++(i))) {
        Write(__v[i], __msg, false);
    }
}

bool
PBrowserChild::Read(
        InfallibleTArray<PBlobChild*>* __v,
        const Message* __msg,
        void** __iter)
{
    InfallibleTArray<PBlobChild*>& a = (*(__v));
    uint32_t length;
    if ((!(Read((&(length)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }

    (__v)->SetLength(length);
    for (uint32_t i = 0; (i) < (length); (++(i))) {
        if ((!(Read((&(a[i])), __msg, __iter, false)))) {
            mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
            return false;
        }
    }
    return true;
}

void
PBrowserChild::Write(
        const SimpleURIParams& __v,
        Message* __msg)
{
    Write((__v).scheme(), __msg);
    Write((__v).path(), __msg);
    Write((__v).ref(), __msg);
    Write((__v).isMutable(), __msg);
}

bool
PBrowserChild::Read(
        SimpleURIParams* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->scheme())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->path())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->ref())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->isMutable())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PBrowserChild::Write(
        const StandardURLParams& __v,
        Message* __msg)
{
    Write((__v).urlType(), __msg);
    Write((__v).port(), __msg);
    Write((__v).defaultPort(), __msg);
    Write((__v).spec(), __msg);
    Write((__v).scheme(), __msg);
    Write((__v).authority(), __msg);
    Write((__v).username(), __msg);
    Write((__v).password(), __msg);
    Write((__v).host(), __msg);
    Write((__v).path(), __msg);
    Write((__v).filePath(), __msg);
    Write((__v).directory(), __msg);
    Write((__v).baseName(), __msg);
    Write((__v).extension(), __msg);
    Write((__v).query(), __msg);
    Write((__v).ref(), __msg);
    Write((__v).originCharset(), __msg);
    Write((__v).isMutable(), __msg);
    Write((__v).supportsFileURL(), __msg);
    Write((__v).hostEncoding(), __msg);
}

bool
PBrowserChild::Read(
        StandardURLParams* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->urlType())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->port())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->defaultPort())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->spec())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->scheme())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->authority())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->username())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->password())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->host())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->path())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->filePath())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->directory())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->baseName())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->extension())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->query())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->ref())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->originCharset())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->isMutable())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->supportsFileURL())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->hostEncoding())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PBrowserChild::Write(
        POfflineCacheUpdateChild* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PBrowserChild::Read(
        POfflineCacheUpdateChild** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PBrowser");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up POfflineCacheUpdate");
        return false;
    }

    if ((POfflineCacheUpdateMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type POfflineCacheUpdate has different type");
        return false;
    }

    (*(__v)) = static_cast<POfflineCacheUpdateChild*>(listener);
    return true;
}

void
PBrowserChild::Write(
        const GenericURIParams& __v,
        Message* __msg)
{
    Write((__v).spec(), __msg);
    Write((__v).charset(), __msg);
}

bool
PBrowserChild::Read(
        GenericURIParams* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->spec())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->charset())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PBrowserChild::Write(
        const JARURIParams& __v,
        Message* __msg)
{
    Write((__v).jarFile(), __msg);
    Write((__v).jarEntry(), __msg);
    Write((__v).charset(), __msg);
}

bool
PBrowserChild::Read(
        JARURIParams* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->jarFile())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->jarEntry())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->charset())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PBrowserChild::Write(
        const StandardURLSegment& __v,
        Message* __msg)
{
    Write((__v).position(), __msg);
    Write((__v).length(), __msg);
}

bool
PBrowserChild::Read(
        StandardURLSegment* __v,
        const Message* __msg,
        void** __iter)
{
    if ((!(Read((&((__v)->position())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read((&((__v)->length())), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    return true;
}

void
PBrowserChild::Write(
        const URIParams& __v,
        Message* __msg)
{
    typedef URIParams __type;
    Write(int((__v).type()), __msg);

    switch ((__v).type()) {
    case __type::TSimpleURIParams:
        {
            Write((__v).get_SimpleURIParams(), __msg);
            return;
        }
    case __type::TStandardURLParams:
        {
            Write((__v).get_StandardURLParams(), __msg);
            return;
        }
    case __type::TJARURIParams:
        {
            Write((__v).get_JARURIParams(), __msg);
            return;
        }
    case __type::TGenericURIParams:
        {
            Write((__v).get_GenericURIParams(), __msg);
            return;
        }
    default:
        {
            NS_RUNTIMEABORT("unknown union type");
            return;
        }
    }
}

bool
PBrowserChild::Read(
        URIParams* __v,
        const Message* __msg,
        void** __iter)
{
    typedef URIParams __type;
    int type;
    if ((!(Read((&(type)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }

    switch (type) {
    case __type::TSimpleURIParams:
        {
            SimpleURIParams tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_SimpleURIParams())), __msg, __iter);
        }
    case __type::TStandardURLParams:
        {
            StandardURLParams tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_StandardURLParams())), __msg, __iter);
        }
    case __type::TJARURIParams:
        {
            JARURIParams tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_JARURIParams())), __msg, __iter);
        }
    case __type::TGenericURIParams:
        {
            GenericURIParams tmp;
            (*(__v)) = tmp;
            return Read((&((__v)->get_GenericURIParams())), __msg, __iter);
        }
    default:
        {
            mozilla::ipc::ProtocolErrorBreakpoint("unknown union type");
            return false;
        }
    }
}

void
PBrowserChild::Write(
        PBlobChild* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PBrowserChild::Read(
        PBlobChild** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PBrowser");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PBlob");
        return false;
    }

    if ((PBlobMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PBlob has different type");
        return false;
    }

    (*(__v)) = static_cast<PBlobChild*>(listener);
    return true;
}

void
PBrowserChild::Write(
        PIndexedDBChild* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PBrowserChild::Read(
        PIndexedDBChild** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PBrowser");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PIndexedDB");
        return false;
    }

    if ((PIndexedDBMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PIndexedDB has different type");
        return false;
    }

    (*(__v)) = static_cast<PIndexedDBChild*>(listener);
    return true;
}

void
PBrowserChild::Write(
        PRenderFrameChild* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PBrowserChild::Read(
        PRenderFrameChild** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PBrowser");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PRenderFrame");
        return false;
    }

    if ((PRenderFrameMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PRenderFrame has different type");
        return false;
    }

    (*(__v)) = static_cast<PRenderFrameChild*>(listener);
    return true;
}

void
PBrowserChild::Write(
        PContentPermissionRequestChild* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PBrowserChild::Read(
        PContentPermissionRequestChild** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PBrowser");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PContentPermissionRequest");
        return false;
    }

    if ((PContentPermissionRequestMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PContentPermissionRequest has different type");
        return false;
    }

    (*(__v)) = static_cast<PContentPermissionRequestChild*>(listener);
    return true;
}



} // namespace dom
} // namespace mozilla
