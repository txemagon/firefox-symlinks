//
// Automatically generated by ipdlc.
// Edit at your own risk
//


#include "mozilla/plugins/PPluginModuleChild.h"
#ifdef MOZ_CRASHREPORTER
#  include "nsXULAppAPI.h"
#endif 

#include "mozilla/plugins/PPluginIdentifierChild.h"
#include "mozilla/plugins/PPluginInstanceChild.h"
#include "mozilla/plugins/PPluginScriptableObjectChild.h"
#include "mozilla/dom/PCrashReporterChild.h"

typedef IPC::Message Message;
typedef mozilla::ipc::RPCChannel Channel;
typedef mozilla::ipc::RPCChannel::RPCListener ChannelListener;
typedef base::ProcessHandle ProcessHandle;
typedef mozilla::ipc::AsyncChannel AsyncChannel;
typedef mozilla::ipc::SharedMemory SharedMemory;
typedef mozilla::ipc::Trigger Trigger;
typedef mozilla::ipc::ActorHandle ActorHandle;
typedef mozilla::ipc::FileDescriptor FileDescriptor;
typedef mac_plugin_interposing::NSCursorInfo NSCursorInfo;
typedef mozilla::dom::NativeThreadId NativeThreadId;
typedef mozilla::ipc::Shmem Shmem;
using mozilla::plugins::PPluginIdentifierChild;
using mozilla::plugins::PPluginInstanceChild;
using mozilla::plugins::PPluginScriptableObjectChild;
using mozilla::dom::PCrashReporterChild;

namespace mozilla {
namespace plugins {


bool
PPluginModuleChild::RecvPPluginIdentifierConstructor(
        PPluginIdentifierChild* actor,
        const nsCString& aString,
        const int32_t& aInt,
        const bool& temporary)
{
    return true;
}

bool
PPluginModuleChild::AnswerPPluginInstanceConstructor(
        PPluginInstanceChild* actor,
        const nsCString& aMimeType,
        const uint16_t& aMode,
        const InfallibleTArray<nsCString>& aNames,
        const InfallibleTArray<nsCString>& aValues,
        NPError* rv)
{
    return true;
}

bool
PPluginModuleChild::AnswerPCrashReporterConstructor(
        PCrashReporterChild* actor,
        NativeThreadId* tid,
        uint32_t* processType)
{
    return true;
}

void
PPluginModuleChild::ActorDestroy(ActorDestroyReason why)
{
}

void
PPluginModuleChild::ProcessingError(Result code)
{
}

bool
PPluginModuleChild::ShouldContinueFromReplyTimeout()
{
    return true;
}

void
PPluginModuleChild::EnteredCxxStack()
{
}

void
PPluginModuleChild::ExitedCxxStack()
{
}

void
PPluginModuleChild::EnteredCall()
{
}

void
PPluginModuleChild::ExitedCall()
{
}

PPluginModuleChild::PPluginModuleChild() :
    mChannel(ALLOW_THIS_IN_INITIALIZER_LIST(this)),
    mLastRouteId(0),
    mLastShmemId(0),
    mState(PPluginModule::__Start)
{
    MOZ_COUNT_CTOR(PPluginModuleChild);
}

PPluginModuleChild::~PPluginModuleChild()
{
    MOZ_COUNT_DTOR(PPluginModuleChild);
}

bool
PPluginModuleChild::Open(
        Channel::Transport* aTransport,
        ProcessHandle aOtherProcess,
        MessageLoop* aThread,
        AsyncChannel::Side aSide)
{
    mOtherProcess = aOtherProcess;
    return (mChannel).Open(aTransport, aThread, aSide);
}

bool
PPluginModuleChild::Open(
        AsyncChannel* aChannel,
        MessageLoop* aMessageLoop,
        AsyncChannel::Side aSide)
{
    mOtherProcess = 0;
    return (mChannel).Open(aChannel, aMessageLoop, aSide);
}

void
PPluginModuleChild::Close()
{
    (mChannel).Close();
}

void
PPluginModuleChild::SetReplyTimeoutMs(int32_t aTimeoutMs)
{
    (mChannel).SetReplyTimeoutMs(aTimeoutMs);
}

void
PPluginModuleChild::ManagedPPluginInstanceChild(InfallibleTArray<PPluginInstanceChild*>& aArr) const
{
    aArr = mManagedPPluginInstanceChild;
}

const InfallibleTArray<PPluginInstanceChild*>&
PPluginModuleChild::ManagedPPluginInstanceChild() const
{
    return mManagedPPluginInstanceChild;
}

void
PPluginModuleChild::ManagedPPluginIdentifierChild(InfallibleTArray<PPluginIdentifierChild*>& aArr) const
{
    aArr = mManagedPPluginIdentifierChild;
}

const InfallibleTArray<PPluginIdentifierChild*>&
PPluginModuleChild::ManagedPPluginIdentifierChild() const
{
    return mManagedPPluginIdentifierChild;
}

void
PPluginModuleChild::ManagedPCrashReporterChild(InfallibleTArray<PCrashReporterChild*>& aArr) const
{
    aArr = mManagedPCrashReporterChild;
}

const InfallibleTArray<PCrashReporterChild*>&
PPluginModuleChild::ManagedPCrashReporterChild() const
{
    return mManagedPCrashReporterChild;
}

PPluginModule::State
PPluginModuleChild::state()
{
    return mState;
}

PPluginIdentifierChild*
PPluginModuleChild::SendPPluginIdentifierConstructor(
        const nsCString& aString,
        const int32_t& aInt,
        const bool& temporary)
{
    return SendPPluginIdentifierConstructor(AllocPPluginIdentifier(aString, aInt, temporary), aString, aInt, temporary);
}

PPluginIdentifierChild*
PPluginModuleChild::SendPPluginIdentifierConstructor(
        PPluginIdentifierChild* actor,
        const nsCString& aString,
        const int32_t& aInt,
        const bool& temporary)
{
    if ((!(actor))) {
        return 0;
    }
    (actor)->mId = Register(actor);
    (actor)->mManager = this;
    (actor)->mChannel = (&(mChannel));
    (mManagedPPluginIdentifierChild).InsertElementSorted(actor);
    (actor)->mState = mozilla::plugins::PPluginIdentifier::__Start;

    PPluginModule::Msg_PPluginIdentifierConstructor* __msg = new PPluginModule::Msg_PPluginIdentifierConstructor();

    Write(actor, __msg, false);
    Write(aString, __msg);
    Write(aInt, __msg);
    Write(temporary, __msg);

    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);


    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginModuleChild] Sending ", stderr);
    }
    if ((!(PPluginModule::Transition(mState, Trigger(Trigger::Recv, PPluginModule::Msg_PPluginIdentifierConstructor__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg);
    if ((!(__sendok))) {
        (actor)->DestroySubtree(FailedConstructor);
        (actor)->DeallocSubtree();
        ((actor)->mManager)->RemoveManagee(PPluginIdentifierMsgStart, actor);
        return 0;
    }
    return actor;
}

bool
PPluginModuleChild::SendProcessNativeEventsInRPCCall()
{
    PPluginModule::Msg_ProcessNativeEventsInRPCCall* __msg = new PPluginModule::Msg_ProcessNativeEventsInRPCCall();


    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginModuleChild] Sending ", stderr);
    }
    if ((!(PPluginModule::Transition(mState, Trigger(Trigger::Recv, PPluginModule::Msg_ProcessNativeEventsInRPCCall__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg);
    return __sendok;
}

bool
PPluginModuleChild::SendBackUpXResources(const FileDescriptor& aXSocketFd)
{
    PPluginModule::Msg_BackUpXResources* __msg = new PPluginModule::Msg_BackUpXResources();

    Write(aXSocketFd, __msg);

    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginModuleChild] Sending ", stderr);
    }
    if ((!(PPluginModule::Transition(mState, Trigger(Trigger::Recv, PPluginModule::Msg_BackUpXResources__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg);
    return __sendok;
}

bool
PPluginModuleChild::CallNPN_UserAgent(nsCString* userAgent)
{
    PPluginModule::Msg_NPN_UserAgent* __msg = new PPluginModule::Msg_NPN_UserAgent();


    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);
    (__msg)->set_rpc();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginModuleChild] Sending ", stderr);
    }
    if ((!(PPluginModule::Transition(mState, Trigger(Trigger::Recv, PPluginModule::Msg_NPN_UserAgent__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Call(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PPluginModule::Reply_NPN_UserAgent*>((&(__reply))))->Log("[PPluginModuleChild] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(userAgent, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    (__reply).EndRead(__iter);

    return true;
}

bool
PPluginModuleChild::CallNPN_GetValue_WithBoolReturn(
        const NPNVariable& aVariable,
        NPError* aError,
        bool* aBoolVal)
{
    PPluginModule::Msg_NPN_GetValue_WithBoolReturn* __msg = new PPluginModule::Msg_NPN_GetValue_WithBoolReturn();

    Write(aVariable, __msg);

    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);
    (__msg)->set_rpc();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginModuleChild] Sending ", stderr);
    }
    if ((!(PPluginModule::Transition(mState, Trigger(Trigger::Recv, PPluginModule::Msg_NPN_GetValue_WithBoolReturn__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Call(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PPluginModule::Reply_NPN_GetValue_WithBoolReturn*>((&(__reply))))->Log("[PPluginModuleChild] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(aError, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    if ((!(Read(aBoolVal, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    (__reply).EndRead(__iter);

    return true;
}

bool
PPluginModuleChild::CallProcessSomeEvents()
{
    PPluginModule::Msg_ProcessSomeEvents* __msg = new PPluginModule::Msg_ProcessSomeEvents();


    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);
    (__msg)->set_rpc();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginModuleChild] Sending ", stderr);
    }
    if ((!(PPluginModule::Transition(mState, Trigger(Trigger::Recv, PPluginModule::Msg_ProcessSomeEvents__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Call(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PPluginModule::Reply_ProcessSomeEvents*>((&(__reply))))->Log("[PPluginModuleChild] Received reply ", stderr);
    }

    return true;
}

bool
PPluginModuleChild::SendPluginShowWindow(
        const uint32_t& aWindowId,
        const bool& aModal,
        const int32_t& aX,
        const int32_t& aY,
        const size_t& aWidth,
        const size_t& aHeight)
{
    PPluginModule::Msg_PluginShowWindow* __msg = new PPluginModule::Msg_PluginShowWindow();

    Write(aWindowId, __msg);
    Write(aModal, __msg);
    Write(aX, __msg);
    Write(aY, __msg);
    Write(aWidth, __msg);
    Write(aHeight, __msg);

    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginModuleChild] Sending ", stderr);
    }
    if ((!(PPluginModule::Transition(mState, Trigger(Trigger::Recv, PPluginModule::Msg_PluginShowWindow__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg);
    return __sendok;
}

bool
PPluginModuleChild::SendPluginHideWindow(const uint32_t& aWindowId)
{
    PPluginModule::Msg_PluginHideWindow* __msg = new PPluginModule::Msg_PluginHideWindow();

    Write(aWindowId, __msg);

    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginModuleChild] Sending ", stderr);
    }
    if ((!(PPluginModule::Transition(mState, Trigger(Trigger::Recv, PPluginModule::Msg_PluginHideWindow__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg);
    return __sendok;
}

bool
PPluginModuleChild::SendSetCursor(const NSCursorInfo& cursorInfo)
{
    PPluginModule::Msg_SetCursor* __msg = new PPluginModule::Msg_SetCursor();

    Write(cursorInfo, __msg);

    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginModuleChild] Sending ", stderr);
    }
    if ((!(PPluginModule::Transition(mState, Trigger(Trigger::Recv, PPluginModule::Msg_SetCursor__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg);
    return __sendok;
}

bool
PPluginModuleChild::SendShowCursor(const bool& show)
{
    PPluginModule::Msg_ShowCursor* __msg = new PPluginModule::Msg_ShowCursor();

    Write(show, __msg);

    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginModuleChild] Sending ", stderr);
    }
    if ((!(PPluginModule::Transition(mState, Trigger(Trigger::Recv, PPluginModule::Msg_ShowCursor__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg);
    return __sendok;
}

bool
PPluginModuleChild::SendPushCursor(const NSCursorInfo& cursorInfo)
{
    PPluginModule::Msg_PushCursor* __msg = new PPluginModule::Msg_PushCursor();

    Write(cursorInfo, __msg);

    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginModuleChild] Sending ", stderr);
    }
    if ((!(PPluginModule::Transition(mState, Trigger(Trigger::Recv, PPluginModule::Msg_PushCursor__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg);
    return __sendok;
}

bool
PPluginModuleChild::SendPopCursor()
{
    PPluginModule::Msg_PopCursor* __msg = new PPluginModule::Msg_PopCursor();


    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginModuleChild] Sending ", stderr);
    }
    if ((!(PPluginModule::Transition(mState, Trigger(Trigger::Recv, PPluginModule::Msg_PopCursor__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg);
    return __sendok;
}

bool
PPluginModuleChild::SendGetNativeCursorsSupported(bool* supported)
{
    PPluginModule::Msg_GetNativeCursorsSupported* __msg = new PPluginModule::Msg_GetNativeCursorsSupported();


    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);
    (__msg)->set_sync();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginModuleChild] Sending ", stderr);
    }
    if ((!(PPluginModule::Transition(mState, Trigger(Trigger::Recv, PPluginModule::Msg_GetNativeCursorsSupported__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PPluginModule::Reply_GetNativeCursorsSupported*>((&(__reply))))->Log("[PPluginModuleChild] Received reply ", stderr);
    }

    void* __iter = 0;
    if ((!(Read(supported, (&(__reply)), (&(__iter)))))) {
        FatalError("error deserializing (better message TODO)");
        return false;
    }
    (__reply).EndRead(__iter);

    return true;
}

bool
PPluginModuleChild::SendNPN_SetException(
        PPluginScriptableObjectChild* actor,
        const nsCString& message)
{
    PPluginModule::Msg_NPN_SetException* __msg = new PPluginModule::Msg_NPN_SetException();

    Write(actor, __msg, true);
    Write(message, __msg);

    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);
    (__msg)->set_sync();


    Message __reply;

    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginModuleChild] Sending ", stderr);
    }
    if ((!(PPluginModule::Transition(mState, Trigger(Trigger::Recv, PPluginModule::Msg_NPN_SetException__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg, (&(__reply)));
    if ((!(__sendok))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabled()) {
        (static_cast<const PPluginModule::Reply_NPN_SetException*>((&(__reply))))->Log("[PPluginModuleChild] Received reply ", stderr);
    }

    return true;
}

bool
PPluginModuleChild::SendNPN_ReloadPlugins(const bool& aReloadPages)
{
    PPluginModule::Msg_NPN_ReloadPlugins* __msg = new PPluginModule::Msg_NPN_ReloadPlugins();

    Write(aReloadPages, __msg);

    (__msg)->set_routing_id(MSG_ROUTING_CONTROL);



    if (mozilla::ipc::LoggingEnabled()) {
        (__msg)->Log("[PPluginModuleChild] Sending ", stderr);
    }
    if ((!(PPluginModule::Transition(mState, Trigger(Trigger::Recv, PPluginModule::Msg_NPN_ReloadPlugins__ID), (&(mState)))))) {
        NS_WARNING("bad state transition!");
    }

    bool __sendok = (mChannel).Send(__msg);
    return __sendok;
}

int32_t
PPluginModuleChild::Register(ChannelListener* aRouted)
{
    int32_t tmp = (--(mLastRouteId));
    (mActorMap).AddWithID(aRouted, tmp);
    return tmp;
}

int32_t
PPluginModuleChild::RegisterID(
        ChannelListener* aRouted,
        int32_t aId)
{
    (mActorMap).AddWithID(aRouted, aId);
    return aId;
}

ChannelListener*
PPluginModuleChild::Lookup(int32_t aId)
{
    return (mActorMap).Lookup(aId);
}

void
PPluginModuleChild::Unregister(int32_t aId)
{
    return (mActorMap).Remove(aId);
}

void
PPluginModuleChild::RemoveManagee(
        int32_t aProtocolId,
        ChannelListener* aListener)
{
    switch (aProtocolId) {
    case PPluginInstanceMsgStart:
        {
            PPluginInstanceChild* actor = static_cast<PPluginInstanceChild*>(aListener);
            NS_ABORT_IF_FALSE(((mManagedPPluginInstanceChild).NoIndex) != ((mManagedPPluginInstanceChild).BinaryIndexOf(actor)), "actor not managed by this!");

            (mManagedPPluginInstanceChild).RemoveElementSorted(actor);
            DeallocPPluginInstance(actor);
            return;
        }
    case PPluginIdentifierMsgStart:
        {
            PPluginIdentifierChild* actor = static_cast<PPluginIdentifierChild*>(aListener);
            NS_ABORT_IF_FALSE(((mManagedPPluginIdentifierChild).NoIndex) != ((mManagedPPluginIdentifierChild).BinaryIndexOf(actor)), "actor not managed by this!");

            (mManagedPPluginIdentifierChild).RemoveElementSorted(actor);
            DeallocPPluginIdentifier(actor);
            return;
        }
    case PCrashReporterMsgStart:
        {
            PCrashReporterChild* actor = static_cast<PCrashReporterChild*>(aListener);
            NS_ABORT_IF_FALSE(((mManagedPCrashReporterChild).NoIndex) != ((mManagedPCrashReporterChild).BinaryIndexOf(actor)), "actor not managed by this!");

            (mManagedPCrashReporterChild).RemoveElementSorted(actor);
            DeallocPCrashReporter(actor);
            return;
        }
    default:
        {
            NS_RUNTIMEABORT("unreached");
            return;
        }
    }
}

Shmem::SharedMemory*
PPluginModuleChild::CreateSharedMemory(
        size_t aSize,
        Shmem::SharedMemory::SharedMemoryType aType,
        bool aUnsafe,
        Shmem::id_t* aId)
{
    nsAutoPtr<Shmem::SharedMemory> segment(Shmem::Alloc(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(), aSize, aType, aUnsafe));
    if ((!(segment))) {
        return 0;
    }
    Shmem shmem(
            Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(),
            (segment).get(),
            (--(mLastShmemId)));
    Message* descriptor = (shmem).ShareTo(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(), OtherProcess(), MSG_ROUTING_CONTROL);
    if ((!(descriptor))) {
        return 0;
    }
    if ((!((mChannel).Send(descriptor)))) {
    }
    (*(aId)) = (shmem).Id(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead());
    (mShmemMap).AddWithID(segment, (*(aId)));
    return (segment).forget();
}

bool
PPluginModuleChild::AdoptSharedMemory(
        Shmem::SharedMemory* segment,
        Shmem::id_t* aId)
{
    Shmem shmem(
            Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(),
            segment,
            (--(mLastShmemId)));
    Message* descriptor = (shmem).ShareTo(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(), OtherProcess(), MSG_ROUTING_CONTROL);
    if ((!(descriptor))) {
        return false;
    }
    if ((!((mChannel).Send(descriptor)))) {
    }
    (*(aId)) = (shmem).Id(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead());
    (mShmemMap).AddWithID(segment, (*(aId)));
    (segment)->AddRef();
    return true;
}

Shmem::SharedMemory*
PPluginModuleChild::LookupSharedMemory(Shmem::id_t aId)
{
    return (mShmemMap).Lookup(aId);
}

bool
PPluginModuleChild::IsTrackingSharedMemory(Shmem::SharedMemory* segment)
{
    return (mShmemMap).HasData(segment);
}

bool
PPluginModuleChild::DestroySharedMemory(Shmem& shmem)
{
    Shmem::id_t aId = (shmem).Id(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead());
    Shmem::SharedMemory* segment = LookupSharedMemory(aId);
    if ((!(segment))) {
        return false;
    }
    Message* descriptor = (shmem).UnshareFrom(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(), OtherProcess(), MSG_ROUTING_CONTROL);

    (mShmemMap).Remove(aId);
    Shmem::Dealloc(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(), segment);

    return (descriptor) && ((mChannel).Send(descriptor));
}

ProcessHandle
PPluginModuleChild::OtherProcess() const
{
    return mOtherProcess;
}

AsyncChannel*
PPluginModuleChild::GetIPCChannel()
{
    return (&(mChannel));
}

PPluginModuleChild::Result
PPluginModuleChild::OnMessageReceived(const Message& __msg)
{
    int32_t __route = (__msg).routing_id();
    if ((MSG_ROUTING_CONTROL) != (__route)) {
        ChannelListener* __routed = Lookup(__route);
        if ((!(__routed))) {
            return MsgRouteError;
        }
        return (__routed)->OnMessageReceived(__msg);
    }

    switch ((__msg).type()) {
    case PPluginModule::Reply_PPluginIdentifierConstructor__ID:
        {
            return MsgProcessed;
        }
    case PPluginModule::Msg_PPluginIdentifierConstructor__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginModule::Msg_PPluginIdentifierConstructor");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginModule::Msg_PPluginIdentifierConstructor*>((&(__msg))))->Log("[PPluginModuleChild] Received ", stderr);
            }

            void* __iter = 0;
            ActorHandle __handle;
            PPluginIdentifierChild* actor;
            nsCString aString;
            int32_t aInt;
            bool temporary;

            if ((!(Read((&(__handle)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(aString)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(aInt)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(temporary)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PPluginModule::Transition(mState, Trigger(Trigger::Send, PPluginModule::Msg_PPluginIdentifierConstructor__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            actor = AllocPPluginIdentifier(aString, aInt, temporary);
            if ((!(actor))) {
                return MsgValueError;
            }
            (actor)->mId = RegisterID(actor, (__handle).mId);
            (actor)->mManager = this;
            (actor)->mChannel = (&(mChannel));
            (mManagedPPluginIdentifierChild).InsertElementSorted(actor);
            (actor)->mState = mozilla::plugins::PPluginIdentifier::__Start;

            if ((!(RecvPPluginIdentifierConstructor(actor, aString, aInt, temporary)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for PPluginIdentifier returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PPluginModule::Msg_ProcessNativeEventsInRPCCall__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginModule::Msg_ProcessNativeEventsInRPCCall");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginModule::Msg_ProcessNativeEventsInRPCCall*>((&(__msg))))->Log("[PPluginModuleChild] Received ", stderr);
            }

            if ((!(PPluginModule::Transition(mState, Trigger(Trigger::Send, PPluginModule::Msg_ProcessNativeEventsInRPCCall__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvProcessNativeEventsInRPCCall()))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for ProcessNativeEventsInRPCCall returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PPluginModule::Msg_SetAudioSessionData__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginModule::Msg_SetAudioSessionData");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginModule::Msg_SetAudioSessionData*>((&(__msg))))->Log("[PPluginModuleChild] Received ", stderr);
            }

            void* __iter = 0;
            nsID aID;
            nsString aDisplayName;
            nsString aIconPath;

            if ((!(Read((&(aID)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(aDisplayName)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(aIconPath)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PPluginModule::Transition(mState, Trigger(Trigger::Send, PPluginModule::Msg_SetAudioSessionData__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvSetAudioSessionData(aID, aDisplayName, aIconPath)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for SetAudioSessionData returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PPluginModule::Msg_SetParentHangTimeout__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginModule::Msg_SetParentHangTimeout");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginModule::Msg_SetParentHangTimeout*>((&(__msg))))->Log("[PPluginModuleChild] Received ", stderr);
            }

            void* __iter = 0;
            uint32_t seconds;

            if ((!(Read((&(seconds)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PPluginModule::Transition(mState, Trigger(Trigger::Send, PPluginModule::Msg_SetParentHangTimeout__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            if ((!(RecvSetParentHangTimeout(seconds)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for SetParentHangTimeout returned error code");
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    default:
        {
            return MsgNotKnown;
        }
    case SHMEM_CREATED_MESSAGE_TYPE:
        {
            Shmem::id_t id;
            nsAutoPtr<Shmem::SharedMemory> rawmem(Shmem::OpenExisting(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(), __msg, (&(id)), true));
            if ((!(rawmem))) {
                return MsgPayloadError;
            }
            (mShmemMap).AddWithID((rawmem).forget(), id);

            return MsgProcessed;
        }
    case SHMEM_DESTROYED_MESSAGE_TYPE:
        {
            Shmem::id_t id;
            void* iter = 0;
            if ((!(IPC::ReadParam((&(__msg)), (&(iter)), (&(id)))))) {
                return MsgPayloadError;
            }
            (__msg).EndRead(iter);

            Shmem::SharedMemory* rawmem = LookupSharedMemory(id);
            if ((!(rawmem))) {
                return MsgValueError;
            }
            (mShmemMap).Remove(id);
            Shmem::Dealloc(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(), rawmem);
            return MsgProcessed;
        }
    }
}

PPluginModuleChild::Result
PPluginModuleChild::OnMessageReceived(
        const Message& __msg,
        Message*& __reply)
{
    int32_t __route = (__msg).routing_id();
    if ((MSG_ROUTING_CONTROL) != (__route)) {
        ChannelListener* __routed = Lookup(__route);
        if ((!(__routed))) {
            return MsgRouteError;
        }
        return (__routed)->OnMessageReceived(__msg, __reply);
    }

    return MsgNotKnown;
}

PPluginModuleChild::Result
PPluginModuleChild::OnCallReceived(
        const Message& __msg,
        Message*& __reply)
{
    int32_t __route = (__msg).routing_id();
    if ((MSG_ROUTING_CONTROL) != (__route)) {
        ChannelListener* __routed = Lookup(__route);
        if ((!(__routed))) {
            return MsgRouteError;
        }
        return (__routed)->OnCallReceived(__msg, __reply);
    }

    switch ((__msg).type()) {
    case PPluginModule::Msg_NP_GetEntryPoints__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginModule::Msg_NP_GetEntryPoints");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginModule::Msg_NP_GetEntryPoints*>((&(__msg))))->Log("[PPluginModuleChild] Received ", stderr);
            }

            if ((!(PPluginModule::Transition(mState, Trigger(Trigger::Send, PPluginModule::Msg_NP_GetEntryPoints__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            NPError rv;
            int32_t __id = MSG_ROUTING_CONTROL;
            if ((!(AnswerNP_GetEntryPoints((&(rv)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for NP_GetEntryPoints returned error code");
                return MsgProcessingError;
            }

            __reply = new PPluginModule::Reply_NP_GetEntryPoints();

            Write(rv, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_rpc();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginModule::Reply_NP_GetEntryPoints*>(__reply))->Log("[PPluginModuleChild] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    case PPluginModule::Msg_NP_Initialize__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginModule::Msg_NP_Initialize");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginModule::Msg_NP_Initialize*>((&(__msg))))->Log("[PPluginModuleChild] Received ", stderr);
            }

            void* __iter = 0;
            uint32_t aFlags;

            if ((!(Read((&(aFlags)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PPluginModule::Transition(mState, Trigger(Trigger::Send, PPluginModule::Msg_NP_Initialize__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            NPError rv;
            int32_t __id = MSG_ROUTING_CONTROL;
            if ((!(AnswerNP_Initialize(aFlags, (&(rv)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for NP_Initialize returned error code");
                return MsgProcessingError;
            }

            __reply = new PPluginModule::Reply_NP_Initialize();

            Write(rv, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_rpc();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginModule::Reply_NP_Initialize*>(__reply))->Log("[PPluginModuleChild] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    case PPluginModule::Msg_PPluginInstanceConstructor__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginModule::Msg_PPluginInstanceConstructor");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginModule::Msg_PPluginInstanceConstructor*>((&(__msg))))->Log("[PPluginModuleChild] Received ", stderr);
            }

            void* __iter = 0;
            ActorHandle __handle;
            PPluginInstanceChild* actor;
            nsCString aMimeType;
            uint16_t aMode;
            InfallibleTArray<nsCString> aNames;
            InfallibleTArray<nsCString> aValues;

            if ((!(Read((&(__handle)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(aMimeType)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(aMode)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(aNames)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(aValues)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PPluginModule::Transition(mState, Trigger(Trigger::Send, PPluginModule::Msg_PPluginInstanceConstructor__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            NPError rv;
            actor = AllocPPluginInstance(aMimeType, aMode, aNames, aValues, (&(rv)));
            if ((!(actor))) {
                return MsgValueError;
            }
            (actor)->mId = RegisterID(actor, (__handle).mId);
            (actor)->mManager = this;
            (actor)->mChannel = (&(mChannel));
            (mManagedPPluginInstanceChild).InsertElementSorted(actor);
            (actor)->mState = mozilla::plugins::PPluginInstance::__Start;

            int32_t __id = MSG_ROUTING_CONTROL;
            if ((!(AnswerPPluginInstanceConstructor(actor, aMimeType, aMode, aNames, aValues, (&(rv)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for PPluginInstance returned error code");
                return MsgProcessingError;
            }
            __reply = new PPluginModule::Reply_PPluginInstanceConstructor();

            Write(rv, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_rpc();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginModule::Reply_PPluginInstanceConstructor*>(__reply))->Log("[PPluginModuleChild] Sending reply ", stderr);
            }

            return MsgProcessed;
        }
    case PPluginModule::Msg_NP_Shutdown__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginModule::Msg_NP_Shutdown");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginModule::Msg_NP_Shutdown*>((&(__msg))))->Log("[PPluginModuleChild] Received ", stderr);
            }

            if ((!(PPluginModule::Transition(mState, Trigger(Trigger::Send, PPluginModule::Msg_NP_Shutdown__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            NPError rv;
            int32_t __id = MSG_ROUTING_CONTROL;
            if ((!(AnswerNP_Shutdown((&(rv)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for NP_Shutdown returned error code");
                return MsgProcessingError;
            }

            __reply = new PPluginModule::Reply_NP_Shutdown();

            Write(rv, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_rpc();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginModule::Reply_NP_Shutdown*>(__reply))->Log("[PPluginModuleChild] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    case PPluginModule::Msg_OptionalFunctionsSupported__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginModule::Msg_OptionalFunctionsSupported");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginModule::Msg_OptionalFunctionsSupported*>((&(__msg))))->Log("[PPluginModuleChild] Received ", stderr);
            }

            if ((!(PPluginModule::Transition(mState, Trigger(Trigger::Send, PPluginModule::Msg_OptionalFunctionsSupported__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            bool aURLRedirectNotify;
            bool aClearSiteData;
            bool aGetSitesWithData;
            int32_t __id = MSG_ROUTING_CONTROL;
            if ((!(AnswerOptionalFunctionsSupported((&(aURLRedirectNotify)), (&(aClearSiteData)), (&(aGetSitesWithData)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for OptionalFunctionsSupported returned error code");
                return MsgProcessingError;
            }

            __reply = new PPluginModule::Reply_OptionalFunctionsSupported();

            Write(aURLRedirectNotify, __reply);
            Write(aClearSiteData, __reply);
            Write(aGetSitesWithData, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_rpc();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginModule::Reply_OptionalFunctionsSupported*>(__reply))->Log("[PPluginModuleChild] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    case PPluginModule::Msg_NPP_ClearSiteData__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginModule::Msg_NPP_ClearSiteData");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginModule::Msg_NPP_ClearSiteData*>((&(__msg))))->Log("[PPluginModuleChild] Received ", stderr);
            }

            void* __iter = 0;
            nsCString site;
            uint64_t flags;
            uint64_t maxAge;

            if ((!(Read((&(site)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(flags)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            if ((!(Read((&(maxAge)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PPluginModule::Transition(mState, Trigger(Trigger::Send, PPluginModule::Msg_NPP_ClearSiteData__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            NPError rv;
            int32_t __id = MSG_ROUTING_CONTROL;
            if ((!(AnswerNPP_ClearSiteData(site, flags, maxAge, (&(rv)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for NPP_ClearSiteData returned error code");
                return MsgProcessingError;
            }

            __reply = new PPluginModule::Reply_NPP_ClearSiteData();

            Write(rv, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_rpc();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginModule::Reply_NPP_ClearSiteData*>(__reply))->Log("[PPluginModuleChild] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    case PPluginModule::Msg_NPP_GetSitesWithData__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginModule::Msg_NPP_GetSitesWithData");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginModule::Msg_NPP_GetSitesWithData*>((&(__msg))))->Log("[PPluginModuleChild] Received ", stderr);
            }

            if ((!(PPluginModule::Transition(mState, Trigger(Trigger::Send, PPluginModule::Msg_NPP_GetSitesWithData__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            InfallibleTArray<nsCString> sites;
            int32_t __id = MSG_ROUTING_CONTROL;
            if ((!(AnswerNPP_GetSitesWithData((&(sites)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for NPP_GetSitesWithData returned error code");
                return MsgProcessingError;
            }

            __reply = new PPluginModule::Reply_NPP_GetSitesWithData();

            Write(sites, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_rpc();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginModule::Reply_NPP_GetSitesWithData*>(__reply))->Log("[PPluginModuleChild] Sending reply ", stderr);
            }
            return MsgProcessed;
        }
    case PPluginModule::Msg_PCrashReporterConstructor__ID:
        {
            (const_cast<Message&>(__msg)).set_name("PPluginModule::Msg_PCrashReporterConstructor");
            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginModule::Msg_PCrashReporterConstructor*>((&(__msg))))->Log("[PPluginModuleChild] Received ", stderr);
            }

            void* __iter = 0;
            ActorHandle __handle;
            PCrashReporterChild* actor;

            if ((!(Read((&(__handle)), (&(__msg)), (&(__iter)))))) {
                FatalError("error deserializing (better message TODO)");
                return MsgValueError;
            }
            (__msg).EndRead(__iter);
            if ((!(PPluginModule::Transition(mState, Trigger(Trigger::Send, PPluginModule::Msg_PCrashReporterConstructor__ID), (&(mState)))))) {
                NS_WARNING("bad state transition!");
            }
            NativeThreadId tid;
            uint32_t processType;
            actor = AllocPCrashReporter((&(tid)), (&(processType)));
            if ((!(actor))) {
                return MsgValueError;
            }
            (actor)->mId = RegisterID(actor, (__handle).mId);
            (actor)->mManager = this;
            (actor)->mChannel = (&(mChannel));
            (mManagedPCrashReporterChild).InsertElementSorted(actor);
            (actor)->mState = mozilla::dom::PCrashReporter::__Start;

            int32_t __id = MSG_ROUTING_CONTROL;
            if ((!(AnswerPCrashReporterConstructor(actor, (&(tid)), (&(processType)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler for PCrashReporter returned error code");
                return MsgProcessingError;
            }
            __reply = new PPluginModule::Reply_PCrashReporterConstructor();

            Write(tid, __reply);
            Write(processType, __reply);
            (__reply)->set_routing_id(__id);
            (__reply)->set_rpc();
            (__reply)->set_reply();

            if (mozilla::ipc::LoggingEnabled()) {
                (static_cast<const PPluginModule::Reply_PCrashReporterConstructor*>(__reply))->Log("[PPluginModuleChild] Sending reply ", stderr);
            }

            return MsgProcessed;
        }
    default:
        {
            return MsgNotKnown;
        }
    }
}

void
PPluginModuleChild::OnProcessingError(Result code)
{
    return ProcessingError(code);
}

int32_t
PPluginModuleChild::GetProtocolTypeId()
{
    return PPluginModuleMsgStart;
}

bool
PPluginModuleChild::OnReplyTimeout()
{
    return ShouldContinueFromReplyTimeout();
}

void
PPluginModuleChild::OnEnteredCxxStack()
{
    return EnteredCxxStack();
}

void
PPluginModuleChild::OnExitedCxxStack()
{
    return ExitedCxxStack();
}

void
PPluginModuleChild::OnEnteredCall()
{
    return EnteredCall();
}

void
PPluginModuleChild::OnExitedCall()
{
    return ExitedCall();
}

bool
PPluginModuleChild::IsOnCxxStack() const
{
    return (mChannel).IsOnCxxStack();
}

void
PPluginModuleChild::FlushPendingRPCQueue()
{
    ((this)->mChannel).FlushPendingRPCQueue();
}

void
PPluginModuleChild::OnChannelClose()
{
    DestroySubtree(NormalShutdown);
    DeallocSubtree();
    DeallocShmems();
}

void
PPluginModuleChild::OnChannelError()
{
    DestroySubtree(AbnormalShutdown);
    DeallocSubtree();
    DeallocShmems();
}

void
PPluginModuleChild::OnChannelConnected(int32_t pid)
{
}

bool
PPluginModuleChild::AllocShmem(
        size_t aSize,
        Shmem::SharedMemory::SharedMemoryType aType,
        Shmem* aMem)
{
    Shmem::id_t aId;
    nsAutoPtr<Shmem::SharedMemory> rawmem(CreateSharedMemory(aSize, aType, false, (&(aId))));
    if ((!(rawmem))) {
        return false;
    }

    (*(aMem)) = Shmem(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(), (rawmem).forget(), aId);
    return true;
}

bool
PPluginModuleChild::AllocUnsafeShmem(
        size_t aSize,
        Shmem::SharedMemory::SharedMemoryType aType,
        Shmem* aMem)
{
    Shmem::id_t aId;
    nsAutoPtr<Shmem::SharedMemory> rawmem(CreateSharedMemory(aSize, aType, true, (&(aId))));
    if ((!(rawmem))) {
        return false;
    }

    (*(aMem)) = Shmem(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(), (rawmem).forget(), aId);
    return true;
}

bool
PPluginModuleChild::AdoptShmem(
        Shmem& aMem,
        Shmem* aOutMem)
{
    Shmem::SharedMemory* rawmem = (aMem).Segment(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead());
    if (((!(rawmem))) || (IsTrackingSharedMemory(rawmem))) {
        NS_RUNTIMEABORT("bad Shmem");
    }

    Shmem::id_t aId;
    if ((!(AdoptSharedMemory(rawmem, (&(aId)))))) {
        return false;
    }

    (*(aOutMem)) = Shmem(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(), rawmem, aId);
    return true;
}

bool
PPluginModuleChild::DeallocShmem(Shmem& aMem)
{
    bool ok = DestroySharedMemory(aMem);
    (aMem).forget(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead());
    return ok;
}

void
PPluginModuleChild::ProcessNativeEventsInRPCCall()
{
#ifdef OS_WIN
    (mChannel).ProcessNativeEventsInRPCCall();
#else 
    NS_RUNTIMEABORT("This method is Windows-only");
#endif 
}

void
PPluginModuleChild::FatalError(const char* const msg) const
{
    // Virtual method to prevent inlining.
    // This give us better error reporting.
    // See bug 589371

    NS_ERROR("IPDL error:");
    NS_ERROR(msg);
    mozilla::ipc::ProtocolErrorBreakpoint(msg);

    NS_RUNTIMEABORT("[PPluginModuleChild] abort()ing as a result");
}

void
PPluginModuleChild::DestroySubtree(ActorDestroyReason why)
{
    ActorDestroyReason subtreewhy = (((why) == (Deletion)) || ((why) == (FailedConstructor)) ? AncestorDeletion : why);

    {
        // Recursively shutting down PPluginInstance kids
        InfallibleTArray<PPluginInstanceChild*> kids(mManagedPPluginInstanceChild);
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DestroySubtree(subtreewhy);
        }
    }
    {
        // Recursively shutting down PPluginIdentifier kids
        InfallibleTArray<PPluginIdentifierChild*> kids(mManagedPPluginIdentifierChild);
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DestroySubtree(subtreewhy);
        }
    }
    {
        // Recursively shutting down PCrashReporter kids
        InfallibleTArray<PCrashReporterChild*> kids(mManagedPCrashReporterChild);
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DestroySubtree(subtreewhy);
        }
    }

    // Finally, destroy "us".
    ActorDestroy(why);
}

void
PPluginModuleChild::DeallocSubtree()
{
    {
        // Recursively deleting PPluginInstance kids
        InfallibleTArray<PPluginInstanceChild*>& kids = mManagedPPluginInstanceChild;
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DeallocSubtree();
        }

        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            DeallocPPluginInstance(kids[i]);
        }
        (mManagedPPluginInstanceChild).Clear();
    }
    {
        // Recursively deleting PPluginIdentifier kids
        InfallibleTArray<PPluginIdentifierChild*>& kids = mManagedPPluginIdentifierChild;
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DeallocSubtree();
        }

        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            DeallocPPluginIdentifier(kids[i]);
        }
        (mManagedPPluginIdentifierChild).Clear();
    }
    {
        // Recursively deleting PCrashReporter kids
        InfallibleTArray<PCrashReporterChild*>& kids = mManagedPCrashReporterChild;
        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            (kids[i])->DeallocSubtree();
        }

        for (uint32_t i = 0; (i) < ((kids).Length()); (++(i))) {
            DeallocPCrashReporter(kids[i]);
        }
        (mManagedPCrashReporterChild).Clear();
    }
}

void
PPluginModuleChild::DeallocShmems()
{
    for (IDMap<SharedMemory>::const_iterator cit = (mShmemMap).begin(); (cit) != ((mShmemMap).end()); (++(cit))) {
        Shmem::Dealloc(Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead(), (cit)->second);
    }
    (mShmemMap).Clear();
}

void
PPluginModuleChild::Write(
        const FileDescriptor& __v,
        Message* __msg)
{
    FileDescriptor::PickleType pfd = (__v).ShareTo(FileDescriptor::IPDLPrivate(), OtherProcess());
    IPC::WriteParam(__msg, pfd);
}

bool
PPluginModuleChild::Read(
        FileDescriptor* __v,
        const Message* __msg,
        void** __iter)
{
    FileDescriptor::PickleType pfd;
    if ((!(IPC::ReadParam(__msg, __iter, (&(pfd)))))) {
        return false;
    }

    FileDescriptor fd = FileDescriptor(FileDescriptor::IPDLPrivate(), pfd);
    if ((!((fd).IsValid()))) {
        return false;
    }

    (*(__v)) = fd;
    return true;
}

void
PPluginModuleChild::Write(
        PPluginScriptableObjectChild* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PPluginModuleChild::Read(
        PPluginScriptableObjectChild** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PPluginModule");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PPluginScriptableObject");
        return false;
    }

    if ((PPluginScriptableObjectMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PPluginScriptableObject has different type");
        return false;
    }

    (*(__v)) = static_cast<PPluginScriptableObjectChild*>(listener);
    return true;
}

void
PPluginModuleChild::Write(
        PPluginInstanceChild* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PPluginModuleChild::Read(
        PPluginInstanceChild** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PPluginModule");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PPluginInstance");
        return false;
    }

    if ((PPluginInstanceMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PPluginInstance has different type");
        return false;
    }

    (*(__v)) = static_cast<PPluginInstanceChild*>(listener);
    return true;
}

void
PPluginModuleChild::Write(
        PCrashReporterChild* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PPluginModuleChild::Read(
        PCrashReporterChild** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PPluginModule");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PCrashReporter");
        return false;
    }

    if ((PCrashReporterMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PCrashReporter has different type");
        return false;
    }

    (*(__v)) = static_cast<PCrashReporterChild*>(listener);
    return true;
}

void
PPluginModuleChild::Write(
        PPluginIdentifierChild* __v,
        Message* __msg,
        bool __nullable)
{
    int32_t id;
    if ((!(__v))) {
        if ((!(__nullable))) {
            NS_RUNTIMEABORT("NULL actor value passed to non-nullable param");
        }
        id = 0;
    }
    else {
        id = (__v)->mId;
        if ((1) == (id)) {
            NS_RUNTIMEABORT("actor has been |delete|d");
        }
    }

    Write(id, __msg);
}

bool
PPluginModuleChild::Read(
        PPluginIdentifierChild** __v,
        const Message* __msg,
        void** __iter,
        bool __nullable)
{
    int32_t id;
    if ((!(Read((&(id)), __msg, __iter)))) {
        mozilla::ipc::ProtocolErrorBreakpoint("error deserializing (better message TODO)");
        return false;
    }
    if (((1) == (id)) || (((0) == (id)) && ((!(__nullable))))) {
        mozilla::ipc::ProtocolErrorBreakpoint("bad ID for PPluginModule");
        return false;
    }

    if ((0) == (id)) {
        (*(__v)) = 0;
        return true;
    }

    ChannelListener* listener = Lookup(id);
    if ((!(listener))) {
        mozilla::ipc::ProtocolErrorBreakpoint("could not look up PPluginIdentifier");
        return false;
    }

    if ((PPluginIdentifierMsgStart) != ((listener)->GetProtocolTypeId())) {
        mozilla::ipc::ProtocolErrorBreakpoint("actor that should be of type PPluginIdentifier has different type");
        return false;
    }

    (*(__v)) = static_cast<PPluginIdentifierChild*>(listener);
    return true;
}



} // namespace plugins
} // namespace mozilla
