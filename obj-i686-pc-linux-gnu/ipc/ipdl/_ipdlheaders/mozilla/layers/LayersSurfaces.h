//
// Automatically generated by ipdlc.
// Edit at your own risk
//

#ifndef LayersSurfaces_h
#define LayersSurfaces_h

#include "mozilla/Attributes.h"
#include "base/basictypes.h"
#include "prtime.h"
#include "nscore.h"
#include "IPCMessageStart.h"
#include "ipc/IPCMessageUtils.h"
#include "nsAutoPtr.h"
#include "nsStringGlue.h"
#include "nsTArray.h"
#include "nsIFile.h"
#include "mozilla/ipc/ProtocolUtils.h"
#include "gfxipc/ShadowLayerUtils.h"


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union MaybeMagicGrallocBufferHandle|
//
namespace mozilla {
namespace layers {
class MaybeMagicGrallocBufferHandle MOZ_FINAL
{
public:
    enum Type {
        T__None,
        TMagicGrallocBufferHandle = 1,
        Tnull_t,
        T__Last = Tnull_t
    };

private:
    typedef mozilla::layers::MagicGrallocBufferHandle MagicGrallocBufferHandle;
    typedef mozilla::null_t null_t;
    typedef MagicGrallocBufferHandle MagicGrallocBufferHandle__tdef;
    typedef null_t null_t__tdef;

    union Value {
        char VMagicGrallocBufferHandle[sizeof(MagicGrallocBufferHandle)];
        char Vnull_t[sizeof(null_t)];
    };

    MagicGrallocBufferHandle*
    ptr_MagicGrallocBufferHandle()
    {
        return reinterpret_cast<MagicGrallocBufferHandle*>((&((mValue).VMagicGrallocBufferHandle)));
    }
    const MagicGrallocBufferHandle* const
    constptr_MagicGrallocBufferHandle() const
    {
        return reinterpret_cast<const MagicGrallocBufferHandle* const>((&((mValue).VMagicGrallocBufferHandle)));
    }
    null_t*
    ptr_null_t()
    {
        return reinterpret_cast<null_t*>((&((mValue).Vnull_t)));
    }
    const null_t* const
    constptr_null_t() const
    {
        return reinterpret_cast<const null_t* const>((&((mValue).Vnull_t)));
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        NS_ABORT_IF_FALSE((T__None) <= (mType), "invalid type tag");
        NS_ABORT_IF_FALSE((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        NS_ABORT_IF_FALSE((mType) == (aType), "unexpected type tag");
    }

public:
    MaybeMagicGrallocBufferHandle() :
        mType(T__None)
    {
    }

    MaybeMagicGrallocBufferHandle(const MagicGrallocBufferHandle& aOther);

    MaybeMagicGrallocBufferHandle(const null_t& aOther);

    MaybeMagicGrallocBufferHandle(const MaybeMagicGrallocBufferHandle& aOther);

    ~MaybeMagicGrallocBufferHandle();

    Type
    type() const
    {
        return mType;
    }

    MaybeMagicGrallocBufferHandle&
    operator=(const MagicGrallocBufferHandle& aRhs);

    MaybeMagicGrallocBufferHandle&
    operator=(const null_t& aRhs);

    MaybeMagicGrallocBufferHandle&
    operator=(const MaybeMagicGrallocBufferHandle& aRhs);

    bool
    operator==(const MagicGrallocBufferHandle& aRhs) const;

    bool
    operator==(const null_t& aRhs) const;

    bool
    operator==(const MaybeMagicGrallocBufferHandle& aRhs) const;

    MagicGrallocBufferHandle&
    get_MagicGrallocBufferHandle()
    {
        AssertSanity(TMagicGrallocBufferHandle);
        return (*(ptr_MagicGrallocBufferHandle()));
    }
    const MagicGrallocBufferHandle&
    get_MagicGrallocBufferHandle() const
    {
        AssertSanity(TMagicGrallocBufferHandle);
        return (*(constptr_MagicGrallocBufferHandle()));
    }
    operator MagicGrallocBufferHandle&()
    {
        return get_MagicGrallocBufferHandle();
    }
    operator const MagicGrallocBufferHandle&() const
    {
        return get_MagicGrallocBufferHandle();
    }

    null_t&
    get_null_t()
    {
        AssertSanity(Tnull_t);
        return (*(ptr_null_t()));
    }
    const null_t&
    get_null_t() const
    {
        AssertSanity(Tnull_t);
        return (*(constptr_null_t()));
    }
    operator null_t&()
    {
        return get_null_t();
    }
    operator const null_t&() const
    {
        return get_null_t();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace layers
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct SurfaceDescriptorD3D10|
//
namespace mozilla {
namespace layers {
class SurfaceDescriptorD3D10 MOZ_FINAL
{
private:
    typedef mozilla::WindowsHandle WindowsHandle;

public:
    SurfaceDescriptorD3D10();

    SurfaceDescriptorD3D10(const WindowsHandle& _handle)
    {
        Init();
        Assign(_handle);
    }

    SurfaceDescriptorD3D10(const SurfaceDescriptorD3D10& _o)
    {
        Init();
        Assign((_o).handle());
    }

    ~SurfaceDescriptorD3D10();

    void
    operator=(const SurfaceDescriptorD3D10& _o)
    {
        Assign((_o).handle());
    }

    bool
    operator==(const SurfaceDescriptorD3D10& _o) const;

    WindowsHandle&
    handle()
    {
        return handle_;
    }
    const WindowsHandle&
    handle() const
    {
        return handle_;
    }

private:
    void
    Init();

    void
    Assign(const WindowsHandle& _handle);

    WindowsHandle handle_;
};
} // namespace layers
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct SharedTextureDescriptor|
//
namespace mozilla {
namespace layers {
class SharedTextureDescriptor MOZ_FINAL
{
private:
    typedef mozilla::gl::GLContext::SharedTextureShareType SharedTextureShareType;
    typedef mozilla::gl::SharedTextureHandle SharedTextureHandle;

public:
    SharedTextureDescriptor();

    SharedTextureDescriptor(
            const SharedTextureShareType& _shareType,
            const SharedTextureHandle& _handle,
            const nsIntSize& _size,
            const bool& _inverted)
    {
        Init();
        Assign(_shareType, _handle, _size, _inverted);
    }

    SharedTextureDescriptor(const SharedTextureDescriptor& _o)
    {
        Init();
        Assign((_o).shareType(), (_o).handle(), (_o).size(), (_o).inverted());
    }

    ~SharedTextureDescriptor();

    void
    operator=(const SharedTextureDescriptor& _o)
    {
        Assign((_o).shareType(), (_o).handle(), (_o).size(), (_o).inverted());
    }

    bool
    operator==(const SharedTextureDescriptor& _o) const;

    SharedTextureShareType&
    shareType()
    {
        return shareType_;
    }
    const SharedTextureShareType&
    shareType() const
    {
        return shareType_;
    }

    SharedTextureHandle&
    handle()
    {
        return handle_;
    }
    const SharedTextureHandle&
    handle() const
    {
        return handle_;
    }

    nsIntSize&
    size()
    {
        return size_;
    }
    const nsIntSize&
    size() const
    {
        return size_;
    }

    bool&
    inverted()
    {
        return inverted_;
    }
    const bool&
    inverted() const
    {
        return inverted_;
    }

private:
    void
    Init();

    void
    Assign(
            const SharedTextureShareType& _shareType,
            const SharedTextureHandle& _handle,
            const nsIntSize& _size,
            const bool& _inverted);

    SharedTextureShareType shareType_;
    SharedTextureHandle handle_;
    nsIntSize size_;
    bool inverted_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace layers {
class PGrallocBufferParent;
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace layers {
class PGrallocBufferChild;
} // namespace layers
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct SurfaceDescriptorGralloc|
//
namespace mozilla {
namespace layers {
class SurfaceDescriptorGralloc MOZ_FINAL
{
private:
    typedef mozilla::layers::PGrallocBufferParent PGrallocBufferParent;
    typedef mozilla::layers::PGrallocBufferChild PGrallocBufferChild;

public:
    SurfaceDescriptorGralloc();

    SurfaceDescriptorGralloc(
            PGrallocBufferParent* _bufferParent,
            PGrallocBufferChild* _bufferChild,
            const bool& _external)
    {
        Init();
        Assign(_bufferParent, _bufferChild, _external);
    }

    SurfaceDescriptorGralloc(const SurfaceDescriptorGralloc& _o)
    {
        Init();
        Assign(const_cast<PGrallocBufferParent*>((_o).bufferParent()), const_cast<PGrallocBufferChild*>((_o).bufferChild()), (_o).external());
    }

    ~SurfaceDescriptorGralloc();

    void
    operator=(const SurfaceDescriptorGralloc& _o)
    {
        Assign(const_cast<PGrallocBufferParent*>((_o).bufferParent()), const_cast<PGrallocBufferChild*>((_o).bufferChild()), (_o).external());
    }

    bool
    operator==(const SurfaceDescriptorGralloc& _o) const;

    PGrallocBufferParent*&
    bufferParent()
    {
        return bufferParent_;
    }
    PGrallocBufferParent*
    bufferParent() const
    {
        return bufferParent_;
    }

    PGrallocBufferChild*&
    bufferChild()
    {
        return bufferChild_;
    }
    PGrallocBufferChild*
    bufferChild() const
    {
        return bufferChild_;
    }

    bool&
    external()
    {
        return external_;
    }
    const bool&
    external() const
    {
        return external_;
    }

private:
    void
    Init();

    void
    Assign(
            PGrallocBufferParent* _bufferParent,
            PGrallocBufferChild* _bufferChild,
            const bool& _external);

    PGrallocBufferParent* bufferParent_;
    PGrallocBufferChild* bufferChild_;
    bool external_;
};
} // namespace layers
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct SharedImageID|
//
namespace mozilla {
namespace layers {
class SharedImageID MOZ_FINAL
{
private:

public:
    SharedImageID();

    SharedImageID(const uint64_t& _id)
    {
        Init();
        Assign(_id);
    }

    SharedImageID(const SharedImageID& _o)
    {
        Init();
        Assign((_o).id());
    }

    ~SharedImageID();

    void
    operator=(const SharedImageID& _o)
    {
        Assign((_o).id());
    }

    bool
    operator==(const SharedImageID& _o) const;

    uint64_t&
    id()
    {
        return id_;
    }
    const uint64_t&
    id() const
    {
        return id_;
    }

private:
    void
    Init();

    void
    Assign(const uint64_t& _id);

    uint64_t id_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace layers {
class SurfaceDescriptorD3D10;
} // namespace layers
} // namespace mozilla
namespace mozilla {
namespace layers {
class SurfaceDescriptorGralloc;
} // namespace layers
} // namespace mozilla
namespace mozilla {
namespace layers {
class SharedTextureDescriptor;
} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union SurfaceDescriptor|
//
namespace mozilla {
namespace layers {
class SurfaceDescriptor MOZ_FINAL
{
public:
    enum Type {
        T__None,
        TShmem = 1,
        TSurfaceDescriptorD3D10,
        TSurfaceDescriptorGralloc,
        TSurfaceDescriptorX11,
        TSharedTextureDescriptor,
        T__Last = TSharedTextureDescriptor
    };

private:
    typedef mozilla::ipc::Shmem Shmem;
    typedef mozilla::layers::SurfaceDescriptorD3D10 SurfaceDescriptorD3D10;
    typedef mozilla::layers::SurfaceDescriptorGralloc SurfaceDescriptorGralloc;
    typedef mozilla::layers::SurfaceDescriptorX11 SurfaceDescriptorX11;
    typedef mozilla::layers::SharedTextureDescriptor SharedTextureDescriptor;
    typedef Shmem Shmem__tdef;
    typedef SurfaceDescriptorD3D10 SurfaceDescriptorD3D10__tdef;
    typedef SurfaceDescriptorGralloc SurfaceDescriptorGralloc__tdef;
    typedef SurfaceDescriptorX11 SurfaceDescriptorX11__tdef;
    typedef SharedTextureDescriptor SharedTextureDescriptor__tdef;

    union Value {
        char VShmem[sizeof(Shmem)];
        char VSurfaceDescriptorD3D10[sizeof(SurfaceDescriptorD3D10)];
        char VSurfaceDescriptorGralloc[sizeof(SurfaceDescriptorGralloc)];
        char VSurfaceDescriptorX11[sizeof(SurfaceDescriptorX11)];
        char VSharedTextureDescriptor[sizeof(SharedTextureDescriptor)];
    };

    Shmem*
    ptr_Shmem()
    {
        return reinterpret_cast<Shmem*>((&((mValue).VShmem)));
    }
    const Shmem* const
    constptr_Shmem() const
    {
        return reinterpret_cast<const Shmem* const>((&((mValue).VShmem)));
    }
    SurfaceDescriptorD3D10*
    ptr_SurfaceDescriptorD3D10()
    {
        return reinterpret_cast<SurfaceDescriptorD3D10*>((&((mValue).VSurfaceDescriptorD3D10)));
    }
    const SurfaceDescriptorD3D10* const
    constptr_SurfaceDescriptorD3D10() const
    {
        return reinterpret_cast<const SurfaceDescriptorD3D10* const>((&((mValue).VSurfaceDescriptorD3D10)));
    }
    SurfaceDescriptorGralloc*
    ptr_SurfaceDescriptorGralloc()
    {
        return reinterpret_cast<SurfaceDescriptorGralloc*>((&((mValue).VSurfaceDescriptorGralloc)));
    }
    const SurfaceDescriptorGralloc* const
    constptr_SurfaceDescriptorGralloc() const
    {
        return reinterpret_cast<const SurfaceDescriptorGralloc* const>((&((mValue).VSurfaceDescriptorGralloc)));
    }
    SurfaceDescriptorX11*
    ptr_SurfaceDescriptorX11()
    {
        return reinterpret_cast<SurfaceDescriptorX11*>((&((mValue).VSurfaceDescriptorX11)));
    }
    const SurfaceDescriptorX11* const
    constptr_SurfaceDescriptorX11() const
    {
        return reinterpret_cast<const SurfaceDescriptorX11* const>((&((mValue).VSurfaceDescriptorX11)));
    }
    SharedTextureDescriptor*
    ptr_SharedTextureDescriptor()
    {
        return reinterpret_cast<SharedTextureDescriptor*>((&((mValue).VSharedTextureDescriptor)));
    }
    const SharedTextureDescriptor* const
    constptr_SharedTextureDescriptor() const
    {
        return reinterpret_cast<const SharedTextureDescriptor* const>((&((mValue).VSharedTextureDescriptor)));
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        NS_ABORT_IF_FALSE((T__None) <= (mType), "invalid type tag");
        NS_ABORT_IF_FALSE((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        NS_ABORT_IF_FALSE((mType) == (aType), "unexpected type tag");
    }

public:
    SurfaceDescriptor() :
        mType(T__None)
    {
    }

    SurfaceDescriptor(Shmem& aOther);

    SurfaceDescriptor(const SurfaceDescriptorD3D10& aOther);

    SurfaceDescriptor(const SurfaceDescriptorGralloc& aOther);

    SurfaceDescriptor(const SurfaceDescriptorX11& aOther);

    SurfaceDescriptor(const SharedTextureDescriptor& aOther);

    SurfaceDescriptor(const SurfaceDescriptor& aOther);

    ~SurfaceDescriptor();

    Type
    type() const
    {
        return mType;
    }

    SurfaceDescriptor&
    operator=(Shmem& aRhs);

    SurfaceDescriptor&
    operator=(const SurfaceDescriptorD3D10& aRhs);

    SurfaceDescriptor&
    operator=(const SurfaceDescriptorGralloc& aRhs);

    SurfaceDescriptor&
    operator=(const SurfaceDescriptorX11& aRhs);

    SurfaceDescriptor&
    operator=(const SharedTextureDescriptor& aRhs);

    SurfaceDescriptor&
    operator=(const SurfaceDescriptor& aRhs);

    bool
    operator==(Shmem& aRhs) const;

    bool
    operator==(const SurfaceDescriptorD3D10& aRhs) const;

    bool
    operator==(const SurfaceDescriptorGralloc& aRhs) const;

    bool
    operator==(const SurfaceDescriptorX11& aRhs) const;

    bool
    operator==(const SharedTextureDescriptor& aRhs) const;

    bool
    operator==(const SurfaceDescriptor& aRhs) const;

    Shmem&
    get_Shmem()
    {
        AssertSanity(TShmem);
        return (*(ptr_Shmem()));
    }
    Shmem&
    get_Shmem() const
    {
        AssertSanity(TShmem);
        return const_cast<Shmem&>((*(constptr_Shmem())));
    }
    operator Shmem&()
    {
        return get_Shmem();
    }
    operator Shmem&() const
    {
        return get_Shmem();
    }

    SurfaceDescriptorD3D10&
    get_SurfaceDescriptorD3D10()
    {
        AssertSanity(TSurfaceDescriptorD3D10);
        return (*(ptr_SurfaceDescriptorD3D10()));
    }
    const SurfaceDescriptorD3D10&
    get_SurfaceDescriptorD3D10() const
    {
        AssertSanity(TSurfaceDescriptorD3D10);
        return (*(constptr_SurfaceDescriptorD3D10()));
    }
    operator SurfaceDescriptorD3D10&()
    {
        return get_SurfaceDescriptorD3D10();
    }
    operator const SurfaceDescriptorD3D10&() const
    {
        return get_SurfaceDescriptorD3D10();
    }

    SurfaceDescriptorGralloc&
    get_SurfaceDescriptorGralloc()
    {
        AssertSanity(TSurfaceDescriptorGralloc);
        return (*(ptr_SurfaceDescriptorGralloc()));
    }
    const SurfaceDescriptorGralloc&
    get_SurfaceDescriptorGralloc() const
    {
        AssertSanity(TSurfaceDescriptorGralloc);
        return (*(constptr_SurfaceDescriptorGralloc()));
    }
    operator SurfaceDescriptorGralloc&()
    {
        return get_SurfaceDescriptorGralloc();
    }
    operator const SurfaceDescriptorGralloc&() const
    {
        return get_SurfaceDescriptorGralloc();
    }

    SurfaceDescriptorX11&
    get_SurfaceDescriptorX11()
    {
        AssertSanity(TSurfaceDescriptorX11);
        return (*(ptr_SurfaceDescriptorX11()));
    }
    const SurfaceDescriptorX11&
    get_SurfaceDescriptorX11() const
    {
        AssertSanity(TSurfaceDescriptorX11);
        return (*(constptr_SurfaceDescriptorX11()));
    }
    operator SurfaceDescriptorX11&()
    {
        return get_SurfaceDescriptorX11();
    }
    operator const SurfaceDescriptorX11&() const
    {
        return get_SurfaceDescriptorX11();
    }

    SharedTextureDescriptor&
    get_SharedTextureDescriptor()
    {
        AssertSanity(TSharedTextureDescriptor);
        return (*(ptr_SharedTextureDescriptor()));
    }
    const SharedTextureDescriptor&
    get_SharedTextureDescriptor() const
    {
        AssertSanity(TSharedTextureDescriptor);
        return (*(constptr_SharedTextureDescriptor()));
    }
    operator SharedTextureDescriptor&()
    {
        return get_SharedTextureDescriptor();
    }
    operator const SharedTextureDescriptor&() const
    {
        return get_SharedTextureDescriptor();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace layers
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct YCbCrImage|
//
namespace mozilla {
namespace layers {
class YCbCrImage MOZ_FINAL
{
private:
    typedef mozilla::ipc::Shmem Shmem;

public:
    YCbCrImage();

    YCbCrImage(
            Shmem& _data,
            const size_t& _offset,
            const nsIntRect& _picture)
    {
        Init();
        Assign(_data, _offset, _picture);
    }

    YCbCrImage(const YCbCrImage& _o)
    {
        Init();
        Assign((_o).data(), (_o).offset(), (_o).picture());
    }

    ~YCbCrImage();

    void
    operator=(const YCbCrImage& _o)
    {
        Assign((_o).data(), (_o).offset(), (_o).picture());
    }

    bool
    operator==(const YCbCrImage& _o) const;

    Shmem&
    data()
    {
        return data_;
    }
    Shmem&
    data() const
    {
        return const_cast<Shmem&>(data_);
    }

    size_t&
    offset()
    {
        return offset_;
    }
    const size_t&
    offset() const
    {
        return offset_;
    }

    nsIntRect&
    picture()
    {
        return picture_;
    }
    const nsIntRect&
    picture() const
    {
        return picture_;
    }

private:
    void
    Init();

    void
    Assign(
            Shmem& _data,
            const size_t& _offset,
            const nsIntRect& _picture);

    Shmem data_;
    size_t offset_;
    nsIntRect picture_;
};
} // namespace layers
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct RGBImage|
//
namespace mozilla {
namespace layers {
class RGBImage MOZ_FINAL
{
private:
    typedef mozilla::ipc::Shmem Shmem;

public:
    RGBImage();

    RGBImage(
            Shmem& _data,
            const nsIntRect& _picture,
            const uint32_t& _rgbFormat)
    {
        Init();
        Assign(_data, _picture, _rgbFormat);
    }

    RGBImage(const RGBImage& _o)
    {
        Init();
        Assign((_o).data(), (_o).picture(), (_o).rgbFormat());
    }

    ~RGBImage();

    void
    operator=(const RGBImage& _o)
    {
        Assign((_o).data(), (_o).picture(), (_o).rgbFormat());
    }

    bool
    operator==(const RGBImage& _o) const;

    Shmem&
    data()
    {
        return data_;
    }
    Shmem&
    data() const
    {
        return const_cast<Shmem&>(data_);
    }

    nsIntRect&
    picture()
    {
        return picture_;
    }
    const nsIntRect&
    picture() const
    {
        return picture_;
    }

    uint32_t&
    rgbFormat()
    {
        return rgbFormat_;
    }
    const uint32_t&
    rgbFormat() const
    {
        return rgbFormat_;
    }

private:
    void
    Init();

    void
    Assign(
            Shmem& _data,
            const nsIntRect& _picture,
            const uint32_t& _rgbFormat);

    Shmem data_;
    nsIntRect picture_;
    uint32_t rgbFormat_;
};
} // namespace layers
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct YUVImage|
//
namespace mozilla {
namespace layers {
class YUVImage MOZ_FINAL
{
private:
    typedef mozilla::ipc::Shmem Shmem;

public:
    YUVImage();

    YUVImage(
            Shmem& _Ydata,
            Shmem& _Udata,
            Shmem& _Vdata,
            const nsIntRect& _picture)
    {
        Init();
        Assign(_Ydata, _Udata, _Vdata, _picture);
    }

    YUVImage(const YUVImage& _o)
    {
        Init();
        Assign((_o).Ydata(), (_o).Udata(), (_o).Vdata(), (_o).picture());
    }

    ~YUVImage();

    void
    operator=(const YUVImage& _o)
    {
        Assign((_o).Ydata(), (_o).Udata(), (_o).Vdata(), (_o).picture());
    }

    bool
    operator==(const YUVImage& _o) const;

    Shmem&
    Ydata()
    {
        return Ydata_;
    }
    Shmem&
    Ydata() const
    {
        return const_cast<Shmem&>(Ydata_);
    }

    Shmem&
    Udata()
    {
        return Udata_;
    }
    Shmem&
    Udata() const
    {
        return const_cast<Shmem&>(Udata_);
    }

    Shmem&
    Vdata()
    {
        return Vdata_;
    }
    Shmem&
    Vdata() const
    {
        return const_cast<Shmem&>(Vdata_);
    }

    nsIntRect&
    picture()
    {
        return picture_;
    }
    const nsIntRect&
    picture() const
    {
        return picture_;
    }

private:
    void
    Init();

    void
    Assign(
            Shmem& _Ydata,
            Shmem& _Udata,
            Shmem& _Vdata,
            const nsIntRect& _picture);

    Shmem Ydata_;
    Shmem Udata_;
    Shmem Vdata_;
    nsIntRect picture_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace layers {
class SurfaceDescriptor;
} // namespace layers
} // namespace mozilla
namespace mozilla {
namespace layers {
class RGBImage;
} // namespace layers
} // namespace mozilla
namespace mozilla {
namespace layers {
class YCbCrImage;
} // namespace layers
} // namespace mozilla
namespace mozilla {
namespace layers {
class YUVImage;
} // namespace layers
} // namespace mozilla
namespace mozilla {
namespace layers {
class SharedImageID;
} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union SharedImage|
//
namespace mozilla {
namespace layers {
class SharedImage MOZ_FINAL
{
public:
    enum Type {
        T__None,
        TSurfaceDescriptor = 1,
        TRGBImage,
        TYCbCrImage,
        TYUVImage,
        TSharedImageID,
        Tnull_t,
        T__Last = Tnull_t
    };

private:
    typedef mozilla::layers::SurfaceDescriptor SurfaceDescriptor;
    typedef mozilla::layers::RGBImage RGBImage;
    typedef mozilla::layers::YCbCrImage YCbCrImage;
    typedef mozilla::layers::YUVImage YUVImage;
    typedef mozilla::layers::SharedImageID SharedImageID;
    typedef mozilla::null_t null_t;
    typedef SurfaceDescriptor SurfaceDescriptor__tdef;
    typedef RGBImage RGBImage__tdef;
    typedef YCbCrImage YCbCrImage__tdef;
    typedef YUVImage YUVImage__tdef;
    typedef SharedImageID SharedImageID__tdef;
    typedef null_t null_t__tdef;

    union Value {
        char VSurfaceDescriptor[sizeof(SurfaceDescriptor)];
        char VRGBImage[sizeof(RGBImage)];
        char VYCbCrImage[sizeof(YCbCrImage)];
        char VYUVImage[sizeof(YUVImage)];
        char VSharedImageID[sizeof(SharedImageID)];
        char Vnull_t[sizeof(null_t)];
    };

    SurfaceDescriptor*
    ptr_SurfaceDescriptor()
    {
        return reinterpret_cast<SurfaceDescriptor*>((&((mValue).VSurfaceDescriptor)));
    }
    const SurfaceDescriptor* const
    constptr_SurfaceDescriptor() const
    {
        return reinterpret_cast<const SurfaceDescriptor* const>((&((mValue).VSurfaceDescriptor)));
    }
    RGBImage*
    ptr_RGBImage()
    {
        return reinterpret_cast<RGBImage*>((&((mValue).VRGBImage)));
    }
    const RGBImage* const
    constptr_RGBImage() const
    {
        return reinterpret_cast<const RGBImage* const>((&((mValue).VRGBImage)));
    }
    YCbCrImage*
    ptr_YCbCrImage()
    {
        return reinterpret_cast<YCbCrImage*>((&((mValue).VYCbCrImage)));
    }
    const YCbCrImage* const
    constptr_YCbCrImage() const
    {
        return reinterpret_cast<const YCbCrImage* const>((&((mValue).VYCbCrImage)));
    }
    YUVImage*
    ptr_YUVImage()
    {
        return reinterpret_cast<YUVImage*>((&((mValue).VYUVImage)));
    }
    const YUVImage* const
    constptr_YUVImage() const
    {
        return reinterpret_cast<const YUVImage* const>((&((mValue).VYUVImage)));
    }
    SharedImageID*
    ptr_SharedImageID()
    {
        return reinterpret_cast<SharedImageID*>((&((mValue).VSharedImageID)));
    }
    const SharedImageID* const
    constptr_SharedImageID() const
    {
        return reinterpret_cast<const SharedImageID* const>((&((mValue).VSharedImageID)));
    }
    null_t*
    ptr_null_t()
    {
        return reinterpret_cast<null_t*>((&((mValue).Vnull_t)));
    }
    const null_t* const
    constptr_null_t() const
    {
        return reinterpret_cast<const null_t* const>((&((mValue).Vnull_t)));
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        NS_ABORT_IF_FALSE((T__None) <= (mType), "invalid type tag");
        NS_ABORT_IF_FALSE((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        NS_ABORT_IF_FALSE((mType) == (aType), "unexpected type tag");
    }

public:
    SharedImage() :
        mType(T__None)
    {
    }

    SharedImage(const SurfaceDescriptor& aOther);

    SharedImage(const RGBImage& aOther);

    SharedImage(const YCbCrImage& aOther);

    SharedImage(const YUVImage& aOther);

    SharedImage(const SharedImageID& aOther);

    SharedImage(const null_t& aOther);

    SharedImage(const SharedImage& aOther);

    ~SharedImage();

    Type
    type() const
    {
        return mType;
    }

    SharedImage&
    operator=(const SurfaceDescriptor& aRhs);

    SharedImage&
    operator=(const RGBImage& aRhs);

    SharedImage&
    operator=(const YCbCrImage& aRhs);

    SharedImage&
    operator=(const YUVImage& aRhs);

    SharedImage&
    operator=(const SharedImageID& aRhs);

    SharedImage&
    operator=(const null_t& aRhs);

    SharedImage&
    operator=(const SharedImage& aRhs);

    bool
    operator==(const SurfaceDescriptor& aRhs) const;

    bool
    operator==(const RGBImage& aRhs) const;

    bool
    operator==(const YCbCrImage& aRhs) const;

    bool
    operator==(const YUVImage& aRhs) const;

    bool
    operator==(const SharedImageID& aRhs) const;

    bool
    operator==(const null_t& aRhs) const;

    bool
    operator==(const SharedImage& aRhs) const;

    SurfaceDescriptor&
    get_SurfaceDescriptor()
    {
        AssertSanity(TSurfaceDescriptor);
        return (*(ptr_SurfaceDescriptor()));
    }
    const SurfaceDescriptor&
    get_SurfaceDescriptor() const
    {
        AssertSanity(TSurfaceDescriptor);
        return (*(constptr_SurfaceDescriptor()));
    }
    operator SurfaceDescriptor&()
    {
        return get_SurfaceDescriptor();
    }
    operator const SurfaceDescriptor&() const
    {
        return get_SurfaceDescriptor();
    }

    RGBImage&
    get_RGBImage()
    {
        AssertSanity(TRGBImage);
        return (*(ptr_RGBImage()));
    }
    const RGBImage&
    get_RGBImage() const
    {
        AssertSanity(TRGBImage);
        return (*(constptr_RGBImage()));
    }
    operator RGBImage&()
    {
        return get_RGBImage();
    }
    operator const RGBImage&() const
    {
        return get_RGBImage();
    }

    YCbCrImage&
    get_YCbCrImage()
    {
        AssertSanity(TYCbCrImage);
        return (*(ptr_YCbCrImage()));
    }
    const YCbCrImage&
    get_YCbCrImage() const
    {
        AssertSanity(TYCbCrImage);
        return (*(constptr_YCbCrImage()));
    }
    operator YCbCrImage&()
    {
        return get_YCbCrImage();
    }
    operator const YCbCrImage&() const
    {
        return get_YCbCrImage();
    }

    YUVImage&
    get_YUVImage()
    {
        AssertSanity(TYUVImage);
        return (*(ptr_YUVImage()));
    }
    const YUVImage&
    get_YUVImage() const
    {
        AssertSanity(TYUVImage);
        return (*(constptr_YUVImage()));
    }
    operator YUVImage&()
    {
        return get_YUVImage();
    }
    operator const YUVImage&() const
    {
        return get_YUVImage();
    }

    SharedImageID&
    get_SharedImageID()
    {
        AssertSanity(TSharedImageID);
        return (*(ptr_SharedImageID()));
    }
    const SharedImageID&
    get_SharedImageID() const
    {
        AssertSanity(TSharedImageID);
        return (*(constptr_SharedImageID()));
    }
    operator SharedImageID&()
    {
        return get_SharedImageID();
    }
    operator const SharedImageID&() const
    {
        return get_SharedImageID();
    }

    null_t&
    get_null_t()
    {
        AssertSanity(Tnull_t);
        return (*(ptr_null_t()));
    }
    const null_t&
    get_null_t() const
    {
        AssertSanity(Tnull_t);
        return (*(constptr_null_t()));
    }
    operator null_t&()
    {
        return get_null_t();
    }
    operator const null_t&() const
    {
        return get_null_t();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace layers
} // namespace mozilla

#endif // ifndef LayersSurfaces_h
