//
// Automatically generated by ipdlc.
// Edit at your own risk
//

#ifndef PLayers_h
#define PLayers_h

#include "mozilla/Attributes.h"
#include "base/basictypes.h"
#include "prtime.h"
#include "nscore.h"
#include "IPCMessageStart.h"
#include "ipc/IPCMessageUtils.h"
#include "nsAutoPtr.h"
#include "nsStringGlue.h"
#include "nsTArray.h"
#include "nsIFile.h"
#include "mozilla/ipc/ProtocolUtils.h"
#include "gfxipc/ShadowLayerUtils.h"
#include "mozilla/WidgetUtils.h"
#include "mozilla/TimeStamp.h"
#include "mozilla/dom/ScreenOrientation.h"
#include "nsCSSProperty.h"
#include "mozilla/layers/LayersSurfaces.h"


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct TargetConfig|
//
namespace mozilla {
namespace layers {
class TargetConfig MOZ_FINAL
{
private:
    typedef mozilla::ScreenRotation ScreenRotation;
    typedef mozilla::dom::ScreenOrientation ScreenOrientation;

public:
    TargetConfig();

    TargetConfig(
            const nsIntRect& _naturalBounds,
            const ScreenRotation& _rotation,
            const nsIntRect& _clientBounds,
            const ScreenOrientation& _orientation)
    {
        Init();
        Assign(_naturalBounds, _rotation, _clientBounds, _orientation);
    }

    TargetConfig(const TargetConfig& _o)
    {
        Init();
        Assign((_o).naturalBounds(), (_o).rotation(), (_o).clientBounds(), (_o).orientation());
    }

    ~TargetConfig();

    void
    operator=(const TargetConfig& _o)
    {
        Assign((_o).naturalBounds(), (_o).rotation(), (_o).clientBounds(), (_o).orientation());
    }

    bool
    operator==(const TargetConfig& _o) const;

    nsIntRect&
    naturalBounds()
    {
        return naturalBounds_;
    }
    const nsIntRect&
    naturalBounds() const
    {
        return naturalBounds_;
    }

    ScreenRotation&
    rotation()
    {
        return rotation_;
    }
    const ScreenRotation&
    rotation() const
    {
        return rotation_;
    }

    nsIntRect&
    clientBounds()
    {
        return clientBounds_;
    }
    const nsIntRect&
    clientBounds() const
    {
        return clientBounds_;
    }

    ScreenOrientation&
    orientation()
    {
        return orientation_;
    }
    const ScreenOrientation&
    orientation() const
    {
        return orientation_;
    }

private:
    void
    Init();

    void
    Assign(
            const nsIntRect& _naturalBounds,
            const ScreenRotation& _rotation,
            const nsIntRect& _clientBounds,
            const ScreenOrientation& _orientation);

    nsIntRect naturalBounds_;
    ScreenRotation rotation_;
    nsIntRect clientBounds_;
    ScreenOrientation orientation_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace layers {
class PLayerParent;
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace layers {
class PLayerChild;
} // namespace layers
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct OpCreateThebesLayer|
//
namespace mozilla {
namespace layers {
class OpCreateThebesLayer MOZ_FINAL
{
private:
    typedef mozilla::layers::PLayerParent PLayerParent;
    typedef mozilla::layers::PLayerChild PLayerChild;

public:
    OpCreateThebesLayer();

    OpCreateThebesLayer(
            PLayerParent* _layerParent,
            PLayerChild* _layerChild)
    {
        Init();
        Assign(_layerParent, _layerChild);
    }

    OpCreateThebesLayer(const OpCreateThebesLayer& _o)
    {
        Init();
        Assign(const_cast<PLayerParent*>((_o).layerParent()), const_cast<PLayerChild*>((_o).layerChild()));
    }

    ~OpCreateThebesLayer();

    void
    operator=(const OpCreateThebesLayer& _o)
    {
        Assign(const_cast<PLayerParent*>((_o).layerParent()), const_cast<PLayerChild*>((_o).layerChild()));
    }

    bool
    operator==(const OpCreateThebesLayer& _o) const;

    PLayerParent*&
    layerParent()
    {
        return layerParent_;
    }
    PLayerParent*
    layerParent() const
    {
        return layerParent_;
    }

    PLayerChild*&
    layerChild()
    {
        return layerChild_;
    }
    PLayerChild*
    layerChild() const
    {
        return layerChild_;
    }

private:
    void
    Init();

    void
    Assign(
            PLayerParent* _layerParent,
            PLayerChild* _layerChild);

    PLayerParent* layerParent_;
    PLayerChild* layerChild_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace layers {
class PLayerParent;
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace layers {
class PLayerChild;
} // namespace layers
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct OpCreateContainerLayer|
//
namespace mozilla {
namespace layers {
class OpCreateContainerLayer MOZ_FINAL
{
private:
    typedef mozilla::layers::PLayerParent PLayerParent;
    typedef mozilla::layers::PLayerChild PLayerChild;

public:
    OpCreateContainerLayer();

    OpCreateContainerLayer(
            PLayerParent* _layerParent,
            PLayerChild* _layerChild)
    {
        Init();
        Assign(_layerParent, _layerChild);
    }

    OpCreateContainerLayer(const OpCreateContainerLayer& _o)
    {
        Init();
        Assign(const_cast<PLayerParent*>((_o).layerParent()), const_cast<PLayerChild*>((_o).layerChild()));
    }

    ~OpCreateContainerLayer();

    void
    operator=(const OpCreateContainerLayer& _o)
    {
        Assign(const_cast<PLayerParent*>((_o).layerParent()), const_cast<PLayerChild*>((_o).layerChild()));
    }

    bool
    operator==(const OpCreateContainerLayer& _o) const;

    PLayerParent*&
    layerParent()
    {
        return layerParent_;
    }
    PLayerParent*
    layerParent() const
    {
        return layerParent_;
    }

    PLayerChild*&
    layerChild()
    {
        return layerChild_;
    }
    PLayerChild*
    layerChild() const
    {
        return layerChild_;
    }

private:
    void
    Init();

    void
    Assign(
            PLayerParent* _layerParent,
            PLayerChild* _layerChild);

    PLayerParent* layerParent_;
    PLayerChild* layerChild_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace layers {
class PLayerParent;
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace layers {
class PLayerChild;
} // namespace layers
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct OpCreateImageLayer|
//
namespace mozilla {
namespace layers {
class OpCreateImageLayer MOZ_FINAL
{
private:
    typedef mozilla::layers::PLayerParent PLayerParent;
    typedef mozilla::layers::PLayerChild PLayerChild;

public:
    OpCreateImageLayer();

    OpCreateImageLayer(
            PLayerParent* _layerParent,
            PLayerChild* _layerChild)
    {
        Init();
        Assign(_layerParent, _layerChild);
    }

    OpCreateImageLayer(const OpCreateImageLayer& _o)
    {
        Init();
        Assign(const_cast<PLayerParent*>((_o).layerParent()), const_cast<PLayerChild*>((_o).layerChild()));
    }

    ~OpCreateImageLayer();

    void
    operator=(const OpCreateImageLayer& _o)
    {
        Assign(const_cast<PLayerParent*>((_o).layerParent()), const_cast<PLayerChild*>((_o).layerChild()));
    }

    bool
    operator==(const OpCreateImageLayer& _o) const;

    PLayerParent*&
    layerParent()
    {
        return layerParent_;
    }
    PLayerParent*
    layerParent() const
    {
        return layerParent_;
    }

    PLayerChild*&
    layerChild()
    {
        return layerChild_;
    }
    PLayerChild*
    layerChild() const
    {
        return layerChild_;
    }

private:
    void
    Init();

    void
    Assign(
            PLayerParent* _layerParent,
            PLayerChild* _layerChild);

    PLayerParent* layerParent_;
    PLayerChild* layerChild_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace layers {
class PLayerParent;
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace layers {
class PLayerChild;
} // namespace layers
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct OpCreateColorLayer|
//
namespace mozilla {
namespace layers {
class OpCreateColorLayer MOZ_FINAL
{
private:
    typedef mozilla::layers::PLayerParent PLayerParent;
    typedef mozilla::layers::PLayerChild PLayerChild;

public:
    OpCreateColorLayer();

    OpCreateColorLayer(
            PLayerParent* _layerParent,
            PLayerChild* _layerChild)
    {
        Init();
        Assign(_layerParent, _layerChild);
    }

    OpCreateColorLayer(const OpCreateColorLayer& _o)
    {
        Init();
        Assign(const_cast<PLayerParent*>((_o).layerParent()), const_cast<PLayerChild*>((_o).layerChild()));
    }

    ~OpCreateColorLayer();

    void
    operator=(const OpCreateColorLayer& _o)
    {
        Assign(const_cast<PLayerParent*>((_o).layerParent()), const_cast<PLayerChild*>((_o).layerChild()));
    }

    bool
    operator==(const OpCreateColorLayer& _o) const;

    PLayerParent*&
    layerParent()
    {
        return layerParent_;
    }
    PLayerParent*
    layerParent() const
    {
        return layerParent_;
    }

    PLayerChild*&
    layerChild()
    {
        return layerChild_;
    }
    PLayerChild*
    layerChild() const
    {
        return layerChild_;
    }

private:
    void
    Init();

    void
    Assign(
            PLayerParent* _layerParent,
            PLayerChild* _layerChild);

    PLayerParent* layerParent_;
    PLayerChild* layerChild_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace layers {
class PLayerParent;
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace layers {
class PLayerChild;
} // namespace layers
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct OpCreateCanvasLayer|
//
namespace mozilla {
namespace layers {
class OpCreateCanvasLayer MOZ_FINAL
{
private:
    typedef mozilla::layers::PLayerParent PLayerParent;
    typedef mozilla::layers::PLayerChild PLayerChild;

public:
    OpCreateCanvasLayer();

    OpCreateCanvasLayer(
            PLayerParent* _layerParent,
            PLayerChild* _layerChild)
    {
        Init();
        Assign(_layerParent, _layerChild);
    }

    OpCreateCanvasLayer(const OpCreateCanvasLayer& _o)
    {
        Init();
        Assign(const_cast<PLayerParent*>((_o).layerParent()), const_cast<PLayerChild*>((_o).layerChild()));
    }

    ~OpCreateCanvasLayer();

    void
    operator=(const OpCreateCanvasLayer& _o)
    {
        Assign(const_cast<PLayerParent*>((_o).layerParent()), const_cast<PLayerChild*>((_o).layerChild()));
    }

    bool
    operator==(const OpCreateCanvasLayer& _o) const;

    PLayerParent*&
    layerParent()
    {
        return layerParent_;
    }
    PLayerParent*
    layerParent() const
    {
        return layerParent_;
    }

    PLayerChild*&
    layerChild()
    {
        return layerChild_;
    }
    PLayerChild*
    layerChild() const
    {
        return layerChild_;
    }

private:
    void
    Init();

    void
    Assign(
            PLayerParent* _layerParent,
            PLayerChild* _layerChild);

    PLayerParent* layerParent_;
    PLayerChild* layerChild_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace layers {
class PLayerParent;
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace layers {
class PLayerChild;
} // namespace layers
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct OpCreateRefLayer|
//
namespace mozilla {
namespace layers {
class OpCreateRefLayer MOZ_FINAL
{
private:
    typedef mozilla::layers::PLayerParent PLayerParent;
    typedef mozilla::layers::PLayerChild PLayerChild;

public:
    OpCreateRefLayer();

    OpCreateRefLayer(
            PLayerParent* _layerParent,
            PLayerChild* _layerChild)
    {
        Init();
        Assign(_layerParent, _layerChild);
    }

    OpCreateRefLayer(const OpCreateRefLayer& _o)
    {
        Init();
        Assign(const_cast<PLayerParent*>((_o).layerParent()), const_cast<PLayerChild*>((_o).layerChild()));
    }

    ~OpCreateRefLayer();

    void
    operator=(const OpCreateRefLayer& _o)
    {
        Assign(const_cast<PLayerParent*>((_o).layerParent()), const_cast<PLayerChild*>((_o).layerChild()));
    }

    bool
    operator==(const OpCreateRefLayer& _o) const;

    PLayerParent*&
    layerParent()
    {
        return layerParent_;
    }
    PLayerParent*
    layerParent() const
    {
        return layerParent_;
    }

    PLayerChild*&
    layerChild()
    {
        return layerChild_;
    }
    PLayerChild*
    layerChild() const
    {
        return layerChild_;
    }

private:
    void
    Init();

    void
    Assign(
            PLayerParent* _layerParent,
            PLayerChild* _layerChild);

    PLayerParent* layerParent_;
    PLayerChild* layerChild_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace layers {
class SurfaceDescriptor;
} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ThebesBuffer|
//
namespace mozilla {
namespace layers {
class ThebesBuffer MOZ_FINAL
{
private:
    typedef mozilla::layers::SurfaceDescriptor SurfaceDescriptor;

public:
    ThebesBuffer();

    ThebesBuffer(
            const SurfaceDescriptor& _buffer,
            const nsIntRect& _rect,
            const nsIntPoint& _rotation)
    {
        Init();
        Assign(_buffer, _rect, _rotation);
    }

    ThebesBuffer(const ThebesBuffer& _o)
    {
        Init();
        Assign((_o).buffer(), (_o).rect(), (_o).rotation());
    }

    ~ThebesBuffer();

    void
    operator=(const ThebesBuffer& _o)
    {
        Assign((_o).buffer(), (_o).rect(), (_o).rotation());
    }

    bool
    operator==(const ThebesBuffer& _o) const;

    SurfaceDescriptor&
    buffer()
    {
        return buffer_;
    }
    const SurfaceDescriptor&
    buffer() const
    {
        return buffer_;
    }

    nsIntRect&
    rect()
    {
        return rect_;
    }
    const nsIntRect&
    rect() const
    {
        return rect_;
    }

    nsIntPoint&
    rotation()
    {
        return rotation_;
    }
    const nsIntPoint&
    rotation() const
    {
        return rotation_;
    }

private:
    void
    Init();

    void
    Assign(
            const SurfaceDescriptor& _buffer,
            const nsIntRect& _rect,
            const nsIntPoint& _rotation);

    SurfaceDescriptor buffer_;
    nsIntRect rect_;
    nsIntPoint rotation_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace layers {
class ThebesBuffer;
} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union OptionalThebesBuffer|
//
namespace mozilla {
namespace layers {
class OptionalThebesBuffer MOZ_FINAL
{
public:
    enum Type {
        T__None,
        TThebesBuffer = 1,
        Tnull_t,
        T__Last = Tnull_t
    };

private:
    typedef mozilla::layers::ThebesBuffer ThebesBuffer;
    typedef mozilla::null_t null_t;
    typedef ThebesBuffer ThebesBuffer__tdef;
    typedef null_t null_t__tdef;

    union Value {
        char VThebesBuffer[sizeof(ThebesBuffer)];
        char Vnull_t[sizeof(null_t)];
    };

    ThebesBuffer*
    ptr_ThebesBuffer()
    {
        return reinterpret_cast<ThebesBuffer*>((&((mValue).VThebesBuffer)));
    }
    const ThebesBuffer* const
    constptr_ThebesBuffer() const
    {
        return reinterpret_cast<const ThebesBuffer* const>((&((mValue).VThebesBuffer)));
    }
    null_t*
    ptr_null_t()
    {
        return reinterpret_cast<null_t*>((&((mValue).Vnull_t)));
    }
    const null_t* const
    constptr_null_t() const
    {
        return reinterpret_cast<const null_t* const>((&((mValue).Vnull_t)));
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        NS_ABORT_IF_FALSE((T__None) <= (mType), "invalid type tag");
        NS_ABORT_IF_FALSE((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        NS_ABORT_IF_FALSE((mType) == (aType), "unexpected type tag");
    }

public:
    OptionalThebesBuffer() :
        mType(T__None)
    {
    }

    OptionalThebesBuffer(const ThebesBuffer& aOther);

    OptionalThebesBuffer(const null_t& aOther);

    OptionalThebesBuffer(const OptionalThebesBuffer& aOther);

    ~OptionalThebesBuffer();

    Type
    type() const
    {
        return mType;
    }

    OptionalThebesBuffer&
    operator=(const ThebesBuffer& aRhs);

    OptionalThebesBuffer&
    operator=(const null_t& aRhs);

    OptionalThebesBuffer&
    operator=(const OptionalThebesBuffer& aRhs);

    bool
    operator==(const ThebesBuffer& aRhs) const;

    bool
    operator==(const null_t& aRhs) const;

    bool
    operator==(const OptionalThebesBuffer& aRhs) const;

    ThebesBuffer&
    get_ThebesBuffer()
    {
        AssertSanity(TThebesBuffer);
        return (*(ptr_ThebesBuffer()));
    }
    const ThebesBuffer&
    get_ThebesBuffer() const
    {
        AssertSanity(TThebesBuffer);
        return (*(constptr_ThebesBuffer()));
    }
    operator ThebesBuffer&()
    {
        return get_ThebesBuffer();
    }
    operator const ThebesBuffer&() const
    {
        return get_ThebesBuffer();
    }

    null_t&
    get_null_t()
    {
        AssertSanity(Tnull_t);
        return (*(ptr_null_t()));
    }
    const null_t&
    get_null_t() const
    {
        AssertSanity(Tnull_t);
        return (*(constptr_null_t()));
    }
    operator null_t&()
    {
        return get_null_t();
    }
    operator const null_t&() const
    {
        return get_null_t();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace layers {
class SurfaceDescriptor;
} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union CanvasSurface|
//
namespace mozilla {
namespace layers {
class CanvasSurface MOZ_FINAL
{
public:
    enum Type {
        T__None,
        TSurfaceDescriptor = 1,
        Tnull_t,
        T__Last = Tnull_t
    };

private:
    typedef mozilla::layers::SurfaceDescriptor SurfaceDescriptor;
    typedef mozilla::null_t null_t;
    typedef SurfaceDescriptor SurfaceDescriptor__tdef;
    typedef null_t null_t__tdef;

    union Value {
        char VSurfaceDescriptor[sizeof(SurfaceDescriptor)];
        char Vnull_t[sizeof(null_t)];
    };

    SurfaceDescriptor*
    ptr_SurfaceDescriptor()
    {
        return reinterpret_cast<SurfaceDescriptor*>((&((mValue).VSurfaceDescriptor)));
    }
    const SurfaceDescriptor* const
    constptr_SurfaceDescriptor() const
    {
        return reinterpret_cast<const SurfaceDescriptor* const>((&((mValue).VSurfaceDescriptor)));
    }
    null_t*
    ptr_null_t()
    {
        return reinterpret_cast<null_t*>((&((mValue).Vnull_t)));
    }
    const null_t* const
    constptr_null_t() const
    {
        return reinterpret_cast<const null_t* const>((&((mValue).Vnull_t)));
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        NS_ABORT_IF_FALSE((T__None) <= (mType), "invalid type tag");
        NS_ABORT_IF_FALSE((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        NS_ABORT_IF_FALSE((mType) == (aType), "unexpected type tag");
    }

public:
    CanvasSurface() :
        mType(T__None)
    {
    }

    CanvasSurface(const SurfaceDescriptor& aOther);

    CanvasSurface(const null_t& aOther);

    CanvasSurface(const CanvasSurface& aOther);

    ~CanvasSurface();

    Type
    type() const
    {
        return mType;
    }

    CanvasSurface&
    operator=(const SurfaceDescriptor& aRhs);

    CanvasSurface&
    operator=(const null_t& aRhs);

    CanvasSurface&
    operator=(const CanvasSurface& aRhs);

    bool
    operator==(const SurfaceDescriptor& aRhs) const;

    bool
    operator==(const null_t& aRhs) const;

    bool
    operator==(const CanvasSurface& aRhs) const;

    SurfaceDescriptor&
    get_SurfaceDescriptor()
    {
        AssertSanity(TSurfaceDescriptor);
        return (*(ptr_SurfaceDescriptor()));
    }
    const SurfaceDescriptor&
    get_SurfaceDescriptor() const
    {
        AssertSanity(TSurfaceDescriptor);
        return (*(constptr_SurfaceDescriptor()));
    }
    operator SurfaceDescriptor&()
    {
        return get_SurfaceDescriptor();
    }
    operator const SurfaceDescriptor&() const
    {
        return get_SurfaceDescriptor();
    }

    null_t&
    get_null_t()
    {
        AssertSanity(Tnull_t);
        return (*(ptr_null_t()));
    }
    const null_t&
    get_null_t() const
    {
        AssertSanity(Tnull_t);
        return (*(constptr_null_t()));
    }
    operator null_t&()
    {
        return get_null_t();
    }
    operator const null_t&() const
    {
        return get_null_t();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace layers
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct CubicBezierFunction|
//
namespace mozilla {
namespace layers {
class CubicBezierFunction MOZ_FINAL
{
private:

public:
    CubicBezierFunction();

    CubicBezierFunction(
            const float& _x1,
            const float& _y1,
            const float& _x2,
            const float& _y2)
    {
        Init();
        Assign(_x1, _y1, _x2, _y2);
    }

    CubicBezierFunction(const CubicBezierFunction& _o)
    {
        Init();
        Assign((_o).x1(), (_o).y1(), (_o).x2(), (_o).y2());
    }

    ~CubicBezierFunction();

    void
    operator=(const CubicBezierFunction& _o)
    {
        Assign((_o).x1(), (_o).y1(), (_o).x2(), (_o).y2());
    }

    bool
    operator==(const CubicBezierFunction& _o) const;

    float&
    x1()
    {
        return x1_;
    }
    const float&
    x1() const
    {
        return x1_;
    }

    float&
    y1()
    {
        return y1_;
    }
    const float&
    y1() const
    {
        return y1_;
    }

    float&
    x2()
    {
        return x2_;
    }
    const float&
    x2() const
    {
        return x2_;
    }

    float&
    y2()
    {
        return y2_;
    }
    const float&
    y2() const
    {
        return y2_;
    }

private:
    void
    Init();

    void
    Assign(
            const float& _x1,
            const float& _y1,
            const float& _x2,
            const float& _y2);

    float x1_;
    float y1_;
    float x2_;
    float y2_;
};
} // namespace layers
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct StepFunction|
//
namespace mozilla {
namespace layers {
class StepFunction MOZ_FINAL
{
private:

public:
    StepFunction();

    StepFunction(
            const int& _steps,
            const int& _type)
    {
        Init();
        Assign(_steps, _type);
    }

    StepFunction(const StepFunction& _o)
    {
        Init();
        Assign((_o).steps(), (_o).type());
    }

    ~StepFunction();

    void
    operator=(const StepFunction& _o)
    {
        Assign((_o).steps(), (_o).type());
    }

    bool
    operator==(const StepFunction& _o) const;

    int&
    steps()
    {
        return steps_;
    }
    const int&
    steps() const
    {
        return steps_;
    }

    int&
    type()
    {
        return type_;
    }
    const int&
    type() const
    {
        return type_;
    }

private:
    void
    Init();

    void
    Assign(
            const int& _steps,
            const int& _type);

    int steps_;
    int type_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace layers {
class CubicBezierFunction;
} // namespace layers
} // namespace mozilla
namespace mozilla {
namespace layers {
class StepFunction;
} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union TimingFunction|
//
namespace mozilla {
namespace layers {
class TimingFunction MOZ_FINAL
{
public:
    enum Type {
        T__None,
        TCubicBezierFunction = 1,
        TStepFunction,
        T__Last = TStepFunction
    };

private:
    typedef mozilla::layers::CubicBezierFunction CubicBezierFunction;
    typedef mozilla::layers::StepFunction StepFunction;
    typedef CubicBezierFunction CubicBezierFunction__tdef;
    typedef StepFunction StepFunction__tdef;

    union Value {
        char VCubicBezierFunction[sizeof(CubicBezierFunction)];
        char VStepFunction[sizeof(StepFunction)];
    };

    CubicBezierFunction*
    ptr_CubicBezierFunction()
    {
        return reinterpret_cast<CubicBezierFunction*>((&((mValue).VCubicBezierFunction)));
    }
    const CubicBezierFunction* const
    constptr_CubicBezierFunction() const
    {
        return reinterpret_cast<const CubicBezierFunction* const>((&((mValue).VCubicBezierFunction)));
    }
    StepFunction*
    ptr_StepFunction()
    {
        return reinterpret_cast<StepFunction*>((&((mValue).VStepFunction)));
    }
    const StepFunction* const
    constptr_StepFunction() const
    {
        return reinterpret_cast<const StepFunction* const>((&((mValue).VStepFunction)));
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        NS_ABORT_IF_FALSE((T__None) <= (mType), "invalid type tag");
        NS_ABORT_IF_FALSE((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        NS_ABORT_IF_FALSE((mType) == (aType), "unexpected type tag");
    }

public:
    TimingFunction() :
        mType(T__None)
    {
    }

    TimingFunction(const CubicBezierFunction& aOther);

    TimingFunction(const StepFunction& aOther);

    TimingFunction(const TimingFunction& aOther);

    ~TimingFunction();

    Type
    type() const
    {
        return mType;
    }

    TimingFunction&
    operator=(const CubicBezierFunction& aRhs);

    TimingFunction&
    operator=(const StepFunction& aRhs);

    TimingFunction&
    operator=(const TimingFunction& aRhs);

    bool
    operator==(const CubicBezierFunction& aRhs) const;

    bool
    operator==(const StepFunction& aRhs) const;

    bool
    operator==(const TimingFunction& aRhs) const;

    CubicBezierFunction&
    get_CubicBezierFunction()
    {
        AssertSanity(TCubicBezierFunction);
        return (*(ptr_CubicBezierFunction()));
    }
    const CubicBezierFunction&
    get_CubicBezierFunction() const
    {
        AssertSanity(TCubicBezierFunction);
        return (*(constptr_CubicBezierFunction()));
    }
    operator CubicBezierFunction&()
    {
        return get_CubicBezierFunction();
    }
    operator const CubicBezierFunction&() const
    {
        return get_CubicBezierFunction();
    }

    StepFunction&
    get_StepFunction()
    {
        AssertSanity(TStepFunction);
        return (*(ptr_StepFunction()));
    }
    const StepFunction&
    get_StepFunction() const
    {
        AssertSanity(TStepFunction);
        return (*(constptr_StepFunction()));
    }
    operator StepFunction&()
    {
        return get_StepFunction();
    }
    operator const StepFunction&() const
    {
        return get_StepFunction();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace layers
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct Color|
//
namespace mozilla {
namespace layers {
class Color MOZ_FINAL
{
private:

public:
    Color();

    Color(const gfxRGBA& _value)
    {
        Init();
        Assign(_value);
    }

    Color(const Color& _o)
    {
        Init();
        Assign((_o).value());
    }

    ~Color();

    void
    operator=(const Color& _o)
    {
        Assign((_o).value());
    }

    bool
    operator==(const Color& _o) const;

    gfxRGBA&
    value()
    {
        return value_;
    }
    const gfxRGBA&
    value() const
    {
        return value_;
    }

private:
    void
    Init();

    void
    Assign(const gfxRGBA& _value);

    gfxRGBA value_;
};
} // namespace layers
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct Perspective|
//
namespace mozilla {
namespace layers {
class Perspective MOZ_FINAL
{
private:

public:
    Perspective();

    Perspective(const float& _value)
    {
        Init();
        Assign(_value);
    }

    Perspective(const Perspective& _o)
    {
        Init();
        Assign((_o).value());
    }

    ~Perspective();

    void
    operator=(const Perspective& _o)
    {
        Assign((_o).value());
    }

    bool
    operator==(const Perspective& _o) const;

    float&
    value()
    {
        return value_;
    }
    const float&
    value() const
    {
        return value_;
    }

private:
    void
    Init();

    void
    Assign(const float& _value);

    float value_;
};
} // namespace layers
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct RotationX|
//
namespace mozilla {
namespace layers {
class RotationX MOZ_FINAL
{
private:

public:
    RotationX();

    RotationX(const float& _radians)
    {
        Init();
        Assign(_radians);
    }

    RotationX(const RotationX& _o)
    {
        Init();
        Assign((_o).radians());
    }

    ~RotationX();

    void
    operator=(const RotationX& _o)
    {
        Assign((_o).radians());
    }

    bool
    operator==(const RotationX& _o) const;

    float&
    radians()
    {
        return radians_;
    }
    const float&
    radians() const
    {
        return radians_;
    }

private:
    void
    Init();

    void
    Assign(const float& _radians);

    float radians_;
};
} // namespace layers
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct RotationY|
//
namespace mozilla {
namespace layers {
class RotationY MOZ_FINAL
{
private:

public:
    RotationY();

    RotationY(const float& _radians)
    {
        Init();
        Assign(_radians);
    }

    RotationY(const RotationY& _o)
    {
        Init();
        Assign((_o).radians());
    }

    ~RotationY();

    void
    operator=(const RotationY& _o)
    {
        Assign((_o).radians());
    }

    bool
    operator==(const RotationY& _o) const;

    float&
    radians()
    {
        return radians_;
    }
    const float&
    radians() const
    {
        return radians_;
    }

private:
    void
    Init();

    void
    Assign(const float& _radians);

    float radians_;
};
} // namespace layers
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct RotationZ|
//
namespace mozilla {
namespace layers {
class RotationZ MOZ_FINAL
{
private:

public:
    RotationZ();

    RotationZ(const float& _radians)
    {
        Init();
        Assign(_radians);
    }

    RotationZ(const RotationZ& _o)
    {
        Init();
        Assign((_o).radians());
    }

    ~RotationZ();

    void
    operator=(const RotationZ& _o)
    {
        Assign((_o).radians());
    }

    bool
    operator==(const RotationZ& _o) const;

    float&
    radians()
    {
        return radians_;
    }
    const float&
    radians() const
    {
        return radians_;
    }

private:
    void
    Init();

    void
    Assign(const float& _radians);

    float radians_;
};
} // namespace layers
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct Rotation|
//
namespace mozilla {
namespace layers {
class Rotation MOZ_FINAL
{
private:

public:
    Rotation();

    Rotation(const float& _radians)
    {
        Init();
        Assign(_radians);
    }

    Rotation(const Rotation& _o)
    {
        Init();
        Assign((_o).radians());
    }

    ~Rotation();

    void
    operator=(const Rotation& _o)
    {
        Assign((_o).radians());
    }

    bool
    operator==(const Rotation& _o) const;

    float&
    radians()
    {
        return radians_;
    }
    const float&
    radians() const
    {
        return radians_;
    }

private:
    void
    Init();

    void
    Assign(const float& _radians);

    float radians_;
};
} // namespace layers
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct Rotation3D|
//
namespace mozilla {
namespace layers {
class Rotation3D MOZ_FINAL
{
private:

public:
    Rotation3D();

    Rotation3D(
            const float& _x,
            const float& _y,
            const float& _z,
            const float& _radians)
    {
        Init();
        Assign(_x, _y, _z, _radians);
    }

    Rotation3D(const Rotation3D& _o)
    {
        Init();
        Assign((_o).x(), (_o).y(), (_o).z(), (_o).radians());
    }

    ~Rotation3D();

    void
    operator=(const Rotation3D& _o)
    {
        Assign((_o).x(), (_o).y(), (_o).z(), (_o).radians());
    }

    bool
    operator==(const Rotation3D& _o) const;

    float&
    x()
    {
        return x_;
    }
    const float&
    x() const
    {
        return x_;
    }

    float&
    y()
    {
        return y_;
    }
    const float&
    y() const
    {
        return y_;
    }

    float&
    z()
    {
        return z_;
    }
    const float&
    z() const
    {
        return z_;
    }

    float&
    radians()
    {
        return radians_;
    }
    const float&
    radians() const
    {
        return radians_;
    }

private:
    void
    Init();

    void
    Assign(
            const float& _x,
            const float& _y,
            const float& _z,
            const float& _radians);

    float x_;
    float y_;
    float z_;
    float radians_;
};
} // namespace layers
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct Scale|
//
namespace mozilla {
namespace layers {
class Scale MOZ_FINAL
{
private:

public:
    Scale();

    Scale(
            const float& _x,
            const float& _y,
            const float& _z)
    {
        Init();
        Assign(_x, _y, _z);
    }

    Scale(const Scale& _o)
    {
        Init();
        Assign((_o).x(), (_o).y(), (_o).z());
    }

    ~Scale();

    void
    operator=(const Scale& _o)
    {
        Assign((_o).x(), (_o).y(), (_o).z());
    }

    bool
    operator==(const Scale& _o) const;

    float&
    x()
    {
        return x_;
    }
    const float&
    x() const
    {
        return x_;
    }

    float&
    y()
    {
        return y_;
    }
    const float&
    y() const
    {
        return y_;
    }

    float&
    z()
    {
        return z_;
    }
    const float&
    z() const
    {
        return z_;
    }

private:
    void
    Init();

    void
    Assign(
            const float& _x,
            const float& _y,
            const float& _z);

    float x_;
    float y_;
    float z_;
};
} // namespace layers
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct SkewX|
//
namespace mozilla {
namespace layers {
class SkewX MOZ_FINAL
{
private:

public:
    SkewX();

    SkewX(const float& _x)
    {
        Init();
        Assign(_x);
    }

    SkewX(const SkewX& _o)
    {
        Init();
        Assign((_o).x());
    }

    ~SkewX();

    void
    operator=(const SkewX& _o)
    {
        Assign((_o).x());
    }

    bool
    operator==(const SkewX& _o) const;

    float&
    x()
    {
        return x_;
    }
    const float&
    x() const
    {
        return x_;
    }

private:
    void
    Init();

    void
    Assign(const float& _x);

    float x_;
};
} // namespace layers
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct SkewY|
//
namespace mozilla {
namespace layers {
class SkewY MOZ_FINAL
{
private:

public:
    SkewY();

    SkewY(const float& _y)
    {
        Init();
        Assign(_y);
    }

    SkewY(const SkewY& _o)
    {
        Init();
        Assign((_o).y());
    }

    ~SkewY();

    void
    operator=(const SkewY& _o)
    {
        Assign((_o).y());
    }

    bool
    operator==(const SkewY& _o) const;

    float&
    y()
    {
        return y_;
    }
    const float&
    y() const
    {
        return y_;
    }

private:
    void
    Init();

    void
    Assign(const float& _y);

    float y_;
};
} // namespace layers
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct TransformMatrix|
//
namespace mozilla {
namespace layers {
class TransformMatrix MOZ_FINAL
{
private:

public:
    TransformMatrix();

    TransformMatrix(const gfx3DMatrix& _value)
    {
        Init();
        Assign(_value);
    }

    TransformMatrix(const TransformMatrix& _o)
    {
        Init();
        Assign((_o).value());
    }

    ~TransformMatrix();

    void
    operator=(const TransformMatrix& _o)
    {
        Assign((_o).value());
    }

    bool
    operator==(const TransformMatrix& _o) const;

    gfx3DMatrix&
    value()
    {
        return value_;
    }
    const gfx3DMatrix&
    value() const
    {
        return value_;
    }

private:
    void
    Init();

    void
    Assign(const gfx3DMatrix& _value);

    gfx3DMatrix value_;
};
} // namespace layers
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct Translation|
//
namespace mozilla {
namespace layers {
class Translation MOZ_FINAL
{
private:

public:
    Translation();

    Translation(
            const float& _x,
            const float& _y,
            const float& _z)
    {
        Init();
        Assign(_x, _y, _z);
    }

    Translation(const Translation& _o)
    {
        Init();
        Assign((_o).x(), (_o).y(), (_o).z());
    }

    ~Translation();

    void
    operator=(const Translation& _o)
    {
        Assign((_o).x(), (_o).y(), (_o).z());
    }

    bool
    operator==(const Translation& _o) const;

    float&
    x()
    {
        return x_;
    }
    const float&
    x() const
    {
        return x_;
    }

    float&
    y()
    {
        return y_;
    }
    const float&
    y() const
    {
        return y_;
    }

    float&
    z()
    {
        return z_;
    }
    const float&
    z() const
    {
        return z_;
    }

private:
    void
    Init();

    void
    Assign(
            const float& _x,
            const float& _y,
            const float& _z);

    float x_;
    float y_;
    float z_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace layers {
class Perspective;
} // namespace layers
} // namespace mozilla
namespace mozilla {
namespace layers {
class RotationX;
} // namespace layers
} // namespace mozilla
namespace mozilla {
namespace layers {
class RotationY;
} // namespace layers
} // namespace mozilla
namespace mozilla {
namespace layers {
class RotationZ;
} // namespace layers
} // namespace mozilla
namespace mozilla {
namespace layers {
class Rotation;
} // namespace layers
} // namespace mozilla
namespace mozilla {
namespace layers {
class Rotation3D;
} // namespace layers
} // namespace mozilla
namespace mozilla {
namespace layers {
class Scale;
} // namespace layers
} // namespace mozilla
namespace mozilla {
namespace layers {
class SkewX;
} // namespace layers
} // namespace mozilla
namespace mozilla {
namespace layers {
class SkewY;
} // namespace layers
} // namespace mozilla
namespace mozilla {
namespace layers {
class Translation;
} // namespace layers
} // namespace mozilla
namespace mozilla {
namespace layers {
class TransformMatrix;
} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union TransformFunction|
//
namespace mozilla {
namespace layers {
class TransformFunction MOZ_FINAL
{
public:
    enum Type {
        T__None,
        TPerspective = 1,
        TRotationX,
        TRotationY,
        TRotationZ,
        TRotation,
        TRotation3D,
        TScale,
        TSkewX,
        TSkewY,
        TTranslation,
        TTransformMatrix,
        T__Last = TTransformMatrix
    };

private:
    typedef mozilla::layers::Perspective Perspective;
    typedef mozilla::layers::RotationX RotationX;
    typedef mozilla::layers::RotationY RotationY;
    typedef mozilla::layers::RotationZ RotationZ;
    typedef mozilla::layers::Rotation Rotation;
    typedef mozilla::layers::Rotation3D Rotation3D;
    typedef mozilla::layers::Scale Scale;
    typedef mozilla::layers::SkewX SkewX;
    typedef mozilla::layers::SkewY SkewY;
    typedef mozilla::layers::Translation Translation;
    typedef mozilla::layers::TransformMatrix TransformMatrix;
    typedef Perspective Perspective__tdef;
    typedef RotationX RotationX__tdef;
    typedef RotationY RotationY__tdef;
    typedef RotationZ RotationZ__tdef;
    typedef Rotation Rotation__tdef;
    typedef Rotation3D Rotation3D__tdef;
    typedef Scale Scale__tdef;
    typedef SkewX SkewX__tdef;
    typedef SkewY SkewY__tdef;
    typedef Translation Translation__tdef;
    typedef TransformMatrix TransformMatrix__tdef;

    union Value {
        char VPerspective[sizeof(Perspective)];
        char VRotationX[sizeof(RotationX)];
        char VRotationY[sizeof(RotationY)];
        char VRotationZ[sizeof(RotationZ)];
        char VRotation[sizeof(Rotation)];
        char VRotation3D[sizeof(Rotation3D)];
        char VScale[sizeof(Scale)];
        char VSkewX[sizeof(SkewX)];
        char VSkewY[sizeof(SkewY)];
        char VTranslation[sizeof(Translation)];
        char VTransformMatrix[sizeof(TransformMatrix)];
    };

    Perspective*
    ptr_Perspective()
    {
        return reinterpret_cast<Perspective*>((&((mValue).VPerspective)));
    }
    const Perspective* const
    constptr_Perspective() const
    {
        return reinterpret_cast<const Perspective* const>((&((mValue).VPerspective)));
    }
    RotationX*
    ptr_RotationX()
    {
        return reinterpret_cast<RotationX*>((&((mValue).VRotationX)));
    }
    const RotationX* const
    constptr_RotationX() const
    {
        return reinterpret_cast<const RotationX* const>((&((mValue).VRotationX)));
    }
    RotationY*
    ptr_RotationY()
    {
        return reinterpret_cast<RotationY*>((&((mValue).VRotationY)));
    }
    const RotationY* const
    constptr_RotationY() const
    {
        return reinterpret_cast<const RotationY* const>((&((mValue).VRotationY)));
    }
    RotationZ*
    ptr_RotationZ()
    {
        return reinterpret_cast<RotationZ*>((&((mValue).VRotationZ)));
    }
    const RotationZ* const
    constptr_RotationZ() const
    {
        return reinterpret_cast<const RotationZ* const>((&((mValue).VRotationZ)));
    }
    Rotation*
    ptr_Rotation()
    {
        return reinterpret_cast<Rotation*>((&((mValue).VRotation)));
    }
    const Rotation* const
    constptr_Rotation() const
    {
        return reinterpret_cast<const Rotation* const>((&((mValue).VRotation)));
    }
    Rotation3D*
    ptr_Rotation3D()
    {
        return reinterpret_cast<Rotation3D*>((&((mValue).VRotation3D)));
    }
    const Rotation3D* const
    constptr_Rotation3D() const
    {
        return reinterpret_cast<const Rotation3D* const>((&((mValue).VRotation3D)));
    }
    Scale*
    ptr_Scale()
    {
        return reinterpret_cast<Scale*>((&((mValue).VScale)));
    }
    const Scale* const
    constptr_Scale() const
    {
        return reinterpret_cast<const Scale* const>((&((mValue).VScale)));
    }
    SkewX*
    ptr_SkewX()
    {
        return reinterpret_cast<SkewX*>((&((mValue).VSkewX)));
    }
    const SkewX* const
    constptr_SkewX() const
    {
        return reinterpret_cast<const SkewX* const>((&((mValue).VSkewX)));
    }
    SkewY*
    ptr_SkewY()
    {
        return reinterpret_cast<SkewY*>((&((mValue).VSkewY)));
    }
    const SkewY* const
    constptr_SkewY() const
    {
        return reinterpret_cast<const SkewY* const>((&((mValue).VSkewY)));
    }
    Translation*
    ptr_Translation()
    {
        return reinterpret_cast<Translation*>((&((mValue).VTranslation)));
    }
    const Translation* const
    constptr_Translation() const
    {
        return reinterpret_cast<const Translation* const>((&((mValue).VTranslation)));
    }
    TransformMatrix*
    ptr_TransformMatrix()
    {
        return reinterpret_cast<TransformMatrix*>((&((mValue).VTransformMatrix)));
    }
    const TransformMatrix* const
    constptr_TransformMatrix() const
    {
        return reinterpret_cast<const TransformMatrix* const>((&((mValue).VTransformMatrix)));
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        NS_ABORT_IF_FALSE((T__None) <= (mType), "invalid type tag");
        NS_ABORT_IF_FALSE((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        NS_ABORT_IF_FALSE((mType) == (aType), "unexpected type tag");
    }

public:
    TransformFunction() :
        mType(T__None)
    {
    }

    TransformFunction(const Perspective& aOther);

    TransformFunction(const RotationX& aOther);

    TransformFunction(const RotationY& aOther);

    TransformFunction(const RotationZ& aOther);

    TransformFunction(const Rotation& aOther);

    TransformFunction(const Rotation3D& aOther);

    TransformFunction(const Scale& aOther);

    TransformFunction(const SkewX& aOther);

    TransformFunction(const SkewY& aOther);

    TransformFunction(const Translation& aOther);

    TransformFunction(const TransformMatrix& aOther);

    TransformFunction(const TransformFunction& aOther);

    ~TransformFunction();

    Type
    type() const
    {
        return mType;
    }

    TransformFunction&
    operator=(const Perspective& aRhs);

    TransformFunction&
    operator=(const RotationX& aRhs);

    TransformFunction&
    operator=(const RotationY& aRhs);

    TransformFunction&
    operator=(const RotationZ& aRhs);

    TransformFunction&
    operator=(const Rotation& aRhs);

    TransformFunction&
    operator=(const Rotation3D& aRhs);

    TransformFunction&
    operator=(const Scale& aRhs);

    TransformFunction&
    operator=(const SkewX& aRhs);

    TransformFunction&
    operator=(const SkewY& aRhs);

    TransformFunction&
    operator=(const Translation& aRhs);

    TransformFunction&
    operator=(const TransformMatrix& aRhs);

    TransformFunction&
    operator=(const TransformFunction& aRhs);

    bool
    operator==(const Perspective& aRhs) const;

    bool
    operator==(const RotationX& aRhs) const;

    bool
    operator==(const RotationY& aRhs) const;

    bool
    operator==(const RotationZ& aRhs) const;

    bool
    operator==(const Rotation& aRhs) const;

    bool
    operator==(const Rotation3D& aRhs) const;

    bool
    operator==(const Scale& aRhs) const;

    bool
    operator==(const SkewX& aRhs) const;

    bool
    operator==(const SkewY& aRhs) const;

    bool
    operator==(const Translation& aRhs) const;

    bool
    operator==(const TransformMatrix& aRhs) const;

    bool
    operator==(const TransformFunction& aRhs) const;

    Perspective&
    get_Perspective()
    {
        AssertSanity(TPerspective);
        return (*(ptr_Perspective()));
    }
    const Perspective&
    get_Perspective() const
    {
        AssertSanity(TPerspective);
        return (*(constptr_Perspective()));
    }
    operator Perspective&()
    {
        return get_Perspective();
    }
    operator const Perspective&() const
    {
        return get_Perspective();
    }

    RotationX&
    get_RotationX()
    {
        AssertSanity(TRotationX);
        return (*(ptr_RotationX()));
    }
    const RotationX&
    get_RotationX() const
    {
        AssertSanity(TRotationX);
        return (*(constptr_RotationX()));
    }
    operator RotationX&()
    {
        return get_RotationX();
    }
    operator const RotationX&() const
    {
        return get_RotationX();
    }

    RotationY&
    get_RotationY()
    {
        AssertSanity(TRotationY);
        return (*(ptr_RotationY()));
    }
    const RotationY&
    get_RotationY() const
    {
        AssertSanity(TRotationY);
        return (*(constptr_RotationY()));
    }
    operator RotationY&()
    {
        return get_RotationY();
    }
    operator const RotationY&() const
    {
        return get_RotationY();
    }

    RotationZ&
    get_RotationZ()
    {
        AssertSanity(TRotationZ);
        return (*(ptr_RotationZ()));
    }
    const RotationZ&
    get_RotationZ() const
    {
        AssertSanity(TRotationZ);
        return (*(constptr_RotationZ()));
    }
    operator RotationZ&()
    {
        return get_RotationZ();
    }
    operator const RotationZ&() const
    {
        return get_RotationZ();
    }

    Rotation&
    get_Rotation()
    {
        AssertSanity(TRotation);
        return (*(ptr_Rotation()));
    }
    const Rotation&
    get_Rotation() const
    {
        AssertSanity(TRotation);
        return (*(constptr_Rotation()));
    }
    operator Rotation&()
    {
        return get_Rotation();
    }
    operator const Rotation&() const
    {
        return get_Rotation();
    }

    Rotation3D&
    get_Rotation3D()
    {
        AssertSanity(TRotation3D);
        return (*(ptr_Rotation3D()));
    }
    const Rotation3D&
    get_Rotation3D() const
    {
        AssertSanity(TRotation3D);
        return (*(constptr_Rotation3D()));
    }
    operator Rotation3D&()
    {
        return get_Rotation3D();
    }
    operator const Rotation3D&() const
    {
        return get_Rotation3D();
    }

    Scale&
    get_Scale()
    {
        AssertSanity(TScale);
        return (*(ptr_Scale()));
    }
    const Scale&
    get_Scale() const
    {
        AssertSanity(TScale);
        return (*(constptr_Scale()));
    }
    operator Scale&()
    {
        return get_Scale();
    }
    operator const Scale&() const
    {
        return get_Scale();
    }

    SkewX&
    get_SkewX()
    {
        AssertSanity(TSkewX);
        return (*(ptr_SkewX()));
    }
    const SkewX&
    get_SkewX() const
    {
        AssertSanity(TSkewX);
        return (*(constptr_SkewX()));
    }
    operator SkewX&()
    {
        return get_SkewX();
    }
    operator const SkewX&() const
    {
        return get_SkewX();
    }

    SkewY&
    get_SkewY()
    {
        AssertSanity(TSkewY);
        return (*(ptr_SkewY()));
    }
    const SkewY&
    get_SkewY() const
    {
        AssertSanity(TSkewY);
        return (*(constptr_SkewY()));
    }
    operator SkewY&()
    {
        return get_SkewY();
    }
    operator const SkewY&() const
    {
        return get_SkewY();
    }

    Translation&
    get_Translation()
    {
        AssertSanity(TTranslation);
        return (*(ptr_Translation()));
    }
    const Translation&
    get_Translation() const
    {
        AssertSanity(TTranslation);
        return (*(constptr_Translation()));
    }
    operator Translation&()
    {
        return get_Translation();
    }
    operator const Translation&() const
    {
        return get_Translation();
    }

    TransformMatrix&
    get_TransformMatrix()
    {
        AssertSanity(TTransformMatrix);
        return (*(ptr_TransformMatrix()));
    }
    const TransformMatrix&
    get_TransformMatrix() const
    {
        AssertSanity(TTransformMatrix);
        return (*(constptr_TransformMatrix()));
    }
    operator TransformMatrix&()
    {
        return get_TransformMatrix();
    }
    operator const TransformMatrix&() const
    {
        return get_TransformMatrix();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace layers {
class TransformFunction;
} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union Animatable|
//
namespace mozilla {
namespace layers {
class Animatable MOZ_FINAL
{
public:
    enum Type {
        T__None,
        Tfloat = 1,
        TArrayOfTransformFunction,
        T__Last = TArrayOfTransformFunction
    };

private:
    typedef mozilla::layers::TransformFunction TransformFunction;
    typedef float float__tdef;
    typedef InfallibleTArray<TransformFunction> ArrayOfTransformFunction__tdef;

    union Value {
        char Vfloat[sizeof(float)];
        char VArrayOfTransformFunction[sizeof(InfallibleTArray<TransformFunction>)];
    };

    float*
    ptr_float()
    {
        return reinterpret_cast<float*>((&((mValue).Vfloat)));
    }
    const float* const
    constptr_float() const
    {
        return reinterpret_cast<const float* const>((&((mValue).Vfloat)));
    }
    InfallibleTArray<TransformFunction>*
    ptr_ArrayOfTransformFunction()
    {
        return reinterpret_cast<InfallibleTArray<TransformFunction>*>((&((mValue).VArrayOfTransformFunction)));
    }
    const InfallibleTArray<TransformFunction>* const
    constptr_ArrayOfTransformFunction() const
    {
        return reinterpret_cast<const InfallibleTArray<TransformFunction>* const>((&((mValue).VArrayOfTransformFunction)));
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        NS_ABORT_IF_FALSE((T__None) <= (mType), "invalid type tag");
        NS_ABORT_IF_FALSE((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        NS_ABORT_IF_FALSE((mType) == (aType), "unexpected type tag");
    }

public:
    Animatable() :
        mType(T__None)
    {
    }

    Animatable(const float& aOther);

    Animatable(const InfallibleTArray<TransformFunction>& aOther);

    Animatable(const Animatable& aOther);

    ~Animatable();

    Type
    type() const
    {
        return mType;
    }

    Animatable&
    operator=(const float& aRhs);

    Animatable&
    operator=(const InfallibleTArray<TransformFunction>& aRhs);

    Animatable&
    operator=(const Animatable& aRhs);

    bool
    operator==(const float& aRhs) const;

    bool
    operator==(const InfallibleTArray<TransformFunction>& aRhs) const;

    bool
    operator==(const Animatable& aRhs) const;

    float&
    get_float()
    {
        AssertSanity(Tfloat);
        return (*(ptr_float()));
    }
    const float&
    get_float() const
    {
        AssertSanity(Tfloat);
        return (*(constptr_float()));
    }
    operator float&()
    {
        return get_float();
    }
    operator const float&() const
    {
        return get_float();
    }

    InfallibleTArray<TransformFunction>&
    get_ArrayOfTransformFunction()
    {
        AssertSanity(TArrayOfTransformFunction);
        return (*(ptr_ArrayOfTransformFunction()));
    }
    const InfallibleTArray<TransformFunction>&
    get_ArrayOfTransformFunction() const
    {
        AssertSanity(TArrayOfTransformFunction);
        return (*(constptr_ArrayOfTransformFunction()));
    }
    operator InfallibleTArray<TransformFunction>&()
    {
        return get_ArrayOfTransformFunction();
    }
    operator const InfallibleTArray<TransformFunction>&() const
    {
        return get_ArrayOfTransformFunction();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace layers {
class Animatable;
} // namespace layers
} // namespace mozilla
namespace mozilla {
namespace layers {
class TimingFunction;
} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct AnimationSegment|
//
namespace mozilla {
namespace layers {
class AnimationSegment MOZ_FINAL
{
private:
    typedef mozilla::layers::Animatable Animatable;
    typedef mozilla::layers::TimingFunction TimingFunction;

public:
    AnimationSegment();

    AnimationSegment(
            const Animatable& _startState,
            const Animatable& _endState,
            const float& _startPortion,
            const float& _endPortion,
            const TimingFunction& _sampleFn)
    {
        Init();
        Assign(_startState, _endState, _startPortion, _endPortion, _sampleFn);
    }

    AnimationSegment(const AnimationSegment& _o)
    {
        Init();
        Assign((_o).startState(), (_o).endState(), (_o).startPortion(), (_o).endPortion(), (_o).sampleFn());
    }

    ~AnimationSegment();

    void
    operator=(const AnimationSegment& _o)
    {
        Assign((_o).startState(), (_o).endState(), (_o).startPortion(), (_o).endPortion(), (_o).sampleFn());
    }

    bool
    operator==(const AnimationSegment& _o) const;

    Animatable&
    startState()
    {
        return startState_;
    }
    const Animatable&
    startState() const
    {
        return startState_;
    }

    Animatable&
    endState()
    {
        return endState_;
    }
    const Animatable&
    endState() const
    {
        return endState_;
    }

    float&
    startPortion()
    {
        return startPortion_;
    }
    const float&
    startPortion() const
    {
        return startPortion_;
    }

    float&
    endPortion()
    {
        return endPortion_;
    }
    const float&
    endPortion() const
    {
        return endPortion_;
    }

    TimingFunction&
    sampleFn()
    {
        return sampleFn_;
    }
    const TimingFunction&
    sampleFn() const
    {
        return sampleFn_;
    }

private:
    void
    Init();

    void
    Assign(
            const Animatable& _startState,
            const Animatable& _endState,
            const float& _startPortion,
            const float& _endPortion,
            const TimingFunction& _sampleFn);

    Animatable startState_;
    Animatable endState_;
    float startPortion_;
    float endPortion_;
    TimingFunction sampleFn_;
};
} // namespace layers
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct TransformData|
//
namespace mozilla {
namespace layers {
class TransformData MOZ_FINAL
{
private:

public:
    TransformData();

    TransformData(
            const nsPoint& _origin,
            const gfxPoint3D& _mozOrigin,
            const gfxPoint3D& _perspectiveOrigin,
            const nsRect& _bounds,
            const nscoord& _perspective)
    {
        Init();
        Assign(_origin, _mozOrigin, _perspectiveOrigin, _bounds, _perspective);
    }

    TransformData(const TransformData& _o)
    {
        Init();
        Assign((_o).origin(), (_o).mozOrigin(), (_o).perspectiveOrigin(), (_o).bounds(), (_o).perspective());
    }

    ~TransformData();

    void
    operator=(const TransformData& _o)
    {
        Assign((_o).origin(), (_o).mozOrigin(), (_o).perspectiveOrigin(), (_o).bounds(), (_o).perspective());
    }

    bool
    operator==(const TransformData& _o) const;

    nsPoint&
    origin()
    {
        return origin_;
    }
    const nsPoint&
    origin() const
    {
        return origin_;
    }

    gfxPoint3D&
    mozOrigin()
    {
        return mozOrigin_;
    }
    const gfxPoint3D&
    mozOrigin() const
    {
        return mozOrigin_;
    }

    gfxPoint3D&
    perspectiveOrigin()
    {
        return perspectiveOrigin_;
    }
    const gfxPoint3D&
    perspectiveOrigin() const
    {
        return perspectiveOrigin_;
    }

    nsRect&
    bounds()
    {
        return bounds_;
    }
    const nsRect&
    bounds() const
    {
        return bounds_;
    }

    nscoord&
    perspective()
    {
        return perspective_;
    }
    const nscoord&
    perspective() const
    {
        return perspective_;
    }

private:
    void
    Init();

    void
    Assign(
            const nsPoint& _origin,
            const gfxPoint3D& _mozOrigin,
            const gfxPoint3D& _perspectiveOrigin,
            const nsRect& _bounds,
            const nscoord& _perspective);

    nsPoint origin_;
    gfxPoint3D mozOrigin_;
    gfxPoint3D perspectiveOrigin_;
    nsRect bounds_;
    nscoord perspective_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace layers {
class TransformData;
} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union AnimationData|
//
namespace mozilla {
namespace layers {
class AnimationData MOZ_FINAL
{
public:
    enum Type {
        T__None,
        Tnull_t = 1,
        TTransformData,
        T__Last = TTransformData
    };

private:
    typedef mozilla::null_t null_t;
    typedef mozilla::layers::TransformData TransformData;
    typedef null_t null_t__tdef;
    typedef TransformData TransformData__tdef;

    union Value {
        char Vnull_t[sizeof(null_t)];
        char VTransformData[sizeof(TransformData)];
    };

    null_t*
    ptr_null_t()
    {
        return reinterpret_cast<null_t*>((&((mValue).Vnull_t)));
    }
    const null_t* const
    constptr_null_t() const
    {
        return reinterpret_cast<const null_t* const>((&((mValue).Vnull_t)));
    }
    TransformData*
    ptr_TransformData()
    {
        return reinterpret_cast<TransformData*>((&((mValue).VTransformData)));
    }
    const TransformData* const
    constptr_TransformData() const
    {
        return reinterpret_cast<const TransformData* const>((&((mValue).VTransformData)));
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        NS_ABORT_IF_FALSE((T__None) <= (mType), "invalid type tag");
        NS_ABORT_IF_FALSE((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        NS_ABORT_IF_FALSE((mType) == (aType), "unexpected type tag");
    }

public:
    AnimationData() :
        mType(T__None)
    {
    }

    AnimationData(const null_t& aOther);

    AnimationData(const TransformData& aOther);

    AnimationData(const AnimationData& aOther);

    ~AnimationData();

    Type
    type() const
    {
        return mType;
    }

    AnimationData&
    operator=(const null_t& aRhs);

    AnimationData&
    operator=(const TransformData& aRhs);

    AnimationData&
    operator=(const AnimationData& aRhs);

    bool
    operator==(const null_t& aRhs) const;

    bool
    operator==(const TransformData& aRhs) const;

    bool
    operator==(const AnimationData& aRhs) const;

    null_t&
    get_null_t()
    {
        AssertSanity(Tnull_t);
        return (*(ptr_null_t()));
    }
    const null_t&
    get_null_t() const
    {
        AssertSanity(Tnull_t);
        return (*(constptr_null_t()));
    }
    operator null_t&()
    {
        return get_null_t();
    }
    operator const null_t&() const
    {
        return get_null_t();
    }

    TransformData&
    get_TransformData()
    {
        AssertSanity(TTransformData);
        return (*(ptr_TransformData()));
    }
    const TransformData&
    get_TransformData() const
    {
        AssertSanity(TTransformData);
        return (*(constptr_TransformData()));
    }
    operator TransformData&()
    {
        return get_TransformData();
    }
    operator const TransformData&() const
    {
        return get_TransformData();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace layers {
class AnimationSegment;
} // namespace layers
} // namespace mozilla
namespace mozilla {
namespace layers {
class AnimationData;
} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct Animation|
//
namespace mozilla {
namespace layers {
class Animation MOZ_FINAL
{
private:
    typedef mozilla::TimeStamp TimeStamp;
    typedef mozilla::TimeDuration TimeDuration;
    typedef mozilla::layers::AnimationSegment AnimationSegment;
    typedef mozilla::layers::AnimationData AnimationData;

public:
    Animation();

    Animation(
            const TimeStamp& _startTime,
            const TimeDuration& _duration,
            const InfallibleTArray<AnimationSegment>& _segments,
            const float& _numIterations,
            const int32_t& _direction,
            const nsCSSProperty& _property,
            const AnimationData& _data)
    {
        Init();
        Assign(_startTime, _duration, _segments, _numIterations, _direction, _property, _data);
    }

    Animation(const Animation& _o)
    {
        Init();
        Assign((_o).startTime(), (_o).duration(), (_o).segments(), (_o).numIterations(), (_o).direction(), (_o).property(), (_o).data());
    }

    ~Animation();

    void
    operator=(const Animation& _o)
    {
        Assign((_o).startTime(), (_o).duration(), (_o).segments(), (_o).numIterations(), (_o).direction(), (_o).property(), (_o).data());
    }

    bool
    operator==(const Animation& _o) const;

    TimeStamp&
    startTime()
    {
        return startTime_;
    }
    const TimeStamp&
    startTime() const
    {
        return startTime_;
    }

    TimeDuration&
    duration()
    {
        return duration_;
    }
    const TimeDuration&
    duration() const
    {
        return duration_;
    }

    InfallibleTArray<AnimationSegment>&
    segments()
    {
        return segments_;
    }
    const InfallibleTArray<AnimationSegment>&
    segments() const
    {
        return segments_;
    }

    float&
    numIterations()
    {
        return numIterations_;
    }
    const float&
    numIterations() const
    {
        return numIterations_;
    }

    int32_t&
    direction()
    {
        return direction_;
    }
    const int32_t&
    direction() const
    {
        return direction_;
    }

    nsCSSProperty&
    property()
    {
        return property_;
    }
    const nsCSSProperty&
    property() const
    {
        return property_;
    }

    AnimationData&
    data()
    {
        return data_;
    }
    const AnimationData&
    data() const
    {
        return data_;
    }

private:
    void
    Init();

    void
    Assign(
            const TimeStamp& _startTime,
            const TimeDuration& _duration,
            const InfallibleTArray<AnimationSegment>& _segments,
            const float& _numIterations,
            const int32_t& _direction,
            const nsCSSProperty& _property,
            const AnimationData& _data);

    TimeStamp startTime_;
    TimeDuration duration_;
    InfallibleTArray<AnimationSegment> segments_;
    float numIterations_;
    int32_t direction_;
    nsCSSProperty property_;
    AnimationData data_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace layers {
class TransformMatrix;
} // namespace layers
} // namespace mozilla
namespace mozilla {
namespace layers {
class PLayerParent;
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace layers {
class PLayerChild;
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace layers {
class Animation;
} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct CommonLayerAttributes|
//
namespace mozilla {
namespace layers {
class CommonLayerAttributes MOZ_FINAL
{
private:
    typedef mozilla::layers::TransformMatrix TransformMatrix;
    typedef mozilla::layers::PLayerParent PLayerParent;
    typedef mozilla::layers::PLayerChild PLayerChild;
    typedef mozilla::layers::Animation Animation;

public:
    CommonLayerAttributes();

    CommonLayerAttributes(
            const nsIntRegion& _visibleRegion,
            const TransformMatrix& _transform,
            const float& _postXScale,
            const float& _postYScale,
            const uint32_t& _contentFlags,
            const float& _opacity,
            const bool& _useClipRect,
            const nsIntRect& _clipRect,
            const bool& _isFixedPosition,
            const gfxPoint& _fixedPositionAnchor,
            PLayerParent* _maskLayerParent,
            PLayerChild* _maskLayerChild,
            const InfallibleTArray<Animation>& _animations)
    {
        Init();
        Assign(_visibleRegion, _transform, _postXScale, _postYScale, _contentFlags, _opacity, _useClipRect, _clipRect, _isFixedPosition, _fixedPositionAnchor, _maskLayerParent, _maskLayerChild, _animations);
    }

    CommonLayerAttributes(const CommonLayerAttributes& _o)
    {
        Init();
        Assign((_o).visibleRegion(), (_o).transform(), (_o).postXScale(), (_o).postYScale(), (_o).contentFlags(), (_o).opacity(), (_o).useClipRect(), (_o).clipRect(), (_o).isFixedPosition(), (_o).fixedPositionAnchor(), const_cast<PLayerParent*>((_o).maskLayerParent()), const_cast<PLayerChild*>((_o).maskLayerChild()), (_o).animations());
    }

    ~CommonLayerAttributes();

    void
    operator=(const CommonLayerAttributes& _o)
    {
        Assign((_o).visibleRegion(), (_o).transform(), (_o).postXScale(), (_o).postYScale(), (_o).contentFlags(), (_o).opacity(), (_o).useClipRect(), (_o).clipRect(), (_o).isFixedPosition(), (_o).fixedPositionAnchor(), const_cast<PLayerParent*>((_o).maskLayerParent()), const_cast<PLayerChild*>((_o).maskLayerChild()), (_o).animations());
    }

    bool
    operator==(const CommonLayerAttributes& _o) const;

    nsIntRegion&
    visibleRegion()
    {
        return visibleRegion_;
    }
    const nsIntRegion&
    visibleRegion() const
    {
        return visibleRegion_;
    }

    TransformMatrix&
    transform()
    {
        return transform_;
    }
    const TransformMatrix&
    transform() const
    {
        return transform_;
    }

    float&
    postXScale()
    {
        return postXScale_;
    }
    const float&
    postXScale() const
    {
        return postXScale_;
    }

    float&
    postYScale()
    {
        return postYScale_;
    }
    const float&
    postYScale() const
    {
        return postYScale_;
    }

    uint32_t&
    contentFlags()
    {
        return contentFlags_;
    }
    const uint32_t&
    contentFlags() const
    {
        return contentFlags_;
    }

    float&
    opacity()
    {
        return opacity_;
    }
    const float&
    opacity() const
    {
        return opacity_;
    }

    bool&
    useClipRect()
    {
        return useClipRect_;
    }
    const bool&
    useClipRect() const
    {
        return useClipRect_;
    }

    nsIntRect&
    clipRect()
    {
        return clipRect_;
    }
    const nsIntRect&
    clipRect() const
    {
        return clipRect_;
    }

    bool&
    isFixedPosition()
    {
        return isFixedPosition_;
    }
    const bool&
    isFixedPosition() const
    {
        return isFixedPosition_;
    }

    gfxPoint&
    fixedPositionAnchor()
    {
        return fixedPositionAnchor_;
    }
    const gfxPoint&
    fixedPositionAnchor() const
    {
        return fixedPositionAnchor_;
    }

    PLayerParent*&
    maskLayerParent()
    {
        return maskLayerParent_;
    }
    PLayerParent*
    maskLayerParent() const
    {
        return maskLayerParent_;
    }

    PLayerChild*&
    maskLayerChild()
    {
        return maskLayerChild_;
    }
    PLayerChild*
    maskLayerChild() const
    {
        return maskLayerChild_;
    }

    InfallibleTArray<Animation>&
    animations()
    {
        return animations_;
    }
    const InfallibleTArray<Animation>&
    animations() const
    {
        return animations_;
    }

private:
    void
    Init();

    void
    Assign(
            const nsIntRegion& _visibleRegion,
            const TransformMatrix& _transform,
            const float& _postXScale,
            const float& _postYScale,
            const uint32_t& _contentFlags,
            const float& _opacity,
            const bool& _useClipRect,
            const nsIntRect& _clipRect,
            const bool& _isFixedPosition,
            const gfxPoint& _fixedPositionAnchor,
            PLayerParent* _maskLayerParent,
            PLayerChild* _maskLayerChild,
            const InfallibleTArray<Animation>& _animations);

    nsIntRegion visibleRegion_;
    TransformMatrix transform_;
    float postXScale_;
    float postYScale_;
    uint32_t contentFlags_;
    float opacity_;
    bool useClipRect_;
    nsIntRect clipRect_;
    bool isFixedPosition_;
    gfxPoint fixedPositionAnchor_;
    PLayerParent* maskLayerParent_;
    PLayerChild* maskLayerChild_;
    InfallibleTArray<Animation> animations_;
};
} // namespace layers
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ThebesLayerAttributes|
//
namespace mozilla {
namespace layers {
class ThebesLayerAttributes MOZ_FINAL
{
private:

public:
    ThebesLayerAttributes();

    ThebesLayerAttributes(const nsIntRegion& _validRegion)
    {
        Init();
        Assign(_validRegion);
    }

    ThebesLayerAttributes(const ThebesLayerAttributes& _o)
    {
        Init();
        Assign((_o).validRegion());
    }

    ~ThebesLayerAttributes();

    void
    operator=(const ThebesLayerAttributes& _o)
    {
        Assign((_o).validRegion());
    }

    bool
    operator==(const ThebesLayerAttributes& _o) const;

    nsIntRegion&
    validRegion()
    {
        return validRegion_;
    }
    const nsIntRegion&
    validRegion() const
    {
        return validRegion_;
    }

private:
    void
    Init();

    void
    Assign(const nsIntRegion& _validRegion);

    nsIntRegion validRegion_;
};
} // namespace layers
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ContainerLayerAttributes|
//
namespace mozilla {
namespace layers {
class ContainerLayerAttributes MOZ_FINAL
{
private:
    typedef mozilla::layers::FrameMetrics FrameMetrics;

public:
    ContainerLayerAttributes();

    ContainerLayerAttributes(
            const FrameMetrics& _metrics,
            const float& _preXScale,
            const float& _preYScale)
    {
        Init();
        Assign(_metrics, _preXScale, _preYScale);
    }

    ContainerLayerAttributes(const ContainerLayerAttributes& _o)
    {
        Init();
        Assign((_o).metrics(), (_o).preXScale(), (_o).preYScale());
    }

    ~ContainerLayerAttributes();

    void
    operator=(const ContainerLayerAttributes& _o)
    {
        Assign((_o).metrics(), (_o).preXScale(), (_o).preYScale());
    }

    bool
    operator==(const ContainerLayerAttributes& _o) const;

    FrameMetrics&
    metrics()
    {
        return metrics_;
    }
    const FrameMetrics&
    metrics() const
    {
        return metrics_;
    }

    float&
    preXScale()
    {
        return preXScale_;
    }
    const float&
    preXScale() const
    {
        return preXScale_;
    }

    float&
    preYScale()
    {
        return preYScale_;
    }
    const float&
    preYScale() const
    {
        return preYScale_;
    }

private:
    void
    Init();

    void
    Assign(
            const FrameMetrics& _metrics,
            const float& _preXScale,
            const float& _preYScale);

    FrameMetrics metrics_;
    float preXScale_;
    float preYScale_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace layers {
class Color;
} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ColorLayerAttributes|
//
namespace mozilla {
namespace layers {
class ColorLayerAttributes MOZ_FINAL
{
private:
    typedef mozilla::layers::Color Color;

public:
    ColorLayerAttributes();

    ColorLayerAttributes(const Color& _color)
    {
        Init();
        Assign(_color);
    }

    ColorLayerAttributes(const ColorLayerAttributes& _o)
    {
        Init();
        Assign((_o).color());
    }

    ~ColorLayerAttributes();

    void
    operator=(const ColorLayerAttributes& _o)
    {
        Assign((_o).color());
    }

    bool
    operator==(const ColorLayerAttributes& _o) const;

    Color&
    color()
    {
        return color_;
    }
    const Color&
    color() const
    {
        return color_;
    }

private:
    void
    Init();

    void
    Assign(const Color& _color);

    Color color_;
};
} // namespace layers
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct CanvasLayerAttributes|
//
namespace mozilla {
namespace layers {
class CanvasLayerAttributes MOZ_FINAL
{
private:
    typedef mozilla::GraphicsFilterType GraphicsFilterType;

public:
    CanvasLayerAttributes();

    CanvasLayerAttributes(const GraphicsFilterType& _filter)
    {
        Init();
        Assign(_filter);
    }

    CanvasLayerAttributes(const CanvasLayerAttributes& _o)
    {
        Init();
        Assign((_o).filter());
    }

    ~CanvasLayerAttributes();

    void
    operator=(const CanvasLayerAttributes& _o)
    {
        Assign((_o).filter());
    }

    bool
    operator==(const CanvasLayerAttributes& _o) const;

    GraphicsFilterType&
    filter()
    {
        return filter_;
    }
    const GraphicsFilterType&
    filter() const
    {
        return filter_;
    }

private:
    void
    Init();

    void
    Assign(const GraphicsFilterType& _filter);

    GraphicsFilterType filter_;
};
} // namespace layers
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct RefLayerAttributes|
//
namespace mozilla {
namespace layers {
class RefLayerAttributes MOZ_FINAL
{
private:

public:
    RefLayerAttributes();

    RefLayerAttributes(const int64_t& _id)
    {
        Init();
        Assign(_id);
    }

    RefLayerAttributes(const RefLayerAttributes& _o)
    {
        Init();
        Assign((_o).id());
    }

    ~RefLayerAttributes();

    void
    operator=(const RefLayerAttributes& _o)
    {
        Assign((_o).id());
    }

    bool
    operator==(const RefLayerAttributes& _o) const;

    int64_t&
    id()
    {
        return id_;
    }
    const int64_t&
    id() const
    {
        return id_;
    }

private:
    void
    Init();

    void
    Assign(const int64_t& _id);

    int64_t id_;
};
} // namespace layers
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ImageLayerAttributes|
//
namespace mozilla {
namespace layers {
class ImageLayerAttributes MOZ_FINAL
{
private:
    typedef mozilla::GraphicsFilterType GraphicsFilterType;

public:
    ImageLayerAttributes();

    ImageLayerAttributes(
            const GraphicsFilterType& _filter,
            const bool& _forceSingleTile)
    {
        Init();
        Assign(_filter, _forceSingleTile);
    }

    ImageLayerAttributes(const ImageLayerAttributes& _o)
    {
        Init();
        Assign((_o).filter(), (_o).forceSingleTile());
    }

    ~ImageLayerAttributes();

    void
    operator=(const ImageLayerAttributes& _o)
    {
        Assign((_o).filter(), (_o).forceSingleTile());
    }

    bool
    operator==(const ImageLayerAttributes& _o) const;

    GraphicsFilterType&
    filter()
    {
        return filter_;
    }
    const GraphicsFilterType&
    filter() const
    {
        return filter_;
    }

    bool&
    forceSingleTile()
    {
        return forceSingleTile_;
    }
    const bool&
    forceSingleTile() const
    {
        return forceSingleTile_;
    }

private:
    void
    Init();

    void
    Assign(
            const GraphicsFilterType& _filter,
            const bool& _forceSingleTile);

    GraphicsFilterType filter_;
    bool forceSingleTile_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace layers {
class ThebesLayerAttributes;
} // namespace layers
} // namespace mozilla
namespace mozilla {
namespace layers {
class ContainerLayerAttributes;
} // namespace layers
} // namespace mozilla
namespace mozilla {
namespace layers {
class ColorLayerAttributes;
} // namespace layers
} // namespace mozilla
namespace mozilla {
namespace layers {
class CanvasLayerAttributes;
} // namespace layers
} // namespace mozilla
namespace mozilla {
namespace layers {
class RefLayerAttributes;
} // namespace layers
} // namespace mozilla
namespace mozilla {
namespace layers {
class ImageLayerAttributes;
} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union SpecificLayerAttributes|
//
namespace mozilla {
namespace layers {
class SpecificLayerAttributes MOZ_FINAL
{
public:
    enum Type {
        T__None,
        Tnull_t = 1,
        TThebesLayerAttributes,
        TContainerLayerAttributes,
        TColorLayerAttributes,
        TCanvasLayerAttributes,
        TRefLayerAttributes,
        TImageLayerAttributes,
        T__Last = TImageLayerAttributes
    };

private:
    typedef mozilla::null_t null_t;
    typedef mozilla::layers::ThebesLayerAttributes ThebesLayerAttributes;
    typedef mozilla::layers::ContainerLayerAttributes ContainerLayerAttributes;
    typedef mozilla::layers::ColorLayerAttributes ColorLayerAttributes;
    typedef mozilla::layers::CanvasLayerAttributes CanvasLayerAttributes;
    typedef mozilla::layers::RefLayerAttributes RefLayerAttributes;
    typedef mozilla::layers::ImageLayerAttributes ImageLayerAttributes;
    typedef null_t null_t__tdef;
    typedef ThebesLayerAttributes ThebesLayerAttributes__tdef;
    typedef ContainerLayerAttributes ContainerLayerAttributes__tdef;
    typedef ColorLayerAttributes ColorLayerAttributes__tdef;
    typedef CanvasLayerAttributes CanvasLayerAttributes__tdef;
    typedef RefLayerAttributes RefLayerAttributes__tdef;
    typedef ImageLayerAttributes ImageLayerAttributes__tdef;

    union Value {
        char Vnull_t[sizeof(null_t)];
        char VThebesLayerAttributes[sizeof(ThebesLayerAttributes)];
        char VContainerLayerAttributes[sizeof(ContainerLayerAttributes)];
        char VColorLayerAttributes[sizeof(ColorLayerAttributes)];
        char VCanvasLayerAttributes[sizeof(CanvasLayerAttributes)];
        char VRefLayerAttributes[sizeof(RefLayerAttributes)];
        char VImageLayerAttributes[sizeof(ImageLayerAttributes)];
    };

    null_t*
    ptr_null_t()
    {
        return reinterpret_cast<null_t*>((&((mValue).Vnull_t)));
    }
    const null_t* const
    constptr_null_t() const
    {
        return reinterpret_cast<const null_t* const>((&((mValue).Vnull_t)));
    }
    ThebesLayerAttributes*
    ptr_ThebesLayerAttributes()
    {
        return reinterpret_cast<ThebesLayerAttributes*>((&((mValue).VThebesLayerAttributes)));
    }
    const ThebesLayerAttributes* const
    constptr_ThebesLayerAttributes() const
    {
        return reinterpret_cast<const ThebesLayerAttributes* const>((&((mValue).VThebesLayerAttributes)));
    }
    ContainerLayerAttributes*
    ptr_ContainerLayerAttributes()
    {
        return reinterpret_cast<ContainerLayerAttributes*>((&((mValue).VContainerLayerAttributes)));
    }
    const ContainerLayerAttributes* const
    constptr_ContainerLayerAttributes() const
    {
        return reinterpret_cast<const ContainerLayerAttributes* const>((&((mValue).VContainerLayerAttributes)));
    }
    ColorLayerAttributes*
    ptr_ColorLayerAttributes()
    {
        return reinterpret_cast<ColorLayerAttributes*>((&((mValue).VColorLayerAttributes)));
    }
    const ColorLayerAttributes* const
    constptr_ColorLayerAttributes() const
    {
        return reinterpret_cast<const ColorLayerAttributes* const>((&((mValue).VColorLayerAttributes)));
    }
    CanvasLayerAttributes*
    ptr_CanvasLayerAttributes()
    {
        return reinterpret_cast<CanvasLayerAttributes*>((&((mValue).VCanvasLayerAttributes)));
    }
    const CanvasLayerAttributes* const
    constptr_CanvasLayerAttributes() const
    {
        return reinterpret_cast<const CanvasLayerAttributes* const>((&((mValue).VCanvasLayerAttributes)));
    }
    RefLayerAttributes*
    ptr_RefLayerAttributes()
    {
        return reinterpret_cast<RefLayerAttributes*>((&((mValue).VRefLayerAttributes)));
    }
    const RefLayerAttributes* const
    constptr_RefLayerAttributes() const
    {
        return reinterpret_cast<const RefLayerAttributes* const>((&((mValue).VRefLayerAttributes)));
    }
    ImageLayerAttributes*
    ptr_ImageLayerAttributes()
    {
        return reinterpret_cast<ImageLayerAttributes*>((&((mValue).VImageLayerAttributes)));
    }
    const ImageLayerAttributes* const
    constptr_ImageLayerAttributes() const
    {
        return reinterpret_cast<const ImageLayerAttributes* const>((&((mValue).VImageLayerAttributes)));
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        NS_ABORT_IF_FALSE((T__None) <= (mType), "invalid type tag");
        NS_ABORT_IF_FALSE((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        NS_ABORT_IF_FALSE((mType) == (aType), "unexpected type tag");
    }

public:
    SpecificLayerAttributes() :
        mType(T__None)
    {
    }

    SpecificLayerAttributes(const null_t& aOther);

    SpecificLayerAttributes(const ThebesLayerAttributes& aOther);

    SpecificLayerAttributes(const ContainerLayerAttributes& aOther);

    SpecificLayerAttributes(const ColorLayerAttributes& aOther);

    SpecificLayerAttributes(const CanvasLayerAttributes& aOther);

    SpecificLayerAttributes(const RefLayerAttributes& aOther);

    SpecificLayerAttributes(const ImageLayerAttributes& aOther);

    SpecificLayerAttributes(const SpecificLayerAttributes& aOther);

    ~SpecificLayerAttributes();

    Type
    type() const
    {
        return mType;
    }

    SpecificLayerAttributes&
    operator=(const null_t& aRhs);

    SpecificLayerAttributes&
    operator=(const ThebesLayerAttributes& aRhs);

    SpecificLayerAttributes&
    operator=(const ContainerLayerAttributes& aRhs);

    SpecificLayerAttributes&
    operator=(const ColorLayerAttributes& aRhs);

    SpecificLayerAttributes&
    operator=(const CanvasLayerAttributes& aRhs);

    SpecificLayerAttributes&
    operator=(const RefLayerAttributes& aRhs);

    SpecificLayerAttributes&
    operator=(const ImageLayerAttributes& aRhs);

    SpecificLayerAttributes&
    operator=(const SpecificLayerAttributes& aRhs);

    bool
    operator==(const null_t& aRhs) const;

    bool
    operator==(const ThebesLayerAttributes& aRhs) const;

    bool
    operator==(const ContainerLayerAttributes& aRhs) const;

    bool
    operator==(const ColorLayerAttributes& aRhs) const;

    bool
    operator==(const CanvasLayerAttributes& aRhs) const;

    bool
    operator==(const RefLayerAttributes& aRhs) const;

    bool
    operator==(const ImageLayerAttributes& aRhs) const;

    bool
    operator==(const SpecificLayerAttributes& aRhs) const;

    null_t&
    get_null_t()
    {
        AssertSanity(Tnull_t);
        return (*(ptr_null_t()));
    }
    const null_t&
    get_null_t() const
    {
        AssertSanity(Tnull_t);
        return (*(constptr_null_t()));
    }
    operator null_t&()
    {
        return get_null_t();
    }
    operator const null_t&() const
    {
        return get_null_t();
    }

    ThebesLayerAttributes&
    get_ThebesLayerAttributes()
    {
        AssertSanity(TThebesLayerAttributes);
        return (*(ptr_ThebesLayerAttributes()));
    }
    const ThebesLayerAttributes&
    get_ThebesLayerAttributes() const
    {
        AssertSanity(TThebesLayerAttributes);
        return (*(constptr_ThebesLayerAttributes()));
    }
    operator ThebesLayerAttributes&()
    {
        return get_ThebesLayerAttributes();
    }
    operator const ThebesLayerAttributes&() const
    {
        return get_ThebesLayerAttributes();
    }

    ContainerLayerAttributes&
    get_ContainerLayerAttributes()
    {
        AssertSanity(TContainerLayerAttributes);
        return (*(ptr_ContainerLayerAttributes()));
    }
    const ContainerLayerAttributes&
    get_ContainerLayerAttributes() const
    {
        AssertSanity(TContainerLayerAttributes);
        return (*(constptr_ContainerLayerAttributes()));
    }
    operator ContainerLayerAttributes&()
    {
        return get_ContainerLayerAttributes();
    }
    operator const ContainerLayerAttributes&() const
    {
        return get_ContainerLayerAttributes();
    }

    ColorLayerAttributes&
    get_ColorLayerAttributes()
    {
        AssertSanity(TColorLayerAttributes);
        return (*(ptr_ColorLayerAttributes()));
    }
    const ColorLayerAttributes&
    get_ColorLayerAttributes() const
    {
        AssertSanity(TColorLayerAttributes);
        return (*(constptr_ColorLayerAttributes()));
    }
    operator ColorLayerAttributes&()
    {
        return get_ColorLayerAttributes();
    }
    operator const ColorLayerAttributes&() const
    {
        return get_ColorLayerAttributes();
    }

    CanvasLayerAttributes&
    get_CanvasLayerAttributes()
    {
        AssertSanity(TCanvasLayerAttributes);
        return (*(ptr_CanvasLayerAttributes()));
    }
    const CanvasLayerAttributes&
    get_CanvasLayerAttributes() const
    {
        AssertSanity(TCanvasLayerAttributes);
        return (*(constptr_CanvasLayerAttributes()));
    }
    operator CanvasLayerAttributes&()
    {
        return get_CanvasLayerAttributes();
    }
    operator const CanvasLayerAttributes&() const
    {
        return get_CanvasLayerAttributes();
    }

    RefLayerAttributes&
    get_RefLayerAttributes()
    {
        AssertSanity(TRefLayerAttributes);
        return (*(ptr_RefLayerAttributes()));
    }
    const RefLayerAttributes&
    get_RefLayerAttributes() const
    {
        AssertSanity(TRefLayerAttributes);
        return (*(constptr_RefLayerAttributes()));
    }
    operator RefLayerAttributes&()
    {
        return get_RefLayerAttributes();
    }
    operator const RefLayerAttributes&() const
    {
        return get_RefLayerAttributes();
    }

    ImageLayerAttributes&
    get_ImageLayerAttributes()
    {
        AssertSanity(TImageLayerAttributes);
        return (*(ptr_ImageLayerAttributes()));
    }
    const ImageLayerAttributes&
    get_ImageLayerAttributes() const
    {
        AssertSanity(TImageLayerAttributes);
        return (*(constptr_ImageLayerAttributes()));
    }
    operator ImageLayerAttributes&()
    {
        return get_ImageLayerAttributes();
    }
    operator const ImageLayerAttributes&() const
    {
        return get_ImageLayerAttributes();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace layers {
class CommonLayerAttributes;
} // namespace layers
} // namespace mozilla
namespace mozilla {
namespace layers {
class SpecificLayerAttributes;
} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct LayerAttributes|
//
namespace mozilla {
namespace layers {
class LayerAttributes MOZ_FINAL
{
private:
    typedef mozilla::layers::CommonLayerAttributes CommonLayerAttributes;
    typedef mozilla::layers::SpecificLayerAttributes SpecificLayerAttributes;

public:
    LayerAttributes();

    LayerAttributes(
            const CommonLayerAttributes& _common,
            const SpecificLayerAttributes& _specific)
    {
        Init();
        Assign(_common, _specific);
    }

    LayerAttributes(const LayerAttributes& _o)
    {
        Init();
        Assign((_o).common(), (_o).specific());
    }

    ~LayerAttributes();

    void
    operator=(const LayerAttributes& _o)
    {
        Assign((_o).common(), (_o).specific());
    }

    bool
    operator==(const LayerAttributes& _o) const;

    CommonLayerAttributes&
    common()
    {
        return common_;
    }
    const CommonLayerAttributes&
    common() const
    {
        return common_;
    }

    SpecificLayerAttributes&
    specific()
    {
        return specific_;
    }
    const SpecificLayerAttributes&
    specific() const
    {
        return specific_;
    }

private:
    void
    Init();

    void
    Assign(
            const CommonLayerAttributes& _common,
            const SpecificLayerAttributes& _specific);

    CommonLayerAttributes common_;
    SpecificLayerAttributes specific_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace layers {
class PLayerParent;
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace layers {
class PLayerChild;
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace layers {
class LayerAttributes;
} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct OpSetLayerAttributes|
//
namespace mozilla {
namespace layers {
class OpSetLayerAttributes MOZ_FINAL
{
private:
    typedef mozilla::layers::PLayerParent PLayerParent;
    typedef mozilla::layers::PLayerChild PLayerChild;
    typedef mozilla::layers::LayerAttributes LayerAttributes;

public:
    OpSetLayerAttributes();

    OpSetLayerAttributes(
            PLayerParent* _layerParent,
            PLayerChild* _layerChild,
            const LayerAttributes& _attrs)
    {
        Init();
        Assign(_layerParent, _layerChild, _attrs);
    }

    OpSetLayerAttributes(const OpSetLayerAttributes& _o)
    {
        Init();
        Assign(const_cast<PLayerParent*>((_o).layerParent()), const_cast<PLayerChild*>((_o).layerChild()), (_o).attrs());
    }

    ~OpSetLayerAttributes();

    void
    operator=(const OpSetLayerAttributes& _o)
    {
        Assign(const_cast<PLayerParent*>((_o).layerParent()), const_cast<PLayerChild*>((_o).layerChild()), (_o).attrs());
    }

    bool
    operator==(const OpSetLayerAttributes& _o) const;

    PLayerParent*&
    layerParent()
    {
        return layerParent_;
    }
    PLayerParent*
    layerParent() const
    {
        return layerParent_;
    }

    PLayerChild*&
    layerChild()
    {
        return layerChild_;
    }
    PLayerChild*
    layerChild() const
    {
        return layerChild_;
    }

    LayerAttributes&
    attrs()
    {
        return attrs_;
    }
    const LayerAttributes&
    attrs() const
    {
        return attrs_;
    }

private:
    void
    Init();

    void
    Assign(
            PLayerParent* _layerParent,
            PLayerChild* _layerChild,
            const LayerAttributes& _attrs);

    PLayerParent* layerParent_;
    PLayerChild* layerChild_;
    LayerAttributes attrs_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace layers {
class PLayerParent;
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace layers {
class PLayerChild;
} // namespace layers
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct OpSetRoot|
//
namespace mozilla {
namespace layers {
class OpSetRoot MOZ_FINAL
{
private:
    typedef mozilla::layers::PLayerParent PLayerParent;
    typedef mozilla::layers::PLayerChild PLayerChild;

public:
    OpSetRoot();

    OpSetRoot(
            PLayerParent* _rootParent,
            PLayerChild* _rootChild)
    {
        Init();
        Assign(_rootParent, _rootChild);
    }

    OpSetRoot(const OpSetRoot& _o)
    {
        Init();
        Assign(const_cast<PLayerParent*>((_o).rootParent()), const_cast<PLayerChild*>((_o).rootChild()));
    }

    ~OpSetRoot();

    void
    operator=(const OpSetRoot& _o)
    {
        Assign(const_cast<PLayerParent*>((_o).rootParent()), const_cast<PLayerChild*>((_o).rootChild()));
    }

    bool
    operator==(const OpSetRoot& _o) const;

    PLayerParent*&
    rootParent()
    {
        return rootParent_;
    }
    PLayerParent*
    rootParent() const
    {
        return rootParent_;
    }

    PLayerChild*&
    rootChild()
    {
        return rootChild_;
    }
    PLayerChild*
    rootChild() const
    {
        return rootChild_;
    }

private:
    void
    Init();

    void
    Assign(
            PLayerParent* _rootParent,
            PLayerChild* _rootChild);

    PLayerParent* rootParent_;
    PLayerChild* rootChild_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace layers {
class PLayerParent;
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace layers {
class PLayerChild;
} // namespace layers
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct OpInsertAfter|
//
namespace mozilla {
namespace layers {
class OpInsertAfter MOZ_FINAL
{
private:
    typedef mozilla::layers::PLayerParent PLayerParent;
    typedef mozilla::layers::PLayerChild PLayerChild;

public:
    OpInsertAfter();

    OpInsertAfter(
            PLayerParent* _containerParent,
            PLayerChild* _containerChild,
            PLayerParent* _childLayerParent,
            PLayerChild* _childLayerChild,
            PLayerParent* _afterParent,
            PLayerChild* _afterChild)
    {
        Init();
        Assign(_containerParent, _containerChild, _childLayerParent, _childLayerChild, _afterParent, _afterChild);
    }

    OpInsertAfter(const OpInsertAfter& _o)
    {
        Init();
        Assign(const_cast<PLayerParent*>((_o).containerParent()), const_cast<PLayerChild*>((_o).containerChild()), const_cast<PLayerParent*>((_o).childLayerParent()), const_cast<PLayerChild*>((_o).childLayerChild()), const_cast<PLayerParent*>((_o).afterParent()), const_cast<PLayerChild*>((_o).afterChild()));
    }

    ~OpInsertAfter();

    void
    operator=(const OpInsertAfter& _o)
    {
        Assign(const_cast<PLayerParent*>((_o).containerParent()), const_cast<PLayerChild*>((_o).containerChild()), const_cast<PLayerParent*>((_o).childLayerParent()), const_cast<PLayerChild*>((_o).childLayerChild()), const_cast<PLayerParent*>((_o).afterParent()), const_cast<PLayerChild*>((_o).afterChild()));
    }

    bool
    operator==(const OpInsertAfter& _o) const;

    PLayerParent*&
    containerParent()
    {
        return containerParent_;
    }
    PLayerParent*
    containerParent() const
    {
        return containerParent_;
    }

    PLayerChild*&
    containerChild()
    {
        return containerChild_;
    }
    PLayerChild*
    containerChild() const
    {
        return containerChild_;
    }

    PLayerParent*&
    childLayerParent()
    {
        return childLayerParent_;
    }
    PLayerParent*
    childLayerParent() const
    {
        return childLayerParent_;
    }

    PLayerChild*&
    childLayerChild()
    {
        return childLayerChild_;
    }
    PLayerChild*
    childLayerChild() const
    {
        return childLayerChild_;
    }

    PLayerParent*&
    afterParent()
    {
        return afterParent_;
    }
    PLayerParent*
    afterParent() const
    {
        return afterParent_;
    }

    PLayerChild*&
    afterChild()
    {
        return afterChild_;
    }
    PLayerChild*
    afterChild() const
    {
        return afterChild_;
    }

private:
    void
    Init();

    void
    Assign(
            PLayerParent* _containerParent,
            PLayerChild* _containerChild,
            PLayerParent* _childLayerParent,
            PLayerChild* _childLayerChild,
            PLayerParent* _afterParent,
            PLayerChild* _afterChild);

    PLayerParent* containerParent_;
    PLayerChild* containerChild_;
    PLayerParent* childLayerParent_;
    PLayerChild* childLayerChild_;
    PLayerParent* afterParent_;
    PLayerChild* afterChild_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace layers {
class PLayerParent;
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace layers {
class PLayerChild;
} // namespace layers
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct OpAppendChild|
//
namespace mozilla {
namespace layers {
class OpAppendChild MOZ_FINAL
{
private:
    typedef mozilla::layers::PLayerParent PLayerParent;
    typedef mozilla::layers::PLayerChild PLayerChild;

public:
    OpAppendChild();

    OpAppendChild(
            PLayerParent* _containerParent,
            PLayerChild* _containerChild,
            PLayerParent* _childLayerParent,
            PLayerChild* _childLayerChild)
    {
        Init();
        Assign(_containerParent, _containerChild, _childLayerParent, _childLayerChild);
    }

    OpAppendChild(const OpAppendChild& _o)
    {
        Init();
        Assign(const_cast<PLayerParent*>((_o).containerParent()), const_cast<PLayerChild*>((_o).containerChild()), const_cast<PLayerParent*>((_o).childLayerParent()), const_cast<PLayerChild*>((_o).childLayerChild()));
    }

    ~OpAppendChild();

    void
    operator=(const OpAppendChild& _o)
    {
        Assign(const_cast<PLayerParent*>((_o).containerParent()), const_cast<PLayerChild*>((_o).containerChild()), const_cast<PLayerParent*>((_o).childLayerParent()), const_cast<PLayerChild*>((_o).childLayerChild()));
    }

    bool
    operator==(const OpAppendChild& _o) const;

    PLayerParent*&
    containerParent()
    {
        return containerParent_;
    }
    PLayerParent*
    containerParent() const
    {
        return containerParent_;
    }

    PLayerChild*&
    containerChild()
    {
        return containerChild_;
    }
    PLayerChild*
    containerChild() const
    {
        return containerChild_;
    }

    PLayerParent*&
    childLayerParent()
    {
        return childLayerParent_;
    }
    PLayerParent*
    childLayerParent() const
    {
        return childLayerParent_;
    }

    PLayerChild*&
    childLayerChild()
    {
        return childLayerChild_;
    }
    PLayerChild*
    childLayerChild() const
    {
        return childLayerChild_;
    }

private:
    void
    Init();

    void
    Assign(
            PLayerParent* _containerParent,
            PLayerChild* _containerChild,
            PLayerParent* _childLayerParent,
            PLayerChild* _childLayerChild);

    PLayerParent* containerParent_;
    PLayerChild* containerChild_;
    PLayerParent* childLayerParent_;
    PLayerChild* childLayerChild_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace layers {
class PLayerParent;
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace layers {
class PLayerChild;
} // namespace layers
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct OpRemoveChild|
//
namespace mozilla {
namespace layers {
class OpRemoveChild MOZ_FINAL
{
private:
    typedef mozilla::layers::PLayerParent PLayerParent;
    typedef mozilla::layers::PLayerChild PLayerChild;

public:
    OpRemoveChild();

    OpRemoveChild(
            PLayerParent* _containerParent,
            PLayerChild* _containerChild,
            PLayerParent* _childLayerParent,
            PLayerChild* _childLayerChild)
    {
        Init();
        Assign(_containerParent, _containerChild, _childLayerParent, _childLayerChild);
    }

    OpRemoveChild(const OpRemoveChild& _o)
    {
        Init();
        Assign(const_cast<PLayerParent*>((_o).containerParent()), const_cast<PLayerChild*>((_o).containerChild()), const_cast<PLayerParent*>((_o).childLayerParent()), const_cast<PLayerChild*>((_o).childLayerChild()));
    }

    ~OpRemoveChild();

    void
    operator=(const OpRemoveChild& _o)
    {
        Assign(const_cast<PLayerParent*>((_o).containerParent()), const_cast<PLayerChild*>((_o).containerChild()), const_cast<PLayerParent*>((_o).childLayerParent()), const_cast<PLayerChild*>((_o).childLayerChild()));
    }

    bool
    operator==(const OpRemoveChild& _o) const;

    PLayerParent*&
    containerParent()
    {
        return containerParent_;
    }
    PLayerParent*
    containerParent() const
    {
        return containerParent_;
    }

    PLayerChild*&
    containerChild()
    {
        return containerChild_;
    }
    PLayerChild*
    containerChild() const
    {
        return containerChild_;
    }

    PLayerParent*&
    childLayerParent()
    {
        return childLayerParent_;
    }
    PLayerParent*
    childLayerParent() const
    {
        return childLayerParent_;
    }

    PLayerChild*&
    childLayerChild()
    {
        return childLayerChild_;
    }
    PLayerChild*
    childLayerChild() const
    {
        return childLayerChild_;
    }

private:
    void
    Init();

    void
    Assign(
            PLayerParent* _containerParent,
            PLayerChild* _containerChild,
            PLayerParent* _childLayerParent,
            PLayerChild* _childLayerChild);

    PLayerParent* containerParent_;
    PLayerChild* containerChild_;
    PLayerParent* childLayerParent_;
    PLayerChild* childLayerChild_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace layers {
class PLayerParent;
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace layers {
class PLayerChild;
} // namespace layers
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct OpRepositionChild|
//
namespace mozilla {
namespace layers {
class OpRepositionChild MOZ_FINAL
{
private:
    typedef mozilla::layers::PLayerParent PLayerParent;
    typedef mozilla::layers::PLayerChild PLayerChild;

public:
    OpRepositionChild();

    OpRepositionChild(
            PLayerParent* _containerParent,
            PLayerChild* _containerChild,
            PLayerParent* _childLayerParent,
            PLayerChild* _childLayerChild,
            PLayerParent* _afterParent,
            PLayerChild* _afterChild)
    {
        Init();
        Assign(_containerParent, _containerChild, _childLayerParent, _childLayerChild, _afterParent, _afterChild);
    }

    OpRepositionChild(const OpRepositionChild& _o)
    {
        Init();
        Assign(const_cast<PLayerParent*>((_o).containerParent()), const_cast<PLayerChild*>((_o).containerChild()), const_cast<PLayerParent*>((_o).childLayerParent()), const_cast<PLayerChild*>((_o).childLayerChild()), const_cast<PLayerParent*>((_o).afterParent()), const_cast<PLayerChild*>((_o).afterChild()));
    }

    ~OpRepositionChild();

    void
    operator=(const OpRepositionChild& _o)
    {
        Assign(const_cast<PLayerParent*>((_o).containerParent()), const_cast<PLayerChild*>((_o).containerChild()), const_cast<PLayerParent*>((_o).childLayerParent()), const_cast<PLayerChild*>((_o).childLayerChild()), const_cast<PLayerParent*>((_o).afterParent()), const_cast<PLayerChild*>((_o).afterChild()));
    }

    bool
    operator==(const OpRepositionChild& _o) const;

    PLayerParent*&
    containerParent()
    {
        return containerParent_;
    }
    PLayerParent*
    containerParent() const
    {
        return containerParent_;
    }

    PLayerChild*&
    containerChild()
    {
        return containerChild_;
    }
    PLayerChild*
    containerChild() const
    {
        return containerChild_;
    }

    PLayerParent*&
    childLayerParent()
    {
        return childLayerParent_;
    }
    PLayerParent*
    childLayerParent() const
    {
        return childLayerParent_;
    }

    PLayerChild*&
    childLayerChild()
    {
        return childLayerChild_;
    }
    PLayerChild*
    childLayerChild() const
    {
        return childLayerChild_;
    }

    PLayerParent*&
    afterParent()
    {
        return afterParent_;
    }
    PLayerParent*
    afterParent() const
    {
        return afterParent_;
    }

    PLayerChild*&
    afterChild()
    {
        return afterChild_;
    }
    PLayerChild*
    afterChild() const
    {
        return afterChild_;
    }

private:
    void
    Init();

    void
    Assign(
            PLayerParent* _containerParent,
            PLayerChild* _containerChild,
            PLayerParent* _childLayerParent,
            PLayerChild* _childLayerChild,
            PLayerParent* _afterParent,
            PLayerChild* _afterChild);

    PLayerParent* containerParent_;
    PLayerChild* containerChild_;
    PLayerParent* childLayerParent_;
    PLayerChild* childLayerChild_;
    PLayerParent* afterParent_;
    PLayerChild* afterChild_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace layers {
class PLayerParent;
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace layers {
class PLayerChild;
} // namespace layers
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct OpRaiseToTopChild|
//
namespace mozilla {
namespace layers {
class OpRaiseToTopChild MOZ_FINAL
{
private:
    typedef mozilla::layers::PLayerParent PLayerParent;
    typedef mozilla::layers::PLayerChild PLayerChild;

public:
    OpRaiseToTopChild();

    OpRaiseToTopChild(
            PLayerParent* _containerParent,
            PLayerChild* _containerChild,
            PLayerParent* _childLayerParent,
            PLayerChild* _childLayerChild)
    {
        Init();
        Assign(_containerParent, _containerChild, _childLayerParent, _childLayerChild);
    }

    OpRaiseToTopChild(const OpRaiseToTopChild& _o)
    {
        Init();
        Assign(const_cast<PLayerParent*>((_o).containerParent()), const_cast<PLayerChild*>((_o).containerChild()), const_cast<PLayerParent*>((_o).childLayerParent()), const_cast<PLayerChild*>((_o).childLayerChild()));
    }

    ~OpRaiseToTopChild();

    void
    operator=(const OpRaiseToTopChild& _o)
    {
        Assign(const_cast<PLayerParent*>((_o).containerParent()), const_cast<PLayerChild*>((_o).containerChild()), const_cast<PLayerParent*>((_o).childLayerParent()), const_cast<PLayerChild*>((_o).childLayerChild()));
    }

    bool
    operator==(const OpRaiseToTopChild& _o) const;

    PLayerParent*&
    containerParent()
    {
        return containerParent_;
    }
    PLayerParent*
    containerParent() const
    {
        return containerParent_;
    }

    PLayerChild*&
    containerChild()
    {
        return containerChild_;
    }
    PLayerChild*
    containerChild() const
    {
        return containerChild_;
    }

    PLayerParent*&
    childLayerParent()
    {
        return childLayerParent_;
    }
    PLayerParent*
    childLayerParent() const
    {
        return childLayerParent_;
    }

    PLayerChild*&
    childLayerChild()
    {
        return childLayerChild_;
    }
    PLayerChild*
    childLayerChild() const
    {
        return childLayerChild_;
    }

private:
    void
    Init();

    void
    Assign(
            PLayerParent* _containerParent,
            PLayerChild* _containerChild,
            PLayerParent* _childLayerParent,
            PLayerChild* _childLayerChild);

    PLayerParent* containerParent_;
    PLayerChild* containerChild_;
    PLayerParent* childLayerParent_;
    PLayerChild* childLayerChild_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace layers {
class PLayerParent;
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace layers {
class PLayerChild;
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace layers {
class ThebesBuffer;
} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct OpPaintThebesBuffer|
//
namespace mozilla {
namespace layers {
class OpPaintThebesBuffer MOZ_FINAL
{
private:
    typedef mozilla::layers::PLayerParent PLayerParent;
    typedef mozilla::layers::PLayerChild PLayerChild;
    typedef mozilla::layers::ThebesBuffer ThebesBuffer;

public:
    OpPaintThebesBuffer();

    OpPaintThebesBuffer(
            PLayerParent* _layerParent,
            PLayerChild* _layerChild,
            const ThebesBuffer& _newFrontBuffer,
            const nsIntRegion& _updatedRegion)
    {
        Init();
        Assign(_layerParent, _layerChild, _newFrontBuffer, _updatedRegion);
    }

    OpPaintThebesBuffer(const OpPaintThebesBuffer& _o)
    {
        Init();
        Assign(const_cast<PLayerParent*>((_o).layerParent()), const_cast<PLayerChild*>((_o).layerChild()), (_o).newFrontBuffer(), (_o).updatedRegion());
    }

    ~OpPaintThebesBuffer();

    void
    operator=(const OpPaintThebesBuffer& _o)
    {
        Assign(const_cast<PLayerParent*>((_o).layerParent()), const_cast<PLayerChild*>((_o).layerChild()), (_o).newFrontBuffer(), (_o).updatedRegion());
    }

    bool
    operator==(const OpPaintThebesBuffer& _o) const;

    PLayerParent*&
    layerParent()
    {
        return layerParent_;
    }
    PLayerParent*
    layerParent() const
    {
        return layerParent_;
    }

    PLayerChild*&
    layerChild()
    {
        return layerChild_;
    }
    PLayerChild*
    layerChild() const
    {
        return layerChild_;
    }

    ThebesBuffer&
    newFrontBuffer()
    {
        return newFrontBuffer_;
    }
    const ThebesBuffer&
    newFrontBuffer() const
    {
        return newFrontBuffer_;
    }

    nsIntRegion&
    updatedRegion()
    {
        return updatedRegion_;
    }
    const nsIntRegion&
    updatedRegion() const
    {
        return updatedRegion_;
    }

private:
    void
    Init();

    void
    Assign(
            PLayerParent* _layerParent,
            PLayerChild* _layerChild,
            const ThebesBuffer& _newFrontBuffer,
            const nsIntRegion& _updatedRegion);

    PLayerParent* layerParent_;
    PLayerChild* layerChild_;
    ThebesBuffer newFrontBuffer_;
    nsIntRegion updatedRegion_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace layers {
class PLayerParent;
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace layers {
class PLayerChild;
} // namespace layers
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct OpPaintTiledLayerBuffer|
//
namespace mozilla {
namespace layers {
class OpPaintTiledLayerBuffer MOZ_FINAL
{
private:
    typedef mozilla::layers::PLayerParent PLayerParent;
    typedef mozilla::layers::PLayerChild PLayerChild;

public:
    OpPaintTiledLayerBuffer();

    OpPaintTiledLayerBuffer(
            PLayerParent* _layerParent,
            PLayerChild* _layerChild,
            const uintptr_t& _tiledLayerBuffer)
    {
        Init();
        Assign(_layerParent, _layerChild, _tiledLayerBuffer);
    }

    OpPaintTiledLayerBuffer(const OpPaintTiledLayerBuffer& _o)
    {
        Init();
        Assign(const_cast<PLayerParent*>((_o).layerParent()), const_cast<PLayerChild*>((_o).layerChild()), (_o).tiledLayerBuffer());
    }

    ~OpPaintTiledLayerBuffer();

    void
    operator=(const OpPaintTiledLayerBuffer& _o)
    {
        Assign(const_cast<PLayerParent*>((_o).layerParent()), const_cast<PLayerChild*>((_o).layerChild()), (_o).tiledLayerBuffer());
    }

    bool
    operator==(const OpPaintTiledLayerBuffer& _o) const;

    PLayerParent*&
    layerParent()
    {
        return layerParent_;
    }
    PLayerParent*
    layerParent() const
    {
        return layerParent_;
    }

    PLayerChild*&
    layerChild()
    {
        return layerChild_;
    }
    PLayerChild*
    layerChild() const
    {
        return layerChild_;
    }

    uintptr_t&
    tiledLayerBuffer()
    {
        return tiledLayerBuffer_;
    }
    const uintptr_t&
    tiledLayerBuffer() const
    {
        return tiledLayerBuffer_;
    }

private:
    void
    Init();

    void
    Assign(
            PLayerParent* _layerParent,
            PLayerChild* _layerChild,
            const uintptr_t& _tiledLayerBuffer);

    PLayerParent* layerParent_;
    PLayerChild* layerChild_;
    uintptr_t tiledLayerBuffer_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace layers {
class PLayerParent;
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace layers {
class PLayerChild;
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace layers {
class CanvasSurface;
} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct OpPaintCanvas|
//
namespace mozilla {
namespace layers {
class OpPaintCanvas MOZ_FINAL
{
private:
    typedef mozilla::layers::PLayerParent PLayerParent;
    typedef mozilla::layers::PLayerChild PLayerChild;
    typedef mozilla::layers::CanvasSurface CanvasSurface;

public:
    OpPaintCanvas();

    OpPaintCanvas(
            PLayerParent* _layerParent,
            PLayerChild* _layerChild,
            const CanvasSurface& _newFrontBuffer,
            const bool& _needYFlip)
    {
        Init();
        Assign(_layerParent, _layerChild, _newFrontBuffer, _needYFlip);
    }

    OpPaintCanvas(const OpPaintCanvas& _o)
    {
        Init();
        Assign(const_cast<PLayerParent*>((_o).layerParent()), const_cast<PLayerChild*>((_o).layerChild()), (_o).newFrontBuffer(), (_o).needYFlip());
    }

    ~OpPaintCanvas();

    void
    operator=(const OpPaintCanvas& _o)
    {
        Assign(const_cast<PLayerParent*>((_o).layerParent()), const_cast<PLayerChild*>((_o).layerChild()), (_o).newFrontBuffer(), (_o).needYFlip());
    }

    bool
    operator==(const OpPaintCanvas& _o) const;

    PLayerParent*&
    layerParent()
    {
        return layerParent_;
    }
    PLayerParent*
    layerParent() const
    {
        return layerParent_;
    }

    PLayerChild*&
    layerChild()
    {
        return layerChild_;
    }
    PLayerChild*
    layerChild() const
    {
        return layerChild_;
    }

    CanvasSurface&
    newFrontBuffer()
    {
        return newFrontBuffer_;
    }
    const CanvasSurface&
    newFrontBuffer() const
    {
        return newFrontBuffer_;
    }

    bool&
    needYFlip()
    {
        return needYFlip_;
    }
    const bool&
    needYFlip() const
    {
        return needYFlip_;
    }

private:
    void
    Init();

    void
    Assign(
            PLayerParent* _layerParent,
            PLayerChild* _layerChild,
            const CanvasSurface& _newFrontBuffer,
            const bool& _needYFlip);

    PLayerParent* layerParent_;
    PLayerChild* layerChild_;
    CanvasSurface newFrontBuffer_;
    bool needYFlip_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace layers {
class PLayerParent;
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace layers {
class PLayerChild;
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace layers {
class SharedImage;
} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct OpPaintImage|
//
namespace mozilla {
namespace layers {
class OpPaintImage MOZ_FINAL
{
private:
    typedef mozilla::layers::PLayerParent PLayerParent;
    typedef mozilla::layers::PLayerChild PLayerChild;
    typedef mozilla::layers::SharedImage SharedImage;

public:
    OpPaintImage();

    OpPaintImage(
            PLayerParent* _layerParent,
            PLayerChild* _layerChild,
            const SharedImage& _newFrontBuffer)
    {
        Init();
        Assign(_layerParent, _layerChild, _newFrontBuffer);
    }

    OpPaintImage(const OpPaintImage& _o)
    {
        Init();
        Assign(const_cast<PLayerParent*>((_o).layerParent()), const_cast<PLayerChild*>((_o).layerChild()), (_o).newFrontBuffer());
    }

    ~OpPaintImage();

    void
    operator=(const OpPaintImage& _o)
    {
        Assign(const_cast<PLayerParent*>((_o).layerParent()), const_cast<PLayerChild*>((_o).layerChild()), (_o).newFrontBuffer());
    }

    bool
    operator==(const OpPaintImage& _o) const;

    PLayerParent*&
    layerParent()
    {
        return layerParent_;
    }
    PLayerParent*
    layerParent() const
    {
        return layerParent_;
    }

    PLayerChild*&
    layerChild()
    {
        return layerChild_;
    }
    PLayerChild*
    layerChild() const
    {
        return layerChild_;
    }

    SharedImage&
    newFrontBuffer()
    {
        return newFrontBuffer_;
    }
    const SharedImage&
    newFrontBuffer() const
    {
        return newFrontBuffer_;
    }

private:
    void
    Init();

    void
    Assign(
            PLayerParent* _layerParent,
            PLayerChild* _layerChild,
            const SharedImage& _newFrontBuffer);

    PLayerParent* layerParent_;
    PLayerChild* layerChild_;
    SharedImage newFrontBuffer_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace layers {
class OpCreateThebesLayer;
} // namespace layers
} // namespace mozilla
namespace mozilla {
namespace layers {
class OpCreateContainerLayer;
} // namespace layers
} // namespace mozilla
namespace mozilla {
namespace layers {
class OpCreateImageLayer;
} // namespace layers
} // namespace mozilla
namespace mozilla {
namespace layers {
class OpCreateColorLayer;
} // namespace layers
} // namespace mozilla
namespace mozilla {
namespace layers {
class OpCreateCanvasLayer;
} // namespace layers
} // namespace mozilla
namespace mozilla {
namespace layers {
class OpCreateRefLayer;
} // namespace layers
} // namespace mozilla
namespace mozilla {
namespace layers {
class OpSetLayerAttributes;
} // namespace layers
} // namespace mozilla
namespace mozilla {
namespace layers {
class OpSetRoot;
} // namespace layers
} // namespace mozilla
namespace mozilla {
namespace layers {
class OpInsertAfter;
} // namespace layers
} // namespace mozilla
namespace mozilla {
namespace layers {
class OpAppendChild;
} // namespace layers
} // namespace mozilla
namespace mozilla {
namespace layers {
class OpRemoveChild;
} // namespace layers
} // namespace mozilla
namespace mozilla {
namespace layers {
class OpRepositionChild;
} // namespace layers
} // namespace mozilla
namespace mozilla {
namespace layers {
class OpRaiseToTopChild;
} // namespace layers
} // namespace mozilla
namespace mozilla {
namespace layers {
class OpPaintThebesBuffer;
} // namespace layers
} // namespace mozilla
namespace mozilla {
namespace layers {
class OpPaintTiledLayerBuffer;
} // namespace layers
} // namespace mozilla
namespace mozilla {
namespace layers {
class OpPaintCanvas;
} // namespace layers
} // namespace mozilla
namespace mozilla {
namespace layers {
class OpPaintImage;
} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union Edit|
//
namespace mozilla {
namespace layers {
class Edit MOZ_FINAL
{
public:
    enum Type {
        T__None,
        TOpCreateThebesLayer = 1,
        TOpCreateContainerLayer,
        TOpCreateImageLayer,
        TOpCreateColorLayer,
        TOpCreateCanvasLayer,
        TOpCreateRefLayer,
        TOpSetLayerAttributes,
        TOpSetRoot,
        TOpInsertAfter,
        TOpAppendChild,
        TOpRemoveChild,
        TOpRepositionChild,
        TOpRaiseToTopChild,
        TOpPaintThebesBuffer,
        TOpPaintTiledLayerBuffer,
        TOpPaintCanvas,
        TOpPaintImage,
        T__Last = TOpPaintImage
    };

private:
    typedef mozilla::layers::OpCreateThebesLayer OpCreateThebesLayer;
    typedef mozilla::layers::OpCreateContainerLayer OpCreateContainerLayer;
    typedef mozilla::layers::OpCreateImageLayer OpCreateImageLayer;
    typedef mozilla::layers::OpCreateColorLayer OpCreateColorLayer;
    typedef mozilla::layers::OpCreateCanvasLayer OpCreateCanvasLayer;
    typedef mozilla::layers::OpCreateRefLayer OpCreateRefLayer;
    typedef mozilla::layers::OpSetLayerAttributes OpSetLayerAttributes;
    typedef mozilla::layers::OpSetRoot OpSetRoot;
    typedef mozilla::layers::OpInsertAfter OpInsertAfter;
    typedef mozilla::layers::OpAppendChild OpAppendChild;
    typedef mozilla::layers::OpRemoveChild OpRemoveChild;
    typedef mozilla::layers::OpRepositionChild OpRepositionChild;
    typedef mozilla::layers::OpRaiseToTopChild OpRaiseToTopChild;
    typedef mozilla::layers::OpPaintThebesBuffer OpPaintThebesBuffer;
    typedef mozilla::layers::OpPaintTiledLayerBuffer OpPaintTiledLayerBuffer;
    typedef mozilla::layers::OpPaintCanvas OpPaintCanvas;
    typedef mozilla::layers::OpPaintImage OpPaintImage;
    typedef OpCreateThebesLayer OpCreateThebesLayer__tdef;
    typedef OpCreateContainerLayer OpCreateContainerLayer__tdef;
    typedef OpCreateImageLayer OpCreateImageLayer__tdef;
    typedef OpCreateColorLayer OpCreateColorLayer__tdef;
    typedef OpCreateCanvasLayer OpCreateCanvasLayer__tdef;
    typedef OpCreateRefLayer OpCreateRefLayer__tdef;
    typedef OpSetLayerAttributes OpSetLayerAttributes__tdef;
    typedef OpSetRoot OpSetRoot__tdef;
    typedef OpInsertAfter OpInsertAfter__tdef;
    typedef OpAppendChild OpAppendChild__tdef;
    typedef OpRemoveChild OpRemoveChild__tdef;
    typedef OpRepositionChild OpRepositionChild__tdef;
    typedef OpRaiseToTopChild OpRaiseToTopChild__tdef;
    typedef OpPaintThebesBuffer OpPaintThebesBuffer__tdef;
    typedef OpPaintTiledLayerBuffer OpPaintTiledLayerBuffer__tdef;
    typedef OpPaintCanvas OpPaintCanvas__tdef;
    typedef OpPaintImage OpPaintImage__tdef;

    union Value {
        char VOpCreateThebesLayer[sizeof(OpCreateThebesLayer)];
        char VOpCreateContainerLayer[sizeof(OpCreateContainerLayer)];
        char VOpCreateImageLayer[sizeof(OpCreateImageLayer)];
        char VOpCreateColorLayer[sizeof(OpCreateColorLayer)];
        char VOpCreateCanvasLayer[sizeof(OpCreateCanvasLayer)];
        char VOpCreateRefLayer[sizeof(OpCreateRefLayer)];
        char VOpSetLayerAttributes[sizeof(OpSetLayerAttributes)];
        char VOpSetRoot[sizeof(OpSetRoot)];
        char VOpInsertAfter[sizeof(OpInsertAfter)];
        char VOpAppendChild[sizeof(OpAppendChild)];
        char VOpRemoveChild[sizeof(OpRemoveChild)];
        char VOpRepositionChild[sizeof(OpRepositionChild)];
        char VOpRaiseToTopChild[sizeof(OpRaiseToTopChild)];
        char VOpPaintThebesBuffer[sizeof(OpPaintThebesBuffer)];
        char VOpPaintTiledLayerBuffer[sizeof(OpPaintTiledLayerBuffer)];
        char VOpPaintCanvas[sizeof(OpPaintCanvas)];
        char VOpPaintImage[sizeof(OpPaintImage)];
    };

    OpCreateThebesLayer*
    ptr_OpCreateThebesLayer()
    {
        return reinterpret_cast<OpCreateThebesLayer*>((&((mValue).VOpCreateThebesLayer)));
    }
    const OpCreateThebesLayer* const
    constptr_OpCreateThebesLayer() const
    {
        return reinterpret_cast<const OpCreateThebesLayer* const>((&((mValue).VOpCreateThebesLayer)));
    }
    OpCreateContainerLayer*
    ptr_OpCreateContainerLayer()
    {
        return reinterpret_cast<OpCreateContainerLayer*>((&((mValue).VOpCreateContainerLayer)));
    }
    const OpCreateContainerLayer* const
    constptr_OpCreateContainerLayer() const
    {
        return reinterpret_cast<const OpCreateContainerLayer* const>((&((mValue).VOpCreateContainerLayer)));
    }
    OpCreateImageLayer*
    ptr_OpCreateImageLayer()
    {
        return reinterpret_cast<OpCreateImageLayer*>((&((mValue).VOpCreateImageLayer)));
    }
    const OpCreateImageLayer* const
    constptr_OpCreateImageLayer() const
    {
        return reinterpret_cast<const OpCreateImageLayer* const>((&((mValue).VOpCreateImageLayer)));
    }
    OpCreateColorLayer*
    ptr_OpCreateColorLayer()
    {
        return reinterpret_cast<OpCreateColorLayer*>((&((mValue).VOpCreateColorLayer)));
    }
    const OpCreateColorLayer* const
    constptr_OpCreateColorLayer() const
    {
        return reinterpret_cast<const OpCreateColorLayer* const>((&((mValue).VOpCreateColorLayer)));
    }
    OpCreateCanvasLayer*
    ptr_OpCreateCanvasLayer()
    {
        return reinterpret_cast<OpCreateCanvasLayer*>((&((mValue).VOpCreateCanvasLayer)));
    }
    const OpCreateCanvasLayer* const
    constptr_OpCreateCanvasLayer() const
    {
        return reinterpret_cast<const OpCreateCanvasLayer* const>((&((mValue).VOpCreateCanvasLayer)));
    }
    OpCreateRefLayer*
    ptr_OpCreateRefLayer()
    {
        return reinterpret_cast<OpCreateRefLayer*>((&((mValue).VOpCreateRefLayer)));
    }
    const OpCreateRefLayer* const
    constptr_OpCreateRefLayer() const
    {
        return reinterpret_cast<const OpCreateRefLayer* const>((&((mValue).VOpCreateRefLayer)));
    }
    OpSetLayerAttributes*
    ptr_OpSetLayerAttributes()
    {
        return reinterpret_cast<OpSetLayerAttributes*>((&((mValue).VOpSetLayerAttributes)));
    }
    const OpSetLayerAttributes* const
    constptr_OpSetLayerAttributes() const
    {
        return reinterpret_cast<const OpSetLayerAttributes* const>((&((mValue).VOpSetLayerAttributes)));
    }
    OpSetRoot*
    ptr_OpSetRoot()
    {
        return reinterpret_cast<OpSetRoot*>((&((mValue).VOpSetRoot)));
    }
    const OpSetRoot* const
    constptr_OpSetRoot() const
    {
        return reinterpret_cast<const OpSetRoot* const>((&((mValue).VOpSetRoot)));
    }
    OpInsertAfter*
    ptr_OpInsertAfter()
    {
        return reinterpret_cast<OpInsertAfter*>((&((mValue).VOpInsertAfter)));
    }
    const OpInsertAfter* const
    constptr_OpInsertAfter() const
    {
        return reinterpret_cast<const OpInsertAfter* const>((&((mValue).VOpInsertAfter)));
    }
    OpAppendChild*
    ptr_OpAppendChild()
    {
        return reinterpret_cast<OpAppendChild*>((&((mValue).VOpAppendChild)));
    }
    const OpAppendChild* const
    constptr_OpAppendChild() const
    {
        return reinterpret_cast<const OpAppendChild* const>((&((mValue).VOpAppendChild)));
    }
    OpRemoveChild*
    ptr_OpRemoveChild()
    {
        return reinterpret_cast<OpRemoveChild*>((&((mValue).VOpRemoveChild)));
    }
    const OpRemoveChild* const
    constptr_OpRemoveChild() const
    {
        return reinterpret_cast<const OpRemoveChild* const>((&((mValue).VOpRemoveChild)));
    }
    OpRepositionChild*
    ptr_OpRepositionChild()
    {
        return reinterpret_cast<OpRepositionChild*>((&((mValue).VOpRepositionChild)));
    }
    const OpRepositionChild* const
    constptr_OpRepositionChild() const
    {
        return reinterpret_cast<const OpRepositionChild* const>((&((mValue).VOpRepositionChild)));
    }
    OpRaiseToTopChild*
    ptr_OpRaiseToTopChild()
    {
        return reinterpret_cast<OpRaiseToTopChild*>((&((mValue).VOpRaiseToTopChild)));
    }
    const OpRaiseToTopChild* const
    constptr_OpRaiseToTopChild() const
    {
        return reinterpret_cast<const OpRaiseToTopChild* const>((&((mValue).VOpRaiseToTopChild)));
    }
    OpPaintThebesBuffer*
    ptr_OpPaintThebesBuffer()
    {
        return reinterpret_cast<OpPaintThebesBuffer*>((&((mValue).VOpPaintThebesBuffer)));
    }
    const OpPaintThebesBuffer* const
    constptr_OpPaintThebesBuffer() const
    {
        return reinterpret_cast<const OpPaintThebesBuffer* const>((&((mValue).VOpPaintThebesBuffer)));
    }
    OpPaintTiledLayerBuffer*
    ptr_OpPaintTiledLayerBuffer()
    {
        return reinterpret_cast<OpPaintTiledLayerBuffer*>((&((mValue).VOpPaintTiledLayerBuffer)));
    }
    const OpPaintTiledLayerBuffer* const
    constptr_OpPaintTiledLayerBuffer() const
    {
        return reinterpret_cast<const OpPaintTiledLayerBuffer* const>((&((mValue).VOpPaintTiledLayerBuffer)));
    }
    OpPaintCanvas*
    ptr_OpPaintCanvas()
    {
        return reinterpret_cast<OpPaintCanvas*>((&((mValue).VOpPaintCanvas)));
    }
    const OpPaintCanvas* const
    constptr_OpPaintCanvas() const
    {
        return reinterpret_cast<const OpPaintCanvas* const>((&((mValue).VOpPaintCanvas)));
    }
    OpPaintImage*
    ptr_OpPaintImage()
    {
        return reinterpret_cast<OpPaintImage*>((&((mValue).VOpPaintImage)));
    }
    const OpPaintImage* const
    constptr_OpPaintImage() const
    {
        return reinterpret_cast<const OpPaintImage* const>((&((mValue).VOpPaintImage)));
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        NS_ABORT_IF_FALSE((T__None) <= (mType), "invalid type tag");
        NS_ABORT_IF_FALSE((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        NS_ABORT_IF_FALSE((mType) == (aType), "unexpected type tag");
    }

public:
    Edit() :
        mType(T__None)
    {
    }

    Edit(const OpCreateThebesLayer& aOther);

    Edit(const OpCreateContainerLayer& aOther);

    Edit(const OpCreateImageLayer& aOther);

    Edit(const OpCreateColorLayer& aOther);

    Edit(const OpCreateCanvasLayer& aOther);

    Edit(const OpCreateRefLayer& aOther);

    Edit(const OpSetLayerAttributes& aOther);

    Edit(const OpSetRoot& aOther);

    Edit(const OpInsertAfter& aOther);

    Edit(const OpAppendChild& aOther);

    Edit(const OpRemoveChild& aOther);

    Edit(const OpRepositionChild& aOther);

    Edit(const OpRaiseToTopChild& aOther);

    Edit(const OpPaintThebesBuffer& aOther);

    Edit(const OpPaintTiledLayerBuffer& aOther);

    Edit(const OpPaintCanvas& aOther);

    Edit(const OpPaintImage& aOther);

    Edit(const Edit& aOther);

    ~Edit();

    Type
    type() const
    {
        return mType;
    }

    Edit&
    operator=(const OpCreateThebesLayer& aRhs);

    Edit&
    operator=(const OpCreateContainerLayer& aRhs);

    Edit&
    operator=(const OpCreateImageLayer& aRhs);

    Edit&
    operator=(const OpCreateColorLayer& aRhs);

    Edit&
    operator=(const OpCreateCanvasLayer& aRhs);

    Edit&
    operator=(const OpCreateRefLayer& aRhs);

    Edit&
    operator=(const OpSetLayerAttributes& aRhs);

    Edit&
    operator=(const OpSetRoot& aRhs);

    Edit&
    operator=(const OpInsertAfter& aRhs);

    Edit&
    operator=(const OpAppendChild& aRhs);

    Edit&
    operator=(const OpRemoveChild& aRhs);

    Edit&
    operator=(const OpRepositionChild& aRhs);

    Edit&
    operator=(const OpRaiseToTopChild& aRhs);

    Edit&
    operator=(const OpPaintThebesBuffer& aRhs);

    Edit&
    operator=(const OpPaintTiledLayerBuffer& aRhs);

    Edit&
    operator=(const OpPaintCanvas& aRhs);

    Edit&
    operator=(const OpPaintImage& aRhs);

    Edit&
    operator=(const Edit& aRhs);

    bool
    operator==(const OpCreateThebesLayer& aRhs) const;

    bool
    operator==(const OpCreateContainerLayer& aRhs) const;

    bool
    operator==(const OpCreateImageLayer& aRhs) const;

    bool
    operator==(const OpCreateColorLayer& aRhs) const;

    bool
    operator==(const OpCreateCanvasLayer& aRhs) const;

    bool
    operator==(const OpCreateRefLayer& aRhs) const;

    bool
    operator==(const OpSetLayerAttributes& aRhs) const;

    bool
    operator==(const OpSetRoot& aRhs) const;

    bool
    operator==(const OpInsertAfter& aRhs) const;

    bool
    operator==(const OpAppendChild& aRhs) const;

    bool
    operator==(const OpRemoveChild& aRhs) const;

    bool
    operator==(const OpRepositionChild& aRhs) const;

    bool
    operator==(const OpRaiseToTopChild& aRhs) const;

    bool
    operator==(const OpPaintThebesBuffer& aRhs) const;

    bool
    operator==(const OpPaintTiledLayerBuffer& aRhs) const;

    bool
    operator==(const OpPaintCanvas& aRhs) const;

    bool
    operator==(const OpPaintImage& aRhs) const;

    bool
    operator==(const Edit& aRhs) const;

    OpCreateThebesLayer&
    get_OpCreateThebesLayer()
    {
        AssertSanity(TOpCreateThebesLayer);
        return (*(ptr_OpCreateThebesLayer()));
    }
    const OpCreateThebesLayer&
    get_OpCreateThebesLayer() const
    {
        AssertSanity(TOpCreateThebesLayer);
        return (*(constptr_OpCreateThebesLayer()));
    }
    operator OpCreateThebesLayer&()
    {
        return get_OpCreateThebesLayer();
    }
    operator const OpCreateThebesLayer&() const
    {
        return get_OpCreateThebesLayer();
    }

    OpCreateContainerLayer&
    get_OpCreateContainerLayer()
    {
        AssertSanity(TOpCreateContainerLayer);
        return (*(ptr_OpCreateContainerLayer()));
    }
    const OpCreateContainerLayer&
    get_OpCreateContainerLayer() const
    {
        AssertSanity(TOpCreateContainerLayer);
        return (*(constptr_OpCreateContainerLayer()));
    }
    operator OpCreateContainerLayer&()
    {
        return get_OpCreateContainerLayer();
    }
    operator const OpCreateContainerLayer&() const
    {
        return get_OpCreateContainerLayer();
    }

    OpCreateImageLayer&
    get_OpCreateImageLayer()
    {
        AssertSanity(TOpCreateImageLayer);
        return (*(ptr_OpCreateImageLayer()));
    }
    const OpCreateImageLayer&
    get_OpCreateImageLayer() const
    {
        AssertSanity(TOpCreateImageLayer);
        return (*(constptr_OpCreateImageLayer()));
    }
    operator OpCreateImageLayer&()
    {
        return get_OpCreateImageLayer();
    }
    operator const OpCreateImageLayer&() const
    {
        return get_OpCreateImageLayer();
    }

    OpCreateColorLayer&
    get_OpCreateColorLayer()
    {
        AssertSanity(TOpCreateColorLayer);
        return (*(ptr_OpCreateColorLayer()));
    }
    const OpCreateColorLayer&
    get_OpCreateColorLayer() const
    {
        AssertSanity(TOpCreateColorLayer);
        return (*(constptr_OpCreateColorLayer()));
    }
    operator OpCreateColorLayer&()
    {
        return get_OpCreateColorLayer();
    }
    operator const OpCreateColorLayer&() const
    {
        return get_OpCreateColorLayer();
    }

    OpCreateCanvasLayer&
    get_OpCreateCanvasLayer()
    {
        AssertSanity(TOpCreateCanvasLayer);
        return (*(ptr_OpCreateCanvasLayer()));
    }
    const OpCreateCanvasLayer&
    get_OpCreateCanvasLayer() const
    {
        AssertSanity(TOpCreateCanvasLayer);
        return (*(constptr_OpCreateCanvasLayer()));
    }
    operator OpCreateCanvasLayer&()
    {
        return get_OpCreateCanvasLayer();
    }
    operator const OpCreateCanvasLayer&() const
    {
        return get_OpCreateCanvasLayer();
    }

    OpCreateRefLayer&
    get_OpCreateRefLayer()
    {
        AssertSanity(TOpCreateRefLayer);
        return (*(ptr_OpCreateRefLayer()));
    }
    const OpCreateRefLayer&
    get_OpCreateRefLayer() const
    {
        AssertSanity(TOpCreateRefLayer);
        return (*(constptr_OpCreateRefLayer()));
    }
    operator OpCreateRefLayer&()
    {
        return get_OpCreateRefLayer();
    }
    operator const OpCreateRefLayer&() const
    {
        return get_OpCreateRefLayer();
    }

    OpSetLayerAttributes&
    get_OpSetLayerAttributes()
    {
        AssertSanity(TOpSetLayerAttributes);
        return (*(ptr_OpSetLayerAttributes()));
    }
    const OpSetLayerAttributes&
    get_OpSetLayerAttributes() const
    {
        AssertSanity(TOpSetLayerAttributes);
        return (*(constptr_OpSetLayerAttributes()));
    }
    operator OpSetLayerAttributes&()
    {
        return get_OpSetLayerAttributes();
    }
    operator const OpSetLayerAttributes&() const
    {
        return get_OpSetLayerAttributes();
    }

    OpSetRoot&
    get_OpSetRoot()
    {
        AssertSanity(TOpSetRoot);
        return (*(ptr_OpSetRoot()));
    }
    const OpSetRoot&
    get_OpSetRoot() const
    {
        AssertSanity(TOpSetRoot);
        return (*(constptr_OpSetRoot()));
    }
    operator OpSetRoot&()
    {
        return get_OpSetRoot();
    }
    operator const OpSetRoot&() const
    {
        return get_OpSetRoot();
    }

    OpInsertAfter&
    get_OpInsertAfter()
    {
        AssertSanity(TOpInsertAfter);
        return (*(ptr_OpInsertAfter()));
    }
    const OpInsertAfter&
    get_OpInsertAfter() const
    {
        AssertSanity(TOpInsertAfter);
        return (*(constptr_OpInsertAfter()));
    }
    operator OpInsertAfter&()
    {
        return get_OpInsertAfter();
    }
    operator const OpInsertAfter&() const
    {
        return get_OpInsertAfter();
    }

    OpAppendChild&
    get_OpAppendChild()
    {
        AssertSanity(TOpAppendChild);
        return (*(ptr_OpAppendChild()));
    }
    const OpAppendChild&
    get_OpAppendChild() const
    {
        AssertSanity(TOpAppendChild);
        return (*(constptr_OpAppendChild()));
    }
    operator OpAppendChild&()
    {
        return get_OpAppendChild();
    }
    operator const OpAppendChild&() const
    {
        return get_OpAppendChild();
    }

    OpRemoveChild&
    get_OpRemoveChild()
    {
        AssertSanity(TOpRemoveChild);
        return (*(ptr_OpRemoveChild()));
    }
    const OpRemoveChild&
    get_OpRemoveChild() const
    {
        AssertSanity(TOpRemoveChild);
        return (*(constptr_OpRemoveChild()));
    }
    operator OpRemoveChild&()
    {
        return get_OpRemoveChild();
    }
    operator const OpRemoveChild&() const
    {
        return get_OpRemoveChild();
    }

    OpRepositionChild&
    get_OpRepositionChild()
    {
        AssertSanity(TOpRepositionChild);
        return (*(ptr_OpRepositionChild()));
    }
    const OpRepositionChild&
    get_OpRepositionChild() const
    {
        AssertSanity(TOpRepositionChild);
        return (*(constptr_OpRepositionChild()));
    }
    operator OpRepositionChild&()
    {
        return get_OpRepositionChild();
    }
    operator const OpRepositionChild&() const
    {
        return get_OpRepositionChild();
    }

    OpRaiseToTopChild&
    get_OpRaiseToTopChild()
    {
        AssertSanity(TOpRaiseToTopChild);
        return (*(ptr_OpRaiseToTopChild()));
    }
    const OpRaiseToTopChild&
    get_OpRaiseToTopChild() const
    {
        AssertSanity(TOpRaiseToTopChild);
        return (*(constptr_OpRaiseToTopChild()));
    }
    operator OpRaiseToTopChild&()
    {
        return get_OpRaiseToTopChild();
    }
    operator const OpRaiseToTopChild&() const
    {
        return get_OpRaiseToTopChild();
    }

    OpPaintThebesBuffer&
    get_OpPaintThebesBuffer()
    {
        AssertSanity(TOpPaintThebesBuffer);
        return (*(ptr_OpPaintThebesBuffer()));
    }
    const OpPaintThebesBuffer&
    get_OpPaintThebesBuffer() const
    {
        AssertSanity(TOpPaintThebesBuffer);
        return (*(constptr_OpPaintThebesBuffer()));
    }
    operator OpPaintThebesBuffer&()
    {
        return get_OpPaintThebesBuffer();
    }
    operator const OpPaintThebesBuffer&() const
    {
        return get_OpPaintThebesBuffer();
    }

    OpPaintTiledLayerBuffer&
    get_OpPaintTiledLayerBuffer()
    {
        AssertSanity(TOpPaintTiledLayerBuffer);
        return (*(ptr_OpPaintTiledLayerBuffer()));
    }
    const OpPaintTiledLayerBuffer&
    get_OpPaintTiledLayerBuffer() const
    {
        AssertSanity(TOpPaintTiledLayerBuffer);
        return (*(constptr_OpPaintTiledLayerBuffer()));
    }
    operator OpPaintTiledLayerBuffer&()
    {
        return get_OpPaintTiledLayerBuffer();
    }
    operator const OpPaintTiledLayerBuffer&() const
    {
        return get_OpPaintTiledLayerBuffer();
    }

    OpPaintCanvas&
    get_OpPaintCanvas()
    {
        AssertSanity(TOpPaintCanvas);
        return (*(ptr_OpPaintCanvas()));
    }
    const OpPaintCanvas&
    get_OpPaintCanvas() const
    {
        AssertSanity(TOpPaintCanvas);
        return (*(constptr_OpPaintCanvas()));
    }
    operator OpPaintCanvas&()
    {
        return get_OpPaintCanvas();
    }
    operator const OpPaintCanvas&() const
    {
        return get_OpPaintCanvas();
    }

    OpPaintImage&
    get_OpPaintImage()
    {
        AssertSanity(TOpPaintImage);
        return (*(ptr_OpPaintImage()));
    }
    const OpPaintImage&
    get_OpPaintImage() const
    {
        AssertSanity(TOpPaintImage);
        return (*(constptr_OpPaintImage()));
    }
    operator OpPaintImage&()
    {
        return get_OpPaintImage();
    }
    operator const OpPaintImage&() const
    {
        return get_OpPaintImage();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace layers {
class PLayerParent;
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace layers {
class PLayerChild;
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace layers {
class CanvasSurface;
} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct OpBufferSwap|
//
namespace mozilla {
namespace layers {
class OpBufferSwap MOZ_FINAL
{
private:
    typedef mozilla::layers::PLayerParent PLayerParent;
    typedef mozilla::layers::PLayerChild PLayerChild;
    typedef mozilla::layers::CanvasSurface CanvasSurface;

public:
    OpBufferSwap();

    OpBufferSwap(
            PLayerParent* _layerParent,
            PLayerChild* _layerChild,
            const CanvasSurface& _newBackBuffer)
    {
        Init();
        Assign(_layerParent, _layerChild, _newBackBuffer);
    }

    OpBufferSwap(const OpBufferSwap& _o)
    {
        Init();
        Assign(const_cast<PLayerParent*>((_o).layerParent()), const_cast<PLayerChild*>((_o).layerChild()), (_o).newBackBuffer());
    }

    ~OpBufferSwap();

    void
    operator=(const OpBufferSwap& _o)
    {
        Assign(const_cast<PLayerParent*>((_o).layerParent()), const_cast<PLayerChild*>((_o).layerChild()), (_o).newBackBuffer());
    }

    bool
    operator==(const OpBufferSwap& _o) const;

    PLayerParent*&
    layerParent()
    {
        return layerParent_;
    }
    PLayerParent*
    layerParent() const
    {
        return layerParent_;
    }

    PLayerChild*&
    layerChild()
    {
        return layerChild_;
    }
    PLayerChild*
    layerChild() const
    {
        return layerChild_;
    }

    CanvasSurface&
    newBackBuffer()
    {
        return newBackBuffer_;
    }
    const CanvasSurface&
    newBackBuffer() const
    {
        return newBackBuffer_;
    }

private:
    void
    Init();

    void
    Assign(
            PLayerParent* _layerParent,
            PLayerChild* _layerChild,
            const CanvasSurface& _newBackBuffer);

    PLayerParent* layerParent_;
    PLayerChild* layerChild_;
    CanvasSurface newBackBuffer_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace layers {
class PLayerParent;
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace layers {
class PLayerChild;
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace layers {
class SharedImage;
} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct OpImageSwap|
//
namespace mozilla {
namespace layers {
class OpImageSwap MOZ_FINAL
{
private:
    typedef mozilla::layers::PLayerParent PLayerParent;
    typedef mozilla::layers::PLayerChild PLayerChild;
    typedef mozilla::layers::SharedImage SharedImage;

public:
    OpImageSwap();

    OpImageSwap(
            PLayerParent* _layerParent,
            PLayerChild* _layerChild,
            const SharedImage& _newBackImage)
    {
        Init();
        Assign(_layerParent, _layerChild, _newBackImage);
    }

    OpImageSwap(const OpImageSwap& _o)
    {
        Init();
        Assign(const_cast<PLayerParent*>((_o).layerParent()), const_cast<PLayerChild*>((_o).layerChild()), (_o).newBackImage());
    }

    ~OpImageSwap();

    void
    operator=(const OpImageSwap& _o)
    {
        Assign(const_cast<PLayerParent*>((_o).layerParent()), const_cast<PLayerChild*>((_o).layerChild()), (_o).newBackImage());
    }

    bool
    operator==(const OpImageSwap& _o) const;

    PLayerParent*&
    layerParent()
    {
        return layerParent_;
    }
    PLayerParent*
    layerParent() const
    {
        return layerParent_;
    }

    PLayerChild*&
    layerChild()
    {
        return layerChild_;
    }
    PLayerChild*
    layerChild() const
    {
        return layerChild_;
    }

    SharedImage&
    newBackImage()
    {
        return newBackImage_;
    }
    const SharedImage&
    newBackImage() const
    {
        return newBackImage_;
    }

private:
    void
    Init();

    void
    Assign(
            PLayerParent* _layerParent,
            PLayerChild* _layerChild,
            const SharedImage& _newBackImage);

    PLayerParent* layerParent_;
    PLayerChild* layerChild_;
    SharedImage newBackImage_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace layers {
class PLayerParent;
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace layers {
class PLayerChild;
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace layers {
class OptionalThebesBuffer;
} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct OpThebesBufferSwap|
//
namespace mozilla {
namespace layers {
class OpThebesBufferSwap MOZ_FINAL
{
private:
    typedef mozilla::layers::PLayerParent PLayerParent;
    typedef mozilla::layers::PLayerChild PLayerChild;
    typedef mozilla::layers::OptionalThebesBuffer OptionalThebesBuffer;

public:
    OpThebesBufferSwap();

    OpThebesBufferSwap(
            PLayerParent* _layerParent,
            PLayerChild* _layerChild,
            const OptionalThebesBuffer& _newBackBuffer,
            const nsIntRegion& _newValidRegion,
            const OptionalThebesBuffer& _readOnlyFrontBuffer,
            const nsIntRegion& _frontUpdatedRegion)
    {
        Init();
        Assign(_layerParent, _layerChild, _newBackBuffer, _newValidRegion, _readOnlyFrontBuffer, _frontUpdatedRegion);
    }

    OpThebesBufferSwap(const OpThebesBufferSwap& _o)
    {
        Init();
        Assign(const_cast<PLayerParent*>((_o).layerParent()), const_cast<PLayerChild*>((_o).layerChild()), (_o).newBackBuffer(), (_o).newValidRegion(), (_o).readOnlyFrontBuffer(), (_o).frontUpdatedRegion());
    }

    ~OpThebesBufferSwap();

    void
    operator=(const OpThebesBufferSwap& _o)
    {
        Assign(const_cast<PLayerParent*>((_o).layerParent()), const_cast<PLayerChild*>((_o).layerChild()), (_o).newBackBuffer(), (_o).newValidRegion(), (_o).readOnlyFrontBuffer(), (_o).frontUpdatedRegion());
    }

    bool
    operator==(const OpThebesBufferSwap& _o) const;

    PLayerParent*&
    layerParent()
    {
        return layerParent_;
    }
    PLayerParent*
    layerParent() const
    {
        return layerParent_;
    }

    PLayerChild*&
    layerChild()
    {
        return layerChild_;
    }
    PLayerChild*
    layerChild() const
    {
        return layerChild_;
    }

    OptionalThebesBuffer&
    newBackBuffer()
    {
        return newBackBuffer_;
    }
    const OptionalThebesBuffer&
    newBackBuffer() const
    {
        return newBackBuffer_;
    }

    nsIntRegion&
    newValidRegion()
    {
        return newValidRegion_;
    }
    const nsIntRegion&
    newValidRegion() const
    {
        return newValidRegion_;
    }

    OptionalThebesBuffer&
    readOnlyFrontBuffer()
    {
        return readOnlyFrontBuffer_;
    }
    const OptionalThebesBuffer&
    readOnlyFrontBuffer() const
    {
        return readOnlyFrontBuffer_;
    }

    nsIntRegion&
    frontUpdatedRegion()
    {
        return frontUpdatedRegion_;
    }
    const nsIntRegion&
    frontUpdatedRegion() const
    {
        return frontUpdatedRegion_;
    }

private:
    void
    Init();

    void
    Assign(
            PLayerParent* _layerParent,
            PLayerChild* _layerChild,
            const OptionalThebesBuffer& _newBackBuffer,
            const nsIntRegion& _newValidRegion,
            const OptionalThebesBuffer& _readOnlyFrontBuffer,
            const nsIntRegion& _frontUpdatedRegion);

    PLayerParent* layerParent_;
    PLayerChild* layerChild_;
    OptionalThebesBuffer newBackBuffer_;
    nsIntRegion newValidRegion_;
    OptionalThebesBuffer readOnlyFrontBuffer_;
    nsIntRegion frontUpdatedRegion_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace layers {
class OpBufferSwap;
} // namespace layers
} // namespace mozilla
namespace mozilla {
namespace layers {
class OpThebesBufferSwap;
} // namespace layers
} // namespace mozilla
namespace mozilla {
namespace layers {
class OpImageSwap;
} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union EditReply|
//
namespace mozilla {
namespace layers {
class EditReply MOZ_FINAL
{
public:
    enum Type {
        T__None,
        TOpBufferSwap = 1,
        TOpThebesBufferSwap,
        TOpImageSwap,
        T__Last = TOpImageSwap
    };

private:
    typedef mozilla::layers::OpBufferSwap OpBufferSwap;
    typedef mozilla::layers::OpThebesBufferSwap OpThebesBufferSwap;
    typedef mozilla::layers::OpImageSwap OpImageSwap;
    typedef OpBufferSwap OpBufferSwap__tdef;
    typedef OpThebesBufferSwap OpThebesBufferSwap__tdef;
    typedef OpImageSwap OpImageSwap__tdef;

    union Value {
        char VOpBufferSwap[sizeof(OpBufferSwap)];
        char VOpThebesBufferSwap[sizeof(OpThebesBufferSwap)];
        char VOpImageSwap[sizeof(OpImageSwap)];
    };

    OpBufferSwap*
    ptr_OpBufferSwap()
    {
        return reinterpret_cast<OpBufferSwap*>((&((mValue).VOpBufferSwap)));
    }
    const OpBufferSwap* const
    constptr_OpBufferSwap() const
    {
        return reinterpret_cast<const OpBufferSwap* const>((&((mValue).VOpBufferSwap)));
    }
    OpThebesBufferSwap*
    ptr_OpThebesBufferSwap()
    {
        return reinterpret_cast<OpThebesBufferSwap*>((&((mValue).VOpThebesBufferSwap)));
    }
    const OpThebesBufferSwap* const
    constptr_OpThebesBufferSwap() const
    {
        return reinterpret_cast<const OpThebesBufferSwap* const>((&((mValue).VOpThebesBufferSwap)));
    }
    OpImageSwap*
    ptr_OpImageSwap()
    {
        return reinterpret_cast<OpImageSwap*>((&((mValue).VOpImageSwap)));
    }
    const OpImageSwap* const
    constptr_OpImageSwap() const
    {
        return reinterpret_cast<const OpImageSwap* const>((&((mValue).VOpImageSwap)));
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        NS_ABORT_IF_FALSE((T__None) <= (mType), "invalid type tag");
        NS_ABORT_IF_FALSE((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        NS_ABORT_IF_FALSE((mType) == (aType), "unexpected type tag");
    }

public:
    EditReply() :
        mType(T__None)
    {
    }

    EditReply(const OpBufferSwap& aOther);

    EditReply(const OpThebesBufferSwap& aOther);

    EditReply(const OpImageSwap& aOther);

    EditReply(const EditReply& aOther);

    ~EditReply();

    Type
    type() const
    {
        return mType;
    }

    EditReply&
    operator=(const OpBufferSwap& aRhs);

    EditReply&
    operator=(const OpThebesBufferSwap& aRhs);

    EditReply&
    operator=(const OpImageSwap& aRhs);

    EditReply&
    operator=(const EditReply& aRhs);

    bool
    operator==(const OpBufferSwap& aRhs) const;

    bool
    operator==(const OpThebesBufferSwap& aRhs) const;

    bool
    operator==(const OpImageSwap& aRhs) const;

    bool
    operator==(const EditReply& aRhs) const;

    OpBufferSwap&
    get_OpBufferSwap()
    {
        AssertSanity(TOpBufferSwap);
        return (*(ptr_OpBufferSwap()));
    }
    const OpBufferSwap&
    get_OpBufferSwap() const
    {
        AssertSanity(TOpBufferSwap);
        return (*(constptr_OpBufferSwap()));
    }
    operator OpBufferSwap&()
    {
        return get_OpBufferSwap();
    }
    operator const OpBufferSwap&() const
    {
        return get_OpBufferSwap();
    }

    OpThebesBufferSwap&
    get_OpThebesBufferSwap()
    {
        AssertSanity(TOpThebesBufferSwap);
        return (*(ptr_OpThebesBufferSwap()));
    }
    const OpThebesBufferSwap&
    get_OpThebesBufferSwap() const
    {
        AssertSanity(TOpThebesBufferSwap);
        return (*(constptr_OpThebesBufferSwap()));
    }
    operator OpThebesBufferSwap&()
    {
        return get_OpThebesBufferSwap();
    }
    operator const OpThebesBufferSwap&() const
    {
        return get_OpThebesBufferSwap();
    }

    OpImageSwap&
    get_OpImageSwap()
    {
        AssertSanity(TOpImageSwap);
        return (*(ptr_OpImageSwap()));
    }
    const OpImageSwap&
    get_OpImageSwap() const
    {
        AssertSanity(TOpImageSwap);
        return (*(constptr_OpImageSwap()));
    }
    operator OpImageSwap&()
    {
        return get_OpImageSwap();
    }
    operator const OpImageSwap&() const
    {
        return get_OpImageSwap();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace layers
} // namespace mozilla

//-----------------------------------------------------------------------------
// Code common to PLayersChild and PLayersParent
//
namespace mozilla {
namespace layers {
namespace PLayers {

enum State {
    __Dead,
    __Null,
    __Error,
    __Dying,
    __Start = __Null
};

enum MessageType {
    PLayersStart = PLayersMsgStart << 16,
    PLayersPreStart = (PLayersMsgStart << 16) - 1,
    Msg_PGrallocBufferConstructor__ID,
    Reply_PGrallocBufferConstructor__ID,
    Msg_PLayerConstructor__ID,
    Reply_PLayerConstructor__ID,
    Msg_Update__ID,
    Reply_Update__ID,
    Msg_UpdateNoSwap__ID,
    Msg_ClearCachedResources__ID,
    Msg___delete____ID,
    Reply___delete____ID,
    PLayersEnd
};

bool
Transition(
        State from,
        mozilla::ipc::Trigger trigger,
        State* next);

class Msg_PGrallocBufferConstructor :
    public IPC::Message
{
private:
    typedef mozilla::ipc::ActorHandle ActorHandle;
    typedef mozilla::layers::Animatable Animatable;
    typedef mozilla::layers::Animation Animation;
    typedef mozilla::layers::AnimationData AnimationData;
    typedef mozilla::layers::AnimationSegment AnimationSegment;
    typedef mozilla::layers::CanvasLayerAttributes CanvasLayerAttributes;
    typedef mozilla::layers::CanvasSurface CanvasSurface;
    typedef mozilla::layers::Color Color;
    typedef mozilla::layers::ColorLayerAttributes ColorLayerAttributes;
    typedef mozilla::layers::CommonLayerAttributes CommonLayerAttributes;
    typedef mozilla::layers::ContainerLayerAttributes ContainerLayerAttributes;
    typedef mozilla::layers::CubicBezierFunction CubicBezierFunction;
    typedef mozilla::layers::Edit Edit;
    typedef mozilla::layers::EditReply EditReply;
    typedef mozilla::ipc::FileDescriptor FileDescriptor;
    typedef mozilla::layers::FrameMetrics FrameMetrics;
    typedef mozilla::GraphicsFilterType GraphicsFilterType;
    typedef mozilla::layers::ImageLayerAttributes ImageLayerAttributes;
    typedef mozilla::layers::LayerAttributes LayerAttributes;
    typedef mozilla::layers::MagicGrallocBufferHandle MagicGrallocBufferHandle;
    typedef mozilla::layers::MaybeMagicGrallocBufferHandle MaybeMagicGrallocBufferHandle;
    typedef mozilla::layers::OpAppendChild OpAppendChild;
    typedef mozilla::layers::OpBufferSwap OpBufferSwap;
    typedef mozilla::layers::OpCreateCanvasLayer OpCreateCanvasLayer;
    typedef mozilla::layers::OpCreateColorLayer OpCreateColorLayer;
    typedef mozilla::layers::OpCreateContainerLayer OpCreateContainerLayer;
    typedef mozilla::layers::OpCreateImageLayer OpCreateImageLayer;
    typedef mozilla::layers::OpCreateRefLayer OpCreateRefLayer;
    typedef mozilla::layers::OpCreateThebesLayer OpCreateThebesLayer;
    typedef mozilla::layers::OpImageSwap OpImageSwap;
    typedef mozilla::layers::OpInsertAfter OpInsertAfter;
    typedef mozilla::layers::OpPaintCanvas OpPaintCanvas;
    typedef mozilla::layers::OpPaintImage OpPaintImage;
    typedef mozilla::layers::OpPaintThebesBuffer OpPaintThebesBuffer;
    typedef mozilla::layers::OpPaintTiledLayerBuffer OpPaintTiledLayerBuffer;
    typedef mozilla::layers::OpRaiseToTopChild OpRaiseToTopChild;
    typedef mozilla::layers::OpRemoveChild OpRemoveChild;
    typedef mozilla::layers::OpRepositionChild OpRepositionChild;
    typedef mozilla::layers::OpSetLayerAttributes OpSetLayerAttributes;
    typedef mozilla::layers::OpSetRoot OpSetRoot;
    typedef mozilla::layers::OpThebesBufferSwap OpThebesBufferSwap;
    typedef mozilla::layers::OptionalThebesBuffer OptionalThebesBuffer;
    typedef mozilla::layers::Perspective Perspective;
    typedef mozilla::layers::RGBImage RGBImage;
    typedef mozilla::layers::RefLayerAttributes RefLayerAttributes;
    typedef mozilla::layers::Rotation Rotation;
    typedef mozilla::layers::Rotation3D Rotation3D;
    typedef mozilla::layers::RotationX RotationX;
    typedef mozilla::layers::RotationY RotationY;
    typedef mozilla::layers::RotationZ RotationZ;
    typedef mozilla::layers::Scale Scale;
    typedef mozilla::dom::ScreenOrientation ScreenOrientation;
    typedef mozilla::ScreenRotation ScreenRotation;
    typedef mozilla::layers::SharedImage SharedImage;
    typedef mozilla::layers::SharedImageID SharedImageID;
    typedef mozilla::layers::SharedTextureDescriptor SharedTextureDescriptor;
    typedef mozilla::gl::SharedTextureHandle SharedTextureHandle;
    typedef mozilla::gl::GLContext::SharedTextureShareType SharedTextureShareType;
    typedef mozilla::ipc::Shmem Shmem;
    typedef mozilla::layers::SkewX SkewX;
    typedef mozilla::layers::SkewY SkewY;
    typedef mozilla::layers::SpecificLayerAttributes SpecificLayerAttributes;
    typedef mozilla::layers::StepFunction StepFunction;
    typedef mozilla::layers::SurfaceDescriptor SurfaceDescriptor;
    typedef mozilla::layers::SurfaceDescriptorD3D10 SurfaceDescriptorD3D10;
    typedef mozilla::layers::SurfaceDescriptorGralloc SurfaceDescriptorGralloc;
    typedef mozilla::layers::SurfaceDescriptorX11 SurfaceDescriptorX11;
    typedef mozilla::layers::TargetConfig TargetConfig;
    typedef mozilla::layers::ThebesBuffer ThebesBuffer;
    typedef mozilla::layers::ThebesLayerAttributes ThebesLayerAttributes;
    typedef mozilla::TimeDuration TimeDuration;
    typedef mozilla::TimeStamp TimeStamp;
    typedef mozilla::layers::TimingFunction TimingFunction;
    typedef mozilla::layers::TransformData TransformData;
    typedef mozilla::layers::TransformFunction TransformFunction;
    typedef mozilla::layers::TransformMatrix TransformMatrix;
    typedef mozilla::layers::Translation Translation;
    typedef mozilla::WindowsHandle WindowsHandle;
    typedef mozilla::layers::YCbCrImage YCbCrImage;
    typedef mozilla::layers::YUVImage YUVImage;
    typedef mozilla::gfxContentType gfxContentType;
    typedef mozilla::null_t null_t;

public:
    enum {
        ID = Msg_PGrallocBufferConstructor__ID
    };
    Msg_PGrallocBufferConstructor() :
        IPC::Message(MSG_ROUTING_NONE, ID, PRIORITY_NORMAL, COMPRESSION_NONE, "PLayers::Msg_PGrallocBufferConstructor")
    {
    }

    void
    Log(
            const std::string& __pfx,
            FILE* __outf) const
    {
        std::string __logmsg;
        StringAppendF((&(__logmsg)), "[time:%" PRId64 "][%d]", PR_Now(), base::GetCurrentProcId());
        (__logmsg).append(__pfx);
        (__logmsg).append("Msg_PGrallocBufferConstructor(");

        (__logmsg).append("[TODO])\n");
        fputs((__logmsg).c_str(), __outf);
    }
};

class Reply_PGrallocBufferConstructor :
    public IPC::Message
{
private:
    typedef mozilla::ipc::ActorHandle ActorHandle;
    typedef mozilla::layers::Animatable Animatable;
    typedef mozilla::layers::Animation Animation;
    typedef mozilla::layers::AnimationData AnimationData;
    typedef mozilla::layers::AnimationSegment AnimationSegment;
    typedef mozilla::layers::CanvasLayerAttributes CanvasLayerAttributes;
    typedef mozilla::layers::CanvasSurface CanvasSurface;
    typedef mozilla::layers::Color Color;
    typedef mozilla::layers::ColorLayerAttributes ColorLayerAttributes;
    typedef mozilla::layers::CommonLayerAttributes CommonLayerAttributes;
    typedef mozilla::layers::ContainerLayerAttributes ContainerLayerAttributes;
    typedef mozilla::layers::CubicBezierFunction CubicBezierFunction;
    typedef mozilla::layers::Edit Edit;
    typedef mozilla::layers::EditReply EditReply;
    typedef mozilla::ipc::FileDescriptor FileDescriptor;
    typedef mozilla::layers::FrameMetrics FrameMetrics;
    typedef mozilla::GraphicsFilterType GraphicsFilterType;
    typedef mozilla::layers::ImageLayerAttributes ImageLayerAttributes;
    typedef mozilla::layers::LayerAttributes LayerAttributes;
    typedef mozilla::layers::MagicGrallocBufferHandle MagicGrallocBufferHandle;
    typedef mozilla::layers::MaybeMagicGrallocBufferHandle MaybeMagicGrallocBufferHandle;
    typedef mozilla::layers::OpAppendChild OpAppendChild;
    typedef mozilla::layers::OpBufferSwap OpBufferSwap;
    typedef mozilla::layers::OpCreateCanvasLayer OpCreateCanvasLayer;
    typedef mozilla::layers::OpCreateColorLayer OpCreateColorLayer;
    typedef mozilla::layers::OpCreateContainerLayer OpCreateContainerLayer;
    typedef mozilla::layers::OpCreateImageLayer OpCreateImageLayer;
    typedef mozilla::layers::OpCreateRefLayer OpCreateRefLayer;
    typedef mozilla::layers::OpCreateThebesLayer OpCreateThebesLayer;
    typedef mozilla::layers::OpImageSwap OpImageSwap;
    typedef mozilla::layers::OpInsertAfter OpInsertAfter;
    typedef mozilla::layers::OpPaintCanvas OpPaintCanvas;
    typedef mozilla::layers::OpPaintImage OpPaintImage;
    typedef mozilla::layers::OpPaintThebesBuffer OpPaintThebesBuffer;
    typedef mozilla::layers::OpPaintTiledLayerBuffer OpPaintTiledLayerBuffer;
    typedef mozilla::layers::OpRaiseToTopChild OpRaiseToTopChild;
    typedef mozilla::layers::OpRemoveChild OpRemoveChild;
    typedef mozilla::layers::OpRepositionChild OpRepositionChild;
    typedef mozilla::layers::OpSetLayerAttributes OpSetLayerAttributes;
    typedef mozilla::layers::OpSetRoot OpSetRoot;
    typedef mozilla::layers::OpThebesBufferSwap OpThebesBufferSwap;
    typedef mozilla::layers::OptionalThebesBuffer OptionalThebesBuffer;
    typedef mozilla::layers::Perspective Perspective;
    typedef mozilla::layers::RGBImage RGBImage;
    typedef mozilla::layers::RefLayerAttributes RefLayerAttributes;
    typedef mozilla::layers::Rotation Rotation;
    typedef mozilla::layers::Rotation3D Rotation3D;
    typedef mozilla::layers::RotationX RotationX;
    typedef mozilla::layers::RotationY RotationY;
    typedef mozilla::layers::RotationZ RotationZ;
    typedef mozilla::layers::Scale Scale;
    typedef mozilla::dom::ScreenOrientation ScreenOrientation;
    typedef mozilla::ScreenRotation ScreenRotation;
    typedef mozilla::layers::SharedImage SharedImage;
    typedef mozilla::layers::SharedImageID SharedImageID;
    typedef mozilla::layers::SharedTextureDescriptor SharedTextureDescriptor;
    typedef mozilla::gl::SharedTextureHandle SharedTextureHandle;
    typedef mozilla::gl::GLContext::SharedTextureShareType SharedTextureShareType;
    typedef mozilla::ipc::Shmem Shmem;
    typedef mozilla::layers::SkewX SkewX;
    typedef mozilla::layers::SkewY SkewY;
    typedef mozilla::layers::SpecificLayerAttributes SpecificLayerAttributes;
    typedef mozilla::layers::StepFunction StepFunction;
    typedef mozilla::layers::SurfaceDescriptor SurfaceDescriptor;
    typedef mozilla::layers::SurfaceDescriptorD3D10 SurfaceDescriptorD3D10;
    typedef mozilla::layers::SurfaceDescriptorGralloc SurfaceDescriptorGralloc;
    typedef mozilla::layers::SurfaceDescriptorX11 SurfaceDescriptorX11;
    typedef mozilla::layers::TargetConfig TargetConfig;
    typedef mozilla::layers::ThebesBuffer ThebesBuffer;
    typedef mozilla::layers::ThebesLayerAttributes ThebesLayerAttributes;
    typedef mozilla::TimeDuration TimeDuration;
    typedef mozilla::TimeStamp TimeStamp;
    typedef mozilla::layers::TimingFunction TimingFunction;
    typedef mozilla::layers::TransformData TransformData;
    typedef mozilla::layers::TransformFunction TransformFunction;
    typedef mozilla::layers::TransformMatrix TransformMatrix;
    typedef mozilla::layers::Translation Translation;
    typedef mozilla::WindowsHandle WindowsHandle;
    typedef mozilla::layers::YCbCrImage YCbCrImage;
    typedef mozilla::layers::YUVImage YUVImage;
    typedef mozilla::gfxContentType gfxContentType;
    typedef mozilla::null_t null_t;

public:
    enum {
        ID = Reply_PGrallocBufferConstructor__ID
    };
    Reply_PGrallocBufferConstructor() :
        IPC::Message(MSG_ROUTING_NONE, ID, PRIORITY_NORMAL, COMPRESSION_NONE, "PLayers::Reply_PGrallocBufferConstructor")
    {
    }

    void
    Log(
            const std::string& __pfx,
            FILE* __outf) const
    {
        std::string __logmsg;
        StringAppendF((&(__logmsg)), "[time:%" PRId64 "][%d]", PR_Now(), base::GetCurrentProcId());
        (__logmsg).append(__pfx);
        (__logmsg).append("Reply_PGrallocBufferConstructor(");

        (__logmsg).append("[TODO])\n");
        fputs((__logmsg).c_str(), __outf);
    }
};

class Msg_PLayerConstructor :
    public IPC::Message
{
private:
    typedef mozilla::ipc::ActorHandle ActorHandle;
    typedef mozilla::layers::Animatable Animatable;
    typedef mozilla::layers::Animation Animation;
    typedef mozilla::layers::AnimationData AnimationData;
    typedef mozilla::layers::AnimationSegment AnimationSegment;
    typedef mozilla::layers::CanvasLayerAttributes CanvasLayerAttributes;
    typedef mozilla::layers::CanvasSurface CanvasSurface;
    typedef mozilla::layers::Color Color;
    typedef mozilla::layers::ColorLayerAttributes ColorLayerAttributes;
    typedef mozilla::layers::CommonLayerAttributes CommonLayerAttributes;
    typedef mozilla::layers::ContainerLayerAttributes ContainerLayerAttributes;
    typedef mozilla::layers::CubicBezierFunction CubicBezierFunction;
    typedef mozilla::layers::Edit Edit;
    typedef mozilla::layers::EditReply EditReply;
    typedef mozilla::ipc::FileDescriptor FileDescriptor;
    typedef mozilla::layers::FrameMetrics FrameMetrics;
    typedef mozilla::GraphicsFilterType GraphicsFilterType;
    typedef mozilla::layers::ImageLayerAttributes ImageLayerAttributes;
    typedef mozilla::layers::LayerAttributes LayerAttributes;
    typedef mozilla::layers::MagicGrallocBufferHandle MagicGrallocBufferHandle;
    typedef mozilla::layers::MaybeMagicGrallocBufferHandle MaybeMagicGrallocBufferHandle;
    typedef mozilla::layers::OpAppendChild OpAppendChild;
    typedef mozilla::layers::OpBufferSwap OpBufferSwap;
    typedef mozilla::layers::OpCreateCanvasLayer OpCreateCanvasLayer;
    typedef mozilla::layers::OpCreateColorLayer OpCreateColorLayer;
    typedef mozilla::layers::OpCreateContainerLayer OpCreateContainerLayer;
    typedef mozilla::layers::OpCreateImageLayer OpCreateImageLayer;
    typedef mozilla::layers::OpCreateRefLayer OpCreateRefLayer;
    typedef mozilla::layers::OpCreateThebesLayer OpCreateThebesLayer;
    typedef mozilla::layers::OpImageSwap OpImageSwap;
    typedef mozilla::layers::OpInsertAfter OpInsertAfter;
    typedef mozilla::layers::OpPaintCanvas OpPaintCanvas;
    typedef mozilla::layers::OpPaintImage OpPaintImage;
    typedef mozilla::layers::OpPaintThebesBuffer OpPaintThebesBuffer;
    typedef mozilla::layers::OpPaintTiledLayerBuffer OpPaintTiledLayerBuffer;
    typedef mozilla::layers::OpRaiseToTopChild OpRaiseToTopChild;
    typedef mozilla::layers::OpRemoveChild OpRemoveChild;
    typedef mozilla::layers::OpRepositionChild OpRepositionChild;
    typedef mozilla::layers::OpSetLayerAttributes OpSetLayerAttributes;
    typedef mozilla::layers::OpSetRoot OpSetRoot;
    typedef mozilla::layers::OpThebesBufferSwap OpThebesBufferSwap;
    typedef mozilla::layers::OptionalThebesBuffer OptionalThebesBuffer;
    typedef mozilla::layers::Perspective Perspective;
    typedef mozilla::layers::RGBImage RGBImage;
    typedef mozilla::layers::RefLayerAttributes RefLayerAttributes;
    typedef mozilla::layers::Rotation Rotation;
    typedef mozilla::layers::Rotation3D Rotation3D;
    typedef mozilla::layers::RotationX RotationX;
    typedef mozilla::layers::RotationY RotationY;
    typedef mozilla::layers::RotationZ RotationZ;
    typedef mozilla::layers::Scale Scale;
    typedef mozilla::dom::ScreenOrientation ScreenOrientation;
    typedef mozilla::ScreenRotation ScreenRotation;
    typedef mozilla::layers::SharedImage SharedImage;
    typedef mozilla::layers::SharedImageID SharedImageID;
    typedef mozilla::layers::SharedTextureDescriptor SharedTextureDescriptor;
    typedef mozilla::gl::SharedTextureHandle SharedTextureHandle;
    typedef mozilla::gl::GLContext::SharedTextureShareType SharedTextureShareType;
    typedef mozilla::ipc::Shmem Shmem;
    typedef mozilla::layers::SkewX SkewX;
    typedef mozilla::layers::SkewY SkewY;
    typedef mozilla::layers::SpecificLayerAttributes SpecificLayerAttributes;
    typedef mozilla::layers::StepFunction StepFunction;
    typedef mozilla::layers::SurfaceDescriptor SurfaceDescriptor;
    typedef mozilla::layers::SurfaceDescriptorD3D10 SurfaceDescriptorD3D10;
    typedef mozilla::layers::SurfaceDescriptorGralloc SurfaceDescriptorGralloc;
    typedef mozilla::layers::SurfaceDescriptorX11 SurfaceDescriptorX11;
    typedef mozilla::layers::TargetConfig TargetConfig;
    typedef mozilla::layers::ThebesBuffer ThebesBuffer;
    typedef mozilla::layers::ThebesLayerAttributes ThebesLayerAttributes;
    typedef mozilla::TimeDuration TimeDuration;
    typedef mozilla::TimeStamp TimeStamp;
    typedef mozilla::layers::TimingFunction TimingFunction;
    typedef mozilla::layers::TransformData TransformData;
    typedef mozilla::layers::TransformFunction TransformFunction;
    typedef mozilla::layers::TransformMatrix TransformMatrix;
    typedef mozilla::layers::Translation Translation;
    typedef mozilla::WindowsHandle WindowsHandle;
    typedef mozilla::layers::YCbCrImage YCbCrImage;
    typedef mozilla::layers::YUVImage YUVImage;
    typedef mozilla::gfxContentType gfxContentType;
    typedef mozilla::null_t null_t;

public:
    enum {
        ID = Msg_PLayerConstructor__ID
    };
    Msg_PLayerConstructor() :
        IPC::Message(MSG_ROUTING_NONE, ID, PRIORITY_NORMAL, COMPRESSION_NONE, "PLayers::Msg_PLayerConstructor")
    {
    }

    void
    Log(
            const std::string& __pfx,
            FILE* __outf) const
    {
        std::string __logmsg;
        StringAppendF((&(__logmsg)), "[time:%" PRId64 "][%d]", PR_Now(), base::GetCurrentProcId());
        (__logmsg).append(__pfx);
        (__logmsg).append("Msg_PLayerConstructor(");

        (__logmsg).append("[TODO])\n");
        fputs((__logmsg).c_str(), __outf);
    }
};

class Reply_PLayerConstructor :
    public IPC::Message
{
private:
    typedef mozilla::ipc::ActorHandle ActorHandle;
    typedef mozilla::layers::Animatable Animatable;
    typedef mozilla::layers::Animation Animation;
    typedef mozilla::layers::AnimationData AnimationData;
    typedef mozilla::layers::AnimationSegment AnimationSegment;
    typedef mozilla::layers::CanvasLayerAttributes CanvasLayerAttributes;
    typedef mozilla::layers::CanvasSurface CanvasSurface;
    typedef mozilla::layers::Color Color;
    typedef mozilla::layers::ColorLayerAttributes ColorLayerAttributes;
    typedef mozilla::layers::CommonLayerAttributes CommonLayerAttributes;
    typedef mozilla::layers::ContainerLayerAttributes ContainerLayerAttributes;
    typedef mozilla::layers::CubicBezierFunction CubicBezierFunction;
    typedef mozilla::layers::Edit Edit;
    typedef mozilla::layers::EditReply EditReply;
    typedef mozilla::ipc::FileDescriptor FileDescriptor;
    typedef mozilla::layers::FrameMetrics FrameMetrics;
    typedef mozilla::GraphicsFilterType GraphicsFilterType;
    typedef mozilla::layers::ImageLayerAttributes ImageLayerAttributes;
    typedef mozilla::layers::LayerAttributes LayerAttributes;
    typedef mozilla::layers::MagicGrallocBufferHandle MagicGrallocBufferHandle;
    typedef mozilla::layers::MaybeMagicGrallocBufferHandle MaybeMagicGrallocBufferHandle;
    typedef mozilla::layers::OpAppendChild OpAppendChild;
    typedef mozilla::layers::OpBufferSwap OpBufferSwap;
    typedef mozilla::layers::OpCreateCanvasLayer OpCreateCanvasLayer;
    typedef mozilla::layers::OpCreateColorLayer OpCreateColorLayer;
    typedef mozilla::layers::OpCreateContainerLayer OpCreateContainerLayer;
    typedef mozilla::layers::OpCreateImageLayer OpCreateImageLayer;
    typedef mozilla::layers::OpCreateRefLayer OpCreateRefLayer;
    typedef mozilla::layers::OpCreateThebesLayer OpCreateThebesLayer;
    typedef mozilla::layers::OpImageSwap OpImageSwap;
    typedef mozilla::layers::OpInsertAfter OpInsertAfter;
    typedef mozilla::layers::OpPaintCanvas OpPaintCanvas;
    typedef mozilla::layers::OpPaintImage OpPaintImage;
    typedef mozilla::layers::OpPaintThebesBuffer OpPaintThebesBuffer;
    typedef mozilla::layers::OpPaintTiledLayerBuffer OpPaintTiledLayerBuffer;
    typedef mozilla::layers::OpRaiseToTopChild OpRaiseToTopChild;
    typedef mozilla::layers::OpRemoveChild OpRemoveChild;
    typedef mozilla::layers::OpRepositionChild OpRepositionChild;
    typedef mozilla::layers::OpSetLayerAttributes OpSetLayerAttributes;
    typedef mozilla::layers::OpSetRoot OpSetRoot;
    typedef mozilla::layers::OpThebesBufferSwap OpThebesBufferSwap;
    typedef mozilla::layers::OptionalThebesBuffer OptionalThebesBuffer;
    typedef mozilla::layers::Perspective Perspective;
    typedef mozilla::layers::RGBImage RGBImage;
    typedef mozilla::layers::RefLayerAttributes RefLayerAttributes;
    typedef mozilla::layers::Rotation Rotation;
    typedef mozilla::layers::Rotation3D Rotation3D;
    typedef mozilla::layers::RotationX RotationX;
    typedef mozilla::layers::RotationY RotationY;
    typedef mozilla::layers::RotationZ RotationZ;
    typedef mozilla::layers::Scale Scale;
    typedef mozilla::dom::ScreenOrientation ScreenOrientation;
    typedef mozilla::ScreenRotation ScreenRotation;
    typedef mozilla::layers::SharedImage SharedImage;
    typedef mozilla::layers::SharedImageID SharedImageID;
    typedef mozilla::layers::SharedTextureDescriptor SharedTextureDescriptor;
    typedef mozilla::gl::SharedTextureHandle SharedTextureHandle;
    typedef mozilla::gl::GLContext::SharedTextureShareType SharedTextureShareType;
    typedef mozilla::ipc::Shmem Shmem;
    typedef mozilla::layers::SkewX SkewX;
    typedef mozilla::layers::SkewY SkewY;
    typedef mozilla::layers::SpecificLayerAttributes SpecificLayerAttributes;
    typedef mozilla::layers::StepFunction StepFunction;
    typedef mozilla::layers::SurfaceDescriptor SurfaceDescriptor;
    typedef mozilla::layers::SurfaceDescriptorD3D10 SurfaceDescriptorD3D10;
    typedef mozilla::layers::SurfaceDescriptorGralloc SurfaceDescriptorGralloc;
    typedef mozilla::layers::SurfaceDescriptorX11 SurfaceDescriptorX11;
    typedef mozilla::layers::TargetConfig TargetConfig;
    typedef mozilla::layers::ThebesBuffer ThebesBuffer;
    typedef mozilla::layers::ThebesLayerAttributes ThebesLayerAttributes;
    typedef mozilla::TimeDuration TimeDuration;
    typedef mozilla::TimeStamp TimeStamp;
    typedef mozilla::layers::TimingFunction TimingFunction;
    typedef mozilla::layers::TransformData TransformData;
    typedef mozilla::layers::TransformFunction TransformFunction;
    typedef mozilla::layers::TransformMatrix TransformMatrix;
    typedef mozilla::layers::Translation Translation;
    typedef mozilla::WindowsHandle WindowsHandle;
    typedef mozilla::layers::YCbCrImage YCbCrImage;
    typedef mozilla::layers::YUVImage YUVImage;
    typedef mozilla::gfxContentType gfxContentType;
    typedef mozilla::null_t null_t;

public:
    enum {
        ID = Reply_PLayerConstructor__ID
    };
    Reply_PLayerConstructor() :
        IPC::Message(MSG_ROUTING_NONE, ID, PRIORITY_NORMAL, COMPRESSION_NONE, "PLayers::Reply_PLayerConstructor")
    {
    }

    void
    Log(
            const std::string& __pfx,
            FILE* __outf) const
    {
        std::string __logmsg;
        StringAppendF((&(__logmsg)), "[time:%" PRId64 "][%d]", PR_Now(), base::GetCurrentProcId());
        (__logmsg).append(__pfx);
        (__logmsg).append("Reply_PLayerConstructor(");

        (__logmsg).append("[TODO])\n");
        fputs((__logmsg).c_str(), __outf);
    }
};

class Msg_Update :
    public IPC::Message
{
private:
    typedef mozilla::ipc::ActorHandle ActorHandle;
    typedef mozilla::layers::Animatable Animatable;
    typedef mozilla::layers::Animation Animation;
    typedef mozilla::layers::AnimationData AnimationData;
    typedef mozilla::layers::AnimationSegment AnimationSegment;
    typedef mozilla::layers::CanvasLayerAttributes CanvasLayerAttributes;
    typedef mozilla::layers::CanvasSurface CanvasSurface;
    typedef mozilla::layers::Color Color;
    typedef mozilla::layers::ColorLayerAttributes ColorLayerAttributes;
    typedef mozilla::layers::CommonLayerAttributes CommonLayerAttributes;
    typedef mozilla::layers::ContainerLayerAttributes ContainerLayerAttributes;
    typedef mozilla::layers::CubicBezierFunction CubicBezierFunction;
    typedef mozilla::layers::Edit Edit;
    typedef mozilla::layers::EditReply EditReply;
    typedef mozilla::ipc::FileDescriptor FileDescriptor;
    typedef mozilla::layers::FrameMetrics FrameMetrics;
    typedef mozilla::GraphicsFilterType GraphicsFilterType;
    typedef mozilla::layers::ImageLayerAttributes ImageLayerAttributes;
    typedef mozilla::layers::LayerAttributes LayerAttributes;
    typedef mozilla::layers::MagicGrallocBufferHandle MagicGrallocBufferHandle;
    typedef mozilla::layers::MaybeMagicGrallocBufferHandle MaybeMagicGrallocBufferHandle;
    typedef mozilla::layers::OpAppendChild OpAppendChild;
    typedef mozilla::layers::OpBufferSwap OpBufferSwap;
    typedef mozilla::layers::OpCreateCanvasLayer OpCreateCanvasLayer;
    typedef mozilla::layers::OpCreateColorLayer OpCreateColorLayer;
    typedef mozilla::layers::OpCreateContainerLayer OpCreateContainerLayer;
    typedef mozilla::layers::OpCreateImageLayer OpCreateImageLayer;
    typedef mozilla::layers::OpCreateRefLayer OpCreateRefLayer;
    typedef mozilla::layers::OpCreateThebesLayer OpCreateThebesLayer;
    typedef mozilla::layers::OpImageSwap OpImageSwap;
    typedef mozilla::layers::OpInsertAfter OpInsertAfter;
    typedef mozilla::layers::OpPaintCanvas OpPaintCanvas;
    typedef mozilla::layers::OpPaintImage OpPaintImage;
    typedef mozilla::layers::OpPaintThebesBuffer OpPaintThebesBuffer;
    typedef mozilla::layers::OpPaintTiledLayerBuffer OpPaintTiledLayerBuffer;
    typedef mozilla::layers::OpRaiseToTopChild OpRaiseToTopChild;
    typedef mozilla::layers::OpRemoveChild OpRemoveChild;
    typedef mozilla::layers::OpRepositionChild OpRepositionChild;
    typedef mozilla::layers::OpSetLayerAttributes OpSetLayerAttributes;
    typedef mozilla::layers::OpSetRoot OpSetRoot;
    typedef mozilla::layers::OpThebesBufferSwap OpThebesBufferSwap;
    typedef mozilla::layers::OptionalThebesBuffer OptionalThebesBuffer;
    typedef mozilla::layers::Perspective Perspective;
    typedef mozilla::layers::RGBImage RGBImage;
    typedef mozilla::layers::RefLayerAttributes RefLayerAttributes;
    typedef mozilla::layers::Rotation Rotation;
    typedef mozilla::layers::Rotation3D Rotation3D;
    typedef mozilla::layers::RotationX RotationX;
    typedef mozilla::layers::RotationY RotationY;
    typedef mozilla::layers::RotationZ RotationZ;
    typedef mozilla::layers::Scale Scale;
    typedef mozilla::dom::ScreenOrientation ScreenOrientation;
    typedef mozilla::ScreenRotation ScreenRotation;
    typedef mozilla::layers::SharedImage SharedImage;
    typedef mozilla::layers::SharedImageID SharedImageID;
    typedef mozilla::layers::SharedTextureDescriptor SharedTextureDescriptor;
    typedef mozilla::gl::SharedTextureHandle SharedTextureHandle;
    typedef mozilla::gl::GLContext::SharedTextureShareType SharedTextureShareType;
    typedef mozilla::ipc::Shmem Shmem;
    typedef mozilla::layers::SkewX SkewX;
    typedef mozilla::layers::SkewY SkewY;
    typedef mozilla::layers::SpecificLayerAttributes SpecificLayerAttributes;
    typedef mozilla::layers::StepFunction StepFunction;
    typedef mozilla::layers::SurfaceDescriptor SurfaceDescriptor;
    typedef mozilla::layers::SurfaceDescriptorD3D10 SurfaceDescriptorD3D10;
    typedef mozilla::layers::SurfaceDescriptorGralloc SurfaceDescriptorGralloc;
    typedef mozilla::layers::SurfaceDescriptorX11 SurfaceDescriptorX11;
    typedef mozilla::layers::TargetConfig TargetConfig;
    typedef mozilla::layers::ThebesBuffer ThebesBuffer;
    typedef mozilla::layers::ThebesLayerAttributes ThebesLayerAttributes;
    typedef mozilla::TimeDuration TimeDuration;
    typedef mozilla::TimeStamp TimeStamp;
    typedef mozilla::layers::TimingFunction TimingFunction;
    typedef mozilla::layers::TransformData TransformData;
    typedef mozilla::layers::TransformFunction TransformFunction;
    typedef mozilla::layers::TransformMatrix TransformMatrix;
    typedef mozilla::layers::Translation Translation;
    typedef mozilla::WindowsHandle WindowsHandle;
    typedef mozilla::layers::YCbCrImage YCbCrImage;
    typedef mozilla::layers::YUVImage YUVImage;
    typedef mozilla::gfxContentType gfxContentType;
    typedef mozilla::null_t null_t;

public:
    enum {
        ID = Msg_Update__ID
    };
    Msg_Update() :
        IPC::Message(MSG_ROUTING_NONE, ID, PRIORITY_NORMAL, COMPRESSION_NONE, "PLayers::Msg_Update")
    {
    }

    void
    Log(
            const std::string& __pfx,
            FILE* __outf) const
    {
        std::string __logmsg;
        StringAppendF((&(__logmsg)), "[time:%" PRId64 "][%d]", PR_Now(), base::GetCurrentProcId());
        (__logmsg).append(__pfx);
        (__logmsg).append("Msg_Update(");

        (__logmsg).append("[TODO])\n");
        fputs((__logmsg).c_str(), __outf);
    }
};

class Reply_Update :
    public IPC::Message
{
private:
    typedef mozilla::ipc::ActorHandle ActorHandle;
    typedef mozilla::layers::Animatable Animatable;
    typedef mozilla::layers::Animation Animation;
    typedef mozilla::layers::AnimationData AnimationData;
    typedef mozilla::layers::AnimationSegment AnimationSegment;
    typedef mozilla::layers::CanvasLayerAttributes CanvasLayerAttributes;
    typedef mozilla::layers::CanvasSurface CanvasSurface;
    typedef mozilla::layers::Color Color;
    typedef mozilla::layers::ColorLayerAttributes ColorLayerAttributes;
    typedef mozilla::layers::CommonLayerAttributes CommonLayerAttributes;
    typedef mozilla::layers::ContainerLayerAttributes ContainerLayerAttributes;
    typedef mozilla::layers::CubicBezierFunction CubicBezierFunction;
    typedef mozilla::layers::Edit Edit;
    typedef mozilla::layers::EditReply EditReply;
    typedef mozilla::ipc::FileDescriptor FileDescriptor;
    typedef mozilla::layers::FrameMetrics FrameMetrics;
    typedef mozilla::GraphicsFilterType GraphicsFilterType;
    typedef mozilla::layers::ImageLayerAttributes ImageLayerAttributes;
    typedef mozilla::layers::LayerAttributes LayerAttributes;
    typedef mozilla::layers::MagicGrallocBufferHandle MagicGrallocBufferHandle;
    typedef mozilla::layers::MaybeMagicGrallocBufferHandle MaybeMagicGrallocBufferHandle;
    typedef mozilla::layers::OpAppendChild OpAppendChild;
    typedef mozilla::layers::OpBufferSwap OpBufferSwap;
    typedef mozilla::layers::OpCreateCanvasLayer OpCreateCanvasLayer;
    typedef mozilla::layers::OpCreateColorLayer OpCreateColorLayer;
    typedef mozilla::layers::OpCreateContainerLayer OpCreateContainerLayer;
    typedef mozilla::layers::OpCreateImageLayer OpCreateImageLayer;
    typedef mozilla::layers::OpCreateRefLayer OpCreateRefLayer;
    typedef mozilla::layers::OpCreateThebesLayer OpCreateThebesLayer;
    typedef mozilla::layers::OpImageSwap OpImageSwap;
    typedef mozilla::layers::OpInsertAfter OpInsertAfter;
    typedef mozilla::layers::OpPaintCanvas OpPaintCanvas;
    typedef mozilla::layers::OpPaintImage OpPaintImage;
    typedef mozilla::layers::OpPaintThebesBuffer OpPaintThebesBuffer;
    typedef mozilla::layers::OpPaintTiledLayerBuffer OpPaintTiledLayerBuffer;
    typedef mozilla::layers::OpRaiseToTopChild OpRaiseToTopChild;
    typedef mozilla::layers::OpRemoveChild OpRemoveChild;
    typedef mozilla::layers::OpRepositionChild OpRepositionChild;
    typedef mozilla::layers::OpSetLayerAttributes OpSetLayerAttributes;
    typedef mozilla::layers::OpSetRoot OpSetRoot;
    typedef mozilla::layers::OpThebesBufferSwap OpThebesBufferSwap;
    typedef mozilla::layers::OptionalThebesBuffer OptionalThebesBuffer;
    typedef mozilla::layers::Perspective Perspective;
    typedef mozilla::layers::RGBImage RGBImage;
    typedef mozilla::layers::RefLayerAttributes RefLayerAttributes;
    typedef mozilla::layers::Rotation Rotation;
    typedef mozilla::layers::Rotation3D Rotation3D;
    typedef mozilla::layers::RotationX RotationX;
    typedef mozilla::layers::RotationY RotationY;
    typedef mozilla::layers::RotationZ RotationZ;
    typedef mozilla::layers::Scale Scale;
    typedef mozilla::dom::ScreenOrientation ScreenOrientation;
    typedef mozilla::ScreenRotation ScreenRotation;
    typedef mozilla::layers::SharedImage SharedImage;
    typedef mozilla::layers::SharedImageID SharedImageID;
    typedef mozilla::layers::SharedTextureDescriptor SharedTextureDescriptor;
    typedef mozilla::gl::SharedTextureHandle SharedTextureHandle;
    typedef mozilla::gl::GLContext::SharedTextureShareType SharedTextureShareType;
    typedef mozilla::ipc::Shmem Shmem;
    typedef mozilla::layers::SkewX SkewX;
    typedef mozilla::layers::SkewY SkewY;
    typedef mozilla::layers::SpecificLayerAttributes SpecificLayerAttributes;
    typedef mozilla::layers::StepFunction StepFunction;
    typedef mozilla::layers::SurfaceDescriptor SurfaceDescriptor;
    typedef mozilla::layers::SurfaceDescriptorD3D10 SurfaceDescriptorD3D10;
    typedef mozilla::layers::SurfaceDescriptorGralloc SurfaceDescriptorGralloc;
    typedef mozilla::layers::SurfaceDescriptorX11 SurfaceDescriptorX11;
    typedef mozilla::layers::TargetConfig TargetConfig;
    typedef mozilla::layers::ThebesBuffer ThebesBuffer;
    typedef mozilla::layers::ThebesLayerAttributes ThebesLayerAttributes;
    typedef mozilla::TimeDuration TimeDuration;
    typedef mozilla::TimeStamp TimeStamp;
    typedef mozilla::layers::TimingFunction TimingFunction;
    typedef mozilla::layers::TransformData TransformData;
    typedef mozilla::layers::TransformFunction TransformFunction;
    typedef mozilla::layers::TransformMatrix TransformMatrix;
    typedef mozilla::layers::Translation Translation;
    typedef mozilla::WindowsHandle WindowsHandle;
    typedef mozilla::layers::YCbCrImage YCbCrImage;
    typedef mozilla::layers::YUVImage YUVImage;
    typedef mozilla::gfxContentType gfxContentType;
    typedef mozilla::null_t null_t;

public:
    enum {
        ID = Reply_Update__ID
    };
    Reply_Update() :
        IPC::Message(MSG_ROUTING_NONE, ID, PRIORITY_NORMAL, COMPRESSION_NONE, "PLayers::Reply_Update")
    {
    }

    void
    Log(
            const std::string& __pfx,
            FILE* __outf) const
    {
        std::string __logmsg;
        StringAppendF((&(__logmsg)), "[time:%" PRId64 "][%d]", PR_Now(), base::GetCurrentProcId());
        (__logmsg).append(__pfx);
        (__logmsg).append("Reply_Update(");

        (__logmsg).append("[TODO])\n");
        fputs((__logmsg).c_str(), __outf);
    }
};

class Msg_UpdateNoSwap :
    public IPC::Message
{
private:
    typedef mozilla::ipc::ActorHandle ActorHandle;
    typedef mozilla::layers::Animatable Animatable;
    typedef mozilla::layers::Animation Animation;
    typedef mozilla::layers::AnimationData AnimationData;
    typedef mozilla::layers::AnimationSegment AnimationSegment;
    typedef mozilla::layers::CanvasLayerAttributes CanvasLayerAttributes;
    typedef mozilla::layers::CanvasSurface CanvasSurface;
    typedef mozilla::layers::Color Color;
    typedef mozilla::layers::ColorLayerAttributes ColorLayerAttributes;
    typedef mozilla::layers::CommonLayerAttributes CommonLayerAttributes;
    typedef mozilla::layers::ContainerLayerAttributes ContainerLayerAttributes;
    typedef mozilla::layers::CubicBezierFunction CubicBezierFunction;
    typedef mozilla::layers::Edit Edit;
    typedef mozilla::layers::EditReply EditReply;
    typedef mozilla::ipc::FileDescriptor FileDescriptor;
    typedef mozilla::layers::FrameMetrics FrameMetrics;
    typedef mozilla::GraphicsFilterType GraphicsFilterType;
    typedef mozilla::layers::ImageLayerAttributes ImageLayerAttributes;
    typedef mozilla::layers::LayerAttributes LayerAttributes;
    typedef mozilla::layers::MagicGrallocBufferHandle MagicGrallocBufferHandle;
    typedef mozilla::layers::MaybeMagicGrallocBufferHandle MaybeMagicGrallocBufferHandle;
    typedef mozilla::layers::OpAppendChild OpAppendChild;
    typedef mozilla::layers::OpBufferSwap OpBufferSwap;
    typedef mozilla::layers::OpCreateCanvasLayer OpCreateCanvasLayer;
    typedef mozilla::layers::OpCreateColorLayer OpCreateColorLayer;
    typedef mozilla::layers::OpCreateContainerLayer OpCreateContainerLayer;
    typedef mozilla::layers::OpCreateImageLayer OpCreateImageLayer;
    typedef mozilla::layers::OpCreateRefLayer OpCreateRefLayer;
    typedef mozilla::layers::OpCreateThebesLayer OpCreateThebesLayer;
    typedef mozilla::layers::OpImageSwap OpImageSwap;
    typedef mozilla::layers::OpInsertAfter OpInsertAfter;
    typedef mozilla::layers::OpPaintCanvas OpPaintCanvas;
    typedef mozilla::layers::OpPaintImage OpPaintImage;
    typedef mozilla::layers::OpPaintThebesBuffer OpPaintThebesBuffer;
    typedef mozilla::layers::OpPaintTiledLayerBuffer OpPaintTiledLayerBuffer;
    typedef mozilla::layers::OpRaiseToTopChild OpRaiseToTopChild;
    typedef mozilla::layers::OpRemoveChild OpRemoveChild;
    typedef mozilla::layers::OpRepositionChild OpRepositionChild;
    typedef mozilla::layers::OpSetLayerAttributes OpSetLayerAttributes;
    typedef mozilla::layers::OpSetRoot OpSetRoot;
    typedef mozilla::layers::OpThebesBufferSwap OpThebesBufferSwap;
    typedef mozilla::layers::OptionalThebesBuffer OptionalThebesBuffer;
    typedef mozilla::layers::Perspective Perspective;
    typedef mozilla::layers::RGBImage RGBImage;
    typedef mozilla::layers::RefLayerAttributes RefLayerAttributes;
    typedef mozilla::layers::Rotation Rotation;
    typedef mozilla::layers::Rotation3D Rotation3D;
    typedef mozilla::layers::RotationX RotationX;
    typedef mozilla::layers::RotationY RotationY;
    typedef mozilla::layers::RotationZ RotationZ;
    typedef mozilla::layers::Scale Scale;
    typedef mozilla::dom::ScreenOrientation ScreenOrientation;
    typedef mozilla::ScreenRotation ScreenRotation;
    typedef mozilla::layers::SharedImage SharedImage;
    typedef mozilla::layers::SharedImageID SharedImageID;
    typedef mozilla::layers::SharedTextureDescriptor SharedTextureDescriptor;
    typedef mozilla::gl::SharedTextureHandle SharedTextureHandle;
    typedef mozilla::gl::GLContext::SharedTextureShareType SharedTextureShareType;
    typedef mozilla::ipc::Shmem Shmem;
    typedef mozilla::layers::SkewX SkewX;
    typedef mozilla::layers::SkewY SkewY;
    typedef mozilla::layers::SpecificLayerAttributes SpecificLayerAttributes;
    typedef mozilla::layers::StepFunction StepFunction;
    typedef mozilla::layers::SurfaceDescriptor SurfaceDescriptor;
    typedef mozilla::layers::SurfaceDescriptorD3D10 SurfaceDescriptorD3D10;
    typedef mozilla::layers::SurfaceDescriptorGralloc SurfaceDescriptorGralloc;
    typedef mozilla::layers::SurfaceDescriptorX11 SurfaceDescriptorX11;
    typedef mozilla::layers::TargetConfig TargetConfig;
    typedef mozilla::layers::ThebesBuffer ThebesBuffer;
    typedef mozilla::layers::ThebesLayerAttributes ThebesLayerAttributes;
    typedef mozilla::TimeDuration TimeDuration;
    typedef mozilla::TimeStamp TimeStamp;
    typedef mozilla::layers::TimingFunction TimingFunction;
    typedef mozilla::layers::TransformData TransformData;
    typedef mozilla::layers::TransformFunction TransformFunction;
    typedef mozilla::layers::TransformMatrix TransformMatrix;
    typedef mozilla::layers::Translation Translation;
    typedef mozilla::WindowsHandle WindowsHandle;
    typedef mozilla::layers::YCbCrImage YCbCrImage;
    typedef mozilla::layers::YUVImage YUVImage;
    typedef mozilla::gfxContentType gfxContentType;
    typedef mozilla::null_t null_t;

public:
    enum {
        ID = Msg_UpdateNoSwap__ID
    };
    Msg_UpdateNoSwap() :
        IPC::Message(MSG_ROUTING_NONE, ID, PRIORITY_NORMAL, COMPRESSION_NONE, "PLayers::Msg_UpdateNoSwap")
    {
    }

    void
    Log(
            const std::string& __pfx,
            FILE* __outf) const
    {
        std::string __logmsg;
        StringAppendF((&(__logmsg)), "[time:%" PRId64 "][%d]", PR_Now(), base::GetCurrentProcId());
        (__logmsg).append(__pfx);
        (__logmsg).append("Msg_UpdateNoSwap(");

        (__logmsg).append("[TODO])\n");
        fputs((__logmsg).c_str(), __outf);
    }
};

class Msg_ClearCachedResources :
    public IPC::Message
{
private:
    typedef mozilla::ipc::ActorHandle ActorHandle;
    typedef mozilla::layers::Animatable Animatable;
    typedef mozilla::layers::Animation Animation;
    typedef mozilla::layers::AnimationData AnimationData;
    typedef mozilla::layers::AnimationSegment AnimationSegment;
    typedef mozilla::layers::CanvasLayerAttributes CanvasLayerAttributes;
    typedef mozilla::layers::CanvasSurface CanvasSurface;
    typedef mozilla::layers::Color Color;
    typedef mozilla::layers::ColorLayerAttributes ColorLayerAttributes;
    typedef mozilla::layers::CommonLayerAttributes CommonLayerAttributes;
    typedef mozilla::layers::ContainerLayerAttributes ContainerLayerAttributes;
    typedef mozilla::layers::CubicBezierFunction CubicBezierFunction;
    typedef mozilla::layers::Edit Edit;
    typedef mozilla::layers::EditReply EditReply;
    typedef mozilla::ipc::FileDescriptor FileDescriptor;
    typedef mozilla::layers::FrameMetrics FrameMetrics;
    typedef mozilla::GraphicsFilterType GraphicsFilterType;
    typedef mozilla::layers::ImageLayerAttributes ImageLayerAttributes;
    typedef mozilla::layers::LayerAttributes LayerAttributes;
    typedef mozilla::layers::MagicGrallocBufferHandle MagicGrallocBufferHandle;
    typedef mozilla::layers::MaybeMagicGrallocBufferHandle MaybeMagicGrallocBufferHandle;
    typedef mozilla::layers::OpAppendChild OpAppendChild;
    typedef mozilla::layers::OpBufferSwap OpBufferSwap;
    typedef mozilla::layers::OpCreateCanvasLayer OpCreateCanvasLayer;
    typedef mozilla::layers::OpCreateColorLayer OpCreateColorLayer;
    typedef mozilla::layers::OpCreateContainerLayer OpCreateContainerLayer;
    typedef mozilla::layers::OpCreateImageLayer OpCreateImageLayer;
    typedef mozilla::layers::OpCreateRefLayer OpCreateRefLayer;
    typedef mozilla::layers::OpCreateThebesLayer OpCreateThebesLayer;
    typedef mozilla::layers::OpImageSwap OpImageSwap;
    typedef mozilla::layers::OpInsertAfter OpInsertAfter;
    typedef mozilla::layers::OpPaintCanvas OpPaintCanvas;
    typedef mozilla::layers::OpPaintImage OpPaintImage;
    typedef mozilla::layers::OpPaintThebesBuffer OpPaintThebesBuffer;
    typedef mozilla::layers::OpPaintTiledLayerBuffer OpPaintTiledLayerBuffer;
    typedef mozilla::layers::OpRaiseToTopChild OpRaiseToTopChild;
    typedef mozilla::layers::OpRemoveChild OpRemoveChild;
    typedef mozilla::layers::OpRepositionChild OpRepositionChild;
    typedef mozilla::layers::OpSetLayerAttributes OpSetLayerAttributes;
    typedef mozilla::layers::OpSetRoot OpSetRoot;
    typedef mozilla::layers::OpThebesBufferSwap OpThebesBufferSwap;
    typedef mozilla::layers::OptionalThebesBuffer OptionalThebesBuffer;
    typedef mozilla::layers::Perspective Perspective;
    typedef mozilla::layers::RGBImage RGBImage;
    typedef mozilla::layers::RefLayerAttributes RefLayerAttributes;
    typedef mozilla::layers::Rotation Rotation;
    typedef mozilla::layers::Rotation3D Rotation3D;
    typedef mozilla::layers::RotationX RotationX;
    typedef mozilla::layers::RotationY RotationY;
    typedef mozilla::layers::RotationZ RotationZ;
    typedef mozilla::layers::Scale Scale;
    typedef mozilla::dom::ScreenOrientation ScreenOrientation;
    typedef mozilla::ScreenRotation ScreenRotation;
    typedef mozilla::layers::SharedImage SharedImage;
    typedef mozilla::layers::SharedImageID SharedImageID;
    typedef mozilla::layers::SharedTextureDescriptor SharedTextureDescriptor;
    typedef mozilla::gl::SharedTextureHandle SharedTextureHandle;
    typedef mozilla::gl::GLContext::SharedTextureShareType SharedTextureShareType;
    typedef mozilla::ipc::Shmem Shmem;
    typedef mozilla::layers::SkewX SkewX;
    typedef mozilla::layers::SkewY SkewY;
    typedef mozilla::layers::SpecificLayerAttributes SpecificLayerAttributes;
    typedef mozilla::layers::StepFunction StepFunction;
    typedef mozilla::layers::SurfaceDescriptor SurfaceDescriptor;
    typedef mozilla::layers::SurfaceDescriptorD3D10 SurfaceDescriptorD3D10;
    typedef mozilla::layers::SurfaceDescriptorGralloc SurfaceDescriptorGralloc;
    typedef mozilla::layers::SurfaceDescriptorX11 SurfaceDescriptorX11;
    typedef mozilla::layers::TargetConfig TargetConfig;
    typedef mozilla::layers::ThebesBuffer ThebesBuffer;
    typedef mozilla::layers::ThebesLayerAttributes ThebesLayerAttributes;
    typedef mozilla::TimeDuration TimeDuration;
    typedef mozilla::TimeStamp TimeStamp;
    typedef mozilla::layers::TimingFunction TimingFunction;
    typedef mozilla::layers::TransformData TransformData;
    typedef mozilla::layers::TransformFunction TransformFunction;
    typedef mozilla::layers::TransformMatrix TransformMatrix;
    typedef mozilla::layers::Translation Translation;
    typedef mozilla::WindowsHandle WindowsHandle;
    typedef mozilla::layers::YCbCrImage YCbCrImage;
    typedef mozilla::layers::YUVImage YUVImage;
    typedef mozilla::gfxContentType gfxContentType;
    typedef mozilla::null_t null_t;

public:
    enum {
        ID = Msg_ClearCachedResources__ID
    };
    Msg_ClearCachedResources() :
        IPC::Message(MSG_ROUTING_NONE, ID, PRIORITY_NORMAL, COMPRESSION_NONE, "PLayers::Msg_ClearCachedResources")
    {
    }

    void
    Log(
            const std::string& __pfx,
            FILE* __outf) const
    {
        std::string __logmsg;
        StringAppendF((&(__logmsg)), "[time:%" PRId64 "][%d]", PR_Now(), base::GetCurrentProcId());
        (__logmsg).append(__pfx);
        (__logmsg).append("Msg_ClearCachedResources(");

        (__logmsg).append("[TODO])\n");
        fputs((__logmsg).c_str(), __outf);
    }
};

class Msg___delete__ :
    public IPC::Message
{
private:
    typedef mozilla::ipc::ActorHandle ActorHandle;
    typedef mozilla::layers::Animatable Animatable;
    typedef mozilla::layers::Animation Animation;
    typedef mozilla::layers::AnimationData AnimationData;
    typedef mozilla::layers::AnimationSegment AnimationSegment;
    typedef mozilla::layers::CanvasLayerAttributes CanvasLayerAttributes;
    typedef mozilla::layers::CanvasSurface CanvasSurface;
    typedef mozilla::layers::Color Color;
    typedef mozilla::layers::ColorLayerAttributes ColorLayerAttributes;
    typedef mozilla::layers::CommonLayerAttributes CommonLayerAttributes;
    typedef mozilla::layers::ContainerLayerAttributes ContainerLayerAttributes;
    typedef mozilla::layers::CubicBezierFunction CubicBezierFunction;
    typedef mozilla::layers::Edit Edit;
    typedef mozilla::layers::EditReply EditReply;
    typedef mozilla::ipc::FileDescriptor FileDescriptor;
    typedef mozilla::layers::FrameMetrics FrameMetrics;
    typedef mozilla::GraphicsFilterType GraphicsFilterType;
    typedef mozilla::layers::ImageLayerAttributes ImageLayerAttributes;
    typedef mozilla::layers::LayerAttributes LayerAttributes;
    typedef mozilla::layers::MagicGrallocBufferHandle MagicGrallocBufferHandle;
    typedef mozilla::layers::MaybeMagicGrallocBufferHandle MaybeMagicGrallocBufferHandle;
    typedef mozilla::layers::OpAppendChild OpAppendChild;
    typedef mozilla::layers::OpBufferSwap OpBufferSwap;
    typedef mozilla::layers::OpCreateCanvasLayer OpCreateCanvasLayer;
    typedef mozilla::layers::OpCreateColorLayer OpCreateColorLayer;
    typedef mozilla::layers::OpCreateContainerLayer OpCreateContainerLayer;
    typedef mozilla::layers::OpCreateImageLayer OpCreateImageLayer;
    typedef mozilla::layers::OpCreateRefLayer OpCreateRefLayer;
    typedef mozilla::layers::OpCreateThebesLayer OpCreateThebesLayer;
    typedef mozilla::layers::OpImageSwap OpImageSwap;
    typedef mozilla::layers::OpInsertAfter OpInsertAfter;
    typedef mozilla::layers::OpPaintCanvas OpPaintCanvas;
    typedef mozilla::layers::OpPaintImage OpPaintImage;
    typedef mozilla::layers::OpPaintThebesBuffer OpPaintThebesBuffer;
    typedef mozilla::layers::OpPaintTiledLayerBuffer OpPaintTiledLayerBuffer;
    typedef mozilla::layers::OpRaiseToTopChild OpRaiseToTopChild;
    typedef mozilla::layers::OpRemoveChild OpRemoveChild;
    typedef mozilla::layers::OpRepositionChild OpRepositionChild;
    typedef mozilla::layers::OpSetLayerAttributes OpSetLayerAttributes;
    typedef mozilla::layers::OpSetRoot OpSetRoot;
    typedef mozilla::layers::OpThebesBufferSwap OpThebesBufferSwap;
    typedef mozilla::layers::OptionalThebesBuffer OptionalThebesBuffer;
    typedef mozilla::layers::Perspective Perspective;
    typedef mozilla::layers::RGBImage RGBImage;
    typedef mozilla::layers::RefLayerAttributes RefLayerAttributes;
    typedef mozilla::layers::Rotation Rotation;
    typedef mozilla::layers::Rotation3D Rotation3D;
    typedef mozilla::layers::RotationX RotationX;
    typedef mozilla::layers::RotationY RotationY;
    typedef mozilla::layers::RotationZ RotationZ;
    typedef mozilla::layers::Scale Scale;
    typedef mozilla::dom::ScreenOrientation ScreenOrientation;
    typedef mozilla::ScreenRotation ScreenRotation;
    typedef mozilla::layers::SharedImage SharedImage;
    typedef mozilla::layers::SharedImageID SharedImageID;
    typedef mozilla::layers::SharedTextureDescriptor SharedTextureDescriptor;
    typedef mozilla::gl::SharedTextureHandle SharedTextureHandle;
    typedef mozilla::gl::GLContext::SharedTextureShareType SharedTextureShareType;
    typedef mozilla::ipc::Shmem Shmem;
    typedef mozilla::layers::SkewX SkewX;
    typedef mozilla::layers::SkewY SkewY;
    typedef mozilla::layers::SpecificLayerAttributes SpecificLayerAttributes;
    typedef mozilla::layers::StepFunction StepFunction;
    typedef mozilla::layers::SurfaceDescriptor SurfaceDescriptor;
    typedef mozilla::layers::SurfaceDescriptorD3D10 SurfaceDescriptorD3D10;
    typedef mozilla::layers::SurfaceDescriptorGralloc SurfaceDescriptorGralloc;
    typedef mozilla::layers::SurfaceDescriptorX11 SurfaceDescriptorX11;
    typedef mozilla::layers::TargetConfig TargetConfig;
    typedef mozilla::layers::ThebesBuffer ThebesBuffer;
    typedef mozilla::layers::ThebesLayerAttributes ThebesLayerAttributes;
    typedef mozilla::TimeDuration TimeDuration;
    typedef mozilla::TimeStamp TimeStamp;
    typedef mozilla::layers::TimingFunction TimingFunction;
    typedef mozilla::layers::TransformData TransformData;
    typedef mozilla::layers::TransformFunction TransformFunction;
    typedef mozilla::layers::TransformMatrix TransformMatrix;
    typedef mozilla::layers::Translation Translation;
    typedef mozilla::WindowsHandle WindowsHandle;
    typedef mozilla::layers::YCbCrImage YCbCrImage;
    typedef mozilla::layers::YUVImage YUVImage;
    typedef mozilla::gfxContentType gfxContentType;
    typedef mozilla::null_t null_t;

public:
    enum {
        ID = Msg___delete____ID
    };
    Msg___delete__() :
        IPC::Message(MSG_ROUTING_NONE, ID, PRIORITY_NORMAL, COMPRESSION_NONE, "PLayers::Msg___delete__")
    {
    }

    void
    Log(
            const std::string& __pfx,
            FILE* __outf) const
    {
        std::string __logmsg;
        StringAppendF((&(__logmsg)), "[time:%" PRId64 "][%d]", PR_Now(), base::GetCurrentProcId());
        (__logmsg).append(__pfx);
        (__logmsg).append("Msg___delete__(");

        (__logmsg).append("[TODO])\n");
        fputs((__logmsg).c_str(), __outf);
    }
};

class Reply___delete__ :
    public IPC::Message
{
private:
    typedef mozilla::ipc::ActorHandle ActorHandle;
    typedef mozilla::layers::Animatable Animatable;
    typedef mozilla::layers::Animation Animation;
    typedef mozilla::layers::AnimationData AnimationData;
    typedef mozilla::layers::AnimationSegment AnimationSegment;
    typedef mozilla::layers::CanvasLayerAttributes CanvasLayerAttributes;
    typedef mozilla::layers::CanvasSurface CanvasSurface;
    typedef mozilla::layers::Color Color;
    typedef mozilla::layers::ColorLayerAttributes ColorLayerAttributes;
    typedef mozilla::layers::CommonLayerAttributes CommonLayerAttributes;
    typedef mozilla::layers::ContainerLayerAttributes ContainerLayerAttributes;
    typedef mozilla::layers::CubicBezierFunction CubicBezierFunction;
    typedef mozilla::layers::Edit Edit;
    typedef mozilla::layers::EditReply EditReply;
    typedef mozilla::ipc::FileDescriptor FileDescriptor;
    typedef mozilla::layers::FrameMetrics FrameMetrics;
    typedef mozilla::GraphicsFilterType GraphicsFilterType;
    typedef mozilla::layers::ImageLayerAttributes ImageLayerAttributes;
    typedef mozilla::layers::LayerAttributes LayerAttributes;
    typedef mozilla::layers::MagicGrallocBufferHandle MagicGrallocBufferHandle;
    typedef mozilla::layers::MaybeMagicGrallocBufferHandle MaybeMagicGrallocBufferHandle;
    typedef mozilla::layers::OpAppendChild OpAppendChild;
    typedef mozilla::layers::OpBufferSwap OpBufferSwap;
    typedef mozilla::layers::OpCreateCanvasLayer OpCreateCanvasLayer;
    typedef mozilla::layers::OpCreateColorLayer OpCreateColorLayer;
    typedef mozilla::layers::OpCreateContainerLayer OpCreateContainerLayer;
    typedef mozilla::layers::OpCreateImageLayer OpCreateImageLayer;
    typedef mozilla::layers::OpCreateRefLayer OpCreateRefLayer;
    typedef mozilla::layers::OpCreateThebesLayer OpCreateThebesLayer;
    typedef mozilla::layers::OpImageSwap OpImageSwap;
    typedef mozilla::layers::OpInsertAfter OpInsertAfter;
    typedef mozilla::layers::OpPaintCanvas OpPaintCanvas;
    typedef mozilla::layers::OpPaintImage OpPaintImage;
    typedef mozilla::layers::OpPaintThebesBuffer OpPaintThebesBuffer;
    typedef mozilla::layers::OpPaintTiledLayerBuffer OpPaintTiledLayerBuffer;
    typedef mozilla::layers::OpRaiseToTopChild OpRaiseToTopChild;
    typedef mozilla::layers::OpRemoveChild OpRemoveChild;
    typedef mozilla::layers::OpRepositionChild OpRepositionChild;
    typedef mozilla::layers::OpSetLayerAttributes OpSetLayerAttributes;
    typedef mozilla::layers::OpSetRoot OpSetRoot;
    typedef mozilla::layers::OpThebesBufferSwap OpThebesBufferSwap;
    typedef mozilla::layers::OptionalThebesBuffer OptionalThebesBuffer;
    typedef mozilla::layers::Perspective Perspective;
    typedef mozilla::layers::RGBImage RGBImage;
    typedef mozilla::layers::RefLayerAttributes RefLayerAttributes;
    typedef mozilla::layers::Rotation Rotation;
    typedef mozilla::layers::Rotation3D Rotation3D;
    typedef mozilla::layers::RotationX RotationX;
    typedef mozilla::layers::RotationY RotationY;
    typedef mozilla::layers::RotationZ RotationZ;
    typedef mozilla::layers::Scale Scale;
    typedef mozilla::dom::ScreenOrientation ScreenOrientation;
    typedef mozilla::ScreenRotation ScreenRotation;
    typedef mozilla::layers::SharedImage SharedImage;
    typedef mozilla::layers::SharedImageID SharedImageID;
    typedef mozilla::layers::SharedTextureDescriptor SharedTextureDescriptor;
    typedef mozilla::gl::SharedTextureHandle SharedTextureHandle;
    typedef mozilla::gl::GLContext::SharedTextureShareType SharedTextureShareType;
    typedef mozilla::ipc::Shmem Shmem;
    typedef mozilla::layers::SkewX SkewX;
    typedef mozilla::layers::SkewY SkewY;
    typedef mozilla::layers::SpecificLayerAttributes SpecificLayerAttributes;
    typedef mozilla::layers::StepFunction StepFunction;
    typedef mozilla::layers::SurfaceDescriptor SurfaceDescriptor;
    typedef mozilla::layers::SurfaceDescriptorD3D10 SurfaceDescriptorD3D10;
    typedef mozilla::layers::SurfaceDescriptorGralloc SurfaceDescriptorGralloc;
    typedef mozilla::layers::SurfaceDescriptorX11 SurfaceDescriptorX11;
    typedef mozilla::layers::TargetConfig TargetConfig;
    typedef mozilla::layers::ThebesBuffer ThebesBuffer;
    typedef mozilla::layers::ThebesLayerAttributes ThebesLayerAttributes;
    typedef mozilla::TimeDuration TimeDuration;
    typedef mozilla::TimeStamp TimeStamp;
    typedef mozilla::layers::TimingFunction TimingFunction;
    typedef mozilla::layers::TransformData TransformData;
    typedef mozilla::layers::TransformFunction TransformFunction;
    typedef mozilla::layers::TransformMatrix TransformMatrix;
    typedef mozilla::layers::Translation Translation;
    typedef mozilla::WindowsHandle WindowsHandle;
    typedef mozilla::layers::YCbCrImage YCbCrImage;
    typedef mozilla::layers::YUVImage YUVImage;
    typedef mozilla::gfxContentType gfxContentType;
    typedef mozilla::null_t null_t;

public:
    enum {
        ID = Reply___delete____ID
    };
    Reply___delete__() :
        IPC::Message(MSG_ROUTING_NONE, ID, PRIORITY_NORMAL, COMPRESSION_NONE, "PLayers::Reply___delete__")
    {
    }

    void
    Log(
            const std::string& __pfx,
            FILE* __outf) const
    {
        std::string __logmsg;
        StringAppendF((&(__logmsg)), "[time:%" PRId64 "][%d]", PR_Now(), base::GetCurrentProcId());
        (__logmsg).append(__pfx);
        (__logmsg).append("Reply___delete__(");

        (__logmsg).append("[TODO])\n");
        fputs((__logmsg).c_str(), __outf);
    }
};



} // namespace PLayers
} // namespace layers
} // namespace mozilla

#endif // ifndef PLayers_h
