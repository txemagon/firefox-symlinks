//
// Automatically generated by ipdlc.
// Edit at your own risk
//

#ifndef PBrowserParent_h
#define PBrowserParent_h

#include "mozilla/dom/PBrowser.h"
namespace mozilla {
namespace dom {
class PBlobParent;
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace dom {
class PContentParent;
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace dom {
class PContentDialogParent;
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
class PDocumentRendererParent;
} // namespace ipc
} // namespace mozilla

namespace mozilla {
namespace dom {
class PContentPermissionRequestParent;
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace layout {
class PRenderFrameParent;
} // namespace layout
} // namespace mozilla

namespace mozilla {
namespace docshell {
class POfflineCacheUpdateParent;
} // namespace docshell
} // namespace mozilla

namespace mozilla {
namespace dom {
namespace indexedDB {
class PIndexedDBParent;
} // namespace indexedDB
} // namespace dom
} // namespace mozilla

#ifdef DEBUG
#include "prenv.h"
#endif // DEBUG
#include "base/id_map.h"
#include "mozilla/ipc/RPCChannel.h"


namespace mozilla {
namespace dom {
namespace indexedDB {
class PIndexedDBParent;
} // namespace indexedDB
} // namespace dom
} // namespace mozilla


namespace mozilla {
namespace dom {
class PContentPermissionRequestParent;
} // namespace dom
} // namespace mozilla


namespace mozilla {
namespace layout {
class PRenderFrameParent;
} // namespace layout
} // namespace mozilla


namespace mozilla {
namespace net {
class PCookieServiceParent;
} // namespace net
} // namespace mozilla


namespace mozilla {
namespace net {
class PWyciwygChannelParent;
} // namespace net
} // namespace mozilla


namespace mozilla {
namespace dom {
class PContentDialogParent;
} // namespace dom
} // namespace mozilla


namespace mozilla {
namespace docshell {
class POfflineCacheUpdateParent;
} // namespace docshell
} // namespace mozilla


namespace mozilla {
namespace net {
class PNeckoParent;
} // namespace net
} // namespace mozilla


namespace mozilla {
namespace dom {
class PContentParent;
} // namespace dom
} // namespace mozilla


namespace mozilla {
namespace ipc {
class PDocumentRendererParent;
} // namespace ipc
} // namespace mozilla


namespace mozilla {
namespace hal_sandbox {
class PHalParent;
} // namespace hal_sandbox
} // namespace mozilla

namespace mozilla {
namespace dom {


class /*NS_ABSTRACT_CLASS*/ PBrowserParent :
    protected mozilla::ipc::RPCChannel::RPCListener,
    protected mozilla::ipc::IProtocolManager<mozilla::ipc::RPCChannel::RPCListener>
{
    friend class mozilla::dom::indexedDB::PIndexedDBParent;

    friend class mozilla::dom::PContentPermissionRequestParent;

    friend class mozilla::layout::PRenderFrameParent;

    friend class mozilla::net::PCookieServiceParent;

    friend class mozilla::net::PWyciwygChannelParent;

    friend class mozilla::dom::PContentDialogParent;

    friend class mozilla::docshell::POfflineCacheUpdateParent;

    friend class mozilla::net::PNeckoParent;

    friend class mozilla::dom::PContentParent;

    friend class mozilla::ipc::PDocumentRendererParent;

    friend class mozilla::hal_sandbox::PHalParent;

protected:
    typedef mozilla::ipc::ActorHandle ActorHandle;
    typedef mozilla::dom::ClonedMessageData ClonedMessageData;
    typedef mozilla::dom::FileBlobConstructorParams FileBlobConstructorParams;
    typedef mozilla::ipc::FileDescriptor FileDescriptor;
    typedef mozilla::layers::FrameMetrics FrameMetrics;
    typedef mozilla::ipc::GenericURIParams GenericURIParams;
    typedef mozilla::ipc::JARURIParams JARURIParams;
    typedef mozilla::layers::LayersBackend LayersBackend;
    typedef mozilla::dom::NormalBlobConstructorParams NormalBlobConstructorParams;
    typedef mozilla::ipc::OptionalURIParams OptionalURIParams;
    typedef IPC::Principal Principal;
    typedef mozilla::dom::ScreenOrientation ScreenOrientation;
    typedef mozilla::layout::ScrollingBehavior ScrollingBehavior;
    typedef mozilla::SerializedStructuredCloneBuffer SerializedStructuredCloneBuffer;
    typedef mozilla::ipc::Shmem Shmem;
    typedef mozilla::ipc::SimpleURIParams SimpleURIParams;
    typedef mozilla::ipc::StandardURLParams StandardURLParams;
    typedef mozilla::ipc::StandardURLSegment StandardURLSegment;
    typedef mozilla::ipc::URIParams URIParams;
    typedef mozilla::widget::WheelEvent WheelEvent;
    typedef mozilla::WindowsHandle WindowsHandle;
    typedef mozilla::void_t void_t;
    typedef mozilla::dom::PBlobParent PBlobParent;
    typedef mozilla::dom::PContentParent PContentParent;
    typedef mozilla::dom::PContentDialogParent PContentDialogParent;
    typedef mozilla::ipc::PDocumentRendererParent PDocumentRendererParent;
    typedef mozilla::dom::PContentPermissionRequestParent PContentPermissionRequestParent;
    typedef mozilla::layout::PRenderFrameParent PRenderFrameParent;
    typedef mozilla::docshell::POfflineCacheUpdateParent POfflineCacheUpdateParent;
    typedef mozilla::dom::indexedDB::PIndexedDBParent PIndexedDBParent;
    typedef base::ProcessId ProcessId;
    typedef mozilla::ipc::ProtocolId ProtocolId;
    typedef mozilla::ipc::Transport Transport;
    typedef mozilla::ipc::TransportDescriptor TransportDescriptor;

    typedef PBrowser::State State;

    virtual bool
    RecvAsyncMessage(
            const nsString& aMessage,
            const ClonedMessageData& aData) = 0;
    virtual bool
    RecvMoveFocus(const bool& forward) = 0;
    virtual bool
    RecvEvent(const RemoteDOMEvent& aEvent) = 0;
    virtual bool
    AnswerCreateWindow(PBrowserParent** window) = 0;
    virtual bool
    RecvSyncMessage(
            const nsString& aMessage,
            const ClonedMessageData& aData,
            InfallibleTArray<nsString>* retval) = 0;
    virtual bool
    RecvNotifyIMEFocus(
            const bool& focus,
            nsIMEUpdatePreference* preference,
            uint32_t* seqno) = 0;
    virtual bool
    RecvNotifyIMETextChange(
            const uint32_t& offset,
            const uint32_t& end,
            const uint32_t& newEnd) = 0;
    virtual bool
    RecvNotifyIMESelection(
            const uint32_t& seqno,
            const uint32_t& anchor,
            const uint32_t& focus) = 0;
    virtual bool
    RecvNotifyIMETextHint(const nsString& text) = 0;
    virtual bool
    RecvEndIMEComposition(
            const bool& cancel,
            nsString* composition) = 0;
    virtual bool
    RecvGetInputContext(
            int32_t* IMEEnabled,
            int32_t* IMEOpen,
            intptr_t* NativeIMEContext) = 0;
    virtual bool
    RecvSetInputContext(
            const int32_t& IMEEnabled,
            const int32_t& IMEOpen,
            const nsString& type,
            const nsString& inputmode,
            const nsString& actionHint,
            const int32_t& cause,
            const int32_t& focusChange) = 0;
    virtual bool
    RecvGetDPI(float* value) = 0;
    virtual bool
    RecvGetWidgetNativeData(WindowsHandle* value) = 0;
    virtual bool
    RecvSetCursor(const uint32_t& value) = 0;
    virtual bool
    RecvSetBackgroundColor(const nscolor& color) = 0;
    virtual bool
    RecvPContentPermissionRequestConstructor(
            PContentPermissionRequestParent* actor,
            const nsCString& aType,
            const nsCString& aAccess,
            const Principal& principal);
    virtual bool
    RecvPContentDialogConstructor(
            PContentDialogParent* actor,
            const uint32_t& aType,
            const nsCString& aName,
            const nsCString& aFeatures,
            const InfallibleTArray<int32_t>& aIntParams,
            const InfallibleTArray<nsString>& aStringParams);
    virtual bool
    RecvPRenderFrameConstructor(
            PRenderFrameParent* actor,
            ScrollingBehavior* scrolling,
            LayersBackend* backend,
            int32_t* maxTextureSize,
            uint64_t* layersId);
    virtual bool
    RecvPOfflineCacheUpdateConstructor(
            POfflineCacheUpdateParent* actor,
            const URIParams& manifestURI,
            const URIParams& documentURI,
            const bool& stickDocument);
    virtual bool
    RecvPIndexedDBConstructor(
            PIndexedDBParent* actor,
            const nsCString& asciiOrigin,
            bool* allowed);
    virtual bool
    RecvBrowserFrameOpenWindow(
            PBrowserParent* opener,
            const nsString& aURL,
            const nsString& aName,
            const nsString& aFeatures,
            bool* windowOpened) = 0;
    virtual bool
    RecvZoomToRect(const gfxRect& aRect) = 0;
    virtual bool
    RecvContentReceivedTouch(const bool& aPreventDefault) = 0;
    virtual bool
    RecvUpdateZoomConstraints(
            const bool& aAllowZoom,
            const float& aMinZoom,
            const float& aMaxZoom) = 0;
    virtual bool
    Recv__delete__();
    virtual PContentPermissionRequestParent*
    AllocPContentPermissionRequest(
            const nsCString& aType,
            const nsCString& aAccess,
            const Principal& principal) = 0;
    virtual bool
    DeallocPContentPermissionRequest(PContentPermissionRequestParent* actor) = 0;
    virtual PContentDialogParent*
    AllocPContentDialog(
            const uint32_t& aType,
            const nsCString& aName,
            const nsCString& aFeatures,
            const InfallibleTArray<int32_t>& aIntParams,
            const InfallibleTArray<nsString>& aStringParams) = 0;
    virtual bool
    DeallocPContentDialog(PContentDialogParent* actor) = 0;
    virtual PRenderFrameParent*
    AllocPRenderFrame(
            ScrollingBehavior* scrolling,
            LayersBackend* backend,
            int32_t* maxTextureSize,
            uint64_t* layersId) = 0;
    virtual bool
    DeallocPRenderFrame(PRenderFrameParent* actor) = 0;
    virtual POfflineCacheUpdateParent*
    AllocPOfflineCacheUpdate(
            const URIParams& manifestURI,
            const URIParams& documentURI,
            const bool& stickDocument) = 0;
    virtual bool
    DeallocPOfflineCacheUpdate(POfflineCacheUpdateParent* actor) = 0;
    virtual PIndexedDBParent*
    AllocPIndexedDB(
            const nsCString& asciiOrigin,
            bool* allowed) = 0;
    virtual bool
    DeallocPIndexedDB(PIndexedDBParent* actor) = 0;
    virtual PDocumentRendererParent*
    AllocPDocumentRenderer(
            const nsRect& documentRect,
            const gfxMatrix& transform,
            const nsString& bgcolor,
            const uint32_t& renderFlags,
            const bool& flushLayout,
            const nsIntSize& renderSize) = 0;
    virtual bool
    DeallocPDocumentRenderer(PDocumentRendererParent* actor) = 0;

    virtual void
    ActorDestroy(ActorDestroyReason why);

public:
    typedef IPC::Message Message;
    typedef mozilla::ipc::RPCChannel Channel;
    typedef mozilla::ipc::RPCChannel::RPCListener ChannelListener;
    typedef base::ProcessHandle ProcessHandle;
    typedef mozilla::ipc::AsyncChannel AsyncChannel;
    typedef mozilla::ipc::SharedMemory SharedMemory;
    typedef mozilla::ipc::Trigger Trigger;

public:
    PBrowserParent();

    virtual ~PBrowserParent();

    PContentParent*
    Manager() const;

    void
    ManagedPContentDialogParent(InfallibleTArray<PContentDialogParent*>& aArr) const;
    const InfallibleTArray<PContentDialogParent*>&
    ManagedPContentDialogParent() const;

    void
    ManagedPDocumentRendererParent(InfallibleTArray<PDocumentRendererParent*>& aArr) const;
    const InfallibleTArray<PDocumentRendererParent*>&
    ManagedPDocumentRendererParent() const;

    void
    ManagedPContentPermissionRequestParent(InfallibleTArray<PContentPermissionRequestParent*>& aArr) const;
    const InfallibleTArray<PContentPermissionRequestParent*>&
    ManagedPContentPermissionRequestParent() const;

    void
    ManagedPRenderFrameParent(InfallibleTArray<PRenderFrameParent*>& aArr) const;
    const InfallibleTArray<PRenderFrameParent*>&
    ManagedPRenderFrameParent() const;

    void
    ManagedPOfflineCacheUpdateParent(InfallibleTArray<POfflineCacheUpdateParent*>& aArr) const;
    const InfallibleTArray<POfflineCacheUpdateParent*>&
    ManagedPOfflineCacheUpdateParent() const;

    void
    ManagedPIndexedDBParent(InfallibleTArray<PIndexedDBParent*>& aArr) const;
    const InfallibleTArray<PIndexedDBParent*>&
    ManagedPIndexedDBParent() const;

    PBrowser::State
    state();

    bool
    SendAsyncMessage(
            const nsString& aMessage,
            const ClonedMessageData& aData) NS_WARN_UNUSED_RESULT;

    bool
    SendShow(const nsIntSize& size) NS_WARN_UNUSED_RESULT;

    bool
    SendLoadURL(const nsCString& uri) NS_WARN_UNUSED_RESULT;

    bool
    SendUpdateDimensions(
            const nsRect& rect,
            const nsIntSize& size,
            const ScreenOrientation& orientation) NS_WARN_UNUSED_RESULT;

    bool
    SendUpdateFrame(const FrameMetrics& frame) NS_WARN_UNUSED_RESULT;

    bool
    SendHandleDoubleTap(const nsIntPoint& point) NS_WARN_UNUSED_RESULT;

    bool
    SendHandleSingleTap(const nsIntPoint& point) NS_WARN_UNUSED_RESULT;

    bool
    SendHandleLongTap(const nsIntPoint& point) NS_WARN_UNUSED_RESULT;

    bool
    SendActivate() NS_WARN_UNUSED_RESULT;

    bool
    SendDeactivate() NS_WARN_UNUSED_RESULT;

    bool
    SendMouseEvent(
            const nsString& aType,
            const float& aX,
            const float& aY,
            const int32_t& aButton,
            const int32_t& aClickCount,
            const int32_t& aModifiers,
            const bool& aIgnoreRootScrollFrame) NS_WARN_UNUSED_RESULT;

    bool
    SendRealMouseEvent(const nsMouseEvent& event) NS_WARN_UNUSED_RESULT;

    bool
    SendRealKeyEvent(const nsKeyEvent& event) NS_WARN_UNUSED_RESULT;

    bool
    SendMouseWheelEvent(const WheelEvent& event) NS_WARN_UNUSED_RESULT;

    bool
    SendRealTouchEvent(const nsTouchEvent& event) NS_WARN_UNUSED_RESULT;

    bool
    SendRealTouchMoveEvent(const nsTouchEvent& event) NS_WARN_UNUSED_RESULT;

    bool
    SendKeyEvent(
            const nsString& aType,
            const int32_t& aKeyCode,
            const int32_t& aCharCode,
            const int32_t& aModifiers,
            const bool& aPreventDefault) NS_WARN_UNUSED_RESULT;

    bool
    SendCompositionEvent(const nsCompositionEvent& event) NS_WARN_UNUSED_RESULT;

    bool
    SendTextEvent(const nsTextEvent& event) NS_WARN_UNUSED_RESULT;

    bool
    SendSelectionEvent(const nsSelectionEvent& event) NS_WARN_UNUSED_RESULT;

    bool
    SendActivateFrameEvent(
            const nsString& aType,
            const bool& capture) NS_WARN_UNUSED_RESULT;

    bool
    SendLoadRemoteScript(const nsString& aURL) NS_WARN_UNUSED_RESULT;

    PDocumentRendererParent*
    SendPDocumentRendererConstructor(
            const nsRect& documentRect,
            const gfxMatrix& transform,
            const nsString& bgcolor,
            const uint32_t& renderFlags,
            const bool& flushLayout,
            const nsIntSize& renderSize) NS_WARN_UNUSED_RESULT;

    PDocumentRendererParent*
    SendPDocumentRendererConstructor(
            PDocumentRendererParent* actor,
            const nsRect& documentRect,
            const gfxMatrix& transform,
            const nsString& bgcolor,
            const uint32_t& renderFlags,
            const bool& flushLayout,
            const nsIntSize& renderSize) NS_WARN_UNUSED_RESULT;

    bool
    SendSetAppType(const nsString& appType) NS_WARN_UNUSED_RESULT;

    bool
    SendDestroy() NS_WARN_UNUSED_RESULT;

    virtual int32_t
    Register(ChannelListener* aRouted);
    virtual int32_t
    RegisterID(
            ChannelListener* aRouted,
            int32_t aId);
    virtual ChannelListener*
    Lookup(int32_t aId);
    virtual void
    Unregister(int32_t aId);
    virtual void
    RemoveManagee(
            int32_t aProtocolId,
            ChannelListener* aListener);
    virtual Shmem::SharedMemory*
    CreateSharedMemory(
            size_t aSize,
            Shmem::SharedMemory::SharedMemoryType aType,
            bool aUnsafe,
            Shmem::id_t* aId);
    virtual bool
    AdoptSharedMemory(
            Shmem::SharedMemory* segment,
            Shmem::id_t* aId);
    virtual Shmem::SharedMemory*
    LookupSharedMemory(Shmem::id_t aId);
    virtual bool
    IsTrackingSharedMemory(Shmem::SharedMemory* segment);
    virtual bool
    DestroySharedMemory(Shmem& shmem);
    virtual ProcessHandle
    OtherProcess() const;
    virtual AsyncChannel*
    GetIPCChannel();

    virtual Result
    OnMessageReceived(const Message& __msg);

    virtual Result
    OnMessageReceived(
            const Message& __msg,
            Message*& __reply);

    virtual Result
    OnCallReceived(
            const Message& __msg,
            Message*& __reply);

    void
    OnProcessingError(Result code);

    int32_t
    GetProtocolTypeId();

    bool
    OnReplyTimeout();

    void
    OnChannelClose();

    void
    OnChannelError();

    void
    OnChannelConnected(int32_t pid);

    // Methods for managing shmem
    bool
    AllocShmem(
            size_t aSize,
            Shmem::SharedMemory::SharedMemoryType aType,
            Shmem* aMem);

    bool
    AllocUnsafeShmem(
            size_t aSize,
            Shmem::SharedMemory::SharedMemoryType aType,
            Shmem* aMem);

    bool
    AdoptShmem(
            Shmem& aMem,
            Shmem* aOutMem);

    bool
    DeallocShmem(Shmem& aMem);

private:
    virtual void
    FatalError(const char* const msg) const;

    void
    DestroySubtree(ActorDestroyReason why);

    void
    DeallocSubtree();

    template<typename T>
    void
    Write(
            const T& __v,
            Message* __msg)
    {
        IPC::WriteParam(__msg, __v);
    }

    template<typename T>
    bool
    Read(
            T* __v,
            const Message* __msg,
            void** __iter)
    {
        return IPC::ReadParam(__msg, __iter, __v);
    }

    void
    Write(
            const ClonedMessageData& __v,
            Message* __msg);

    bool
    Read(
            ClonedMessageData* __v,
            const Message* __msg,
            void** __iter) NS_WARN_UNUSED_RESULT;

    void
    Write(
            PDocumentRendererParent* __v,
            Message* __msg,
            bool __nullable);

    bool
    Read(
            PDocumentRendererParent** __v,
            const Message* __msg,
            void** __iter,
            bool __nullable) NS_WARN_UNUSED_RESULT;

    void
    Write(
            PBrowserParent* __v,
            Message* __msg,
            bool __nullable);

    bool
    Read(
            PBrowserParent** __v,
            const Message* __msg,
            void** __iter,
            bool __nullable) NS_WARN_UNUSED_RESULT;

    void
    Write(
            PContentDialogParent* __v,
            Message* __msg,
            bool __nullable);

    bool
    Read(
            PContentDialogParent** __v,
            const Message* __msg,
            void** __iter,
            bool __nullable) NS_WARN_UNUSED_RESULT;

    void
    Write(
            const InfallibleTArray<PBlobParent*>& __v,
            Message* __msg);

    bool
    Read(
            InfallibleTArray<PBlobParent*>* __v,
            const Message* __msg,
            void** __iter) NS_WARN_UNUSED_RESULT;

    void
    Write(
            const SimpleURIParams& __v,
            Message* __msg);

    bool
    Read(
            SimpleURIParams* __v,
            const Message* __msg,
            void** __iter) NS_WARN_UNUSED_RESULT;

    void
    Write(
            const StandardURLParams& __v,
            Message* __msg);

    bool
    Read(
            StandardURLParams* __v,
            const Message* __msg,
            void** __iter) NS_WARN_UNUSED_RESULT;

    void
    Write(
            POfflineCacheUpdateParent* __v,
            Message* __msg,
            bool __nullable);

    bool
    Read(
            POfflineCacheUpdateParent** __v,
            const Message* __msg,
            void** __iter,
            bool __nullable) NS_WARN_UNUSED_RESULT;

    void
    Write(
            const GenericURIParams& __v,
            Message* __msg);

    bool
    Read(
            GenericURIParams* __v,
            const Message* __msg,
            void** __iter) NS_WARN_UNUSED_RESULT;

    void
    Write(
            const JARURIParams& __v,
            Message* __msg);

    bool
    Read(
            JARURIParams* __v,
            const Message* __msg,
            void** __iter) NS_WARN_UNUSED_RESULT;

    void
    Write(
            const StandardURLSegment& __v,
            Message* __msg);

    bool
    Read(
            StandardURLSegment* __v,
            const Message* __msg,
            void** __iter) NS_WARN_UNUSED_RESULT;

    void
    Write(
            const URIParams& __v,
            Message* __msg);

    bool
    Read(
            URIParams* __v,
            const Message* __msg,
            void** __iter) NS_WARN_UNUSED_RESULT;

    void
    Write(
            PBlobParent* __v,
            Message* __msg,
            bool __nullable);

    bool
    Read(
            PBlobParent** __v,
            const Message* __msg,
            void** __iter,
            bool __nullable) NS_WARN_UNUSED_RESULT;

    void
    Write(
            PIndexedDBParent* __v,
            Message* __msg,
            bool __nullable);

    bool
    Read(
            PIndexedDBParent** __v,
            const Message* __msg,
            void** __iter,
            bool __nullable) NS_WARN_UNUSED_RESULT;

    void
    Write(
            PRenderFrameParent* __v,
            Message* __msg,
            bool __nullable);

    bool
    Read(
            PRenderFrameParent** __v,
            const Message* __msg,
            void** __iter,
            bool __nullable) NS_WARN_UNUSED_RESULT;

    void
    Write(
            PContentPermissionRequestParent* __v,
            Message* __msg,
            bool __nullable);

    bool
    Read(
            PContentPermissionRequestParent** __v,
            const Message* __msg,
            void** __iter,
            bool __nullable) NS_WARN_UNUSED_RESULT;

    Channel* mChannel;
    mozilla::ipc::IProtocolManager<mozilla::ipc::RPCChannel::RPCListener>* mManager;
    int32_t mId;
    State mState;
    // Sorted by pointer value
    InfallibleTArray<PContentDialogParent*> mManagedPContentDialogParent;
    // Sorted by pointer value
    InfallibleTArray<PDocumentRendererParent*> mManagedPDocumentRendererParent;
    // Sorted by pointer value
    InfallibleTArray<PContentPermissionRequestParent*> mManagedPContentPermissionRequestParent;
    // Sorted by pointer value
    InfallibleTArray<PRenderFrameParent*> mManagedPRenderFrameParent;
    // Sorted by pointer value
    InfallibleTArray<POfflineCacheUpdateParent*> mManagedPOfflineCacheUpdateParent;
    // Sorted by pointer value
    InfallibleTArray<PIndexedDBParent*> mManagedPIndexedDBParent;
};


} // namespace dom
} // namespace mozilla

#if 0

//-----------------------------------------------------------------------------
// Skeleton implementation of abstract actor class

// Header file contents
namespace mozilla {
namespace dom {
class BrowserParent :
    public PBrowserParent
{
    virtual bool
    RecvAsyncMessage(
            const nsString& aMessage,
            const ClonedMessageData& aData);

    virtual bool
    RecvMoveFocus(const bool& forward);

    virtual bool
    RecvEvent(const RemoteDOMEvent& aEvent);

    virtual bool
    AnswerCreateWindow(PBrowserParent** window);

    virtual bool
    RecvSyncMessage(
            const nsString& aMessage,
            const ClonedMessageData& aData,
            InfallibleTArray<nsString>* retval);

    virtual bool
    RecvNotifyIMEFocus(
            const bool& focus,
            nsIMEUpdatePreference* preference,
            uint32_t* seqno);

    virtual bool
    RecvNotifyIMETextChange(
            const uint32_t& offset,
            const uint32_t& end,
            const uint32_t& newEnd);

    virtual bool
    RecvNotifyIMESelection(
            const uint32_t& seqno,
            const uint32_t& anchor,
            const uint32_t& focus);

    virtual bool
    RecvNotifyIMETextHint(const nsString& text);

    virtual bool
    RecvEndIMEComposition(
            const bool& cancel,
            nsString* composition);

    virtual bool
    RecvGetInputContext(
            int32_t* IMEEnabled,
            int32_t* IMEOpen,
            intptr_t* NativeIMEContext);

    virtual bool
    RecvSetInputContext(
            const int32_t& IMEEnabled,
            const int32_t& IMEOpen,
            const nsString& type,
            const nsString& inputmode,
            const nsString& actionHint,
            const int32_t& cause,
            const int32_t& focusChange);

    virtual bool
    RecvGetDPI(float* value);

    virtual bool
    RecvGetWidgetNativeData(WindowsHandle* value);

    virtual bool
    RecvSetCursor(const uint32_t& value);

    virtual bool
    RecvSetBackgroundColor(const nscolor& color);

    virtual bool
    RecvBrowserFrameOpenWindow(
            PBrowserParent* opener,
            const nsString& aURL,
            const nsString& aName,
            const nsString& aFeatures,
            bool* windowOpened);

    virtual bool
    RecvZoomToRect(const gfxRect& aRect);

    virtual bool
    RecvContentReceivedTouch(const bool& aPreventDefault);

    virtual bool
    RecvUpdateZoomConstraints(
            const bool& aAllowZoom,
            const float& aMinZoom,
            const float& aMaxZoom);

    virtual PContentPermissionRequestParent*
    AllocPContentPermissionRequest(
            const nsCString& aType,
            const nsCString& aAccess,
            const Principal& principal);

    virtual bool
    DeallocPContentPermissionRequest(PContentPermissionRequestParent* actor);

    virtual PContentDialogParent*
    AllocPContentDialog(
            const uint32_t& aType,
            const nsCString& aName,
            const nsCString& aFeatures,
            const InfallibleTArray<int32_t>& aIntParams,
            const InfallibleTArray<nsString>& aStringParams);

    virtual bool
    DeallocPContentDialog(PContentDialogParent* actor);

    virtual PRenderFrameParent*
    AllocPRenderFrame(
            ScrollingBehavior* scrolling,
            LayersBackend* backend,
            int32_t* maxTextureSize,
            uint64_t* layersId);

    virtual bool
    DeallocPRenderFrame(PRenderFrameParent* actor);

    virtual POfflineCacheUpdateParent*
    AllocPOfflineCacheUpdate(
            const URIParams& manifestURI,
            const URIParams& documentURI,
            const bool& stickDocument);

    virtual bool
    DeallocPOfflineCacheUpdate(POfflineCacheUpdateParent* actor);

    virtual PIndexedDBParent*
    AllocPIndexedDB(
            const nsCString& asciiOrigin,
            bool* allowed);

    virtual bool
    DeallocPIndexedDB(PIndexedDBParent* actor);

    virtual PDocumentRendererParent*
    AllocPDocumentRenderer(
            const nsRect& documentRect,
            const gfxMatrix& transform,
            const nsString& bgcolor,
            const uint32_t& renderFlags,
            const bool& flushLayout,
            const nsIntSize& renderSize);

    virtual bool
    DeallocPDocumentRenderer(PDocumentRendererParent* actor);

    BrowserParent();
    virtual ~BrowserParent();
};
} // namespace dom
} // namespace mozilla


// C++ file contents
namespace mozilla {
namespace dom {
bool
BrowserParent::RecvAsyncMessage(
        const nsString& aMessage,
        const ClonedMessageData& aData)
{
    return false;
}

bool
BrowserParent::RecvMoveFocus(const bool& forward)
{
    return false;
}

bool
BrowserParent::RecvEvent(const RemoteDOMEvent& aEvent)
{
    return false;
}

bool
BrowserParent::AnswerCreateWindow(PBrowserParent** window)
{
    return false;
}

bool
BrowserParent::RecvSyncMessage(
        const nsString& aMessage,
        const ClonedMessageData& aData,
        InfallibleTArray<nsString>* retval)
{
    return false;
}

bool
BrowserParent::RecvNotifyIMEFocus(
        const bool& focus,
        nsIMEUpdatePreference* preference,
        uint32_t* seqno)
{
    return false;
}

bool
BrowserParent::RecvNotifyIMETextChange(
        const uint32_t& offset,
        const uint32_t& end,
        const uint32_t& newEnd)
{
    return false;
}

bool
BrowserParent::RecvNotifyIMESelection(
        const uint32_t& seqno,
        const uint32_t& anchor,
        const uint32_t& focus)
{
    return false;
}

bool
BrowserParent::RecvNotifyIMETextHint(const nsString& text)
{
    return false;
}

bool
BrowserParent::RecvEndIMEComposition(
        const bool& cancel,
        nsString* composition)
{
    return false;
}

bool
BrowserParent::RecvGetInputContext(
        int32_t* IMEEnabled,
        int32_t* IMEOpen,
        intptr_t* NativeIMEContext)
{
    return false;
}

bool
BrowserParent::RecvSetInputContext(
        const int32_t& IMEEnabled,
        const int32_t& IMEOpen,
        const nsString& type,
        const nsString& inputmode,
        const nsString& actionHint,
        const int32_t& cause,
        const int32_t& focusChange)
{
    return false;
}

bool
BrowserParent::RecvGetDPI(float* value)
{
    return false;
}

bool
BrowserParent::RecvGetWidgetNativeData(WindowsHandle* value)
{
    return false;
}

bool
BrowserParent::RecvSetCursor(const uint32_t& value)
{
    return false;
}

bool
BrowserParent::RecvSetBackgroundColor(const nscolor& color)
{
    return false;
}

bool
BrowserParent::RecvBrowserFrameOpenWindow(
        PBrowserParent* opener,
        const nsString& aURL,
        const nsString& aName,
        const nsString& aFeatures,
        bool* windowOpened)
{
    return false;
}

bool
BrowserParent::RecvZoomToRect(const gfxRect& aRect)
{
    return false;
}

bool
BrowserParent::RecvContentReceivedTouch(const bool& aPreventDefault)
{
    return false;
}

bool
BrowserParent::RecvUpdateZoomConstraints(
        const bool& aAllowZoom,
        const float& aMinZoom,
        const float& aMaxZoom)
{
    return false;
}

PContentPermissionRequestParent*
BrowserParent::AllocPContentPermissionRequest(
        const nsCString& aType,
        const nsCString& aAccess,
        const Principal& principal)
{
    return 0;
}

bool
BrowserParent::DeallocPContentPermissionRequest(PContentPermissionRequestParent* actor)
{
    return false;
}

PContentDialogParent*
BrowserParent::AllocPContentDialog(
        const uint32_t& aType,
        const nsCString& aName,
        const nsCString& aFeatures,
        const InfallibleTArray<int32_t>& aIntParams,
        const InfallibleTArray<nsString>& aStringParams)
{
    return 0;
}

bool
BrowserParent::DeallocPContentDialog(PContentDialogParent* actor)
{
    return false;
}

PRenderFrameParent*
BrowserParent::AllocPRenderFrame(
        ScrollingBehavior* scrolling,
        LayersBackend* backend,
        int32_t* maxTextureSize,
        uint64_t* layersId)
{
    return 0;
}

bool
BrowserParent::DeallocPRenderFrame(PRenderFrameParent* actor)
{
    return false;
}

POfflineCacheUpdateParent*
BrowserParent::AllocPOfflineCacheUpdate(
        const URIParams& manifestURI,
        const URIParams& documentURI,
        const bool& stickDocument)
{
    return 0;
}

bool
BrowserParent::DeallocPOfflineCacheUpdate(POfflineCacheUpdateParent* actor)
{
    return false;
}

PIndexedDBParent*
BrowserParent::AllocPIndexedDB(
        const nsCString& asciiOrigin,
        bool* allowed)
{
    return 0;
}

bool
BrowserParent::DeallocPIndexedDB(PIndexedDBParent* actor)
{
    return false;
}

PDocumentRendererParent*
BrowserParent::AllocPDocumentRenderer(
        const nsRect& documentRect,
        const gfxMatrix& transform,
        const nsString& bgcolor,
        const uint32_t& renderFlags,
        const bool& flushLayout,
        const nsIntSize& renderSize)
{
    return 0;
}

bool
BrowserParent::DeallocPDocumentRenderer(PDocumentRendererParent* actor)
{
    return false;
}

BrowserParent::BrowserParent()
{
    MOZ_COUNT_CTOR(BrowserParent);
}

BrowserParent::~BrowserParent()
{
    MOZ_COUNT_DTOR(BrowserParent);
}

} // namespace dom
} // namespace mozilla
#endif // if 0

#endif // ifndef PBrowserParent_h
