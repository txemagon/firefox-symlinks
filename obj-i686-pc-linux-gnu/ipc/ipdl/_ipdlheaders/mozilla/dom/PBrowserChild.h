//
// Automatically generated by ipdlc.
// Edit at your own risk
//

#ifndef PBrowserChild_h
#define PBrowserChild_h

#include "mozilla/dom/PBrowser.h"
namespace mozilla {
namespace dom {
class PBlobChild;
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace dom {
class PContentChild;
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace dom {
class PContentDialogChild;
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
class PDocumentRendererChild;
} // namespace ipc
} // namespace mozilla

namespace mozilla {
namespace dom {
class PContentPermissionRequestChild;
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace layout {
class PRenderFrameChild;
} // namespace layout
} // namespace mozilla

namespace mozilla {
namespace docshell {
class POfflineCacheUpdateChild;
} // namespace docshell
} // namespace mozilla

namespace mozilla {
namespace dom {
namespace indexedDB {
class PIndexedDBChild;
} // namespace indexedDB
} // namespace dom
} // namespace mozilla

#ifdef DEBUG
#include "prenv.h"
#endif // DEBUG
#include "base/id_map.h"
#include "mozilla/ipc/RPCChannel.h"


namespace mozilla {
namespace dom {
namespace indexedDB {
class PIndexedDBChild;
} // namespace indexedDB
} // namespace dom
} // namespace mozilla


namespace mozilla {
namespace dom {
class PContentPermissionRequestChild;
} // namespace dom
} // namespace mozilla


namespace mozilla {
namespace layout {
class PRenderFrameChild;
} // namespace layout
} // namespace mozilla


namespace mozilla {
namespace net {
class PCookieServiceChild;
} // namespace net
} // namespace mozilla


namespace mozilla {
namespace net {
class PWyciwygChannelChild;
} // namespace net
} // namespace mozilla


namespace mozilla {
namespace dom {
class PContentDialogChild;
} // namespace dom
} // namespace mozilla


namespace mozilla {
namespace docshell {
class POfflineCacheUpdateChild;
} // namespace docshell
} // namespace mozilla


namespace mozilla {
namespace net {
class PNeckoChild;
} // namespace net
} // namespace mozilla


namespace mozilla {
namespace dom {
class PContentChild;
} // namespace dom
} // namespace mozilla


namespace mozilla {
namespace ipc {
class PDocumentRendererChild;
} // namespace ipc
} // namespace mozilla


namespace mozilla {
namespace hal_sandbox {
class PHalChild;
} // namespace hal_sandbox
} // namespace mozilla

namespace mozilla {
namespace dom {


class /*NS_ABSTRACT_CLASS*/ PBrowserChild :
    protected mozilla::ipc::RPCChannel::RPCListener,
    protected mozilla::ipc::IProtocolManager<mozilla::ipc::RPCChannel::RPCListener>
{
    friend class mozilla::dom::indexedDB::PIndexedDBChild;

    friend class mozilla::dom::PContentPermissionRequestChild;

    friend class mozilla::layout::PRenderFrameChild;

    friend class mozilla::net::PCookieServiceChild;

    friend class mozilla::net::PWyciwygChannelChild;

    friend class mozilla::dom::PContentDialogChild;

    friend class mozilla::docshell::POfflineCacheUpdateChild;

    friend class mozilla::net::PNeckoChild;

    friend class mozilla::dom::PContentChild;

    friend class mozilla::ipc::PDocumentRendererChild;

    friend class mozilla::hal_sandbox::PHalChild;

protected:
    typedef mozilla::ipc::ActorHandle ActorHandle;
    typedef mozilla::dom::ClonedMessageData ClonedMessageData;
    typedef mozilla::dom::FileBlobConstructorParams FileBlobConstructorParams;
    typedef mozilla::ipc::FileDescriptor FileDescriptor;
    typedef mozilla::layers::FrameMetrics FrameMetrics;
    typedef mozilla::ipc::GenericURIParams GenericURIParams;
    typedef mozilla::ipc::JARURIParams JARURIParams;
    typedef mozilla::layers::LayersBackend LayersBackend;
    typedef mozilla::dom::NormalBlobConstructorParams NormalBlobConstructorParams;
    typedef mozilla::ipc::OptionalURIParams OptionalURIParams;
    typedef IPC::Principal Principal;
    typedef mozilla::dom::ScreenOrientation ScreenOrientation;
    typedef mozilla::layout::ScrollingBehavior ScrollingBehavior;
    typedef mozilla::SerializedStructuredCloneBuffer SerializedStructuredCloneBuffer;
    typedef mozilla::ipc::Shmem Shmem;
    typedef mozilla::ipc::SimpleURIParams SimpleURIParams;
    typedef mozilla::ipc::StandardURLParams StandardURLParams;
    typedef mozilla::ipc::StandardURLSegment StandardURLSegment;
    typedef mozilla::ipc::URIParams URIParams;
    typedef mozilla::widget::WheelEvent WheelEvent;
    typedef mozilla::WindowsHandle WindowsHandle;
    typedef mozilla::void_t void_t;
    typedef mozilla::dom::PBlobChild PBlobChild;
    typedef mozilla::dom::PContentChild PContentChild;
    typedef mozilla::dom::PContentDialogChild PContentDialogChild;
    typedef mozilla::ipc::PDocumentRendererChild PDocumentRendererChild;
    typedef mozilla::dom::PContentPermissionRequestChild PContentPermissionRequestChild;
    typedef mozilla::layout::PRenderFrameChild PRenderFrameChild;
    typedef mozilla::docshell::POfflineCacheUpdateChild POfflineCacheUpdateChild;
    typedef mozilla::dom::indexedDB::PIndexedDBChild PIndexedDBChild;
    typedef base::ProcessId ProcessId;
    typedef mozilla::ipc::ProtocolId ProtocolId;
    typedef mozilla::ipc::Transport Transport;
    typedef mozilla::ipc::TransportDescriptor TransportDescriptor;

    typedef PBrowser::State State;

    virtual bool
    RecvAsyncMessage(
            const nsString& aMessage,
            const ClonedMessageData& aData) = 0;
    virtual bool
    RecvShow(const nsIntSize& size) = 0;
    virtual bool
    RecvLoadURL(const nsCString& uri) = 0;
    virtual bool
    RecvUpdateDimensions(
            const nsRect& rect,
            const nsIntSize& size,
            const ScreenOrientation& orientation) = 0;
    virtual bool
    RecvUpdateFrame(const FrameMetrics& frame) = 0;
    virtual bool
    RecvHandleDoubleTap(const nsIntPoint& point) = 0;
    virtual bool
    RecvHandleSingleTap(const nsIntPoint& point) = 0;
    virtual bool
    RecvHandleLongTap(const nsIntPoint& point) = 0;
    virtual bool
    RecvActivate() = 0;
    virtual bool
    RecvDeactivate() = 0;
    virtual bool
    RecvMouseEvent(
            const nsString& aType,
            const float& aX,
            const float& aY,
            const int32_t& aButton,
            const int32_t& aClickCount,
            const int32_t& aModifiers,
            const bool& aIgnoreRootScrollFrame) = 0;
    virtual bool
    RecvRealMouseEvent(const nsMouseEvent& event) = 0;
    virtual bool
    RecvRealKeyEvent(const nsKeyEvent& event) = 0;
    virtual bool
    RecvMouseWheelEvent(const WheelEvent& event) = 0;
    virtual bool
    RecvRealTouchEvent(const nsTouchEvent& event) = 0;
    virtual bool
    RecvRealTouchMoveEvent(const nsTouchEvent& event) = 0;
    virtual bool
    RecvKeyEvent(
            const nsString& aType,
            const int32_t& aKeyCode,
            const int32_t& aCharCode,
            const int32_t& aModifiers,
            const bool& aPreventDefault) = 0;
    virtual bool
    RecvCompositionEvent(const nsCompositionEvent& event) = 0;
    virtual bool
    RecvTextEvent(const nsTextEvent& event) = 0;
    virtual bool
    RecvSelectionEvent(const nsSelectionEvent& event) = 0;
    virtual bool
    RecvActivateFrameEvent(
            const nsString& aType,
            const bool& capture) = 0;
    virtual bool
    RecvLoadRemoteScript(const nsString& aURL) = 0;
    virtual bool
    RecvPDocumentRendererConstructor(
            PDocumentRendererChild* actor,
            const nsRect& documentRect,
            const gfxMatrix& transform,
            const nsString& bgcolor,
            const uint32_t& renderFlags,
            const bool& flushLayout,
            const nsIntSize& renderSize);
    virtual bool
    RecvSetAppType(const nsString& appType) = 0;
    virtual bool
    RecvDestroy() = 0;
    virtual PContentPermissionRequestChild*
    AllocPContentPermissionRequest(
            const nsCString& aType,
            const nsCString& aAccess,
            const Principal& principal) = 0;
    virtual bool
    DeallocPContentPermissionRequest(PContentPermissionRequestChild* actor) = 0;
    virtual PContentDialogChild*
    AllocPContentDialog(
            const uint32_t& aType,
            const nsCString& aName,
            const nsCString& aFeatures,
            const InfallibleTArray<int32_t>& aIntParams,
            const InfallibleTArray<nsString>& aStringParams) = 0;
    virtual bool
    DeallocPContentDialog(PContentDialogChild* actor) = 0;
    virtual PRenderFrameChild*
    AllocPRenderFrame(
            ScrollingBehavior* scrolling,
            LayersBackend* backend,
            int32_t* maxTextureSize,
            uint64_t* layersId) = 0;
    virtual bool
    DeallocPRenderFrame(PRenderFrameChild* actor) = 0;
    virtual POfflineCacheUpdateChild*
    AllocPOfflineCacheUpdate(
            const URIParams& manifestURI,
            const URIParams& documentURI,
            const bool& stickDocument) = 0;
    virtual bool
    DeallocPOfflineCacheUpdate(POfflineCacheUpdateChild* actor) = 0;
    virtual PIndexedDBChild*
    AllocPIndexedDB(
            const nsCString& asciiOrigin,
            bool* allowed) = 0;
    virtual bool
    DeallocPIndexedDB(PIndexedDBChild* actor) = 0;
    virtual PDocumentRendererChild*
    AllocPDocumentRenderer(
            const nsRect& documentRect,
            const gfxMatrix& transform,
            const nsString& bgcolor,
            const uint32_t& renderFlags,
            const bool& flushLayout,
            const nsIntSize& renderSize) = 0;
    virtual bool
    DeallocPDocumentRenderer(PDocumentRendererChild* actor) = 0;

    virtual void
    ActorDestroy(ActorDestroyReason why);

public:
    typedef IPC::Message Message;
    typedef mozilla::ipc::RPCChannel Channel;
    typedef mozilla::ipc::RPCChannel::RPCListener ChannelListener;
    typedef base::ProcessHandle ProcessHandle;
    typedef mozilla::ipc::AsyncChannel AsyncChannel;
    typedef mozilla::ipc::SharedMemory SharedMemory;
    typedef mozilla::ipc::Trigger Trigger;

public:
    PBrowserChild();

    virtual ~PBrowserChild();

    PContentChild*
    Manager() const;

    void
    ManagedPContentDialogChild(InfallibleTArray<PContentDialogChild*>& aArr) const;
    const InfallibleTArray<PContentDialogChild*>&
    ManagedPContentDialogChild() const;

    void
    ManagedPDocumentRendererChild(InfallibleTArray<PDocumentRendererChild*>& aArr) const;
    const InfallibleTArray<PDocumentRendererChild*>&
    ManagedPDocumentRendererChild() const;

    void
    ManagedPContentPermissionRequestChild(InfallibleTArray<PContentPermissionRequestChild*>& aArr) const;
    const InfallibleTArray<PContentPermissionRequestChild*>&
    ManagedPContentPermissionRequestChild() const;

    void
    ManagedPRenderFrameChild(InfallibleTArray<PRenderFrameChild*>& aArr) const;
    const InfallibleTArray<PRenderFrameChild*>&
    ManagedPRenderFrameChild() const;

    void
    ManagedPOfflineCacheUpdateChild(InfallibleTArray<POfflineCacheUpdateChild*>& aArr) const;
    const InfallibleTArray<POfflineCacheUpdateChild*>&
    ManagedPOfflineCacheUpdateChild() const;

    void
    ManagedPIndexedDBChild(InfallibleTArray<PIndexedDBChild*>& aArr) const;
    const InfallibleTArray<PIndexedDBChild*>&
    ManagedPIndexedDBChild() const;

    PBrowser::State
    state();

    bool
    SendAsyncMessage(
            const nsString& aMessage,
            const ClonedMessageData& aData);

    bool
    SendMoveFocus(const bool& forward);

    bool
    SendEvent(const RemoteDOMEvent& aEvent);

    bool
    CallCreateWindow(PBrowserChild** window);

    bool
    SendSyncMessage(
            const nsString& aMessage,
            const ClonedMessageData& aData,
            InfallibleTArray<nsString>* retval);

    bool
    SendNotifyIMEFocus(
            const bool& focus,
            nsIMEUpdatePreference* preference,
            uint32_t* seqno);

    bool
    SendNotifyIMETextChange(
            const uint32_t& offset,
            const uint32_t& end,
            const uint32_t& newEnd);

    bool
    SendNotifyIMESelection(
            const uint32_t& seqno,
            const uint32_t& anchor,
            const uint32_t& focus);

    bool
    SendNotifyIMETextHint(const nsString& text);

    bool
    SendEndIMEComposition(
            const bool& cancel,
            nsString* composition);

    bool
    SendGetInputContext(
            int32_t* IMEEnabled,
            int32_t* IMEOpen,
            intptr_t* NativeIMEContext);

    bool
    SendSetInputContext(
            const int32_t& IMEEnabled,
            const int32_t& IMEOpen,
            const nsString& type,
            const nsString& inputmode,
            const nsString& actionHint,
            const int32_t& cause,
            const int32_t& focusChange);

    bool
    SendGetDPI(float* value);

    bool
    SendGetWidgetNativeData(WindowsHandle* value);

    bool
    SendSetCursor(const uint32_t& value);

    bool
    SendSetBackgroundColor(const nscolor& color);

    PContentPermissionRequestChild*
    SendPContentPermissionRequestConstructor(
            const nsCString& aType,
            const nsCString& aAccess,
            const Principal& principal);

    PContentPermissionRequestChild*
    SendPContentPermissionRequestConstructor(
            PContentPermissionRequestChild* actor,
            const nsCString& aType,
            const nsCString& aAccess,
            const Principal& principal);

    PContentDialogChild*
    SendPContentDialogConstructor(
            const uint32_t& aType,
            const nsCString& aName,
            const nsCString& aFeatures,
            const InfallibleTArray<int32_t>& aIntParams,
            const InfallibleTArray<nsString>& aStringParams);

    PContentDialogChild*
    SendPContentDialogConstructor(
            PContentDialogChild* actor,
            const uint32_t& aType,
            const nsCString& aName,
            const nsCString& aFeatures,
            const InfallibleTArray<int32_t>& aIntParams,
            const InfallibleTArray<nsString>& aStringParams);

    PRenderFrameChild*
    SendPRenderFrameConstructor(
            ScrollingBehavior* scrolling,
            LayersBackend* backend,
            int32_t* maxTextureSize,
            uint64_t* layersId);

    PRenderFrameChild*
    SendPRenderFrameConstructor(
            PRenderFrameChild* actor,
            ScrollingBehavior* scrolling,
            LayersBackend* backend,
            int32_t* maxTextureSize,
            uint64_t* layersId);

    POfflineCacheUpdateChild*
    SendPOfflineCacheUpdateConstructor(
            const URIParams& manifestURI,
            const URIParams& documentURI,
            const bool& stickDocument);

    POfflineCacheUpdateChild*
    SendPOfflineCacheUpdateConstructor(
            POfflineCacheUpdateChild* actor,
            const URIParams& manifestURI,
            const URIParams& documentURI,
            const bool& stickDocument);

    PIndexedDBChild*
    SendPIndexedDBConstructor(
            const nsCString& asciiOrigin,
            bool* allowed);

    PIndexedDBChild*
    SendPIndexedDBConstructor(
            PIndexedDBChild* actor,
            const nsCString& asciiOrigin,
            bool* allowed);

    bool
    SendBrowserFrameOpenWindow(
            PBrowserChild* opener,
            const nsString& aURL,
            const nsString& aName,
            const nsString& aFeatures,
            bool* windowOpened);

    bool
    SendZoomToRect(const gfxRect& aRect);

    bool
    SendContentReceivedTouch(const bool& aPreventDefault);

    bool
    SendUpdateZoomConstraints(
            const bool& aAllowZoom,
            const float& aMinZoom,
            const float& aMaxZoom);

    static bool
    Send__delete__(PBrowserChild* actor);

    virtual int32_t
    Register(ChannelListener* aRouted);
    virtual int32_t
    RegisterID(
            ChannelListener* aRouted,
            int32_t aId);
    virtual ChannelListener*
    Lookup(int32_t aId);
    virtual void
    Unregister(int32_t aId);
    virtual void
    RemoveManagee(
            int32_t aProtocolId,
            ChannelListener* aListener);
    virtual Shmem::SharedMemory*
    CreateSharedMemory(
            size_t aSize,
            Shmem::SharedMemory::SharedMemoryType aType,
            bool aUnsafe,
            Shmem::id_t* aId);
    virtual bool
    AdoptSharedMemory(
            Shmem::SharedMemory* segment,
            Shmem::id_t* aId);
    virtual Shmem::SharedMemory*
    LookupSharedMemory(Shmem::id_t aId);
    virtual bool
    IsTrackingSharedMemory(Shmem::SharedMemory* segment);
    virtual bool
    DestroySharedMemory(Shmem& shmem);
    virtual ProcessHandle
    OtherProcess() const;
    virtual AsyncChannel*
    GetIPCChannel();

    virtual Result
    OnMessageReceived(const Message& __msg);

    virtual Result
    OnMessageReceived(
            const Message& __msg,
            Message*& __reply);

    virtual Result
    OnCallReceived(
            const Message& __msg,
            Message*& __reply);

    void
    OnProcessingError(Result code);

    int32_t
    GetProtocolTypeId();

    bool
    OnReplyTimeout();

    void
    OnChannelClose();

    void
    OnChannelError();

    void
    OnChannelConnected(int32_t pid);

    // Methods for managing shmem
    bool
    AllocShmem(
            size_t aSize,
            Shmem::SharedMemory::SharedMemoryType aType,
            Shmem* aMem);

    bool
    AllocUnsafeShmem(
            size_t aSize,
            Shmem::SharedMemory::SharedMemoryType aType,
            Shmem* aMem);

    bool
    AdoptShmem(
            Shmem& aMem,
            Shmem* aOutMem);

    bool
    DeallocShmem(Shmem& aMem);

private:
    virtual void
    FatalError(const char* const msg) const;

    void
    DestroySubtree(ActorDestroyReason why);

    void
    DeallocSubtree();

    template<typename T>
    void
    Write(
            const T& __v,
            Message* __msg)
    {
        IPC::WriteParam(__msg, __v);
    }

    template<typename T>
    bool
    Read(
            T* __v,
            const Message* __msg,
            void** __iter)
    {
        return IPC::ReadParam(__msg, __iter, __v);
    }

    void
    Write(
            const ClonedMessageData& __v,
            Message* __msg);

    bool
    Read(
            ClonedMessageData* __v,
            const Message* __msg,
            void** __iter) NS_WARN_UNUSED_RESULT;

    void
    Write(
            PDocumentRendererChild* __v,
            Message* __msg,
            bool __nullable);

    bool
    Read(
            PDocumentRendererChild** __v,
            const Message* __msg,
            void** __iter,
            bool __nullable) NS_WARN_UNUSED_RESULT;

    void
    Write(
            PBrowserChild* __v,
            Message* __msg,
            bool __nullable);

    bool
    Read(
            PBrowserChild** __v,
            const Message* __msg,
            void** __iter,
            bool __nullable) NS_WARN_UNUSED_RESULT;

    void
    Write(
            PContentDialogChild* __v,
            Message* __msg,
            bool __nullable);

    bool
    Read(
            PContentDialogChild** __v,
            const Message* __msg,
            void** __iter,
            bool __nullable) NS_WARN_UNUSED_RESULT;

    void
    Write(
            const InfallibleTArray<PBlobChild*>& __v,
            Message* __msg);

    bool
    Read(
            InfallibleTArray<PBlobChild*>* __v,
            const Message* __msg,
            void** __iter) NS_WARN_UNUSED_RESULT;

    void
    Write(
            const SimpleURIParams& __v,
            Message* __msg);

    bool
    Read(
            SimpleURIParams* __v,
            const Message* __msg,
            void** __iter) NS_WARN_UNUSED_RESULT;

    void
    Write(
            const StandardURLParams& __v,
            Message* __msg);

    bool
    Read(
            StandardURLParams* __v,
            const Message* __msg,
            void** __iter) NS_WARN_UNUSED_RESULT;

    void
    Write(
            POfflineCacheUpdateChild* __v,
            Message* __msg,
            bool __nullable);

    bool
    Read(
            POfflineCacheUpdateChild** __v,
            const Message* __msg,
            void** __iter,
            bool __nullable) NS_WARN_UNUSED_RESULT;

    void
    Write(
            const GenericURIParams& __v,
            Message* __msg);

    bool
    Read(
            GenericURIParams* __v,
            const Message* __msg,
            void** __iter) NS_WARN_UNUSED_RESULT;

    void
    Write(
            const JARURIParams& __v,
            Message* __msg);

    bool
    Read(
            JARURIParams* __v,
            const Message* __msg,
            void** __iter) NS_WARN_UNUSED_RESULT;

    void
    Write(
            const StandardURLSegment& __v,
            Message* __msg);

    bool
    Read(
            StandardURLSegment* __v,
            const Message* __msg,
            void** __iter) NS_WARN_UNUSED_RESULT;

    void
    Write(
            const URIParams& __v,
            Message* __msg);

    bool
    Read(
            URIParams* __v,
            const Message* __msg,
            void** __iter) NS_WARN_UNUSED_RESULT;

    void
    Write(
            PBlobChild* __v,
            Message* __msg,
            bool __nullable);

    bool
    Read(
            PBlobChild** __v,
            const Message* __msg,
            void** __iter,
            bool __nullable) NS_WARN_UNUSED_RESULT;

    void
    Write(
            PIndexedDBChild* __v,
            Message* __msg,
            bool __nullable);

    bool
    Read(
            PIndexedDBChild** __v,
            const Message* __msg,
            void** __iter,
            bool __nullable) NS_WARN_UNUSED_RESULT;

    void
    Write(
            PRenderFrameChild* __v,
            Message* __msg,
            bool __nullable);

    bool
    Read(
            PRenderFrameChild** __v,
            const Message* __msg,
            void** __iter,
            bool __nullable) NS_WARN_UNUSED_RESULT;

    void
    Write(
            PContentPermissionRequestChild* __v,
            Message* __msg,
            bool __nullable);

    bool
    Read(
            PContentPermissionRequestChild** __v,
            const Message* __msg,
            void** __iter,
            bool __nullable) NS_WARN_UNUSED_RESULT;

    Channel* mChannel;
    mozilla::ipc::IProtocolManager<mozilla::ipc::RPCChannel::RPCListener>* mManager;
    int32_t mId;
    State mState;
    // Sorted by pointer value
    InfallibleTArray<PContentDialogChild*> mManagedPContentDialogChild;
    // Sorted by pointer value
    InfallibleTArray<PDocumentRendererChild*> mManagedPDocumentRendererChild;
    // Sorted by pointer value
    InfallibleTArray<PContentPermissionRequestChild*> mManagedPContentPermissionRequestChild;
    // Sorted by pointer value
    InfallibleTArray<PRenderFrameChild*> mManagedPRenderFrameChild;
    // Sorted by pointer value
    InfallibleTArray<POfflineCacheUpdateChild*> mManagedPOfflineCacheUpdateChild;
    // Sorted by pointer value
    InfallibleTArray<PIndexedDBChild*> mManagedPIndexedDBChild;
};


} // namespace dom
} // namespace mozilla

#if 0

//-----------------------------------------------------------------------------
// Skeleton implementation of abstract actor class

// Header file contents
namespace mozilla {
namespace dom {
class BrowserChild :
    public PBrowserChild
{
    virtual bool
    RecvAsyncMessage(
            const nsString& aMessage,
            const ClonedMessageData& aData);

    virtual bool
    RecvShow(const nsIntSize& size);

    virtual bool
    RecvLoadURL(const nsCString& uri);

    virtual bool
    RecvUpdateDimensions(
            const nsRect& rect,
            const nsIntSize& size,
            const ScreenOrientation& orientation);

    virtual bool
    RecvUpdateFrame(const FrameMetrics& frame);

    virtual bool
    RecvHandleDoubleTap(const nsIntPoint& point);

    virtual bool
    RecvHandleSingleTap(const nsIntPoint& point);

    virtual bool
    RecvHandleLongTap(const nsIntPoint& point);

    virtual bool
    RecvActivate();

    virtual bool
    RecvDeactivate();

    virtual bool
    RecvMouseEvent(
            const nsString& aType,
            const float& aX,
            const float& aY,
            const int32_t& aButton,
            const int32_t& aClickCount,
            const int32_t& aModifiers,
            const bool& aIgnoreRootScrollFrame);

    virtual bool
    RecvRealMouseEvent(const nsMouseEvent& event);

    virtual bool
    RecvRealKeyEvent(const nsKeyEvent& event);

    virtual bool
    RecvMouseWheelEvent(const WheelEvent& event);

    virtual bool
    RecvRealTouchEvent(const nsTouchEvent& event);

    virtual bool
    RecvRealTouchMoveEvent(const nsTouchEvent& event);

    virtual bool
    RecvKeyEvent(
            const nsString& aType,
            const int32_t& aKeyCode,
            const int32_t& aCharCode,
            const int32_t& aModifiers,
            const bool& aPreventDefault);

    virtual bool
    RecvCompositionEvent(const nsCompositionEvent& event);

    virtual bool
    RecvTextEvent(const nsTextEvent& event);

    virtual bool
    RecvSelectionEvent(const nsSelectionEvent& event);

    virtual bool
    RecvActivateFrameEvent(
            const nsString& aType,
            const bool& capture);

    virtual bool
    RecvLoadRemoteScript(const nsString& aURL);

    virtual bool
    RecvSetAppType(const nsString& appType);

    virtual bool
    RecvDestroy();

    virtual PContentPermissionRequestChild*
    AllocPContentPermissionRequest(
            const nsCString& aType,
            const nsCString& aAccess,
            const Principal& principal);

    virtual bool
    DeallocPContentPermissionRequest(PContentPermissionRequestChild* actor);

    virtual PContentDialogChild*
    AllocPContentDialog(
            const uint32_t& aType,
            const nsCString& aName,
            const nsCString& aFeatures,
            const InfallibleTArray<int32_t>& aIntParams,
            const InfallibleTArray<nsString>& aStringParams);

    virtual bool
    DeallocPContentDialog(PContentDialogChild* actor);

    virtual PRenderFrameChild*
    AllocPRenderFrame(
            ScrollingBehavior* scrolling,
            LayersBackend* backend,
            int32_t* maxTextureSize,
            uint64_t* layersId);

    virtual bool
    DeallocPRenderFrame(PRenderFrameChild* actor);

    virtual POfflineCacheUpdateChild*
    AllocPOfflineCacheUpdate(
            const URIParams& manifestURI,
            const URIParams& documentURI,
            const bool& stickDocument);

    virtual bool
    DeallocPOfflineCacheUpdate(POfflineCacheUpdateChild* actor);

    virtual PIndexedDBChild*
    AllocPIndexedDB(
            const nsCString& asciiOrigin,
            bool* allowed);

    virtual bool
    DeallocPIndexedDB(PIndexedDBChild* actor);

    virtual PDocumentRendererChild*
    AllocPDocumentRenderer(
            const nsRect& documentRect,
            const gfxMatrix& transform,
            const nsString& bgcolor,
            const uint32_t& renderFlags,
            const bool& flushLayout,
            const nsIntSize& renderSize);

    virtual bool
    DeallocPDocumentRenderer(PDocumentRendererChild* actor);

    BrowserChild();
    virtual ~BrowserChild();
};
} // namespace dom
} // namespace mozilla


// C++ file contents
namespace mozilla {
namespace dom {
bool
BrowserChild::RecvAsyncMessage(
        const nsString& aMessage,
        const ClonedMessageData& aData)
{
    return false;
}

bool
BrowserChild::RecvShow(const nsIntSize& size)
{
    return false;
}

bool
BrowserChild::RecvLoadURL(const nsCString& uri)
{
    return false;
}

bool
BrowserChild::RecvUpdateDimensions(
        const nsRect& rect,
        const nsIntSize& size,
        const ScreenOrientation& orientation)
{
    return false;
}

bool
BrowserChild::RecvUpdateFrame(const FrameMetrics& frame)
{
    return false;
}

bool
BrowserChild::RecvHandleDoubleTap(const nsIntPoint& point)
{
    return false;
}

bool
BrowserChild::RecvHandleSingleTap(const nsIntPoint& point)
{
    return false;
}

bool
BrowserChild::RecvHandleLongTap(const nsIntPoint& point)
{
    return false;
}

bool
BrowserChild::RecvActivate()
{
    return false;
}

bool
BrowserChild::RecvDeactivate()
{
    return false;
}

bool
BrowserChild::RecvMouseEvent(
        const nsString& aType,
        const float& aX,
        const float& aY,
        const int32_t& aButton,
        const int32_t& aClickCount,
        const int32_t& aModifiers,
        const bool& aIgnoreRootScrollFrame)
{
    return false;
}

bool
BrowserChild::RecvRealMouseEvent(const nsMouseEvent& event)
{
    return false;
}

bool
BrowserChild::RecvRealKeyEvent(const nsKeyEvent& event)
{
    return false;
}

bool
BrowserChild::RecvMouseWheelEvent(const WheelEvent& event)
{
    return false;
}

bool
BrowserChild::RecvRealTouchEvent(const nsTouchEvent& event)
{
    return false;
}

bool
BrowserChild::RecvRealTouchMoveEvent(const nsTouchEvent& event)
{
    return false;
}

bool
BrowserChild::RecvKeyEvent(
        const nsString& aType,
        const int32_t& aKeyCode,
        const int32_t& aCharCode,
        const int32_t& aModifiers,
        const bool& aPreventDefault)
{
    return false;
}

bool
BrowserChild::RecvCompositionEvent(const nsCompositionEvent& event)
{
    return false;
}

bool
BrowserChild::RecvTextEvent(const nsTextEvent& event)
{
    return false;
}

bool
BrowserChild::RecvSelectionEvent(const nsSelectionEvent& event)
{
    return false;
}

bool
BrowserChild::RecvActivateFrameEvent(
        const nsString& aType,
        const bool& capture)
{
    return false;
}

bool
BrowserChild::RecvLoadRemoteScript(const nsString& aURL)
{
    return false;
}

bool
BrowserChild::RecvSetAppType(const nsString& appType)
{
    return false;
}

bool
BrowserChild::RecvDestroy()
{
    return false;
}

PContentPermissionRequestChild*
BrowserChild::AllocPContentPermissionRequest(
        const nsCString& aType,
        const nsCString& aAccess,
        const Principal& principal)
{
    return 0;
}

bool
BrowserChild::DeallocPContentPermissionRequest(PContentPermissionRequestChild* actor)
{
    return false;
}

PContentDialogChild*
BrowserChild::AllocPContentDialog(
        const uint32_t& aType,
        const nsCString& aName,
        const nsCString& aFeatures,
        const InfallibleTArray<int32_t>& aIntParams,
        const InfallibleTArray<nsString>& aStringParams)
{
    return 0;
}

bool
BrowserChild::DeallocPContentDialog(PContentDialogChild* actor)
{
    return false;
}

PRenderFrameChild*
BrowserChild::AllocPRenderFrame(
        ScrollingBehavior* scrolling,
        LayersBackend* backend,
        int32_t* maxTextureSize,
        uint64_t* layersId)
{
    return 0;
}

bool
BrowserChild::DeallocPRenderFrame(PRenderFrameChild* actor)
{
    return false;
}

POfflineCacheUpdateChild*
BrowserChild::AllocPOfflineCacheUpdate(
        const URIParams& manifestURI,
        const URIParams& documentURI,
        const bool& stickDocument)
{
    return 0;
}

bool
BrowserChild::DeallocPOfflineCacheUpdate(POfflineCacheUpdateChild* actor)
{
    return false;
}

PIndexedDBChild*
BrowserChild::AllocPIndexedDB(
        const nsCString& asciiOrigin,
        bool* allowed)
{
    return 0;
}

bool
BrowserChild::DeallocPIndexedDB(PIndexedDBChild* actor)
{
    return false;
}

PDocumentRendererChild*
BrowserChild::AllocPDocumentRenderer(
        const nsRect& documentRect,
        const gfxMatrix& transform,
        const nsString& bgcolor,
        const uint32_t& renderFlags,
        const bool& flushLayout,
        const nsIntSize& renderSize)
{
    return 0;
}

bool
BrowserChild::DeallocPDocumentRenderer(PDocumentRendererChild* actor)
{
    return false;
}

BrowserChild::BrowserChild()
{
    MOZ_COUNT_CTOR(BrowserChild);
}

BrowserChild::~BrowserChild()
{
    MOZ_COUNT_DTOR(BrowserChild);
}

} // namespace dom
} // namespace mozilla
#endif // if 0

#endif // ifndef PBrowserChild_h
