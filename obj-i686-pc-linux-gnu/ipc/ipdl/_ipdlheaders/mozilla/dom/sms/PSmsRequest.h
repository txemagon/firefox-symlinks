//
// Automatically generated by ipdlc.
// Edit at your own risk
//

#ifndef PSmsRequest_h
#define PSmsRequest_h

#include "mozilla/Attributes.h"
#include "base/basictypes.h"
#include "prtime.h"
#include "nscore.h"
#include "IPCMessageStart.h"
#include "ipc/IPCMessageUtils.h"
#include "nsAutoPtr.h"
#include "nsStringGlue.h"
#include "nsTArray.h"
#include "nsIFile.h"
#include "mozilla/ipc/ProtocolUtils.h"
#include "mozilla/dom/sms/Types.h"
#include "mozilla/dom/sms/SmsTypes.h"

namespace mozilla {
namespace dom {
namespace sms {
class SmsMessageData;
} // namespace sms
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ReplyMessageSend|
//
namespace mozilla {
namespace dom {
namespace sms {
class ReplyMessageSend MOZ_FINAL
{
private:
    typedef mozilla::dom::sms::SmsMessageData SmsMessageData;

public:
    ReplyMessageSend();

    ReplyMessageSend(const SmsMessageData& _messageData)
    {
        Init();
        Assign(_messageData);
    }

    ReplyMessageSend(const ReplyMessageSend& _o)
    {
        Init();
        Assign((_o).messageData());
    }

    ~ReplyMessageSend();

    void
    operator=(const ReplyMessageSend& _o)
    {
        Assign((_o).messageData());
    }

    bool
    operator==(const ReplyMessageSend& _o) const;

    SmsMessageData&
    messageData()
    {
        return messageData_;
    }
    const SmsMessageData&
    messageData() const
    {
        return messageData_;
    }

private:
    void
    Init();

    void
    Assign(const SmsMessageData& _messageData);

    SmsMessageData messageData_;
};
} // namespace sms
} // namespace dom
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ReplyMessageSendFail|
//
namespace mozilla {
namespace dom {
namespace sms {
class ReplyMessageSendFail MOZ_FINAL
{
private:

public:
    ReplyMessageSendFail();

    ReplyMessageSendFail(const int32_t& _error)
    {
        Init();
        Assign(_error);
    }

    ReplyMessageSendFail(const ReplyMessageSendFail& _o)
    {
        Init();
        Assign((_o).error());
    }

    ~ReplyMessageSendFail();

    void
    operator=(const ReplyMessageSendFail& _o)
    {
        Assign((_o).error());
    }

    bool
    operator==(const ReplyMessageSendFail& _o) const;

    int32_t&
    error()
    {
        return error_;
    }
    const int32_t&
    error() const
    {
        return error_;
    }

private:
    void
    Init();

    void
    Assign(const int32_t& _error);

    int32_t error_;
};
} // namespace sms
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace dom {
namespace sms {
class SmsMessageData;
} // namespace sms
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ReplyGetMessage|
//
namespace mozilla {
namespace dom {
namespace sms {
class ReplyGetMessage MOZ_FINAL
{
private:
    typedef mozilla::dom::sms::SmsMessageData SmsMessageData;

public:
    ReplyGetMessage();

    ReplyGetMessage(const SmsMessageData& _messageData)
    {
        Init();
        Assign(_messageData);
    }

    ReplyGetMessage(const ReplyGetMessage& _o)
    {
        Init();
        Assign((_o).messageData());
    }

    ~ReplyGetMessage();

    void
    operator=(const ReplyGetMessage& _o)
    {
        Assign((_o).messageData());
    }

    bool
    operator==(const ReplyGetMessage& _o) const;

    SmsMessageData&
    messageData()
    {
        return messageData_;
    }
    const SmsMessageData&
    messageData() const
    {
        return messageData_;
    }

private:
    void
    Init();

    void
    Assign(const SmsMessageData& _messageData);

    SmsMessageData messageData_;
};
} // namespace sms
} // namespace dom
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ReplyGetMessageFail|
//
namespace mozilla {
namespace dom {
namespace sms {
class ReplyGetMessageFail MOZ_FINAL
{
private:

public:
    ReplyGetMessageFail();

    ReplyGetMessageFail(const int32_t& _error)
    {
        Init();
        Assign(_error);
    }

    ReplyGetMessageFail(const ReplyGetMessageFail& _o)
    {
        Init();
        Assign((_o).error());
    }

    ~ReplyGetMessageFail();

    void
    operator=(const ReplyGetMessageFail& _o)
    {
        Assign((_o).error());
    }

    bool
    operator==(const ReplyGetMessageFail& _o) const;

    int32_t&
    error()
    {
        return error_;
    }
    const int32_t&
    error() const
    {
        return error_;
    }

private:
    void
    Init();

    void
    Assign(const int32_t& _error);

    int32_t error_;
};
} // namespace sms
} // namespace dom
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ReplyMessageDelete|
//
namespace mozilla {
namespace dom {
namespace sms {
class ReplyMessageDelete MOZ_FINAL
{
private:

public:
    ReplyMessageDelete();

    ReplyMessageDelete(const bool& _deleted)
    {
        Init();
        Assign(_deleted);
    }

    ReplyMessageDelete(const ReplyMessageDelete& _o)
    {
        Init();
        Assign((_o).deleted());
    }

    ~ReplyMessageDelete();

    void
    operator=(const ReplyMessageDelete& _o)
    {
        Assign((_o).deleted());
    }

    bool
    operator==(const ReplyMessageDelete& _o) const;

    bool&
    deleted()
    {
        return deleted_;
    }
    const bool&
    deleted() const
    {
        return deleted_;
    }

private:
    void
    Init();

    void
    Assign(const bool& _deleted);

    bool deleted_;
};
} // namespace sms
} // namespace dom
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ReplyMessageDeleteFail|
//
namespace mozilla {
namespace dom {
namespace sms {
class ReplyMessageDeleteFail MOZ_FINAL
{
private:

public:
    ReplyMessageDeleteFail();

    ReplyMessageDeleteFail(const int32_t& _error)
    {
        Init();
        Assign(_error);
    }

    ReplyMessageDeleteFail(const ReplyMessageDeleteFail& _o)
    {
        Init();
        Assign((_o).error());
    }

    ~ReplyMessageDeleteFail();

    void
    operator=(const ReplyMessageDeleteFail& _o)
    {
        Assign((_o).error());
    }

    bool
    operator==(const ReplyMessageDeleteFail& _o) const;

    int32_t&
    error()
    {
        return error_;
    }
    const int32_t&
    error() const
    {
        return error_;
    }

private:
    void
    Init();

    void
    Assign(const int32_t& _error);

    int32_t error_;
};
} // namespace sms
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace dom {
namespace sms {
class SmsMessageData;
} // namespace sms
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ReplyCreateMessageList|
//
namespace mozilla {
namespace dom {
namespace sms {
class ReplyCreateMessageList MOZ_FINAL
{
private:
    typedef mozilla::dom::sms::SmsMessageData SmsMessageData;

public:
    ReplyCreateMessageList();

    ReplyCreateMessageList(
            const int32_t& _listId,
            const SmsMessageData& _messageData)
    {
        Init();
        Assign(_listId, _messageData);
    }

    ReplyCreateMessageList(const ReplyCreateMessageList& _o)
    {
        Init();
        Assign((_o).listId(), (_o).messageData());
    }

    ~ReplyCreateMessageList();

    void
    operator=(const ReplyCreateMessageList& _o)
    {
        Assign((_o).listId(), (_o).messageData());
    }

    bool
    operator==(const ReplyCreateMessageList& _o) const;

    int32_t&
    listId()
    {
        return listId_;
    }
    const int32_t&
    listId() const
    {
        return listId_;
    }

    SmsMessageData&
    messageData()
    {
        return messageData_;
    }
    const SmsMessageData&
    messageData() const
    {
        return messageData_;
    }

private:
    void
    Init();

    void
    Assign(
            const int32_t& _listId,
            const SmsMessageData& _messageData);

    int32_t listId_;
    SmsMessageData messageData_;
};
} // namespace sms
} // namespace dom
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ReplyCreateMessageListFail|
//
namespace mozilla {
namespace dom {
namespace sms {
class ReplyCreateMessageListFail MOZ_FINAL
{
private:

public:
    ReplyCreateMessageListFail();

    ReplyCreateMessageListFail(const int32_t& _error)
    {
        Init();
        Assign(_error);
    }

    ReplyCreateMessageListFail(const ReplyCreateMessageListFail& _o)
    {
        Init();
        Assign((_o).error());
    }

    ~ReplyCreateMessageListFail();

    void
    operator=(const ReplyCreateMessageListFail& _o)
    {
        Assign((_o).error());
    }

    bool
    operator==(const ReplyCreateMessageListFail& _o) const;

    int32_t&
    error()
    {
        return error_;
    }
    const int32_t&
    error() const
    {
        return error_;
    }

private:
    void
    Init();

    void
    Assign(const int32_t& _error);

    int32_t error_;
};
} // namespace sms
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace dom {
namespace sms {
class SmsMessageData;
} // namespace sms
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ReplyGetNextMessage|
//
namespace mozilla {
namespace dom {
namespace sms {
class ReplyGetNextMessage MOZ_FINAL
{
private:
    typedef mozilla::dom::sms::SmsMessageData SmsMessageData;

public:
    ReplyGetNextMessage();

    ReplyGetNextMessage(const SmsMessageData& _messageData)
    {
        Init();
        Assign(_messageData);
    }

    ReplyGetNextMessage(const ReplyGetNextMessage& _o)
    {
        Init();
        Assign((_o).messageData());
    }

    ~ReplyGetNextMessage();

    void
    operator=(const ReplyGetNextMessage& _o)
    {
        Assign((_o).messageData());
    }

    bool
    operator==(const ReplyGetNextMessage& _o) const;

    SmsMessageData&
    messageData()
    {
        return messageData_;
    }
    const SmsMessageData&
    messageData() const
    {
        return messageData_;
    }

private:
    void
    Init();

    void
    Assign(const SmsMessageData& _messageData);

    SmsMessageData messageData_;
};
} // namespace sms
} // namespace dom
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ReplyMarkeMessageRead|
//
namespace mozilla {
namespace dom {
namespace sms {
class ReplyMarkeMessageRead MOZ_FINAL
{
private:

public:
    ReplyMarkeMessageRead();

    ReplyMarkeMessageRead(const bool& _read)
    {
        Init();
        Assign(_read);
    }

    ReplyMarkeMessageRead(const ReplyMarkeMessageRead& _o)
    {
        Init();
        Assign((_o).read());
    }

    ~ReplyMarkeMessageRead();

    void
    operator=(const ReplyMarkeMessageRead& _o)
    {
        Assign((_o).read());
    }

    bool
    operator==(const ReplyMarkeMessageRead& _o) const;

    bool&
    read()
    {
        return read_;
    }
    const bool&
    read() const
    {
        return read_;
    }

private:
    void
    Init();

    void
    Assign(const bool& _read);

    bool read_;
};
} // namespace sms
} // namespace dom
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ReplyMarkeMessageReadFail|
//
namespace mozilla {
namespace dom {
namespace sms {
class ReplyMarkeMessageReadFail MOZ_FINAL
{
private:

public:
    ReplyMarkeMessageReadFail();

    ReplyMarkeMessageReadFail(const int32_t& _error)
    {
        Init();
        Assign(_error);
    }

    ReplyMarkeMessageReadFail(const ReplyMarkeMessageReadFail& _o)
    {
        Init();
        Assign((_o).error());
    }

    ~ReplyMarkeMessageReadFail();

    void
    operator=(const ReplyMarkeMessageReadFail& _o)
    {
        Assign((_o).error());
    }

    bool
    operator==(const ReplyMarkeMessageReadFail& _o) const;

    int32_t&
    error()
    {
        return error_;
    }
    const int32_t&
    error() const
    {
        return error_;
    }

private:
    void
    Init();

    void
    Assign(const int32_t& _error);

    int32_t error_;
};
} // namespace sms
} // namespace dom
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ReplyNoMessageInList|
//
namespace mozilla {
namespace dom {
namespace sms {
class ReplyNoMessageInList MOZ_FINAL
{
private:

public:
    ReplyNoMessageInList()
    {
        Init();
        Assign();
    }

    ReplyNoMessageInList(const ReplyNoMessageInList& _o)
    {
        Init();
        Assign();
    }

    ~ReplyNoMessageInList();

    void
    operator=(const ReplyNoMessageInList& _o)
    {
        Assign();
    }

    bool
    operator==(const ReplyNoMessageInList& _o) const;

private:
    void
    Init();

    void
    Assign();

};
} // namespace sms
} // namespace dom
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ThreadListItem|
//
namespace mozilla {
namespace dom {
namespace sms {
class ThreadListItem MOZ_FINAL
{
private:

public:
    ThreadListItem();

    ThreadListItem(
            const nsString& _senderOrReceiver,
            const uint64_t& _timestamp,
            const nsString& _body,
            const uint64_t& _unreadCount)
    {
        Init();
        Assign(_senderOrReceiver, _timestamp, _body, _unreadCount);
    }

    ThreadListItem(const ThreadListItem& _o)
    {
        Init();
        Assign((_o).senderOrReceiver(), (_o).timestamp(), (_o).body(), (_o).unreadCount());
    }

    ~ThreadListItem();

    void
    operator=(const ThreadListItem& _o)
    {
        Assign((_o).senderOrReceiver(), (_o).timestamp(), (_o).body(), (_o).unreadCount());
    }

    bool
    operator==(const ThreadListItem& _o) const;

    nsString&
    senderOrReceiver()
    {
        return senderOrReceiver_;
    }
    const nsString&
    senderOrReceiver() const
    {
        return senderOrReceiver_;
    }

    uint64_t&
    timestamp()
    {
        return timestamp_;
    }
    const uint64_t&
    timestamp() const
    {
        return timestamp_;
    }

    nsString&
    body()
    {
        return body_;
    }
    const nsString&
    body() const
    {
        return body_;
    }

    uint64_t&
    unreadCount()
    {
        return unreadCount_;
    }
    const uint64_t&
    unreadCount() const
    {
        return unreadCount_;
    }

private:
    void
    Init();

    void
    Assign(
            const nsString& _senderOrReceiver,
            const uint64_t& _timestamp,
            const nsString& _body,
            const uint64_t& _unreadCount);

    nsString senderOrReceiver_;
    uint64_t timestamp_;
    nsString body_;
    uint64_t unreadCount_;
};
} // namespace sms
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace dom {
namespace sms {
class ThreadListItem;
} // namespace sms
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ReplyThreadList|
//
namespace mozilla {
namespace dom {
namespace sms {
class ReplyThreadList MOZ_FINAL
{
private:
    typedef mozilla::dom::sms::ThreadListItem ThreadListItem;

public:
    ReplyThreadList();

    ReplyThreadList(const InfallibleTArray<ThreadListItem>& _items)
    {
        Init();
        Assign(_items);
    }

    ReplyThreadList(const ReplyThreadList& _o)
    {
        Init();
        Assign((_o).items());
    }

    ~ReplyThreadList();

    void
    operator=(const ReplyThreadList& _o)
    {
        Assign((_o).items());
    }

    bool
    operator==(const ReplyThreadList& _o) const;

    InfallibleTArray<ThreadListItem>&
    items()
    {
        return items_;
    }
    const InfallibleTArray<ThreadListItem>&
    items() const
    {
        return items_;
    }

private:
    void
    Init();

    void
    Assign(const InfallibleTArray<ThreadListItem>& _items);

    InfallibleTArray<ThreadListItem> items_;
};
} // namespace sms
} // namespace dom
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ReplyThreadListFail|
//
namespace mozilla {
namespace dom {
namespace sms {
class ReplyThreadListFail MOZ_FINAL
{
private:

public:
    ReplyThreadListFail();

    ReplyThreadListFail(const int32_t& _error)
    {
        Init();
        Assign(_error);
    }

    ReplyThreadListFail(const ReplyThreadListFail& _o)
    {
        Init();
        Assign((_o).error());
    }

    ~ReplyThreadListFail();

    void
    operator=(const ReplyThreadListFail& _o)
    {
        Assign((_o).error());
    }

    bool
    operator==(const ReplyThreadListFail& _o) const;

    int32_t&
    error()
    {
        return error_;
    }
    const int32_t&
    error() const
    {
        return error_;
    }

private:
    void
    Init();

    void
    Assign(const int32_t& _error);

    int32_t error_;
};
} // namespace sms
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace dom {
namespace sms {
class ReplyMessageSend;
} // namespace sms
} // namespace dom
} // namespace mozilla
namespace mozilla {
namespace dom {
namespace sms {
class ReplyMessageSendFail;
} // namespace sms
} // namespace dom
} // namespace mozilla
namespace mozilla {
namespace dom {
namespace sms {
class ReplyGetMessage;
} // namespace sms
} // namespace dom
} // namespace mozilla
namespace mozilla {
namespace dom {
namespace sms {
class ReplyGetMessageFail;
} // namespace sms
} // namespace dom
} // namespace mozilla
namespace mozilla {
namespace dom {
namespace sms {
class ReplyMessageDelete;
} // namespace sms
} // namespace dom
} // namespace mozilla
namespace mozilla {
namespace dom {
namespace sms {
class ReplyMessageDeleteFail;
} // namespace sms
} // namespace dom
} // namespace mozilla
namespace mozilla {
namespace dom {
namespace sms {
class ReplyNoMessageInList;
} // namespace sms
} // namespace dom
} // namespace mozilla
namespace mozilla {
namespace dom {
namespace sms {
class ReplyCreateMessageList;
} // namespace sms
} // namespace dom
} // namespace mozilla
namespace mozilla {
namespace dom {
namespace sms {
class ReplyCreateMessageListFail;
} // namespace sms
} // namespace dom
} // namespace mozilla
namespace mozilla {
namespace dom {
namespace sms {
class ReplyGetNextMessage;
} // namespace sms
} // namespace dom
} // namespace mozilla
namespace mozilla {
namespace dom {
namespace sms {
class ReplyMarkeMessageRead;
} // namespace sms
} // namespace dom
} // namespace mozilla
namespace mozilla {
namespace dom {
namespace sms {
class ReplyMarkeMessageReadFail;
} // namespace sms
} // namespace dom
} // namespace mozilla
namespace mozilla {
namespace dom {
namespace sms {
class ReplyThreadList;
} // namespace sms
} // namespace dom
} // namespace mozilla
namespace mozilla {
namespace dom {
namespace sms {
class ReplyThreadListFail;
} // namespace sms
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union MessageReply|
//
namespace mozilla {
namespace dom {
namespace sms {
class MessageReply MOZ_FINAL
{
public:
    enum Type {
        T__None,
        TReplyMessageSend = 1,
        TReplyMessageSendFail,
        TReplyGetMessage,
        TReplyGetMessageFail,
        TReplyMessageDelete,
        TReplyMessageDeleteFail,
        TReplyNoMessageInList,
        TReplyCreateMessageList,
        TReplyCreateMessageListFail,
        TReplyGetNextMessage,
        TReplyMarkeMessageRead,
        TReplyMarkeMessageReadFail,
        TReplyThreadList,
        TReplyThreadListFail,
        T__Last = TReplyThreadListFail
    };

private:
    typedef mozilla::dom::sms::ReplyMessageSend ReplyMessageSend;
    typedef mozilla::dom::sms::ReplyMessageSendFail ReplyMessageSendFail;
    typedef mozilla::dom::sms::ReplyGetMessage ReplyGetMessage;
    typedef mozilla::dom::sms::ReplyGetMessageFail ReplyGetMessageFail;
    typedef mozilla::dom::sms::ReplyMessageDelete ReplyMessageDelete;
    typedef mozilla::dom::sms::ReplyMessageDeleteFail ReplyMessageDeleteFail;
    typedef mozilla::dom::sms::ReplyNoMessageInList ReplyNoMessageInList;
    typedef mozilla::dom::sms::ReplyCreateMessageList ReplyCreateMessageList;
    typedef mozilla::dom::sms::ReplyCreateMessageListFail ReplyCreateMessageListFail;
    typedef mozilla::dom::sms::ReplyGetNextMessage ReplyGetNextMessage;
    typedef mozilla::dom::sms::ReplyMarkeMessageRead ReplyMarkeMessageRead;
    typedef mozilla::dom::sms::ReplyMarkeMessageReadFail ReplyMarkeMessageReadFail;
    typedef mozilla::dom::sms::ReplyThreadList ReplyThreadList;
    typedef mozilla::dom::sms::ReplyThreadListFail ReplyThreadListFail;
    typedef ReplyMessageSend ReplyMessageSend__tdef;
    typedef ReplyMessageSendFail ReplyMessageSendFail__tdef;
    typedef ReplyGetMessage ReplyGetMessage__tdef;
    typedef ReplyGetMessageFail ReplyGetMessageFail__tdef;
    typedef ReplyMessageDelete ReplyMessageDelete__tdef;
    typedef ReplyMessageDeleteFail ReplyMessageDeleteFail__tdef;
    typedef ReplyNoMessageInList ReplyNoMessageInList__tdef;
    typedef ReplyCreateMessageList ReplyCreateMessageList__tdef;
    typedef ReplyCreateMessageListFail ReplyCreateMessageListFail__tdef;
    typedef ReplyGetNextMessage ReplyGetNextMessage__tdef;
    typedef ReplyMarkeMessageRead ReplyMarkeMessageRead__tdef;
    typedef ReplyMarkeMessageReadFail ReplyMarkeMessageReadFail__tdef;
    typedef ReplyThreadList ReplyThreadList__tdef;
    typedef ReplyThreadListFail ReplyThreadListFail__tdef;

    union Value {
        char VReplyMessageSend[sizeof(ReplyMessageSend)];
        char VReplyMessageSendFail[sizeof(ReplyMessageSendFail)];
        char VReplyGetMessage[sizeof(ReplyGetMessage)];
        char VReplyGetMessageFail[sizeof(ReplyGetMessageFail)];
        char VReplyMessageDelete[sizeof(ReplyMessageDelete)];
        char VReplyMessageDeleteFail[sizeof(ReplyMessageDeleteFail)];
        char VReplyNoMessageInList[sizeof(ReplyNoMessageInList)];
        char VReplyCreateMessageList[sizeof(ReplyCreateMessageList)];
        char VReplyCreateMessageListFail[sizeof(ReplyCreateMessageListFail)];
        char VReplyGetNextMessage[sizeof(ReplyGetNextMessage)];
        char VReplyMarkeMessageRead[sizeof(ReplyMarkeMessageRead)];
        char VReplyMarkeMessageReadFail[sizeof(ReplyMarkeMessageReadFail)];
        char VReplyThreadList[sizeof(ReplyThreadList)];
        char VReplyThreadListFail[sizeof(ReplyThreadListFail)];
    };

    ReplyMessageSend*
    ptr_ReplyMessageSend()
    {
        return reinterpret_cast<ReplyMessageSend*>((&((mValue).VReplyMessageSend)));
    }
    const ReplyMessageSend* const
    constptr_ReplyMessageSend() const
    {
        return reinterpret_cast<const ReplyMessageSend* const>((&((mValue).VReplyMessageSend)));
    }
    ReplyMessageSendFail*
    ptr_ReplyMessageSendFail()
    {
        return reinterpret_cast<ReplyMessageSendFail*>((&((mValue).VReplyMessageSendFail)));
    }
    const ReplyMessageSendFail* const
    constptr_ReplyMessageSendFail() const
    {
        return reinterpret_cast<const ReplyMessageSendFail* const>((&((mValue).VReplyMessageSendFail)));
    }
    ReplyGetMessage*
    ptr_ReplyGetMessage()
    {
        return reinterpret_cast<ReplyGetMessage*>((&((mValue).VReplyGetMessage)));
    }
    const ReplyGetMessage* const
    constptr_ReplyGetMessage() const
    {
        return reinterpret_cast<const ReplyGetMessage* const>((&((mValue).VReplyGetMessage)));
    }
    ReplyGetMessageFail*
    ptr_ReplyGetMessageFail()
    {
        return reinterpret_cast<ReplyGetMessageFail*>((&((mValue).VReplyGetMessageFail)));
    }
    const ReplyGetMessageFail* const
    constptr_ReplyGetMessageFail() const
    {
        return reinterpret_cast<const ReplyGetMessageFail* const>((&((mValue).VReplyGetMessageFail)));
    }
    ReplyMessageDelete*
    ptr_ReplyMessageDelete()
    {
        return reinterpret_cast<ReplyMessageDelete*>((&((mValue).VReplyMessageDelete)));
    }
    const ReplyMessageDelete* const
    constptr_ReplyMessageDelete() const
    {
        return reinterpret_cast<const ReplyMessageDelete* const>((&((mValue).VReplyMessageDelete)));
    }
    ReplyMessageDeleteFail*
    ptr_ReplyMessageDeleteFail()
    {
        return reinterpret_cast<ReplyMessageDeleteFail*>((&((mValue).VReplyMessageDeleteFail)));
    }
    const ReplyMessageDeleteFail* const
    constptr_ReplyMessageDeleteFail() const
    {
        return reinterpret_cast<const ReplyMessageDeleteFail* const>((&((mValue).VReplyMessageDeleteFail)));
    }
    ReplyNoMessageInList*
    ptr_ReplyNoMessageInList()
    {
        return reinterpret_cast<ReplyNoMessageInList*>((&((mValue).VReplyNoMessageInList)));
    }
    const ReplyNoMessageInList* const
    constptr_ReplyNoMessageInList() const
    {
        return reinterpret_cast<const ReplyNoMessageInList* const>((&((mValue).VReplyNoMessageInList)));
    }
    ReplyCreateMessageList*
    ptr_ReplyCreateMessageList()
    {
        return reinterpret_cast<ReplyCreateMessageList*>((&((mValue).VReplyCreateMessageList)));
    }
    const ReplyCreateMessageList* const
    constptr_ReplyCreateMessageList() const
    {
        return reinterpret_cast<const ReplyCreateMessageList* const>((&((mValue).VReplyCreateMessageList)));
    }
    ReplyCreateMessageListFail*
    ptr_ReplyCreateMessageListFail()
    {
        return reinterpret_cast<ReplyCreateMessageListFail*>((&((mValue).VReplyCreateMessageListFail)));
    }
    const ReplyCreateMessageListFail* const
    constptr_ReplyCreateMessageListFail() const
    {
        return reinterpret_cast<const ReplyCreateMessageListFail* const>((&((mValue).VReplyCreateMessageListFail)));
    }
    ReplyGetNextMessage*
    ptr_ReplyGetNextMessage()
    {
        return reinterpret_cast<ReplyGetNextMessage*>((&((mValue).VReplyGetNextMessage)));
    }
    const ReplyGetNextMessage* const
    constptr_ReplyGetNextMessage() const
    {
        return reinterpret_cast<const ReplyGetNextMessage* const>((&((mValue).VReplyGetNextMessage)));
    }
    ReplyMarkeMessageRead*
    ptr_ReplyMarkeMessageRead()
    {
        return reinterpret_cast<ReplyMarkeMessageRead*>((&((mValue).VReplyMarkeMessageRead)));
    }
    const ReplyMarkeMessageRead* const
    constptr_ReplyMarkeMessageRead() const
    {
        return reinterpret_cast<const ReplyMarkeMessageRead* const>((&((mValue).VReplyMarkeMessageRead)));
    }
    ReplyMarkeMessageReadFail*
    ptr_ReplyMarkeMessageReadFail()
    {
        return reinterpret_cast<ReplyMarkeMessageReadFail*>((&((mValue).VReplyMarkeMessageReadFail)));
    }
    const ReplyMarkeMessageReadFail* const
    constptr_ReplyMarkeMessageReadFail() const
    {
        return reinterpret_cast<const ReplyMarkeMessageReadFail* const>((&((mValue).VReplyMarkeMessageReadFail)));
    }
    ReplyThreadList*
    ptr_ReplyThreadList()
    {
        return reinterpret_cast<ReplyThreadList*>((&((mValue).VReplyThreadList)));
    }
    const ReplyThreadList* const
    constptr_ReplyThreadList() const
    {
        return reinterpret_cast<const ReplyThreadList* const>((&((mValue).VReplyThreadList)));
    }
    ReplyThreadListFail*
    ptr_ReplyThreadListFail()
    {
        return reinterpret_cast<ReplyThreadListFail*>((&((mValue).VReplyThreadListFail)));
    }
    const ReplyThreadListFail* const
    constptr_ReplyThreadListFail() const
    {
        return reinterpret_cast<const ReplyThreadListFail* const>((&((mValue).VReplyThreadListFail)));
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        NS_ABORT_IF_FALSE((T__None) <= (mType), "invalid type tag");
        NS_ABORT_IF_FALSE((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        NS_ABORT_IF_FALSE((mType) == (aType), "unexpected type tag");
    }

public:
    MessageReply() :
        mType(T__None)
    {
    }

    MessageReply(const ReplyMessageSend& aOther);

    MessageReply(const ReplyMessageSendFail& aOther);

    MessageReply(const ReplyGetMessage& aOther);

    MessageReply(const ReplyGetMessageFail& aOther);

    MessageReply(const ReplyMessageDelete& aOther);

    MessageReply(const ReplyMessageDeleteFail& aOther);

    MessageReply(const ReplyNoMessageInList& aOther);

    MessageReply(const ReplyCreateMessageList& aOther);

    MessageReply(const ReplyCreateMessageListFail& aOther);

    MessageReply(const ReplyGetNextMessage& aOther);

    MessageReply(const ReplyMarkeMessageRead& aOther);

    MessageReply(const ReplyMarkeMessageReadFail& aOther);

    MessageReply(const ReplyThreadList& aOther);

    MessageReply(const ReplyThreadListFail& aOther);

    MessageReply(const MessageReply& aOther);

    ~MessageReply();

    Type
    type() const
    {
        return mType;
    }

    MessageReply&
    operator=(const ReplyMessageSend& aRhs);

    MessageReply&
    operator=(const ReplyMessageSendFail& aRhs);

    MessageReply&
    operator=(const ReplyGetMessage& aRhs);

    MessageReply&
    operator=(const ReplyGetMessageFail& aRhs);

    MessageReply&
    operator=(const ReplyMessageDelete& aRhs);

    MessageReply&
    operator=(const ReplyMessageDeleteFail& aRhs);

    MessageReply&
    operator=(const ReplyNoMessageInList& aRhs);

    MessageReply&
    operator=(const ReplyCreateMessageList& aRhs);

    MessageReply&
    operator=(const ReplyCreateMessageListFail& aRhs);

    MessageReply&
    operator=(const ReplyGetNextMessage& aRhs);

    MessageReply&
    operator=(const ReplyMarkeMessageRead& aRhs);

    MessageReply&
    operator=(const ReplyMarkeMessageReadFail& aRhs);

    MessageReply&
    operator=(const ReplyThreadList& aRhs);

    MessageReply&
    operator=(const ReplyThreadListFail& aRhs);

    MessageReply&
    operator=(const MessageReply& aRhs);

    bool
    operator==(const ReplyMessageSend& aRhs) const;

    bool
    operator==(const ReplyMessageSendFail& aRhs) const;

    bool
    operator==(const ReplyGetMessage& aRhs) const;

    bool
    operator==(const ReplyGetMessageFail& aRhs) const;

    bool
    operator==(const ReplyMessageDelete& aRhs) const;

    bool
    operator==(const ReplyMessageDeleteFail& aRhs) const;

    bool
    operator==(const ReplyNoMessageInList& aRhs) const;

    bool
    operator==(const ReplyCreateMessageList& aRhs) const;

    bool
    operator==(const ReplyCreateMessageListFail& aRhs) const;

    bool
    operator==(const ReplyGetNextMessage& aRhs) const;

    bool
    operator==(const ReplyMarkeMessageRead& aRhs) const;

    bool
    operator==(const ReplyMarkeMessageReadFail& aRhs) const;

    bool
    operator==(const ReplyThreadList& aRhs) const;

    bool
    operator==(const ReplyThreadListFail& aRhs) const;

    bool
    operator==(const MessageReply& aRhs) const;

    ReplyMessageSend&
    get_ReplyMessageSend()
    {
        AssertSanity(TReplyMessageSend);
        return (*(ptr_ReplyMessageSend()));
    }
    const ReplyMessageSend&
    get_ReplyMessageSend() const
    {
        AssertSanity(TReplyMessageSend);
        return (*(constptr_ReplyMessageSend()));
    }
    operator ReplyMessageSend&()
    {
        return get_ReplyMessageSend();
    }
    operator const ReplyMessageSend&() const
    {
        return get_ReplyMessageSend();
    }

    ReplyMessageSendFail&
    get_ReplyMessageSendFail()
    {
        AssertSanity(TReplyMessageSendFail);
        return (*(ptr_ReplyMessageSendFail()));
    }
    const ReplyMessageSendFail&
    get_ReplyMessageSendFail() const
    {
        AssertSanity(TReplyMessageSendFail);
        return (*(constptr_ReplyMessageSendFail()));
    }
    operator ReplyMessageSendFail&()
    {
        return get_ReplyMessageSendFail();
    }
    operator const ReplyMessageSendFail&() const
    {
        return get_ReplyMessageSendFail();
    }

    ReplyGetMessage&
    get_ReplyGetMessage()
    {
        AssertSanity(TReplyGetMessage);
        return (*(ptr_ReplyGetMessage()));
    }
    const ReplyGetMessage&
    get_ReplyGetMessage() const
    {
        AssertSanity(TReplyGetMessage);
        return (*(constptr_ReplyGetMessage()));
    }
    operator ReplyGetMessage&()
    {
        return get_ReplyGetMessage();
    }
    operator const ReplyGetMessage&() const
    {
        return get_ReplyGetMessage();
    }

    ReplyGetMessageFail&
    get_ReplyGetMessageFail()
    {
        AssertSanity(TReplyGetMessageFail);
        return (*(ptr_ReplyGetMessageFail()));
    }
    const ReplyGetMessageFail&
    get_ReplyGetMessageFail() const
    {
        AssertSanity(TReplyGetMessageFail);
        return (*(constptr_ReplyGetMessageFail()));
    }
    operator ReplyGetMessageFail&()
    {
        return get_ReplyGetMessageFail();
    }
    operator const ReplyGetMessageFail&() const
    {
        return get_ReplyGetMessageFail();
    }

    ReplyMessageDelete&
    get_ReplyMessageDelete()
    {
        AssertSanity(TReplyMessageDelete);
        return (*(ptr_ReplyMessageDelete()));
    }
    const ReplyMessageDelete&
    get_ReplyMessageDelete() const
    {
        AssertSanity(TReplyMessageDelete);
        return (*(constptr_ReplyMessageDelete()));
    }
    operator ReplyMessageDelete&()
    {
        return get_ReplyMessageDelete();
    }
    operator const ReplyMessageDelete&() const
    {
        return get_ReplyMessageDelete();
    }

    ReplyMessageDeleteFail&
    get_ReplyMessageDeleteFail()
    {
        AssertSanity(TReplyMessageDeleteFail);
        return (*(ptr_ReplyMessageDeleteFail()));
    }
    const ReplyMessageDeleteFail&
    get_ReplyMessageDeleteFail() const
    {
        AssertSanity(TReplyMessageDeleteFail);
        return (*(constptr_ReplyMessageDeleteFail()));
    }
    operator ReplyMessageDeleteFail&()
    {
        return get_ReplyMessageDeleteFail();
    }
    operator const ReplyMessageDeleteFail&() const
    {
        return get_ReplyMessageDeleteFail();
    }

    ReplyNoMessageInList&
    get_ReplyNoMessageInList()
    {
        AssertSanity(TReplyNoMessageInList);
        return (*(ptr_ReplyNoMessageInList()));
    }
    const ReplyNoMessageInList&
    get_ReplyNoMessageInList() const
    {
        AssertSanity(TReplyNoMessageInList);
        return (*(constptr_ReplyNoMessageInList()));
    }
    operator ReplyNoMessageInList&()
    {
        return get_ReplyNoMessageInList();
    }
    operator const ReplyNoMessageInList&() const
    {
        return get_ReplyNoMessageInList();
    }

    ReplyCreateMessageList&
    get_ReplyCreateMessageList()
    {
        AssertSanity(TReplyCreateMessageList);
        return (*(ptr_ReplyCreateMessageList()));
    }
    const ReplyCreateMessageList&
    get_ReplyCreateMessageList() const
    {
        AssertSanity(TReplyCreateMessageList);
        return (*(constptr_ReplyCreateMessageList()));
    }
    operator ReplyCreateMessageList&()
    {
        return get_ReplyCreateMessageList();
    }
    operator const ReplyCreateMessageList&() const
    {
        return get_ReplyCreateMessageList();
    }

    ReplyCreateMessageListFail&
    get_ReplyCreateMessageListFail()
    {
        AssertSanity(TReplyCreateMessageListFail);
        return (*(ptr_ReplyCreateMessageListFail()));
    }
    const ReplyCreateMessageListFail&
    get_ReplyCreateMessageListFail() const
    {
        AssertSanity(TReplyCreateMessageListFail);
        return (*(constptr_ReplyCreateMessageListFail()));
    }
    operator ReplyCreateMessageListFail&()
    {
        return get_ReplyCreateMessageListFail();
    }
    operator const ReplyCreateMessageListFail&() const
    {
        return get_ReplyCreateMessageListFail();
    }

    ReplyGetNextMessage&
    get_ReplyGetNextMessage()
    {
        AssertSanity(TReplyGetNextMessage);
        return (*(ptr_ReplyGetNextMessage()));
    }
    const ReplyGetNextMessage&
    get_ReplyGetNextMessage() const
    {
        AssertSanity(TReplyGetNextMessage);
        return (*(constptr_ReplyGetNextMessage()));
    }
    operator ReplyGetNextMessage&()
    {
        return get_ReplyGetNextMessage();
    }
    operator const ReplyGetNextMessage&() const
    {
        return get_ReplyGetNextMessage();
    }

    ReplyMarkeMessageRead&
    get_ReplyMarkeMessageRead()
    {
        AssertSanity(TReplyMarkeMessageRead);
        return (*(ptr_ReplyMarkeMessageRead()));
    }
    const ReplyMarkeMessageRead&
    get_ReplyMarkeMessageRead() const
    {
        AssertSanity(TReplyMarkeMessageRead);
        return (*(constptr_ReplyMarkeMessageRead()));
    }
    operator ReplyMarkeMessageRead&()
    {
        return get_ReplyMarkeMessageRead();
    }
    operator const ReplyMarkeMessageRead&() const
    {
        return get_ReplyMarkeMessageRead();
    }

    ReplyMarkeMessageReadFail&
    get_ReplyMarkeMessageReadFail()
    {
        AssertSanity(TReplyMarkeMessageReadFail);
        return (*(ptr_ReplyMarkeMessageReadFail()));
    }
    const ReplyMarkeMessageReadFail&
    get_ReplyMarkeMessageReadFail() const
    {
        AssertSanity(TReplyMarkeMessageReadFail);
        return (*(constptr_ReplyMarkeMessageReadFail()));
    }
    operator ReplyMarkeMessageReadFail&()
    {
        return get_ReplyMarkeMessageReadFail();
    }
    operator const ReplyMarkeMessageReadFail&() const
    {
        return get_ReplyMarkeMessageReadFail();
    }

    ReplyThreadList&
    get_ReplyThreadList()
    {
        AssertSanity(TReplyThreadList);
        return (*(ptr_ReplyThreadList()));
    }
    const ReplyThreadList&
    get_ReplyThreadList() const
    {
        AssertSanity(TReplyThreadList);
        return (*(constptr_ReplyThreadList()));
    }
    operator ReplyThreadList&()
    {
        return get_ReplyThreadList();
    }
    operator const ReplyThreadList&() const
    {
        return get_ReplyThreadList();
    }

    ReplyThreadListFail&
    get_ReplyThreadListFail()
    {
        AssertSanity(TReplyThreadListFail);
        return (*(ptr_ReplyThreadListFail()));
    }
    const ReplyThreadListFail&
    get_ReplyThreadListFail() const
    {
        AssertSanity(TReplyThreadListFail);
        return (*(constptr_ReplyThreadListFail()));
    }
    operator ReplyThreadListFail&()
    {
        return get_ReplyThreadListFail();
    }
    operator const ReplyThreadListFail&() const
    {
        return get_ReplyThreadListFail();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace sms
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Code common to PSmsRequestChild and PSmsRequestParent
//
namespace mozilla {
namespace dom {
namespace sms {
namespace PSmsRequest {

enum State {
    __Dead,
    __Null,
    __Error,
    __Dying,
    __Start = __Null
};

enum MessageType {
    PSmsRequestStart = PSmsRequestMsgStart << 16,
    PSmsRequestPreStart = (PSmsRequestMsgStart << 16) - 1,
    Msg___delete____ID,
    Reply___delete____ID,
    PSmsRequestEnd
};

bool
Transition(
        State from,
        mozilla::ipc::Trigger trigger,
        State* next);

class Msg___delete__ :
    public IPC::Message
{
private:
    typedef mozilla::ipc::ActorHandle ActorHandle;
    typedef mozilla::ipc::FileDescriptor FileDescriptor;
    typedef mozilla::dom::sms::MessageReply MessageReply;
    typedef mozilla::dom::sms::ReplyCreateMessageList ReplyCreateMessageList;
    typedef mozilla::dom::sms::ReplyCreateMessageListFail ReplyCreateMessageListFail;
    typedef mozilla::dom::sms::ReplyGetMessage ReplyGetMessage;
    typedef mozilla::dom::sms::ReplyGetMessageFail ReplyGetMessageFail;
    typedef mozilla::dom::sms::ReplyGetNextMessage ReplyGetNextMessage;
    typedef mozilla::dom::sms::ReplyMarkeMessageRead ReplyMarkeMessageRead;
    typedef mozilla::dom::sms::ReplyMarkeMessageReadFail ReplyMarkeMessageReadFail;
    typedef mozilla::dom::sms::ReplyMessageDelete ReplyMessageDelete;
    typedef mozilla::dom::sms::ReplyMessageDeleteFail ReplyMessageDeleteFail;
    typedef mozilla::dom::sms::ReplyMessageSend ReplyMessageSend;
    typedef mozilla::dom::sms::ReplyMessageSendFail ReplyMessageSendFail;
    typedef mozilla::dom::sms::ReplyNoMessageInList ReplyNoMessageInList;
    typedef mozilla::dom::sms::ReplyThreadList ReplyThreadList;
    typedef mozilla::dom::sms::ReplyThreadListFail ReplyThreadListFail;
    typedef mozilla::ipc::Shmem Shmem;
    typedef mozilla::dom::sms::SmsMessageData SmsMessageData;
    typedef mozilla::dom::sms::SmsSegmentInfoData SmsSegmentInfoData;
    typedef mozilla::dom::sms::ThreadListItem ThreadListItem;

public:
    enum {
        ID = Msg___delete____ID
    };
    Msg___delete__() :
        IPC::Message(MSG_ROUTING_NONE, ID, PRIORITY_NORMAL, COMPRESSION_NONE, "PSmsRequest::Msg___delete__")
    {
    }

    void
    Log(
            const std::string& __pfx,
            FILE* __outf) const
    {
        std::string __logmsg;
        StringAppendF((&(__logmsg)), "[time:%" PRId64 "][%d]", PR_Now(), base::GetCurrentProcId());
        (__logmsg).append(__pfx);
        (__logmsg).append("Msg___delete__(");

        (__logmsg).append("[TODO])\n");
        fputs((__logmsg).c_str(), __outf);
    }
};

class Reply___delete__ :
    public IPC::Message
{
private:
    typedef mozilla::ipc::ActorHandle ActorHandle;
    typedef mozilla::ipc::FileDescriptor FileDescriptor;
    typedef mozilla::dom::sms::MessageReply MessageReply;
    typedef mozilla::dom::sms::ReplyCreateMessageList ReplyCreateMessageList;
    typedef mozilla::dom::sms::ReplyCreateMessageListFail ReplyCreateMessageListFail;
    typedef mozilla::dom::sms::ReplyGetMessage ReplyGetMessage;
    typedef mozilla::dom::sms::ReplyGetMessageFail ReplyGetMessageFail;
    typedef mozilla::dom::sms::ReplyGetNextMessage ReplyGetNextMessage;
    typedef mozilla::dom::sms::ReplyMarkeMessageRead ReplyMarkeMessageRead;
    typedef mozilla::dom::sms::ReplyMarkeMessageReadFail ReplyMarkeMessageReadFail;
    typedef mozilla::dom::sms::ReplyMessageDelete ReplyMessageDelete;
    typedef mozilla::dom::sms::ReplyMessageDeleteFail ReplyMessageDeleteFail;
    typedef mozilla::dom::sms::ReplyMessageSend ReplyMessageSend;
    typedef mozilla::dom::sms::ReplyMessageSendFail ReplyMessageSendFail;
    typedef mozilla::dom::sms::ReplyNoMessageInList ReplyNoMessageInList;
    typedef mozilla::dom::sms::ReplyThreadList ReplyThreadList;
    typedef mozilla::dom::sms::ReplyThreadListFail ReplyThreadListFail;
    typedef mozilla::ipc::Shmem Shmem;
    typedef mozilla::dom::sms::SmsMessageData SmsMessageData;
    typedef mozilla::dom::sms::SmsSegmentInfoData SmsSegmentInfoData;
    typedef mozilla::dom::sms::ThreadListItem ThreadListItem;

public:
    enum {
        ID = Reply___delete____ID
    };
    Reply___delete__() :
        IPC::Message(MSG_ROUTING_NONE, ID, PRIORITY_NORMAL, COMPRESSION_NONE, "PSmsRequest::Reply___delete__")
    {
    }

    void
    Log(
            const std::string& __pfx,
            FILE* __outf) const
    {
        std::string __logmsg;
        StringAppendF((&(__logmsg)), "[time:%" PRId64 "][%d]", PR_Now(), base::GetCurrentProcId());
        (__logmsg).append(__pfx);
        (__logmsg).append("Reply___delete__(");

        (__logmsg).append("[TODO])\n");
        fputs((__logmsg).c_str(), __outf);
    }
};



} // namespace PSmsRequest
} // namespace sms
} // namespace dom
} // namespace mozilla

#endif // ifndef PSmsRequest_h
