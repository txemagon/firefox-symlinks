//
// Automatically generated by ipdlc.
// Edit at your own risk
//

#ifndef URIParams_h
#define URIParams_h

#include "mozilla/Attributes.h"
#include "base/basictypes.h"
#include "prtime.h"
#include "nscore.h"
#include "IPCMessageStart.h"
#include "ipc/IPCMessageUtils.h"
#include "nsAutoPtr.h"
#include "nsStringGlue.h"
#include "nsTArray.h"
#include "nsIFile.h"
#include "mozilla/ipc/ProtocolUtils.h"
#include "ipc/IPCMessageUtils.h"


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct SimpleURIParams|
//
namespace mozilla {
namespace ipc {
class SimpleURIParams MOZ_FINAL
{
private:

public:
    SimpleURIParams();

    SimpleURIParams(
            const nsCString& _scheme,
            const nsCString& _path,
            const nsCString& _ref,
            const bool& _isMutable)
    {
        Init();
        Assign(_scheme, _path, _ref, _isMutable);
    }

    SimpleURIParams(const SimpleURIParams& _o)
    {
        Init();
        Assign((_o).scheme(), (_o).path(), (_o).ref(), (_o).isMutable());
    }

    ~SimpleURIParams();

    void
    operator=(const SimpleURIParams& _o)
    {
        Assign((_o).scheme(), (_o).path(), (_o).ref(), (_o).isMutable());
    }

    bool
    operator==(const SimpleURIParams& _o) const;

    nsCString&
    scheme()
    {
        return scheme_;
    }
    const nsCString&
    scheme() const
    {
        return scheme_;
    }

    nsCString&
    path()
    {
        return path_;
    }
    const nsCString&
    path() const
    {
        return path_;
    }

    nsCString&
    ref()
    {
        return ref_;
    }
    const nsCString&
    ref() const
    {
        return ref_;
    }

    bool&
    isMutable()
    {
        return isMutable_;
    }
    const bool&
    isMutable() const
    {
        return isMutable_;
    }

private:
    void
    Init();

    void
    Assign(
            const nsCString& _scheme,
            const nsCString& _path,
            const nsCString& _ref,
            const bool& _isMutable);

    nsCString scheme_;
    nsCString path_;
    nsCString ref_;
    bool isMutable_;
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct StandardURLSegment|
//
namespace mozilla {
namespace ipc {
class StandardURLSegment MOZ_FINAL
{
private:

public:
    StandardURLSegment();

    StandardURLSegment(
            const uint32_t& _position,
            const int32_t& _length)
    {
        Init();
        Assign(_position, _length);
    }

    StandardURLSegment(const StandardURLSegment& _o)
    {
        Init();
        Assign((_o).position(), (_o).length());
    }

    ~StandardURLSegment();

    void
    operator=(const StandardURLSegment& _o)
    {
        Assign((_o).position(), (_o).length());
    }

    bool
    operator==(const StandardURLSegment& _o) const;

    uint32_t&
    position()
    {
        return position_;
    }
    const uint32_t&
    position() const
    {
        return position_;
    }

    int32_t&
    length()
    {
        return length_;
    }
    const int32_t&
    length() const
    {
        return length_;
    }

private:
    void
    Init();

    void
    Assign(
            const uint32_t& _position,
            const int32_t& _length);

    uint32_t position_;
    int32_t length_;
};
} // namespace ipc
} // namespace mozilla

namespace mozilla {
namespace ipc {
class StandardURLSegment;
} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct StandardURLParams|
//
namespace mozilla {
namespace ipc {
class StandardURLParams MOZ_FINAL
{
private:
    typedef mozilla::ipc::StandardURLSegment StandardURLSegment;

public:
    StandardURLParams();

    StandardURLParams(
            const uint32_t& _urlType,
            const int32_t& _port,
            const int32_t& _defaultPort,
            const nsCString& _spec,
            const StandardURLSegment& _scheme,
            const StandardURLSegment& _authority,
            const StandardURLSegment& _username,
            const StandardURLSegment& _password,
            const StandardURLSegment& _host,
            const StandardURLSegment& _path,
            const StandardURLSegment& _filePath,
            const StandardURLSegment& _directory,
            const StandardURLSegment& _baseName,
            const StandardURLSegment& _extension,
            const StandardURLSegment& _query,
            const StandardURLSegment& _ref,
            const nsCString& _originCharset,
            const bool& _isMutable,
            const bool& _supportsFileURL,
            const uint32_t& _hostEncoding)
    {
        Init();
        Assign(_urlType, _port, _defaultPort, _spec, _scheme, _authority, _username, _password, _host, _path, _filePath, _directory, _baseName, _extension, _query, _ref, _originCharset, _isMutable, _supportsFileURL, _hostEncoding);
    }

    StandardURLParams(const StandardURLParams& _o)
    {
        Init();
        Assign((_o).urlType(), (_o).port(), (_o).defaultPort(), (_o).spec(), (_o).scheme(), (_o).authority(), (_o).username(), (_o).password(), (_o).host(), (_o).path(), (_o).filePath(), (_o).directory(), (_o).baseName(), (_o).extension(), (_o).query(), (_o).ref(), (_o).originCharset(), (_o).isMutable(), (_o).supportsFileURL(), (_o).hostEncoding());
    }

    ~StandardURLParams();

    void
    operator=(const StandardURLParams& _o)
    {
        Assign((_o).urlType(), (_o).port(), (_o).defaultPort(), (_o).spec(), (_o).scheme(), (_o).authority(), (_o).username(), (_o).password(), (_o).host(), (_o).path(), (_o).filePath(), (_o).directory(), (_o).baseName(), (_o).extension(), (_o).query(), (_o).ref(), (_o).originCharset(), (_o).isMutable(), (_o).supportsFileURL(), (_o).hostEncoding());
    }

    bool
    operator==(const StandardURLParams& _o) const;

    uint32_t&
    urlType()
    {
        return urlType_;
    }
    const uint32_t&
    urlType() const
    {
        return urlType_;
    }

    int32_t&
    port()
    {
        return port_;
    }
    const int32_t&
    port() const
    {
        return port_;
    }

    int32_t&
    defaultPort()
    {
        return defaultPort_;
    }
    const int32_t&
    defaultPort() const
    {
        return defaultPort_;
    }

    nsCString&
    spec()
    {
        return spec_;
    }
    const nsCString&
    spec() const
    {
        return spec_;
    }

    StandardURLSegment&
    scheme()
    {
        return scheme_;
    }
    const StandardURLSegment&
    scheme() const
    {
        return scheme_;
    }

    StandardURLSegment&
    authority()
    {
        return authority_;
    }
    const StandardURLSegment&
    authority() const
    {
        return authority_;
    }

    StandardURLSegment&
    username()
    {
        return username_;
    }
    const StandardURLSegment&
    username() const
    {
        return username_;
    }

    StandardURLSegment&
    password()
    {
        return password_;
    }
    const StandardURLSegment&
    password() const
    {
        return password_;
    }

    StandardURLSegment&
    host()
    {
        return host_;
    }
    const StandardURLSegment&
    host() const
    {
        return host_;
    }

    StandardURLSegment&
    path()
    {
        return path_;
    }
    const StandardURLSegment&
    path() const
    {
        return path_;
    }

    StandardURLSegment&
    filePath()
    {
        return filePath_;
    }
    const StandardURLSegment&
    filePath() const
    {
        return filePath_;
    }

    StandardURLSegment&
    directory()
    {
        return directory_;
    }
    const StandardURLSegment&
    directory() const
    {
        return directory_;
    }

    StandardURLSegment&
    baseName()
    {
        return baseName_;
    }
    const StandardURLSegment&
    baseName() const
    {
        return baseName_;
    }

    StandardURLSegment&
    extension()
    {
        return extension_;
    }
    const StandardURLSegment&
    extension() const
    {
        return extension_;
    }

    StandardURLSegment&
    query()
    {
        return query_;
    }
    const StandardURLSegment&
    query() const
    {
        return query_;
    }

    StandardURLSegment&
    ref()
    {
        return ref_;
    }
    const StandardURLSegment&
    ref() const
    {
        return ref_;
    }

    nsCString&
    originCharset()
    {
        return originCharset_;
    }
    const nsCString&
    originCharset() const
    {
        return originCharset_;
    }

    bool&
    isMutable()
    {
        return isMutable_;
    }
    const bool&
    isMutable() const
    {
        return isMutable_;
    }

    bool&
    supportsFileURL()
    {
        return supportsFileURL_;
    }
    const bool&
    supportsFileURL() const
    {
        return supportsFileURL_;
    }

    uint32_t&
    hostEncoding()
    {
        return hostEncoding_;
    }
    const uint32_t&
    hostEncoding() const
    {
        return hostEncoding_;
    }

private:
    void
    Init();

    void
    Assign(
            const uint32_t& _urlType,
            const int32_t& _port,
            const int32_t& _defaultPort,
            const nsCString& _spec,
            const StandardURLSegment& _scheme,
            const StandardURLSegment& _authority,
            const StandardURLSegment& _username,
            const StandardURLSegment& _password,
            const StandardURLSegment& _host,
            const StandardURLSegment& _path,
            const StandardURLSegment& _filePath,
            const StandardURLSegment& _directory,
            const StandardURLSegment& _baseName,
            const StandardURLSegment& _extension,
            const StandardURLSegment& _query,
            const StandardURLSegment& _ref,
            const nsCString& _originCharset,
            const bool& _isMutable,
            const bool& _supportsFileURL,
            const uint32_t& _hostEncoding);

    uint32_t urlType_;
    int32_t port_;
    int32_t defaultPort_;
    nsCString spec_;
    StandardURLSegment scheme_;
    StandardURLSegment authority_;
    StandardURLSegment username_;
    StandardURLSegment password_;
    StandardURLSegment host_;
    StandardURLSegment path_;
    StandardURLSegment filePath_;
    StandardURLSegment directory_;
    StandardURLSegment baseName_;
    StandardURLSegment extension_;
    StandardURLSegment query_;
    StandardURLSegment ref_;
    nsCString originCharset_;
    bool isMutable_;
    bool supportsFileURL_;
    uint32_t hostEncoding_;
};
} // namespace ipc
} // namespace mozilla

namespace mozilla {
namespace ipc {
class URIParams;
} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct JARURIParams|
//
namespace mozilla {
namespace ipc {
class JARURIParams MOZ_FINAL
{
private:
    typedef mozilla::ipc::URIParams URIParams;

public:
    JARURIParams();

    JARURIParams(
            const URIParams& _jarFile,
            const URIParams& _jarEntry,
            const nsCString& _charset)
    {
        Init();
        Assign(_jarFile, _jarEntry, _charset);
    }

    JARURIParams(const JARURIParams& _o)
    {
        Init();
        Assign((_o).jarFile(), (_o).jarEntry(), (_o).charset());
    }

    ~JARURIParams();

    void
    operator=(const JARURIParams& _o)
    {
        Assign((_o).jarFile(), (_o).jarEntry(), (_o).charset());
    }

    bool
    operator==(const JARURIParams& _o) const;

    URIParams&
    jarFile()
    {
        return (*(jarFile_));
    }
    const URIParams&
    jarFile() const
    {
        return (*(jarFile_));
    }

    URIParams&
    jarEntry()
    {
        return (*(jarEntry_));
    }
    const URIParams&
    jarEntry() const
    {
        return (*(jarEntry_));
    }

    nsCString&
    charset()
    {
        return charset_;
    }
    const nsCString&
    charset() const
    {
        return charset_;
    }

private:
    void
    Init();

    void
    Assign(
            const URIParams& _jarFile,
            const URIParams& _jarEntry,
            const nsCString& _charset);

    URIParams* jarFile_;
    URIParams* jarEntry_;
    nsCString charset_;
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct GenericURIParams|
//
namespace mozilla {
namespace ipc {
class GenericURIParams MOZ_FINAL
{
private:

public:
    GenericURIParams();

    GenericURIParams(
            const nsCString& _spec,
            const nsCString& _charset)
    {
        Init();
        Assign(_spec, _charset);
    }

    GenericURIParams(const GenericURIParams& _o)
    {
        Init();
        Assign((_o).spec(), (_o).charset());
    }

    ~GenericURIParams();

    void
    operator=(const GenericURIParams& _o)
    {
        Assign((_o).spec(), (_o).charset());
    }

    bool
    operator==(const GenericURIParams& _o) const;

    nsCString&
    spec()
    {
        return spec_;
    }
    const nsCString&
    spec() const
    {
        return spec_;
    }

    nsCString&
    charset()
    {
        return charset_;
    }
    const nsCString&
    charset() const
    {
        return charset_;
    }

private:
    void
    Init();

    void
    Assign(
            const nsCString& _spec,
            const nsCString& _charset);

    nsCString spec_;
    nsCString charset_;
};
} // namespace ipc
} // namespace mozilla

namespace mozilla {
namespace ipc {
class SimpleURIParams;
} // namespace ipc
} // namespace mozilla
namespace mozilla {
namespace ipc {
class StandardURLParams;
} // namespace ipc
} // namespace mozilla
namespace mozilla {
namespace ipc {
class JARURIParams;
} // namespace ipc
} // namespace mozilla
namespace mozilla {
namespace ipc {
class GenericURIParams;
} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union URIParams|
//
namespace mozilla {
namespace ipc {
class URIParams MOZ_FINAL
{
public:
    enum Type {
        T__None,
        TSimpleURIParams = 1,
        TStandardURLParams,
        TJARURIParams,
        TGenericURIParams,
        T__Last = TGenericURIParams
    };

private:
    typedef mozilla::ipc::SimpleURIParams SimpleURIParams;
    typedef mozilla::ipc::StandardURLParams StandardURLParams;
    typedef mozilla::ipc::JARURIParams JARURIParams;
    typedef mozilla::ipc::GenericURIParams GenericURIParams;
    typedef SimpleURIParams SimpleURIParams__tdef;
    typedef StandardURLParams StandardURLParams__tdef;
    typedef JARURIParams* JARURIParams__tdef;
    typedef GenericURIParams GenericURIParams__tdef;

    union Value {
        char VSimpleURIParams[sizeof(SimpleURIParams)];
        char VStandardURLParams[sizeof(StandardURLParams)];
        JARURIParams* VJARURIParams;
        char VGenericURIParams[sizeof(GenericURIParams)];
    };

    SimpleURIParams*
    ptr_SimpleURIParams()
    {
        return reinterpret_cast<SimpleURIParams*>((&((mValue).VSimpleURIParams)));
    }
    const SimpleURIParams* const
    constptr_SimpleURIParams() const
    {
        return reinterpret_cast<const SimpleURIParams* const>((&((mValue).VSimpleURIParams)));
    }
    StandardURLParams*
    ptr_StandardURLParams()
    {
        return reinterpret_cast<StandardURLParams*>((&((mValue).VStandardURLParams)));
    }
    const StandardURLParams* const
    constptr_StandardURLParams() const
    {
        return reinterpret_cast<const StandardURLParams* const>((&((mValue).VStandardURLParams)));
    }
    JARURIParams*&
    ptr_JARURIParams()
    {
        return (mValue).VJARURIParams;
    }
    const JARURIParams* const
    constptr_JARURIParams() const
    {
        return (mValue).VJARURIParams;
    }
    GenericURIParams*
    ptr_GenericURIParams()
    {
        return reinterpret_cast<GenericURIParams*>((&((mValue).VGenericURIParams)));
    }
    const GenericURIParams* const
    constptr_GenericURIParams() const
    {
        return reinterpret_cast<const GenericURIParams* const>((&((mValue).VGenericURIParams)));
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        NS_ABORT_IF_FALSE((T__None) <= (mType), "invalid type tag");
        NS_ABORT_IF_FALSE((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        NS_ABORT_IF_FALSE((mType) == (aType), "unexpected type tag");
    }

public:
    URIParams() :
        mType(T__None)
    {
    }

    URIParams(const SimpleURIParams& aOther);

    URIParams(const StandardURLParams& aOther);

    URIParams(const JARURIParams& aOther);

    URIParams(const GenericURIParams& aOther);

    URIParams(const URIParams& aOther);

    ~URIParams();

    Type
    type() const
    {
        return mType;
    }

    URIParams&
    operator=(const SimpleURIParams& aRhs);

    URIParams&
    operator=(const StandardURLParams& aRhs);

    URIParams&
    operator=(const JARURIParams& aRhs);

    URIParams&
    operator=(const GenericURIParams& aRhs);

    URIParams&
    operator=(const URIParams& aRhs);

    bool
    operator==(const SimpleURIParams& aRhs) const;

    bool
    operator==(const StandardURLParams& aRhs) const;

    bool
    operator==(const JARURIParams& aRhs) const;

    bool
    operator==(const GenericURIParams& aRhs) const;

    bool
    operator==(const URIParams& aRhs) const;

    SimpleURIParams&
    get_SimpleURIParams()
    {
        AssertSanity(TSimpleURIParams);
        return (*(ptr_SimpleURIParams()));
    }
    const SimpleURIParams&
    get_SimpleURIParams() const
    {
        AssertSanity(TSimpleURIParams);
        return (*(constptr_SimpleURIParams()));
    }
    operator SimpleURIParams&()
    {
        return get_SimpleURIParams();
    }
    operator const SimpleURIParams&() const
    {
        return get_SimpleURIParams();
    }

    StandardURLParams&
    get_StandardURLParams()
    {
        AssertSanity(TStandardURLParams);
        return (*(ptr_StandardURLParams()));
    }
    const StandardURLParams&
    get_StandardURLParams() const
    {
        AssertSanity(TStandardURLParams);
        return (*(constptr_StandardURLParams()));
    }
    operator StandardURLParams&()
    {
        return get_StandardURLParams();
    }
    operator const StandardURLParams&() const
    {
        return get_StandardURLParams();
    }

    JARURIParams&
    get_JARURIParams()
    {
        AssertSanity(TJARURIParams);
        return (*(ptr_JARURIParams()));
    }
    const JARURIParams&
    get_JARURIParams() const
    {
        AssertSanity(TJARURIParams);
        return (*(constptr_JARURIParams()));
    }
    operator JARURIParams&()
    {
        return get_JARURIParams();
    }
    operator const JARURIParams&() const
    {
        return get_JARURIParams();
    }

    GenericURIParams&
    get_GenericURIParams()
    {
        AssertSanity(TGenericURIParams);
        return (*(ptr_GenericURIParams()));
    }
    const GenericURIParams&
    get_GenericURIParams() const
    {
        AssertSanity(TGenericURIParams);
        return (*(constptr_GenericURIParams()));
    }
    operator GenericURIParams&()
    {
        return get_GenericURIParams();
    }
    operator const GenericURIParams&() const
    {
        return get_GenericURIParams();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace ipc
} // namespace mozilla

namespace mozilla {
namespace ipc {
class URIParams;
} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union OptionalURIParams|
//
namespace mozilla {
namespace ipc {
class OptionalURIParams MOZ_FINAL
{
public:
    enum Type {
        T__None,
        Tvoid_t = 1,
        TURIParams,
        T__Last = TURIParams
    };

private:
    typedef mozilla::void_t void_t;
    typedef mozilla::ipc::URIParams URIParams;
    typedef void_t void_t__tdef;
    typedef URIParams URIParams__tdef;

    union Value {
        char Vvoid_t[sizeof(void_t)];
        char VURIParams[sizeof(URIParams)];
    };

    void_t*
    ptr_void_t()
    {
        return reinterpret_cast<void_t*>((&((mValue).Vvoid_t)));
    }
    const void_t* const
    constptr_void_t() const
    {
        return reinterpret_cast<const void_t* const>((&((mValue).Vvoid_t)));
    }
    URIParams*
    ptr_URIParams()
    {
        return reinterpret_cast<URIParams*>((&((mValue).VURIParams)));
    }
    const URIParams* const
    constptr_URIParams() const
    {
        return reinterpret_cast<const URIParams* const>((&((mValue).VURIParams)));
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        NS_ABORT_IF_FALSE((T__None) <= (mType), "invalid type tag");
        NS_ABORT_IF_FALSE((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        NS_ABORT_IF_FALSE((mType) == (aType), "unexpected type tag");
    }

public:
    OptionalURIParams() :
        mType(T__None)
    {
    }

    OptionalURIParams(const void_t& aOther);

    OptionalURIParams(const URIParams& aOther);

    OptionalURIParams(const OptionalURIParams& aOther);

    ~OptionalURIParams();

    Type
    type() const
    {
        return mType;
    }

    OptionalURIParams&
    operator=(const void_t& aRhs);

    OptionalURIParams&
    operator=(const URIParams& aRhs);

    OptionalURIParams&
    operator=(const OptionalURIParams& aRhs);

    bool
    operator==(const void_t& aRhs) const;

    bool
    operator==(const URIParams& aRhs) const;

    bool
    operator==(const OptionalURIParams& aRhs) const;

    void_t&
    get_void_t()
    {
        AssertSanity(Tvoid_t);
        return (*(ptr_void_t()));
    }
    const void_t&
    get_void_t() const
    {
        AssertSanity(Tvoid_t);
        return (*(constptr_void_t()));
    }
    operator void_t&()
    {
        return get_void_t();
    }
    operator const void_t&() const
    {
        return get_void_t();
    }

    URIParams&
    get_URIParams()
    {
        AssertSanity(TURIParams);
        return (*(ptr_URIParams()));
    }
    const URIParams&
    get_URIParams() const
    {
        AssertSanity(TURIParams);
        return (*(constptr_URIParams()));
    }
    operator URIParams&()
    {
        return get_URIParams();
    }
    operator const URIParams&() const
    {
        return get_URIParams();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace ipc
} // namespace mozilla

#endif // ifndef URIParams_h
