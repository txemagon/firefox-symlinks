//
// Automatically generated by ipdlc.
// Edit at your own risk
//

#ifndef PTCPSocket_h
#define PTCPSocket_h

#include "mozilla/Attributes.h"
#include "base/basictypes.h"
#include "prtime.h"
#include "nscore.h"
#include "IPCMessageStart.h"
#include "ipc/IPCMessageUtils.h"
#include "nsAutoPtr.h"
#include "nsStringGlue.h"
#include "nsTArray.h"
#include "nsIFile.h"
#include "mozilla/ipc/ProtocolUtils.h"
#include "mozilla/net/NeckoMessageUtils.h"


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct JSError|
//
class JSError MOZ_FINAL
{
private:

public:
    JSError();

    JSError(
            const nsString& _message,
            const nsString& _filename,
            const uint32_t& _lineNumber,
            const uint32_t& _columnNumber)
    {
        Init();
        Assign(_message, _filename, _lineNumber, _columnNumber);
    }

    JSError(const JSError& _o)
    {
        Init();
        Assign((_o).message(), (_o).filename(), (_o).lineNumber(), (_o).columnNumber());
    }

    ~JSError();

    void
    operator=(const JSError& _o)
    {
        Assign((_o).message(), (_o).filename(), (_o).lineNumber(), (_o).columnNumber());
    }

    bool
    operator==(const JSError& _o) const;

    nsString&
    message()
    {
        return message_;
    }
    const nsString&
    message() const
    {
        return message_;
    }

    nsString&
    filename()
    {
        return filename_;
    }
    const nsString&
    filename() const
    {
        return filename_;
    }

    uint32_t&
    lineNumber()
    {
        return lineNumber_;
    }
    const uint32_t&
    lineNumber() const
    {
        return lineNumber_;
    }

    uint32_t&
    columnNumber()
    {
        return columnNumber_;
    }
    const uint32_t&
    columnNumber() const
    {
        return columnNumber_;
    }

private:
    void
    Init();

    void
    Assign(
            const nsString& _message,
            const nsString& _filename,
            const uint32_t& _lineNumber,
            const uint32_t& _columnNumber);

    nsString message_;
    nsString filename_;
    uint32_t lineNumber_;
    uint32_t columnNumber_;
};


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union SendableData|
//
class SendableData MOZ_FINAL
{
public:
    enum Type {
        T__None,
        TArrayOfuint8_t = 1,
        TnsString,
        T__Last = TnsString
    };

private:
    typedef InfallibleTArray<uint8_t> ArrayOfuint8_t__tdef;
    typedef nsString nsString__tdef;

    union Value {
        char VArrayOfuint8_t[sizeof(InfallibleTArray<uint8_t>)];
        char VnsString[sizeof(nsString)];
    };

    InfallibleTArray<uint8_t>*
    ptr_ArrayOfuint8_t()
    {
        return reinterpret_cast<InfallibleTArray<uint8_t>*>((&((mValue).VArrayOfuint8_t)));
    }
    const InfallibleTArray<uint8_t>* const
    constptr_ArrayOfuint8_t() const
    {
        return reinterpret_cast<const InfallibleTArray<uint8_t>* const>((&((mValue).VArrayOfuint8_t)));
    }
    nsString*
    ptr_nsString()
    {
        return reinterpret_cast<nsString*>((&((mValue).VnsString)));
    }
    const nsString* const
    constptr_nsString() const
    {
        return reinterpret_cast<const nsString* const>((&((mValue).VnsString)));
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        NS_ABORT_IF_FALSE((T__None) <= (mType), "invalid type tag");
        NS_ABORT_IF_FALSE((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        NS_ABORT_IF_FALSE((mType) == (aType), "unexpected type tag");
    }

public:
    SendableData() :
        mType(T__None)
    {
    }

    SendableData(const InfallibleTArray<uint8_t>& aOther);

    SendableData(const nsString& aOther);

    SendableData(const SendableData& aOther);

    ~SendableData();

    Type
    type() const
    {
        return mType;
    }

    SendableData&
    operator=(const InfallibleTArray<uint8_t>& aRhs);

    SendableData&
    operator=(const nsString& aRhs);

    SendableData&
    operator=(const SendableData& aRhs);

    bool
    operator==(const InfallibleTArray<uint8_t>& aRhs) const;

    bool
    operator==(const nsString& aRhs) const;

    bool
    operator==(const SendableData& aRhs) const;

    InfallibleTArray<uint8_t>&
    get_ArrayOfuint8_t()
    {
        AssertSanity(TArrayOfuint8_t);
        return (*(ptr_ArrayOfuint8_t()));
    }
    const InfallibleTArray<uint8_t>&
    get_ArrayOfuint8_t() const
    {
        AssertSanity(TArrayOfuint8_t);
        return (*(constptr_ArrayOfuint8_t()));
    }
    operator InfallibleTArray<uint8_t>&()
    {
        return get_ArrayOfuint8_t();
    }
    operator const InfallibleTArray<uint8_t>&() const
    {
        return get_ArrayOfuint8_t();
    }

    nsString&
    get_nsString()
    {
        AssertSanity(TnsString);
        return (*(ptr_nsString()));
    }
    const nsString&
    get_nsString() const
    {
        AssertSanity(TnsString);
        return (*(constptr_nsString()));
    }
    operator nsString&()
    {
        return get_nsString();
    }
    operator const nsString&() const
    {
        return get_nsString();
    }

private:
    Value mValue;
    Type mType;
};

class SendableData;
class JSError;

//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union CallbackData|
//
class CallbackData MOZ_FINAL
{
public:
    enum Type {
        T__None,
        Tvoid_t = 1,
        TSendableData,
        TJSError,
        T__Last = TJSError
    };

private:
    typedef mozilla::void_t void_t;
    typedef void_t void_t__tdef;
    typedef SendableData SendableData__tdef;
    typedef JSError JSError__tdef;

    union Value {
        char Vvoid_t[sizeof(void_t)];
        char VSendableData[sizeof(SendableData)];
        char VJSError[sizeof(JSError)];
    };

    void_t*
    ptr_void_t()
    {
        return reinterpret_cast<void_t*>((&((mValue).Vvoid_t)));
    }
    const void_t* const
    constptr_void_t() const
    {
        return reinterpret_cast<const void_t* const>((&((mValue).Vvoid_t)));
    }
    SendableData*
    ptr_SendableData()
    {
        return reinterpret_cast<SendableData*>((&((mValue).VSendableData)));
    }
    const SendableData* const
    constptr_SendableData() const
    {
        return reinterpret_cast<const SendableData* const>((&((mValue).VSendableData)));
    }
    JSError*
    ptr_JSError()
    {
        return reinterpret_cast<JSError*>((&((mValue).VJSError)));
    }
    const JSError* const
    constptr_JSError() const
    {
        return reinterpret_cast<const JSError* const>((&((mValue).VJSError)));
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        NS_ABORT_IF_FALSE((T__None) <= (mType), "invalid type tag");
        NS_ABORT_IF_FALSE((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        NS_ABORT_IF_FALSE((mType) == (aType), "unexpected type tag");
    }

public:
    CallbackData() :
        mType(T__None)
    {
    }

    CallbackData(const void_t& aOther);

    CallbackData(const SendableData& aOther);

    CallbackData(const JSError& aOther);

    CallbackData(const CallbackData& aOther);

    ~CallbackData();

    Type
    type() const
    {
        return mType;
    }

    CallbackData&
    operator=(const void_t& aRhs);

    CallbackData&
    operator=(const SendableData& aRhs);

    CallbackData&
    operator=(const JSError& aRhs);

    CallbackData&
    operator=(const CallbackData& aRhs);

    bool
    operator==(const void_t& aRhs) const;

    bool
    operator==(const SendableData& aRhs) const;

    bool
    operator==(const JSError& aRhs) const;

    bool
    operator==(const CallbackData& aRhs) const;

    void_t&
    get_void_t()
    {
        AssertSanity(Tvoid_t);
        return (*(ptr_void_t()));
    }
    const void_t&
    get_void_t() const
    {
        AssertSanity(Tvoid_t);
        return (*(constptr_void_t()));
    }
    operator void_t&()
    {
        return get_void_t();
    }
    operator const void_t&() const
    {
        return get_void_t();
    }

    SendableData&
    get_SendableData()
    {
        AssertSanity(TSendableData);
        return (*(ptr_SendableData()));
    }
    const SendableData&
    get_SendableData() const
    {
        AssertSanity(TSendableData);
        return (*(constptr_SendableData()));
    }
    operator SendableData&()
    {
        return get_SendableData();
    }
    operator const SendableData&() const
    {
        return get_SendableData();
    }

    JSError&
    get_JSError()
    {
        AssertSanity(TJSError);
        return (*(ptr_JSError()));
    }
    const JSError&
    get_JSError() const
    {
        AssertSanity(TJSError);
        return (*(constptr_JSError()));
    }
    operator JSError&()
    {
        return get_JSError();
    }
    operator const JSError&() const
    {
        return get_JSError();
    }

private:
    Value mValue;
    Type mType;
};

//-----------------------------------------------------------------------------
// Code common to PTCPSocketChild and PTCPSocketParent
//
namespace mozilla {
namespace net {
namespace PTCPSocket {

enum State {
    __Dead,
    __Null,
    __Error,
    __Dying,
    __Start = __Null
};

enum MessageType {
    PTCPSocketStart = PTCPSocketMsgStart << 16,
    PTCPSocketPreStart = (PTCPSocketMsgStart << 16) - 1,
    Msg_Data__ID,
    Msg_Suspend__ID,
    Msg_Resume__ID,
    Msg_Close__ID,
    Msg_RequestDelete__ID,
    Msg_Callback__ID,
    Msg___delete____ID,
    Reply___delete____ID,
    PTCPSocketEnd
};

bool
Transition(
        State from,
        mozilla::ipc::Trigger trigger,
        State* next);

class Msg_Data :
    public IPC::Message
{
private:
    typedef mozilla::ipc::ActorHandle ActorHandle;
    typedef mozilla::ipc::FileDescriptor FileDescriptor;
    typedef mozilla::ipc::Shmem Shmem;
    typedef mozilla::void_t void_t;

public:
    enum {
        ID = Msg_Data__ID
    };
    Msg_Data() :
        IPC::Message(MSG_ROUTING_NONE, ID, PRIORITY_NORMAL, COMPRESSION_NONE, "PTCPSocket::Msg_Data")
    {
    }

    void
    Log(
            const std::string& __pfx,
            FILE* __outf) const
    {
        std::string __logmsg;
        StringAppendF((&(__logmsg)), "[time:%" PRId64 "][%d]", PR_Now(), base::GetCurrentProcId());
        (__logmsg).append(__pfx);
        (__logmsg).append("Msg_Data(");

        (__logmsg).append("[TODO])\n");
        fputs((__logmsg).c_str(), __outf);
    }
};

class Msg_Suspend :
    public IPC::Message
{
private:
    typedef mozilla::ipc::ActorHandle ActorHandle;
    typedef mozilla::ipc::FileDescriptor FileDescriptor;
    typedef mozilla::ipc::Shmem Shmem;
    typedef mozilla::void_t void_t;

public:
    enum {
        ID = Msg_Suspend__ID
    };
    Msg_Suspend() :
        IPC::Message(MSG_ROUTING_NONE, ID, PRIORITY_NORMAL, COMPRESSION_NONE, "PTCPSocket::Msg_Suspend")
    {
    }

    void
    Log(
            const std::string& __pfx,
            FILE* __outf) const
    {
        std::string __logmsg;
        StringAppendF((&(__logmsg)), "[time:%" PRId64 "][%d]", PR_Now(), base::GetCurrentProcId());
        (__logmsg).append(__pfx);
        (__logmsg).append("Msg_Suspend(");

        (__logmsg).append("[TODO])\n");
        fputs((__logmsg).c_str(), __outf);
    }
};

class Msg_Resume :
    public IPC::Message
{
private:
    typedef mozilla::ipc::ActorHandle ActorHandle;
    typedef mozilla::ipc::FileDescriptor FileDescriptor;
    typedef mozilla::ipc::Shmem Shmem;
    typedef mozilla::void_t void_t;

public:
    enum {
        ID = Msg_Resume__ID
    };
    Msg_Resume() :
        IPC::Message(MSG_ROUTING_NONE, ID, PRIORITY_NORMAL, COMPRESSION_NONE, "PTCPSocket::Msg_Resume")
    {
    }

    void
    Log(
            const std::string& __pfx,
            FILE* __outf) const
    {
        std::string __logmsg;
        StringAppendF((&(__logmsg)), "[time:%" PRId64 "][%d]", PR_Now(), base::GetCurrentProcId());
        (__logmsg).append(__pfx);
        (__logmsg).append("Msg_Resume(");

        (__logmsg).append("[TODO])\n");
        fputs((__logmsg).c_str(), __outf);
    }
};

class Msg_Close :
    public IPC::Message
{
private:
    typedef mozilla::ipc::ActorHandle ActorHandle;
    typedef mozilla::ipc::FileDescriptor FileDescriptor;
    typedef mozilla::ipc::Shmem Shmem;
    typedef mozilla::void_t void_t;

public:
    enum {
        ID = Msg_Close__ID
    };
    Msg_Close() :
        IPC::Message(MSG_ROUTING_NONE, ID, PRIORITY_NORMAL, COMPRESSION_NONE, "PTCPSocket::Msg_Close")
    {
    }

    void
    Log(
            const std::string& __pfx,
            FILE* __outf) const
    {
        std::string __logmsg;
        StringAppendF((&(__logmsg)), "[time:%" PRId64 "][%d]", PR_Now(), base::GetCurrentProcId());
        (__logmsg).append(__pfx);
        (__logmsg).append("Msg_Close(");

        (__logmsg).append("[TODO])\n");
        fputs((__logmsg).c_str(), __outf);
    }
};

class Msg_RequestDelete :
    public IPC::Message
{
private:
    typedef mozilla::ipc::ActorHandle ActorHandle;
    typedef mozilla::ipc::FileDescriptor FileDescriptor;
    typedef mozilla::ipc::Shmem Shmem;
    typedef mozilla::void_t void_t;

public:
    enum {
        ID = Msg_RequestDelete__ID
    };
    Msg_RequestDelete() :
        IPC::Message(MSG_ROUTING_NONE, ID, PRIORITY_NORMAL, COMPRESSION_NONE, "PTCPSocket::Msg_RequestDelete")
    {
    }

    void
    Log(
            const std::string& __pfx,
            FILE* __outf) const
    {
        std::string __logmsg;
        StringAppendF((&(__logmsg)), "[time:%" PRId64 "][%d]", PR_Now(), base::GetCurrentProcId());
        (__logmsg).append(__pfx);
        (__logmsg).append("Msg_RequestDelete(");

        (__logmsg).append("[TODO])\n");
        fputs((__logmsg).c_str(), __outf);
    }
};

class Msg_Callback :
    public IPC::Message
{
private:
    typedef mozilla::ipc::ActorHandle ActorHandle;
    typedef mozilla::ipc::FileDescriptor FileDescriptor;
    typedef mozilla::ipc::Shmem Shmem;
    typedef mozilla::void_t void_t;

public:
    enum {
        ID = Msg_Callback__ID
    };
    Msg_Callback() :
        IPC::Message(MSG_ROUTING_NONE, ID, PRIORITY_NORMAL, COMPRESSION_NONE, "PTCPSocket::Msg_Callback")
    {
    }

    void
    Log(
            const std::string& __pfx,
            FILE* __outf) const
    {
        std::string __logmsg;
        StringAppendF((&(__logmsg)), "[time:%" PRId64 "][%d]", PR_Now(), base::GetCurrentProcId());
        (__logmsg).append(__pfx);
        (__logmsg).append("Msg_Callback(");

        (__logmsg).append("[TODO])\n");
        fputs((__logmsg).c_str(), __outf);
    }
};

class Msg___delete__ :
    public IPC::Message
{
private:
    typedef mozilla::ipc::ActorHandle ActorHandle;
    typedef mozilla::ipc::FileDescriptor FileDescriptor;
    typedef mozilla::ipc::Shmem Shmem;
    typedef mozilla::void_t void_t;

public:
    enum {
        ID = Msg___delete____ID
    };
    Msg___delete__() :
        IPC::Message(MSG_ROUTING_NONE, ID, PRIORITY_NORMAL, COMPRESSION_NONE, "PTCPSocket::Msg___delete__")
    {
    }

    void
    Log(
            const std::string& __pfx,
            FILE* __outf) const
    {
        std::string __logmsg;
        StringAppendF((&(__logmsg)), "[time:%" PRId64 "][%d]", PR_Now(), base::GetCurrentProcId());
        (__logmsg).append(__pfx);
        (__logmsg).append("Msg___delete__(");

        (__logmsg).append("[TODO])\n");
        fputs((__logmsg).c_str(), __outf);
    }
};

class Reply___delete__ :
    public IPC::Message
{
private:
    typedef mozilla::ipc::ActorHandle ActorHandle;
    typedef mozilla::ipc::FileDescriptor FileDescriptor;
    typedef mozilla::ipc::Shmem Shmem;
    typedef mozilla::void_t void_t;

public:
    enum {
        ID = Reply___delete____ID
    };
    Reply___delete__() :
        IPC::Message(MSG_ROUTING_NONE, ID, PRIORITY_NORMAL, COMPRESSION_NONE, "PTCPSocket::Reply___delete__")
    {
    }

    void
    Log(
            const std::string& __pfx,
            FILE* __outf) const
    {
        std::string __logmsg;
        StringAppendF((&(__logmsg)), "[time:%" PRId64 "][%d]", PR_Now(), base::GetCurrentProcId());
        (__logmsg).append(__pfx);
        (__logmsg).append("Reply___delete__(");

        (__logmsg).append("[TODO])\n");
        fputs((__logmsg).c_str(), __outf);
    }
};



} // namespace PTCPSocket
} // namespace net
} // namespace mozilla

#endif // ifndef PTCPSocket_h
