/* THIS FILE IS AUTOGENERATED - DO NOT EDIT */

#include "AccessCheck.h"
#include "CSSStyleDeclarationBinding.h"
#include "CSSValueBinding.h"
#include "ElementBinding.h"
#include "EventHandlerBinding.h"
#include "EventTargetBinding.h"
#include "NodeBinding.h"
#include "PrimitiveConversions.h"
#include "SVGElementBinding.h"
#include "WorkerPrivate.h"
#include "XPCQuickStubs.h"
#include "XPCWrapper.h"
#include "mozilla/Preferences.h"
#include "mozilla/dom/BindingUtils.h"
#include "mozilla/dom/CSSValue.h"
#include "mozilla/dom/NonRefcountedDOMObject.h"
#include "mozilla/dom/Nullable.h"
#include "nsContentUtils.h"
#include "nsDOMQS.h"
#include "nsICSSDeclaration.h"
#include "nsIDOMSVGAnimatedString.h"
#include "nsIDOMSVGElement.h"
#include "nsSVGElement.h"
#include "nsSVGSVGElement.h"

using namespace mozilla::dom;
namespace mozilla {
namespace dom {

namespace SVGElementBinding {

static bool
get_id(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* vp)
{
  nsString result;
  self->GetId(result);
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_id(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eStringify, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  self->SetId(arg0);

  return true;
}


const JSJitInfo id_getterinfo = {
  (JSJitPropertyOp)get_id,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo id_setterinfo = {
  (JSJitPropertyOp)set_id,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_className(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* vp)
{
  nsRefPtr<nsIDOMSVGAnimatedString> result;
  result = self->ClassName();
  if (!WrapObject(cx, obj, result, vp)) {
    return false;
  }
  return true;
}


const JSJitInfo className_getterinfo = {
  (JSJitPropertyOp)get_className,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_style(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* vp)
{
  ErrorResult rv;
  nsICSSDeclaration* result;
  result = self->GetStyle(rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGElement", "style");
  }
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}


const JSJitInfo style_getterinfo = {
  (JSJitPropertyOp)get_style,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
getPresentationAttribute(JSContext* cx, JSHandleObject obj, nsSVGElement* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "SVGElement.getPresentationAttribute");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eStringify, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  nsRefPtr<mozilla::dom::CSSValue> result;
  result = self->GetPresentationAttribute(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGElement", "getPresentationAttribute");
  }
  if (!result) {
    *vp = JSVAL_NULL;
    return true;
  }
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}


const JSJitInfo getPresentationAttribute_methodinfo = {
  (JSJitPropertyOp)getPresentationAttribute,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_ownerSVGElement(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* vp)
{
  ErrorResult rv;
  nsSVGSVGElement* result;
  result = self->GetOwnerSVGElement(rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGElement", "ownerSVGElement");
  }
  if (!result) {
    *vp = JSVAL_NULL;
    return true;
  }
  if (!WrapObject(cx, obj, result, vp)) {
    return false;
  }
  return true;
}


const JSJitInfo ownerSVGElement_getterinfo = {
  (JSJitPropertyOp)get_ownerSVGElement,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_viewportElement(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* vp)
{
  nsSVGElement* result;
  result = self->GetViewportElement();
  if (!result) {
    *vp = JSVAL_NULL;
    return true;
  }
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    if (!HandleNewBindingWrappingFailure(cx, obj, result, vp)) {
      return false;
    }
    return true;
  }
  return true;
}


const JSJitInfo viewportElement_getterinfo = {
  (JSJitPropertyOp)get_viewportElement,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onabort(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnabort();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onabort(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnabort(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGElement", "onabort");
  }

  return true;
}


const JSJitInfo onabort_getterinfo = {
  (JSJitPropertyOp)get_onabort,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onabort_setterinfo = {
  (JSJitPropertyOp)set_onabort,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onblur(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnblur();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onblur(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnblur(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGElement", "onblur");
  }

  return true;
}


const JSJitInfo onblur_getterinfo = {
  (JSJitPropertyOp)get_onblur,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onblur_setterinfo = {
  (JSJitPropertyOp)set_onblur,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_oncanplay(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOncanplay();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_oncanplay(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOncanplay(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGElement", "oncanplay");
  }

  return true;
}


const JSJitInfo oncanplay_getterinfo = {
  (JSJitPropertyOp)get_oncanplay,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo oncanplay_setterinfo = {
  (JSJitPropertyOp)set_oncanplay,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_oncanplaythrough(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOncanplaythrough();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_oncanplaythrough(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOncanplaythrough(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGElement", "oncanplaythrough");
  }

  return true;
}


const JSJitInfo oncanplaythrough_getterinfo = {
  (JSJitPropertyOp)get_oncanplaythrough,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo oncanplaythrough_setterinfo = {
  (JSJitPropertyOp)set_oncanplaythrough,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onchange(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnchange();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onchange(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnchange(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGElement", "onchange");
  }

  return true;
}


const JSJitInfo onchange_getterinfo = {
  (JSJitPropertyOp)get_onchange,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onchange_setterinfo = {
  (JSJitPropertyOp)set_onchange,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onclick(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnclick();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onclick(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnclick(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGElement", "onclick");
  }

  return true;
}


const JSJitInfo onclick_getterinfo = {
  (JSJitPropertyOp)get_onclick,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onclick_setterinfo = {
  (JSJitPropertyOp)set_onclick,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_oncontextmenu(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOncontextmenu();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_oncontextmenu(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOncontextmenu(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGElement", "oncontextmenu");
  }

  return true;
}


const JSJitInfo oncontextmenu_getterinfo = {
  (JSJitPropertyOp)get_oncontextmenu,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo oncontextmenu_setterinfo = {
  (JSJitPropertyOp)set_oncontextmenu,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_ondblclick(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOndblclick();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_ondblclick(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOndblclick(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGElement", "ondblclick");
  }

  return true;
}


const JSJitInfo ondblclick_getterinfo = {
  (JSJitPropertyOp)get_ondblclick,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo ondblclick_setterinfo = {
  (JSJitPropertyOp)set_ondblclick,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_ondrag(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOndrag();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_ondrag(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOndrag(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGElement", "ondrag");
  }

  return true;
}


const JSJitInfo ondrag_getterinfo = {
  (JSJitPropertyOp)get_ondrag,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo ondrag_setterinfo = {
  (JSJitPropertyOp)set_ondrag,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_ondragend(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOndragend();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_ondragend(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOndragend(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGElement", "ondragend");
  }

  return true;
}


const JSJitInfo ondragend_getterinfo = {
  (JSJitPropertyOp)get_ondragend,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo ondragend_setterinfo = {
  (JSJitPropertyOp)set_ondragend,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_ondragenter(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOndragenter();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_ondragenter(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOndragenter(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGElement", "ondragenter");
  }

  return true;
}


const JSJitInfo ondragenter_getterinfo = {
  (JSJitPropertyOp)get_ondragenter,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo ondragenter_setterinfo = {
  (JSJitPropertyOp)set_ondragenter,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_ondragleave(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOndragleave();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_ondragleave(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOndragleave(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGElement", "ondragleave");
  }

  return true;
}


const JSJitInfo ondragleave_getterinfo = {
  (JSJitPropertyOp)get_ondragleave,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo ondragleave_setterinfo = {
  (JSJitPropertyOp)set_ondragleave,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_ondragover(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOndragover();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_ondragover(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOndragover(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGElement", "ondragover");
  }

  return true;
}


const JSJitInfo ondragover_getterinfo = {
  (JSJitPropertyOp)get_ondragover,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo ondragover_setterinfo = {
  (JSJitPropertyOp)set_ondragover,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_ondragstart(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOndragstart();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_ondragstart(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOndragstart(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGElement", "ondragstart");
  }

  return true;
}


const JSJitInfo ondragstart_getterinfo = {
  (JSJitPropertyOp)get_ondragstart,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo ondragstart_setterinfo = {
  (JSJitPropertyOp)set_ondragstart,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_ondrop(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOndrop();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_ondrop(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOndrop(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGElement", "ondrop");
  }

  return true;
}


const JSJitInfo ondrop_getterinfo = {
  (JSJitPropertyOp)get_ondrop,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo ondrop_setterinfo = {
  (JSJitPropertyOp)set_ondrop,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_ondurationchange(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOndurationchange();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_ondurationchange(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOndurationchange(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGElement", "ondurationchange");
  }

  return true;
}


const JSJitInfo ondurationchange_getterinfo = {
  (JSJitPropertyOp)get_ondurationchange,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo ondurationchange_setterinfo = {
  (JSJitPropertyOp)set_ondurationchange,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onemptied(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnemptied();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onemptied(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnemptied(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGElement", "onemptied");
  }

  return true;
}


const JSJitInfo onemptied_getterinfo = {
  (JSJitPropertyOp)get_onemptied,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onemptied_setterinfo = {
  (JSJitPropertyOp)set_onemptied,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onended(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnended();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onended(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnended(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGElement", "onended");
  }

  return true;
}


const JSJitInfo onended_getterinfo = {
  (JSJitPropertyOp)get_onended,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onended_setterinfo = {
  (JSJitPropertyOp)set_onended,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onerror(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnerror();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onerror(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnerror(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGElement", "onerror");
  }

  return true;
}


const JSJitInfo onerror_getterinfo = {
  (JSJitPropertyOp)get_onerror,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onerror_setterinfo = {
  (JSJitPropertyOp)set_onerror,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onfocus(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnfocus();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onfocus(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnfocus(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGElement", "onfocus");
  }

  return true;
}


const JSJitInfo onfocus_getterinfo = {
  (JSJitPropertyOp)get_onfocus,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onfocus_setterinfo = {
  (JSJitPropertyOp)set_onfocus,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_oninput(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOninput();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_oninput(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOninput(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGElement", "oninput");
  }

  return true;
}


const JSJitInfo oninput_getterinfo = {
  (JSJitPropertyOp)get_oninput,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo oninput_setterinfo = {
  (JSJitPropertyOp)set_oninput,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_oninvalid(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOninvalid();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_oninvalid(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOninvalid(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGElement", "oninvalid");
  }

  return true;
}


const JSJitInfo oninvalid_getterinfo = {
  (JSJitPropertyOp)get_oninvalid,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo oninvalid_setterinfo = {
  (JSJitPropertyOp)set_oninvalid,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onkeydown(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnkeydown();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onkeydown(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnkeydown(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGElement", "onkeydown");
  }

  return true;
}


const JSJitInfo onkeydown_getterinfo = {
  (JSJitPropertyOp)get_onkeydown,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onkeydown_setterinfo = {
  (JSJitPropertyOp)set_onkeydown,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onkeypress(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnkeypress();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onkeypress(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnkeypress(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGElement", "onkeypress");
  }

  return true;
}


const JSJitInfo onkeypress_getterinfo = {
  (JSJitPropertyOp)get_onkeypress,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onkeypress_setterinfo = {
  (JSJitPropertyOp)set_onkeypress,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onkeyup(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnkeyup();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onkeyup(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnkeyup(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGElement", "onkeyup");
  }

  return true;
}


const JSJitInfo onkeyup_getterinfo = {
  (JSJitPropertyOp)get_onkeyup,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onkeyup_setterinfo = {
  (JSJitPropertyOp)set_onkeyup,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onload(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnload();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onload(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnload(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGElement", "onload");
  }

  return true;
}


const JSJitInfo onload_getterinfo = {
  (JSJitPropertyOp)get_onload,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onload_setterinfo = {
  (JSJitPropertyOp)set_onload,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onloadeddata(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnloadeddata();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onloadeddata(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnloadeddata(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGElement", "onloadeddata");
  }

  return true;
}


const JSJitInfo onloadeddata_getterinfo = {
  (JSJitPropertyOp)get_onloadeddata,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onloadeddata_setterinfo = {
  (JSJitPropertyOp)set_onloadeddata,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onloadedmetadata(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnloadedmetadata();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onloadedmetadata(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnloadedmetadata(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGElement", "onloadedmetadata");
  }

  return true;
}


const JSJitInfo onloadedmetadata_getterinfo = {
  (JSJitPropertyOp)get_onloadedmetadata,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onloadedmetadata_setterinfo = {
  (JSJitPropertyOp)set_onloadedmetadata,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onloadstart(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnloadstart();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onloadstart(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnloadstart(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGElement", "onloadstart");
  }

  return true;
}


const JSJitInfo onloadstart_getterinfo = {
  (JSJitPropertyOp)get_onloadstart,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onloadstart_setterinfo = {
  (JSJitPropertyOp)set_onloadstart,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onmousedown(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnmousedown();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onmousedown(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnmousedown(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGElement", "onmousedown");
  }

  return true;
}


const JSJitInfo onmousedown_getterinfo = {
  (JSJitPropertyOp)get_onmousedown,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onmousedown_setterinfo = {
  (JSJitPropertyOp)set_onmousedown,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onmousemove(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnmousemove();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onmousemove(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnmousemove(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGElement", "onmousemove");
  }

  return true;
}


const JSJitInfo onmousemove_getterinfo = {
  (JSJitPropertyOp)get_onmousemove,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onmousemove_setterinfo = {
  (JSJitPropertyOp)set_onmousemove,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onmouseout(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnmouseout();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onmouseout(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnmouseout(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGElement", "onmouseout");
  }

  return true;
}


const JSJitInfo onmouseout_getterinfo = {
  (JSJitPropertyOp)get_onmouseout,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onmouseout_setterinfo = {
  (JSJitPropertyOp)set_onmouseout,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onmouseover(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnmouseover();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onmouseover(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnmouseover(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGElement", "onmouseover");
  }

  return true;
}


const JSJitInfo onmouseover_getterinfo = {
  (JSJitPropertyOp)get_onmouseover,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onmouseover_setterinfo = {
  (JSJitPropertyOp)set_onmouseover,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onmouseup(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnmouseup();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onmouseup(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnmouseup(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGElement", "onmouseup");
  }

  return true;
}


const JSJitInfo onmouseup_getterinfo = {
  (JSJitPropertyOp)get_onmouseup,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onmouseup_setterinfo = {
  (JSJitPropertyOp)set_onmouseup,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onpause(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnpause();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onpause(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnpause(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGElement", "onpause");
  }

  return true;
}


const JSJitInfo onpause_getterinfo = {
  (JSJitPropertyOp)get_onpause,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onpause_setterinfo = {
  (JSJitPropertyOp)set_onpause,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onplay(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnplay();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onplay(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnplay(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGElement", "onplay");
  }

  return true;
}


const JSJitInfo onplay_getterinfo = {
  (JSJitPropertyOp)get_onplay,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onplay_setterinfo = {
  (JSJitPropertyOp)set_onplay,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onplaying(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnplaying();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onplaying(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnplaying(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGElement", "onplaying");
  }

  return true;
}


const JSJitInfo onplaying_getterinfo = {
  (JSJitPropertyOp)get_onplaying,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onplaying_setterinfo = {
  (JSJitPropertyOp)set_onplaying,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onprogress(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnprogress();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onprogress(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnprogress(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGElement", "onprogress");
  }

  return true;
}


const JSJitInfo onprogress_getterinfo = {
  (JSJitPropertyOp)get_onprogress,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onprogress_setterinfo = {
  (JSJitPropertyOp)set_onprogress,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onratechange(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnratechange();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onratechange(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnratechange(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGElement", "onratechange");
  }

  return true;
}


const JSJitInfo onratechange_getterinfo = {
  (JSJitPropertyOp)get_onratechange,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onratechange_setterinfo = {
  (JSJitPropertyOp)set_onratechange,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onreset(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnreset();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onreset(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnreset(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGElement", "onreset");
  }

  return true;
}


const JSJitInfo onreset_getterinfo = {
  (JSJitPropertyOp)get_onreset,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onreset_setterinfo = {
  (JSJitPropertyOp)set_onreset,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onscroll(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnscroll();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onscroll(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnscroll(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGElement", "onscroll");
  }

  return true;
}


const JSJitInfo onscroll_getterinfo = {
  (JSJitPropertyOp)get_onscroll,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onscroll_setterinfo = {
  (JSJitPropertyOp)set_onscroll,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onseeked(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnseeked();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onseeked(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnseeked(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGElement", "onseeked");
  }

  return true;
}


const JSJitInfo onseeked_getterinfo = {
  (JSJitPropertyOp)get_onseeked,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onseeked_setterinfo = {
  (JSJitPropertyOp)set_onseeked,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onseeking(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnseeking();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onseeking(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnseeking(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGElement", "onseeking");
  }

  return true;
}


const JSJitInfo onseeking_getterinfo = {
  (JSJitPropertyOp)get_onseeking,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onseeking_setterinfo = {
  (JSJitPropertyOp)set_onseeking,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onselect(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnselect();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onselect(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnselect(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGElement", "onselect");
  }

  return true;
}


const JSJitInfo onselect_getterinfo = {
  (JSJitPropertyOp)get_onselect,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onselect_setterinfo = {
  (JSJitPropertyOp)set_onselect,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onshow(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnshow();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onshow(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnshow(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGElement", "onshow");
  }

  return true;
}


const JSJitInfo onshow_getterinfo = {
  (JSJitPropertyOp)get_onshow,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onshow_setterinfo = {
  (JSJitPropertyOp)set_onshow,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onstalled(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnstalled();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onstalled(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnstalled(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGElement", "onstalled");
  }

  return true;
}


const JSJitInfo onstalled_getterinfo = {
  (JSJitPropertyOp)get_onstalled,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onstalled_setterinfo = {
  (JSJitPropertyOp)set_onstalled,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onsubmit(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnsubmit();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onsubmit(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnsubmit(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGElement", "onsubmit");
  }

  return true;
}


const JSJitInfo onsubmit_getterinfo = {
  (JSJitPropertyOp)get_onsubmit,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onsubmit_setterinfo = {
  (JSJitPropertyOp)set_onsubmit,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onsuspend(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnsuspend();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onsuspend(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnsuspend(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGElement", "onsuspend");
  }

  return true;
}


const JSJitInfo onsuspend_getterinfo = {
  (JSJitPropertyOp)get_onsuspend,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onsuspend_setterinfo = {
  (JSJitPropertyOp)set_onsuspend,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_ontimeupdate(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOntimeupdate();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_ontimeupdate(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOntimeupdate(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGElement", "ontimeupdate");
  }

  return true;
}


const JSJitInfo ontimeupdate_getterinfo = {
  (JSJitPropertyOp)get_ontimeupdate,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo ontimeupdate_setterinfo = {
  (JSJitPropertyOp)set_ontimeupdate,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onvolumechange(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnvolumechange();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onvolumechange(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnvolumechange(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGElement", "onvolumechange");
  }

  return true;
}


const JSJitInfo onvolumechange_getterinfo = {
  (JSJitPropertyOp)get_onvolumechange,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onvolumechange_setterinfo = {
  (JSJitPropertyOp)set_onvolumechange,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onwaiting(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnwaiting();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onwaiting(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnwaiting(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGElement", "onwaiting");
  }

  return true;
}


const JSJitInfo onwaiting_getterinfo = {
  (JSJitPropertyOp)get_onwaiting,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onwaiting_setterinfo = {
  (JSJitPropertyOp)set_onwaiting,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onmozfullscreenchange(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnmozfullscreenchange();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onmozfullscreenchange(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnmozfullscreenchange(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGElement", "onmozfullscreenchange");
  }

  return true;
}


const JSJitInfo onmozfullscreenchange_getterinfo = {
  (JSJitPropertyOp)get_onmozfullscreenchange,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onmozfullscreenchange_setterinfo = {
  (JSJitPropertyOp)set_onmozfullscreenchange,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onmozfullscreenerror(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnmozfullscreenerror();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onmozfullscreenerror(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnmozfullscreenerror(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGElement", "onmozfullscreenerror");
  }

  return true;
}


const JSJitInfo onmozfullscreenerror_getterinfo = {
  (JSJitPropertyOp)get_onmozfullscreenerror,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onmozfullscreenerror_setterinfo = {
  (JSJitPropertyOp)set_onmozfullscreenerror,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onmozpointerlockchange(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnmozpointerlockchange();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onmozpointerlockchange(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnmozpointerlockchange(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGElement", "onmozpointerlockchange");
  }

  return true;
}


const JSJitInfo onmozpointerlockchange_getterinfo = {
  (JSJitPropertyOp)get_onmozpointerlockchange,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onmozpointerlockchange_setterinfo = {
  (JSJitPropertyOp)set_onmozpointerlockchange,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onmozpointerlockerror(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnmozpointerlockerror();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onmozpointerlockerror(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnmozpointerlockerror(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGElement", "onmozpointerlockerror");
  }

  return true;
}


const JSJitInfo onmozpointerlockerror_getterinfo = {
  (JSJitPropertyOp)get_onmozpointerlockerror,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onmozpointerlockerror_setterinfo = {
  (JSJitPropertyOp)set_onmozpointerlockerror,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_ontouchstart(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOntouchstart();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_ontouchstart(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOntouchstart(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGElement", "ontouchstart");
  }

  return true;
}


const JSJitInfo ontouchstart_getterinfo = {
  (JSJitPropertyOp)get_ontouchstart,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo ontouchstart_setterinfo = {
  (JSJitPropertyOp)set_ontouchstart,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_ontouchend(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOntouchend();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_ontouchend(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOntouchend(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGElement", "ontouchend");
  }

  return true;
}


const JSJitInfo ontouchend_getterinfo = {
  (JSJitPropertyOp)get_ontouchend,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo ontouchend_setterinfo = {
  (JSJitPropertyOp)set_ontouchend,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_ontouchmove(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOntouchmove();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_ontouchmove(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOntouchmove(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGElement", "ontouchmove");
  }

  return true;
}


const JSJitInfo ontouchmove_getterinfo = {
  (JSJitPropertyOp)get_ontouchmove,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo ontouchmove_setterinfo = {
  (JSJitPropertyOp)set_ontouchmove,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_ontouchenter(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOntouchenter();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_ontouchenter(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOntouchenter(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGElement", "ontouchenter");
  }

  return true;
}


const JSJitInfo ontouchenter_getterinfo = {
  (JSJitPropertyOp)get_ontouchenter,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo ontouchenter_setterinfo = {
  (JSJitPropertyOp)set_ontouchenter,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_ontouchleave(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOntouchleave();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_ontouchleave(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOntouchleave(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGElement", "ontouchleave");
  }

  return true;
}


const JSJitInfo ontouchleave_getterinfo = {
  (JSJitPropertyOp)get_ontouchleave,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo ontouchleave_setterinfo = {
  (JSJitPropertyOp)set_ontouchleave,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_ontouchcancel(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOntouchcancel();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_ontouchcancel(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOntouchcancel(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGElement", "ontouchcancel");
  }

  return true;
}


const JSJitInfo ontouchcancel_getterinfo = {
  (JSJitPropertyOp)get_ontouchcancel,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo ontouchcancel_setterinfo = {
  (JSJitPropertyOp)set_ontouchcancel,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_oncopy(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOncopy();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_oncopy(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOncopy(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGElement", "oncopy");
  }

  return true;
}


const JSJitInfo oncopy_getterinfo = {
  (JSJitPropertyOp)get_oncopy,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo oncopy_setterinfo = {
  (JSJitPropertyOp)set_oncopy,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_oncut(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOncut();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_oncut(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOncut(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGElement", "oncut");
  }

  return true;
}


const JSJitInfo oncut_getterinfo = {
  (JSJitPropertyOp)get_oncut,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo oncut_setterinfo = {
  (JSJitPropertyOp)set_oncut,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onpaste(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnpaste();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onpaste(JSContext* cx, JSHandleObject obj, nsSVGElement* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnpaste(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGElement", "onpaste");
  }

  return true;
}


const JSJitInfo onpaste_getterinfo = {
  (JSJitPropertyOp)get_onpaste,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onpaste_setterinfo = {
  (JSJitPropertyOp)set_onpaste,
  prototypes::id::SVGElement,
  PrototypeTraits<prototypes::id::SVGElement>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static JSBool
genericMethod(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  nsSVGElement* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::SVGElement, nsSVGElement>(cx, obj, self);
    if (NS_FAILED(rv)) {
      nsSVGElement *objPtr;
      xpc_qsSelfRef objRef;
      JS::Value val = JS::ObjectValue(*obj);
      nsresult rv = xpc_qsUnwrapArg<nsSVGElement>(cx, val, &objPtr, &objRef.ptr, &val);
      if (NS_FAILED(rv)) {
          return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "SVGElement");
      }
      // We should be castable!
      MOZ_ASSERT(!objRef.ptr);
      // We should have an object, too!
      MOZ_ASSERT(objPtr);
      self = objPtr;
    }
  }
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Method);
  JSJitMethodOp method = (JSJitMethodOp)info->op;
  return method(cx, obj, self, argc, vp);
}

static JSBool
genericGetter(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  nsSVGElement* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::SVGElement, nsSVGElement>(cx, obj, self);
    if (NS_FAILED(rv)) {
      nsSVGElement *objPtr;
      xpc_qsSelfRef objRef;
      JS::Value val = JS::ObjectValue(*obj);
      nsresult rv = xpc_qsUnwrapArg<nsSVGElement>(cx, val, &objPtr, &objRef.ptr, &val);
      if (NS_FAILED(rv)) {
          return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "SVGElement");
      }
      // We should be castable!
      MOZ_ASSERT(!objRef.ptr);
      // We should have an object, too!
      MOZ_ASSERT(objPtr);
      self = objPtr;
    }
  }
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Getter);
  JSJitPropertyOp getter = info->op;
  return getter(cx, obj, self, vp);
}

static JSBool
genericSetter(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  nsSVGElement* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::SVGElement, nsSVGElement>(cx, obj, self);
    if (NS_FAILED(rv)) {
      nsSVGElement *objPtr;
      xpc_qsSelfRef objRef;
      JS::Value val = JS::ObjectValue(*obj);
      nsresult rv = xpc_qsUnwrapArg<nsSVGElement>(cx, val, &objPtr, &objRef.ptr, &val);
      if (NS_FAILED(rv)) {
          return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "SVGElement");
      }
      // We should be castable!
      MOZ_ASSERT(!objRef.ptr);
      // We should have an object, too!
      MOZ_ASSERT(objPtr);
      self = objPtr;
    }
  }
  if (argc == 0) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "SVGElement attribute setter");
  }
  JS::Value* argv = JS_ARGV(cx, vp);
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Setter);
  JSJitPropertyOp setter = info->op;
  if (!setter(cx, obj, self, argv)) {
    return false;
  }
  *vp = JSVAL_VOID;
  return true;
}

static JSBool
_addProperty(JSContext* cx, JSHandleObject obj, JSHandleId id, JSMutableHandleValue vp)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, nsSVGElement>::value), "Must be an nsISupports class");
  nsSVGElement* self = UnwrapDOMObject<nsSVGElement>(obj);
  nsContentUtils::PreserveWrapper(reinterpret_cast<nsISupports*>(self), self);
  return true;
}

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, nsSVGElement>::value), "Must be an nsISupports class");
  nsSVGElement* self = UnwrapDOMObject<nsSVGElement>(obj);
  if (self) {
    ClearWrapper(self, self);
    XPCJSRuntime *rt = nsXPConnect::GetRuntimeInstance();
    if (rt) {
      rt->DeferredRelease(reinterpret_cast<nsISupports*>(self));
    } else {
      NS_RELEASE(self);
    }
  }
}

static JSFunctionSpec sMethods_specs[] = {
  JS_FNINFO("getPresentationAttribute", genericMethod, &getPresentationAttribute_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FS_END
};

static Prefable<JSFunctionSpec> sMethods[] = {
  { true, &sMethods_specs[0] },
  { false, NULL }
};

static jsid sMethods_ids[2] = { JSID_VOID };

static JSPropertySpec sAttributes_specs[] = {
  { "id", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &id_getterinfo }, { (JSStrictPropertyOp)genericSetter, &id_setterinfo }},
  { "className", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &className_getterinfo }, JSOP_NULLWRAPPER},
  { "style", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &style_getterinfo }, JSOP_NULLWRAPPER},
  { "ownerSVGElement", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &ownerSVGElement_getterinfo }, JSOP_NULLWRAPPER},
  { "viewportElement", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &viewportElement_getterinfo }, JSOP_NULLWRAPPER},
  { "onabort", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onabort_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onabort_setterinfo }},
  { "onblur", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onblur_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onblur_setterinfo }},
  { "oncanplay", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &oncanplay_getterinfo }, { (JSStrictPropertyOp)genericSetter, &oncanplay_setterinfo }},
  { "oncanplaythrough", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &oncanplaythrough_getterinfo }, { (JSStrictPropertyOp)genericSetter, &oncanplaythrough_setterinfo }},
  { "onchange", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onchange_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onchange_setterinfo }},
  { "onclick", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onclick_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onclick_setterinfo }},
  { "oncontextmenu", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &oncontextmenu_getterinfo }, { (JSStrictPropertyOp)genericSetter, &oncontextmenu_setterinfo }},
  { "ondblclick", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &ondblclick_getterinfo }, { (JSStrictPropertyOp)genericSetter, &ondblclick_setterinfo }},
  { "ondrag", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &ondrag_getterinfo }, { (JSStrictPropertyOp)genericSetter, &ondrag_setterinfo }},
  { "ondragend", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &ondragend_getterinfo }, { (JSStrictPropertyOp)genericSetter, &ondragend_setterinfo }},
  { "ondragenter", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &ondragenter_getterinfo }, { (JSStrictPropertyOp)genericSetter, &ondragenter_setterinfo }},
  { "ondragleave", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &ondragleave_getterinfo }, { (JSStrictPropertyOp)genericSetter, &ondragleave_setterinfo }},
  { "ondragover", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &ondragover_getterinfo }, { (JSStrictPropertyOp)genericSetter, &ondragover_setterinfo }},
  { "ondragstart", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &ondragstart_getterinfo }, { (JSStrictPropertyOp)genericSetter, &ondragstart_setterinfo }},
  { "ondrop", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &ondrop_getterinfo }, { (JSStrictPropertyOp)genericSetter, &ondrop_setterinfo }},
  { "ondurationchange", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &ondurationchange_getterinfo }, { (JSStrictPropertyOp)genericSetter, &ondurationchange_setterinfo }},
  { "onemptied", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onemptied_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onemptied_setterinfo }},
  { "onended", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onended_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onended_setterinfo }},
  { "onerror", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onerror_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onerror_setterinfo }},
  { "onfocus", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onfocus_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onfocus_setterinfo }},
  { "oninput", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &oninput_getterinfo }, { (JSStrictPropertyOp)genericSetter, &oninput_setterinfo }},
  { "oninvalid", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &oninvalid_getterinfo }, { (JSStrictPropertyOp)genericSetter, &oninvalid_setterinfo }},
  { "onkeydown", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onkeydown_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onkeydown_setterinfo }},
  { "onkeypress", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onkeypress_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onkeypress_setterinfo }},
  { "onkeyup", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onkeyup_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onkeyup_setterinfo }},
  { "onload", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onload_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onload_setterinfo }},
  { "onloadeddata", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onloadeddata_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onloadeddata_setterinfo }},
  { "onloadedmetadata", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onloadedmetadata_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onloadedmetadata_setterinfo }},
  { "onloadstart", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onloadstart_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onloadstart_setterinfo }},
  { "onmousedown", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onmousedown_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onmousedown_setterinfo }},
  { "onmousemove", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onmousemove_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onmousemove_setterinfo }},
  { "onmouseout", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onmouseout_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onmouseout_setterinfo }},
  { "onmouseover", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onmouseover_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onmouseover_setterinfo }},
  { "onmouseup", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onmouseup_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onmouseup_setterinfo }},
  { "onpause", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onpause_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onpause_setterinfo }},
  { "onplay", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onplay_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onplay_setterinfo }},
  { "onplaying", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onplaying_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onplaying_setterinfo }},
  { "onprogress", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onprogress_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onprogress_setterinfo }},
  { "onratechange", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onratechange_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onratechange_setterinfo }},
  { "onreset", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onreset_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onreset_setterinfo }},
  { "onscroll", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onscroll_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onscroll_setterinfo }},
  { "onseeked", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onseeked_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onseeked_setterinfo }},
  { "onseeking", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onseeking_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onseeking_setterinfo }},
  { "onselect", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onselect_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onselect_setterinfo }},
  { "onshow", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onshow_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onshow_setterinfo }},
  { "onstalled", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onstalled_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onstalled_setterinfo }},
  { "onsubmit", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onsubmit_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onsubmit_setterinfo }},
  { "onsuspend", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onsuspend_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onsuspend_setterinfo }},
  { "ontimeupdate", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &ontimeupdate_getterinfo }, { (JSStrictPropertyOp)genericSetter, &ontimeupdate_setterinfo }},
  { "onvolumechange", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onvolumechange_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onvolumechange_setterinfo }},
  { "onwaiting", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onwaiting_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onwaiting_setterinfo }},
  { "onmozfullscreenchange", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onmozfullscreenchange_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onmozfullscreenchange_setterinfo }},
  { "onmozfullscreenerror", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onmozfullscreenerror_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onmozfullscreenerror_setterinfo }},
  { "onmozpointerlockchange", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onmozpointerlockchange_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onmozpointerlockchange_setterinfo }},
  { "onmozpointerlockerror", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onmozpointerlockerror_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onmozpointerlockerror_setterinfo }},
  { 0, 0, 0, JSOP_NULLWRAPPER, JSOP_NULLWRAPPER },
  { "ontouchstart", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &ontouchstart_getterinfo }, { (JSStrictPropertyOp)genericSetter, &ontouchstart_setterinfo }},
  { "ontouchend", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &ontouchend_getterinfo }, { (JSStrictPropertyOp)genericSetter, &ontouchend_setterinfo }},
  { "ontouchmove", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &ontouchmove_getterinfo }, { (JSStrictPropertyOp)genericSetter, &ontouchmove_setterinfo }},
  { "ontouchenter", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &ontouchenter_getterinfo }, { (JSStrictPropertyOp)genericSetter, &ontouchenter_setterinfo }},
  { "ontouchleave", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &ontouchleave_getterinfo }, { (JSStrictPropertyOp)genericSetter, &ontouchleave_setterinfo }},
  { "ontouchcancel", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &ontouchcancel_getterinfo }, { (JSStrictPropertyOp)genericSetter, &ontouchcancel_setterinfo }},
  { 0, 0, 0, JSOP_NULLWRAPPER, JSOP_NULLWRAPPER },
  { "oncopy", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &oncopy_getterinfo }, { (JSStrictPropertyOp)genericSetter, &oncopy_setterinfo }},
  { "oncut", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &oncut_getterinfo }, { (JSStrictPropertyOp)genericSetter, &oncut_setterinfo }},
  { "onpaste", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onpaste_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onpaste_setterinfo }},
  { 0, 0, 0, JSOP_NULLWRAPPER, JSOP_NULLWRAPPER }
};

static Prefable<JSPropertySpec> sAttributes[] = {
  { true, &sAttributes_specs[0] },
  { true, &sAttributes_specs[61] },
  { true, &sAttributes_specs[68] },
  { false, NULL }
};

static jsid sAttributes_ids[72] = { JSID_VOID };


static const NativeProperties sNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sMethods, sMethods_ids, sMethods_specs,
  sAttributes, sAttributes_ids, sAttributes_specs,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr
};
const NativePropertyHooks sNativePropertyHooks = {
  nullptr,
  nullptr,
  { &sNativeProperties, nullptr },
  prototypes::id::SVGElement,
  constructors::id::SVGElement,
  &ElementBinding::sNativePropertyHooks
};

static JSBool
_hasInstance(JSContext* cx, JSHandleObject obj, JSMutableHandleValue vp, JSBool* bp)
{
  if (!vp.isObject()) {
    *bp = false;
    return true;
  }

  jsval protov;
  if (!JS_GetProperty(cx, obj, "prototype", &protov))
    return false;
  if (!protov.isObject()) {
    JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_BAD_PROTOTYPE,
                         "SVGElement");
    return false;
  }
  JSObject *objProto = &protov.toObject();

  JSObject* instance = &vp.toObject();
  JSObject* proto;
  if (!JS_GetPrototype(cx, instance, &proto))
    return false;
  while (proto) {
    if (proto == objProto) {
      *bp = true;
      return true;
    }
    if (!JS_GetPrototype(cx, proto, &proto))
      return false;
  }

  // FIXME Limit this to chrome by checking xpc::AccessCheck::isChrome(obj).
  nsISupports* native =
    nsContentUtils::XPConnect()->GetNativeOfWrapper(cx, instance);
  nsCOMPtr<nsIDOMSVGElement> qiResult = do_QueryInterface(native);
  *bp = !!qiResult;
  return true;

}


static DOMIfaceAndProtoJSClass InterfaceObjectClass = {
  {
    "Function",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(2),
    JS_PropertyStub,       /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    nullptr,               /* finalize */
    nullptr,               /* checkAccess */
    ThrowingConstructor, /* call */
    _hasInstance, /* hasInstance */
    ThrowingConstructor, /* construct */
    nullptr,               /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  eInterface,
  &sNativePropertyHooks
};

static DOMIfaceAndProtoJSClass PrototypeClass = {
  {
    "SVGElementPrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(2),
    JS_PropertyStub,       /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    nullptr,               /* finalize */
    nullptr,               /* checkAccess */
    nullptr,               /* call */
    nullptr,               /* hasInstance */
    nullptr,               /* construct */
    nullptr,               /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  eInterfacePrototype,
  &sNativePropertyHooks
};

void
CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray)
{
  JSObject* parentProto = ElementBinding::GetProtoObject(aCx, aGlobal);
  if (!parentProto) {
    return;
  }


  if (sMethods_ids[0] == JSID_VOID &&
      (!InitIds(aCx, sMethods, sMethods_ids) ||
       !InitIds(aCx, sAttributes, sAttributes_ids))) {
    sMethods_ids[0] = JSID_VOID;
    return;
  }

  static bool sPrefCachesInited = false;
  if (!sPrefCachesInited) {
    sPrefCachesInited = true;
    Preferences::AddBoolVarCache(&sAttributes[1].enabled, "dom.w3c_touch_events.expose");
  }

  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &PrototypeClass.mBase, &protoAndIfaceArray[prototypes::id::SVGElement],
                              &InterfaceObjectClass.mBase, nullptr, 0, &protoAndIfaceArray[constructors::id::SVGElement],
                              &Class.mClass,
                              &sNativeProperties,
                              nullptr,
                              "SVGElement");
}

JSObject*
DefineDOMInterface(JSContext* aCx, JSObject* aGlobal, bool* aEnabled)
{

  *aEnabled = true;
  return GetConstructorObject(aCx, aGlobal);
}

bool
PrefEnabled()
{
  return nsSVGElement::PrefEnabled();
}


DOMJSClass Class = {
  { "SVGElement",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(3),
    _addProperty, /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    _finalize, /* finalize */
    NULL,                  /* checkAccess */
    NULL,                  /* call */
    NULL,                  /* hasInstance */
    NULL,                  /* construct */
    NULL, /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  {
    { prototypes::id::EventTarget, prototypes::id::Node, prototypes::id::Element, prototypes::id::SVGElement, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
    true,
    &sNativePropertyHooks,
    GetParentObject<nsSVGElement>::Get,
    GetProtoObject,
    nullptr
  }
};

JSObject*
Wrap(JSContext* aCx, JSObject* aScope, nsSVGElement* aObject, nsWrapperCache* aCache, bool* aTriedToWrap)
{
  MOZ_ASSERT(static_cast<nsSVGElement*>(aObject) ==
             reinterpret_cast<nsSVGElement*>(aObject));
  MOZ_ASSERT(static_cast<mozilla::dom::Element*>(aObject) ==
             reinterpret_cast<mozilla::dom::Element*>(aObject));
  MOZ_ASSERT(static_cast<nsINode*>(aObject) ==
             reinterpret_cast<nsINode*>(aObject));
  MOZ_ASSERT(static_cast<mozilla::dom::EventTarget*>(aObject) ==
             reinterpret_cast<mozilla::dom::EventTarget*>(aObject));

  *aTriedToWrap = true;

  JSObject* parent = WrapNativeParent(aCx, aScope, aObject->GetParentObject());
  if (!parent) {
    return NULL;
  }

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.  Scope so we don't
  // collide with the "obj" we declare in CreateBindingJSObject.
  {
    JSObject* obj = aCache->GetWrapper();
    if (obj) {
      return obj;
    }
  }

  JSAutoCompartment ac(aCx, parent);
  JSObject* global = JS_GetGlobalForObject(aCx, parent);

  JSObject* proto = GetProtoObject(aCx, global);
  if (!proto) {
    return NULL;
  }

  JSObject* obj = JS_NewObject(aCx, &Class.mBase, proto, parent);
  if (!obj) {
    return NULL;
  }

  js::SetReservedSlot(obj, DOM_OBJECT_SLOT, PRIVATE_TO_JSVAL(aObject));
  NS_ADDREF(aObject);


  aCache->SetWrapper(obj);

  return obj;
}

} // namespace SVGElementBinding



} // namespace dom
} // namespace mozilla
