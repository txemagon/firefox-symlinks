/* THIS FILE IS AUTOGENERATED - DO NOT EDIT */

#include "AccessCheck.h"
#include "DOMSVGPathSeg.h"
#include "PrimitiveConversions.h"
#include "SVGPathSegBinding.h"
#include "WorkerPrivate.h"
#include "XPCQuickStubs.h"
#include "XPCWrapper.h"
#include "mozilla/FloatingPoint.h"
#include "mozilla/Preferences.h"
#include "mozilla/dom/BindingUtils.h"
#include "mozilla/dom/NonRefcountedDOMObject.h"
#include "mozilla/dom/Nullable.h"
#include "nsContentUtils.h"
#include "nsDOMQS.h"

using namespace mozilla::dom;
namespace mozilla {
namespace dom {

namespace SVGPathSegBinding {

static bool
get_pathSegType(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSeg* self, JS::Value* vp)
{
  uint16_t result;
  result = self->PathSegType();
  *vp = INT_TO_JSVAL(int32_t(result));
  return true;
}


const JSJitInfo pathSegType_getterinfo = {
  (JSJitPropertyOp)get_pathSegType,
  prototypes::id::SVGPathSeg,
  PrototypeTraits<prototypes::id::SVGPathSeg>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_pathSegTypeAsLetter(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSeg* self, JS::Value* vp)
{
  nsString result;
  self->GetPathSegTypeAsLetter(result);
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}


const JSJitInfo pathSegTypeAsLetter_getterinfo = {
  (JSJitPropertyOp)get_pathSegTypeAsLetter,
  prototypes::id::SVGPathSeg,
  PrototypeTraits<prototypes::id::SVGPathSeg>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

static JSBool
genericGetter(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  mozilla::DOMSVGPathSeg* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::SVGPathSeg, mozilla::DOMSVGPathSeg>(cx, obj, self);
    if (NS_FAILED(rv)) {
      return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "SVGPathSeg");
    }
  }
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Getter);
  JSJitPropertyOp getter = info->op;
  return getter(cx, obj, self, vp);
}

static JSFunctionSpec sChromeMethods_specs[] = {
  JS_FNINFO("QueryInterface", QueryInterface, nullptr, 1, 0),
  JS_FS_END
};

static Prefable<JSFunctionSpec> sChromeMethods[] = {
  { true, &sChromeMethods_specs[0] },
  { false, NULL }
};

static jsid sChromeMethods_ids[2] = { JSID_VOID };

static JSPropertySpec sAttributes_specs[] = {
  { "pathSegType", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &pathSegType_getterinfo }, JSOP_NULLWRAPPER},
  { "pathSegTypeAsLetter", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &pathSegTypeAsLetter_getterinfo }, JSOP_NULLWRAPPER},
  { 0, 0, 0, JSOP_NULLWRAPPER, JSOP_NULLWRAPPER }
};

static Prefable<JSPropertySpec> sAttributes[] = {
  { true, &sAttributes_specs[0] },
  { false, NULL }
};

static jsid sAttributes_ids[3] = { JSID_VOID };

static ConstantSpec sConstants_specs[] = {
  { "PATHSEG_UNKNOWN", INT_TO_JSVAL(0) },
  { "PATHSEG_CLOSEPATH", INT_TO_JSVAL(1) },
  { "PATHSEG_MOVETO_ABS", INT_TO_JSVAL(2) },
  { "PATHSEG_MOVETO_REL", INT_TO_JSVAL(3) },
  { "PATHSEG_LINETO_ABS", INT_TO_JSVAL(4) },
  { "PATHSEG_LINETO_REL", INT_TO_JSVAL(5) },
  { "PATHSEG_CURVETO_CUBIC_ABS", INT_TO_JSVAL(6) },
  { "PATHSEG_CURVETO_CUBIC_REL", INT_TO_JSVAL(7) },
  { "PATHSEG_CURVETO_QUADRATIC_ABS", INT_TO_JSVAL(8) },
  { "PATHSEG_CURVETO_QUADRATIC_REL", INT_TO_JSVAL(9) },
  { "PATHSEG_ARC_ABS", INT_TO_JSVAL(10) },
  { "PATHSEG_ARC_REL", INT_TO_JSVAL(11) },
  { "PATHSEG_LINETO_HORIZONTAL_ABS", INT_TO_JSVAL(12) },
  { "PATHSEG_LINETO_HORIZONTAL_REL", INT_TO_JSVAL(13) },
  { "PATHSEG_LINETO_VERTICAL_ABS", INT_TO_JSVAL(14) },
  { "PATHSEG_LINETO_VERTICAL_REL", INT_TO_JSVAL(15) },
  { "PATHSEG_CURVETO_CUBIC_SMOOTH_ABS", INT_TO_JSVAL(16) },
  { "PATHSEG_CURVETO_CUBIC_SMOOTH_REL", INT_TO_JSVAL(17) },
  { "PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS", INT_TO_JSVAL(18) },
  { "PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL", INT_TO_JSVAL(19) },
  { 0, JSVAL_VOID }
};

static Prefable<ConstantSpec> sConstants[] = {
  { true, &sConstants_specs[0] },
  { false, NULL }
};

static jsid sConstants_ids[21] = { JSID_VOID };


static const NativeProperties sNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sAttributes, sAttributes_ids, sAttributes_specs,
  nullptr, nullptr, nullptr,
  sConstants, sConstants_ids, sConstants_specs
};

static const NativeProperties sChromeOnlyNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sChromeMethods, sChromeMethods_ids, sChromeMethods_specs,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr
};
const NativePropertyHooks sNativePropertyHooks = {
  nullptr,
  nullptr,
  { &sNativeProperties, &sChromeOnlyNativeProperties },
  prototypes::id::SVGPathSeg,
  constructors::id::SVGPathSeg,
  NULL
};

JSNativeHolder _constructor_holder = {
  ThrowingConstructor,
  &sNativePropertyHooks
};

static DOMIfaceAndProtoJSClass PrototypeClass = {
  {
    "SVGPathSegPrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(2),
    JS_PropertyStub,       /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    nullptr,               /* finalize */
    nullptr,               /* checkAccess */
    nullptr,               /* call */
    nullptr,               /* hasInstance */
    nullptr,               /* construct */
    nullptr,               /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  eInterfacePrototype,
  &sNativePropertyHooks
};

void
CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray)
{
  JSObject* parentProto = JS_GetObjectPrototype(aCx, aGlobal);
  if (!parentProto) {
    return;
  }


  if (sChromeMethods_ids[0] == JSID_VOID &&
      (!InitIds(aCx, sChromeMethods, sChromeMethods_ids) ||
       !InitIds(aCx, sAttributes, sAttributes_ids) ||
       !InitIds(aCx, sConstants, sConstants_ids))) {
    sChromeMethods_ids[0] = JSID_VOID;
    return;
  }

  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &PrototypeClass.mBase, &protoAndIfaceArray[prototypes::id::SVGPathSeg],
                              nullptr, &_constructor_holder, 0, &protoAndIfaceArray[constructors::id::SVGPathSeg],
                              nullptr,
                              &sNativeProperties,
                              xpc::AccessCheck::isChrome(aGlobal) ? &sChromeOnlyNativeProperties : nullptr,
                              "SVGPathSeg");
}

JSObject*
DefineDOMInterface(JSContext* aCx, JSObject* aGlobal, bool* aEnabled)
{

  *aEnabled = true;
  return GetConstructorObject(aCx, aGlobal);
}

} // namespace SVGPathSegBinding



namespace SVGPathSegArcAbsBinding {

static bool
get_x(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegArcAbs* self, JS::Value* vp)
{
  float result;
  result = self->X();
  *vp = JS_NumberValue(double(result));
  return true;
}

static bool
set_x(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegArcAbs* self, JS::Value* argv)
{
  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[0], &arg0)) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg0)) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    ThrowErrorMessage(cx, MSG_NOT_FINITE);
    return false;
  }
  ErrorResult rv;
  self->SetX(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGPathSegArcAbs", "x");
  }

  return true;
}


const JSJitInfo x_getterinfo = {
  (JSJitPropertyOp)get_x,
  prototypes::id::SVGPathSegArcAbs,
  PrototypeTraits<prototypes::id::SVGPathSegArcAbs>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo x_setterinfo = {
  (JSJitPropertyOp)set_x,
  prototypes::id::SVGPathSegArcAbs,
  PrototypeTraits<prototypes::id::SVGPathSegArcAbs>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_y(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegArcAbs* self, JS::Value* vp)
{
  float result;
  result = self->Y();
  *vp = JS_NumberValue(double(result));
  return true;
}

static bool
set_y(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegArcAbs* self, JS::Value* argv)
{
  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[0], &arg0)) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg0)) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    ThrowErrorMessage(cx, MSG_NOT_FINITE);
    return false;
  }
  ErrorResult rv;
  self->SetY(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGPathSegArcAbs", "y");
  }

  return true;
}


const JSJitInfo y_getterinfo = {
  (JSJitPropertyOp)get_y,
  prototypes::id::SVGPathSegArcAbs,
  PrototypeTraits<prototypes::id::SVGPathSegArcAbs>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo y_setterinfo = {
  (JSJitPropertyOp)set_y,
  prototypes::id::SVGPathSegArcAbs,
  PrototypeTraits<prototypes::id::SVGPathSegArcAbs>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_r1(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegArcAbs* self, JS::Value* vp)
{
  float result;
  result = self->R1();
  *vp = JS_NumberValue(double(result));
  return true;
}

static bool
set_r1(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegArcAbs* self, JS::Value* argv)
{
  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[0], &arg0)) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg0)) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    ThrowErrorMessage(cx, MSG_NOT_FINITE);
    return false;
  }
  ErrorResult rv;
  self->SetR1(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGPathSegArcAbs", "r1");
  }

  return true;
}


const JSJitInfo r1_getterinfo = {
  (JSJitPropertyOp)get_r1,
  prototypes::id::SVGPathSegArcAbs,
  PrototypeTraits<prototypes::id::SVGPathSegArcAbs>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo r1_setterinfo = {
  (JSJitPropertyOp)set_r1,
  prototypes::id::SVGPathSegArcAbs,
  PrototypeTraits<prototypes::id::SVGPathSegArcAbs>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_r2(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegArcAbs* self, JS::Value* vp)
{
  float result;
  result = self->R2();
  *vp = JS_NumberValue(double(result));
  return true;
}

static bool
set_r2(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegArcAbs* self, JS::Value* argv)
{
  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[0], &arg0)) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg0)) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    ThrowErrorMessage(cx, MSG_NOT_FINITE);
    return false;
  }
  ErrorResult rv;
  self->SetR2(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGPathSegArcAbs", "r2");
  }

  return true;
}


const JSJitInfo r2_getterinfo = {
  (JSJitPropertyOp)get_r2,
  prototypes::id::SVGPathSegArcAbs,
  PrototypeTraits<prototypes::id::SVGPathSegArcAbs>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo r2_setterinfo = {
  (JSJitPropertyOp)set_r2,
  prototypes::id::SVGPathSegArcAbs,
  PrototypeTraits<prototypes::id::SVGPathSegArcAbs>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_angle(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegArcAbs* self, JS::Value* vp)
{
  float result;
  result = self->Angle();
  *vp = JS_NumberValue(double(result));
  return true;
}

static bool
set_angle(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegArcAbs* self, JS::Value* argv)
{
  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[0], &arg0)) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg0)) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    ThrowErrorMessage(cx, MSG_NOT_FINITE);
    return false;
  }
  ErrorResult rv;
  self->SetAngle(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGPathSegArcAbs", "angle");
  }

  return true;
}


const JSJitInfo angle_getterinfo = {
  (JSJitPropertyOp)get_angle,
  prototypes::id::SVGPathSegArcAbs,
  PrototypeTraits<prototypes::id::SVGPathSegArcAbs>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo angle_setterinfo = {
  (JSJitPropertyOp)set_angle,
  prototypes::id::SVGPathSegArcAbs,
  PrototypeTraits<prototypes::id::SVGPathSegArcAbs>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_largeArcFlag(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegArcAbs* self, JS::Value* vp)
{
  bool result;
  result = self->LargeArcFlag();
  *vp = BOOLEAN_TO_JSVAL(result);
  return true;
}

static bool
set_largeArcFlag(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegArcAbs* self, JS::Value* argv)
{
  bool arg0;
  if (!ValueToPrimitive<bool, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  ErrorResult rv;
  self->SetLargeArcFlag(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGPathSegArcAbs", "largeArcFlag");
  }

  return true;
}


const JSJitInfo largeArcFlag_getterinfo = {
  (JSJitPropertyOp)get_largeArcFlag,
  prototypes::id::SVGPathSegArcAbs,
  PrototypeTraits<prototypes::id::SVGPathSegArcAbs>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo largeArcFlag_setterinfo = {
  (JSJitPropertyOp)set_largeArcFlag,
  prototypes::id::SVGPathSegArcAbs,
  PrototypeTraits<prototypes::id::SVGPathSegArcAbs>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_sweepFlag(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegArcAbs* self, JS::Value* vp)
{
  bool result;
  result = self->SweepFlag();
  *vp = BOOLEAN_TO_JSVAL(result);
  return true;
}

static bool
set_sweepFlag(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegArcAbs* self, JS::Value* argv)
{
  bool arg0;
  if (!ValueToPrimitive<bool, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  ErrorResult rv;
  self->SetSweepFlag(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGPathSegArcAbs", "sweepFlag");
  }

  return true;
}


const JSJitInfo sweepFlag_getterinfo = {
  (JSJitPropertyOp)get_sweepFlag,
  prototypes::id::SVGPathSegArcAbs,
  PrototypeTraits<prototypes::id::SVGPathSegArcAbs>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo sweepFlag_setterinfo = {
  (JSJitPropertyOp)set_sweepFlag,
  prototypes::id::SVGPathSegArcAbs,
  PrototypeTraits<prototypes::id::SVGPathSegArcAbs>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static JSBool
genericGetter(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  mozilla::DOMSVGPathSegArcAbs* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::SVGPathSegArcAbs, mozilla::DOMSVGPathSegArcAbs>(cx, obj, self);
    if (NS_FAILED(rv)) {
      return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "SVGPathSegArcAbs");
    }
  }
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Getter);
  JSJitPropertyOp getter = info->op;
  return getter(cx, obj, self, vp);
}

static JSBool
genericSetter(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  mozilla::DOMSVGPathSegArcAbs* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::SVGPathSegArcAbs, mozilla::DOMSVGPathSegArcAbs>(cx, obj, self);
    if (NS_FAILED(rv)) {
      return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "SVGPathSegArcAbs");
    }
  }
  if (argc == 0) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "SVGPathSegArcAbs attribute setter");
  }
  JS::Value* argv = JS_ARGV(cx, vp);
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Setter);
  JSJitPropertyOp setter = info->op;
  if (!setter(cx, obj, self, argv)) {
    return false;
  }
  *vp = JSVAL_VOID;
  return true;
}

static JSBool
_addProperty(JSContext* cx, JSHandleObject obj, JSHandleId id, JSMutableHandleValue vp)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::DOMSVGPathSegArcAbs>::value), "Must be an nsISupports class");
  mozilla::DOMSVGPathSegArcAbs* self = UnwrapDOMObject<mozilla::DOMSVGPathSegArcAbs>(obj);
  nsContentUtils::PreserveWrapper(reinterpret_cast<nsISupports*>(self), self);
  return true;
}

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::DOMSVGPathSegArcAbs>::value), "Must be an nsISupports class");
  mozilla::DOMSVGPathSegArcAbs* self = UnwrapDOMObject<mozilla::DOMSVGPathSegArcAbs>(obj);
  if (self) {
    ClearWrapper(self, self);
    XPCJSRuntime *rt = nsXPConnect::GetRuntimeInstance();
    if (rt) {
      rt->DeferredRelease(reinterpret_cast<nsISupports*>(self));
    } else {
      NS_RELEASE(self);
    }
  }
}

static JSPropertySpec sAttributes_specs[] = {
  { "x", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &x_getterinfo }, { (JSStrictPropertyOp)genericSetter, &x_setterinfo }},
  { "y", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &y_getterinfo }, { (JSStrictPropertyOp)genericSetter, &y_setterinfo }},
  { "r1", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &r1_getterinfo }, { (JSStrictPropertyOp)genericSetter, &r1_setterinfo }},
  { "r2", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &r2_getterinfo }, { (JSStrictPropertyOp)genericSetter, &r2_setterinfo }},
  { "angle", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &angle_getterinfo }, { (JSStrictPropertyOp)genericSetter, &angle_setterinfo }},
  { "largeArcFlag", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &largeArcFlag_getterinfo }, { (JSStrictPropertyOp)genericSetter, &largeArcFlag_setterinfo }},
  { "sweepFlag", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &sweepFlag_getterinfo }, { (JSStrictPropertyOp)genericSetter, &sweepFlag_setterinfo }},
  { 0, 0, 0, JSOP_NULLWRAPPER, JSOP_NULLWRAPPER }
};

static Prefable<JSPropertySpec> sAttributes[] = {
  { true, &sAttributes_specs[0] },
  { false, NULL }
};

static jsid sAttributes_ids[8] = { JSID_VOID };


static const NativeProperties sNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sAttributes, sAttributes_ids, sAttributes_specs,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr
};
const NativePropertyHooks sNativePropertyHooks = {
  nullptr,
  nullptr,
  { &sNativeProperties, nullptr },
  prototypes::id::SVGPathSegArcAbs,
  constructors::id::SVGPathSegArcAbs,
  &SVGPathSegBinding::sNativePropertyHooks
};

JSNativeHolder _constructor_holder = {
  ThrowingConstructor,
  &sNativePropertyHooks
};

static DOMIfaceAndProtoJSClass PrototypeClass = {
  {
    "SVGPathSegArcAbsPrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(2),
    JS_PropertyStub,       /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    nullptr,               /* finalize */
    nullptr,               /* checkAccess */
    nullptr,               /* call */
    nullptr,               /* hasInstance */
    nullptr,               /* construct */
    nullptr,               /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  eInterfacePrototype,
  &sNativePropertyHooks
};

void
CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray)
{
  JSObject* parentProto = SVGPathSegBinding::GetProtoObject(aCx, aGlobal);
  if (!parentProto) {
    return;
  }


  if (sAttributes_ids[0] == JSID_VOID &&
      !InitIds(aCx, sAttributes, sAttributes_ids)) {
    sAttributes_ids[0] = JSID_VOID;
    return;
  }

  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &PrototypeClass.mBase, &protoAndIfaceArray[prototypes::id::SVGPathSegArcAbs],
                              nullptr, &_constructor_holder, 0, &protoAndIfaceArray[constructors::id::SVGPathSegArcAbs],
                              &Class.mClass,
                              &sNativeProperties,
                              nullptr,
                              "SVGPathSegArcAbs");
}

JSObject*
DefineDOMInterface(JSContext* aCx, JSObject* aGlobal, bool* aEnabled)
{

  *aEnabled = true;
  return GetConstructorObject(aCx, aGlobal);
}


DOMJSClass Class = {
  { "SVGPathSegArcAbs",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(3),
    _addProperty, /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    _finalize, /* finalize */
    NULL,                  /* checkAccess */
    NULL,                  /* call */
    NULL,                  /* hasInstance */
    NULL,                  /* construct */
    NULL, /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  {
    { prototypes::id::SVGPathSeg, prototypes::id::SVGPathSegArcAbs, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
    true,
    &sNativePropertyHooks,
    GetParentObject<mozilla::DOMSVGPathSegArcAbs>::Get,
    GetProtoObject,
    nullptr
  }
};

JSObject*
Wrap(JSContext* aCx, JSObject* aScope, mozilla::DOMSVGPathSegArcAbs* aObject, nsWrapperCache* aCache, bool* aTriedToWrap)
{
  MOZ_ASSERT(static_cast<mozilla::DOMSVGPathSegArcAbs*>(aObject) ==
             reinterpret_cast<mozilla::DOMSVGPathSegArcAbs*>(aObject));
  MOZ_ASSERT(static_cast<mozilla::DOMSVGPathSeg*>(aObject) ==
             reinterpret_cast<mozilla::DOMSVGPathSeg*>(aObject));

  *aTriedToWrap = true;

  JSObject* parent = WrapNativeParent(aCx, aScope, aObject->GetParentObject());
  if (!parent) {
    return NULL;
  }

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.  Scope so we don't
  // collide with the "obj" we declare in CreateBindingJSObject.
  {
    JSObject* obj = aCache->GetWrapper();
    if (obj) {
      return obj;
    }
  }

  JSAutoCompartment ac(aCx, parent);
  JSObject* global = JS_GetGlobalForObject(aCx, parent);

  JSObject* proto = GetProtoObject(aCx, global);
  if (!proto) {
    return NULL;
  }

  JSObject* obj = JS_NewObject(aCx, &Class.mBase, proto, parent);
  if (!obj) {
    return NULL;
  }

  js::SetReservedSlot(obj, DOM_OBJECT_SLOT, PRIVATE_TO_JSVAL(aObject));
  NS_ADDREF(aObject);


  aCache->SetWrapper(obj);

  return obj;
}

} // namespace SVGPathSegArcAbsBinding



namespace SVGPathSegArcRelBinding {

static bool
get_x(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegArcRel* self, JS::Value* vp)
{
  float result;
  result = self->X();
  *vp = JS_NumberValue(double(result));
  return true;
}

static bool
set_x(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegArcRel* self, JS::Value* argv)
{
  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[0], &arg0)) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg0)) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    ThrowErrorMessage(cx, MSG_NOT_FINITE);
    return false;
  }
  ErrorResult rv;
  self->SetX(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGPathSegArcRel", "x");
  }

  return true;
}


const JSJitInfo x_getterinfo = {
  (JSJitPropertyOp)get_x,
  prototypes::id::SVGPathSegArcRel,
  PrototypeTraits<prototypes::id::SVGPathSegArcRel>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo x_setterinfo = {
  (JSJitPropertyOp)set_x,
  prototypes::id::SVGPathSegArcRel,
  PrototypeTraits<prototypes::id::SVGPathSegArcRel>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_y(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegArcRel* self, JS::Value* vp)
{
  float result;
  result = self->Y();
  *vp = JS_NumberValue(double(result));
  return true;
}

static bool
set_y(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegArcRel* self, JS::Value* argv)
{
  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[0], &arg0)) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg0)) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    ThrowErrorMessage(cx, MSG_NOT_FINITE);
    return false;
  }
  ErrorResult rv;
  self->SetY(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGPathSegArcRel", "y");
  }

  return true;
}


const JSJitInfo y_getterinfo = {
  (JSJitPropertyOp)get_y,
  prototypes::id::SVGPathSegArcRel,
  PrototypeTraits<prototypes::id::SVGPathSegArcRel>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo y_setterinfo = {
  (JSJitPropertyOp)set_y,
  prototypes::id::SVGPathSegArcRel,
  PrototypeTraits<prototypes::id::SVGPathSegArcRel>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_r1(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegArcRel* self, JS::Value* vp)
{
  float result;
  result = self->R1();
  *vp = JS_NumberValue(double(result));
  return true;
}

static bool
set_r1(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegArcRel* self, JS::Value* argv)
{
  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[0], &arg0)) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg0)) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    ThrowErrorMessage(cx, MSG_NOT_FINITE);
    return false;
  }
  ErrorResult rv;
  self->SetR1(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGPathSegArcRel", "r1");
  }

  return true;
}


const JSJitInfo r1_getterinfo = {
  (JSJitPropertyOp)get_r1,
  prototypes::id::SVGPathSegArcRel,
  PrototypeTraits<prototypes::id::SVGPathSegArcRel>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo r1_setterinfo = {
  (JSJitPropertyOp)set_r1,
  prototypes::id::SVGPathSegArcRel,
  PrototypeTraits<prototypes::id::SVGPathSegArcRel>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_r2(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegArcRel* self, JS::Value* vp)
{
  float result;
  result = self->R2();
  *vp = JS_NumberValue(double(result));
  return true;
}

static bool
set_r2(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegArcRel* self, JS::Value* argv)
{
  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[0], &arg0)) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg0)) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    ThrowErrorMessage(cx, MSG_NOT_FINITE);
    return false;
  }
  ErrorResult rv;
  self->SetR2(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGPathSegArcRel", "r2");
  }

  return true;
}


const JSJitInfo r2_getterinfo = {
  (JSJitPropertyOp)get_r2,
  prototypes::id::SVGPathSegArcRel,
  PrototypeTraits<prototypes::id::SVGPathSegArcRel>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo r2_setterinfo = {
  (JSJitPropertyOp)set_r2,
  prototypes::id::SVGPathSegArcRel,
  PrototypeTraits<prototypes::id::SVGPathSegArcRel>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_angle(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegArcRel* self, JS::Value* vp)
{
  float result;
  result = self->Angle();
  *vp = JS_NumberValue(double(result));
  return true;
}

static bool
set_angle(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegArcRel* self, JS::Value* argv)
{
  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[0], &arg0)) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg0)) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    ThrowErrorMessage(cx, MSG_NOT_FINITE);
    return false;
  }
  ErrorResult rv;
  self->SetAngle(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGPathSegArcRel", "angle");
  }

  return true;
}


const JSJitInfo angle_getterinfo = {
  (JSJitPropertyOp)get_angle,
  prototypes::id::SVGPathSegArcRel,
  PrototypeTraits<prototypes::id::SVGPathSegArcRel>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo angle_setterinfo = {
  (JSJitPropertyOp)set_angle,
  prototypes::id::SVGPathSegArcRel,
  PrototypeTraits<prototypes::id::SVGPathSegArcRel>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_largeArcFlag(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegArcRel* self, JS::Value* vp)
{
  bool result;
  result = self->LargeArcFlag();
  *vp = BOOLEAN_TO_JSVAL(result);
  return true;
}

static bool
set_largeArcFlag(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegArcRel* self, JS::Value* argv)
{
  bool arg0;
  if (!ValueToPrimitive<bool, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  ErrorResult rv;
  self->SetLargeArcFlag(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGPathSegArcRel", "largeArcFlag");
  }

  return true;
}


const JSJitInfo largeArcFlag_getterinfo = {
  (JSJitPropertyOp)get_largeArcFlag,
  prototypes::id::SVGPathSegArcRel,
  PrototypeTraits<prototypes::id::SVGPathSegArcRel>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo largeArcFlag_setterinfo = {
  (JSJitPropertyOp)set_largeArcFlag,
  prototypes::id::SVGPathSegArcRel,
  PrototypeTraits<prototypes::id::SVGPathSegArcRel>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_sweepFlag(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegArcRel* self, JS::Value* vp)
{
  bool result;
  result = self->SweepFlag();
  *vp = BOOLEAN_TO_JSVAL(result);
  return true;
}

static bool
set_sweepFlag(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegArcRel* self, JS::Value* argv)
{
  bool arg0;
  if (!ValueToPrimitive<bool, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  ErrorResult rv;
  self->SetSweepFlag(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGPathSegArcRel", "sweepFlag");
  }

  return true;
}


const JSJitInfo sweepFlag_getterinfo = {
  (JSJitPropertyOp)get_sweepFlag,
  prototypes::id::SVGPathSegArcRel,
  PrototypeTraits<prototypes::id::SVGPathSegArcRel>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo sweepFlag_setterinfo = {
  (JSJitPropertyOp)set_sweepFlag,
  prototypes::id::SVGPathSegArcRel,
  PrototypeTraits<prototypes::id::SVGPathSegArcRel>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static JSBool
genericGetter(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  mozilla::DOMSVGPathSegArcRel* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::SVGPathSegArcRel, mozilla::DOMSVGPathSegArcRel>(cx, obj, self);
    if (NS_FAILED(rv)) {
      return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "SVGPathSegArcRel");
    }
  }
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Getter);
  JSJitPropertyOp getter = info->op;
  return getter(cx, obj, self, vp);
}

static JSBool
genericSetter(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  mozilla::DOMSVGPathSegArcRel* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::SVGPathSegArcRel, mozilla::DOMSVGPathSegArcRel>(cx, obj, self);
    if (NS_FAILED(rv)) {
      return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "SVGPathSegArcRel");
    }
  }
  if (argc == 0) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "SVGPathSegArcRel attribute setter");
  }
  JS::Value* argv = JS_ARGV(cx, vp);
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Setter);
  JSJitPropertyOp setter = info->op;
  if (!setter(cx, obj, self, argv)) {
    return false;
  }
  *vp = JSVAL_VOID;
  return true;
}

static JSBool
_addProperty(JSContext* cx, JSHandleObject obj, JSHandleId id, JSMutableHandleValue vp)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::DOMSVGPathSegArcRel>::value), "Must be an nsISupports class");
  mozilla::DOMSVGPathSegArcRel* self = UnwrapDOMObject<mozilla::DOMSVGPathSegArcRel>(obj);
  nsContentUtils::PreserveWrapper(reinterpret_cast<nsISupports*>(self), self);
  return true;
}

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::DOMSVGPathSegArcRel>::value), "Must be an nsISupports class");
  mozilla::DOMSVGPathSegArcRel* self = UnwrapDOMObject<mozilla::DOMSVGPathSegArcRel>(obj);
  if (self) {
    ClearWrapper(self, self);
    XPCJSRuntime *rt = nsXPConnect::GetRuntimeInstance();
    if (rt) {
      rt->DeferredRelease(reinterpret_cast<nsISupports*>(self));
    } else {
      NS_RELEASE(self);
    }
  }
}

static JSPropertySpec sAttributes_specs[] = {
  { "x", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &x_getterinfo }, { (JSStrictPropertyOp)genericSetter, &x_setterinfo }},
  { "y", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &y_getterinfo }, { (JSStrictPropertyOp)genericSetter, &y_setterinfo }},
  { "r1", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &r1_getterinfo }, { (JSStrictPropertyOp)genericSetter, &r1_setterinfo }},
  { "r2", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &r2_getterinfo }, { (JSStrictPropertyOp)genericSetter, &r2_setterinfo }},
  { "angle", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &angle_getterinfo }, { (JSStrictPropertyOp)genericSetter, &angle_setterinfo }},
  { "largeArcFlag", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &largeArcFlag_getterinfo }, { (JSStrictPropertyOp)genericSetter, &largeArcFlag_setterinfo }},
  { "sweepFlag", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &sweepFlag_getterinfo }, { (JSStrictPropertyOp)genericSetter, &sweepFlag_setterinfo }},
  { 0, 0, 0, JSOP_NULLWRAPPER, JSOP_NULLWRAPPER }
};

static Prefable<JSPropertySpec> sAttributes[] = {
  { true, &sAttributes_specs[0] },
  { false, NULL }
};

static jsid sAttributes_ids[8] = { JSID_VOID };


static const NativeProperties sNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sAttributes, sAttributes_ids, sAttributes_specs,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr
};
const NativePropertyHooks sNativePropertyHooks = {
  nullptr,
  nullptr,
  { &sNativeProperties, nullptr },
  prototypes::id::SVGPathSegArcRel,
  constructors::id::SVGPathSegArcRel,
  &SVGPathSegBinding::sNativePropertyHooks
};

JSNativeHolder _constructor_holder = {
  ThrowingConstructor,
  &sNativePropertyHooks
};

static DOMIfaceAndProtoJSClass PrototypeClass = {
  {
    "SVGPathSegArcRelPrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(2),
    JS_PropertyStub,       /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    nullptr,               /* finalize */
    nullptr,               /* checkAccess */
    nullptr,               /* call */
    nullptr,               /* hasInstance */
    nullptr,               /* construct */
    nullptr,               /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  eInterfacePrototype,
  &sNativePropertyHooks
};

void
CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray)
{
  JSObject* parentProto = SVGPathSegBinding::GetProtoObject(aCx, aGlobal);
  if (!parentProto) {
    return;
  }


  if (sAttributes_ids[0] == JSID_VOID &&
      !InitIds(aCx, sAttributes, sAttributes_ids)) {
    sAttributes_ids[0] = JSID_VOID;
    return;
  }

  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &PrototypeClass.mBase, &protoAndIfaceArray[prototypes::id::SVGPathSegArcRel],
                              nullptr, &_constructor_holder, 0, &protoAndIfaceArray[constructors::id::SVGPathSegArcRel],
                              &Class.mClass,
                              &sNativeProperties,
                              nullptr,
                              "SVGPathSegArcRel");
}

JSObject*
DefineDOMInterface(JSContext* aCx, JSObject* aGlobal, bool* aEnabled)
{

  *aEnabled = true;
  return GetConstructorObject(aCx, aGlobal);
}


DOMJSClass Class = {
  { "SVGPathSegArcRel",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(3),
    _addProperty, /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    _finalize, /* finalize */
    NULL,                  /* checkAccess */
    NULL,                  /* call */
    NULL,                  /* hasInstance */
    NULL,                  /* construct */
    NULL, /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  {
    { prototypes::id::SVGPathSeg, prototypes::id::SVGPathSegArcRel, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
    true,
    &sNativePropertyHooks,
    GetParentObject<mozilla::DOMSVGPathSegArcRel>::Get,
    GetProtoObject,
    nullptr
  }
};

JSObject*
Wrap(JSContext* aCx, JSObject* aScope, mozilla::DOMSVGPathSegArcRel* aObject, nsWrapperCache* aCache, bool* aTriedToWrap)
{
  MOZ_ASSERT(static_cast<mozilla::DOMSVGPathSegArcRel*>(aObject) ==
             reinterpret_cast<mozilla::DOMSVGPathSegArcRel*>(aObject));
  MOZ_ASSERT(static_cast<mozilla::DOMSVGPathSeg*>(aObject) ==
             reinterpret_cast<mozilla::DOMSVGPathSeg*>(aObject));

  *aTriedToWrap = true;

  JSObject* parent = WrapNativeParent(aCx, aScope, aObject->GetParentObject());
  if (!parent) {
    return NULL;
  }

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.  Scope so we don't
  // collide with the "obj" we declare in CreateBindingJSObject.
  {
    JSObject* obj = aCache->GetWrapper();
    if (obj) {
      return obj;
    }
  }

  JSAutoCompartment ac(aCx, parent);
  JSObject* global = JS_GetGlobalForObject(aCx, parent);

  JSObject* proto = GetProtoObject(aCx, global);
  if (!proto) {
    return NULL;
  }

  JSObject* obj = JS_NewObject(aCx, &Class.mBase, proto, parent);
  if (!obj) {
    return NULL;
  }

  js::SetReservedSlot(obj, DOM_OBJECT_SLOT, PRIVATE_TO_JSVAL(aObject));
  NS_ADDREF(aObject);


  aCache->SetWrapper(obj);

  return obj;
}

} // namespace SVGPathSegArcRelBinding



namespace SVGPathSegClosePathBinding {

static JSBool
_addProperty(JSContext* cx, JSHandleObject obj, JSHandleId id, JSMutableHandleValue vp)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::DOMSVGPathSegClosePath>::value), "Must be an nsISupports class");
  mozilla::DOMSVGPathSegClosePath* self = UnwrapDOMObject<mozilla::DOMSVGPathSegClosePath>(obj);
  nsContentUtils::PreserveWrapper(reinterpret_cast<nsISupports*>(self), self);
  return true;
}

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::DOMSVGPathSegClosePath>::value), "Must be an nsISupports class");
  mozilla::DOMSVGPathSegClosePath* self = UnwrapDOMObject<mozilla::DOMSVGPathSegClosePath>(obj);
  if (self) {
    ClearWrapper(self, self);
    XPCJSRuntime *rt = nsXPConnect::GetRuntimeInstance();
    if (rt) {
      rt->DeferredRelease(reinterpret_cast<nsISupports*>(self));
    } else {
      NS_RELEASE(self);
    }
  }
}

const NativePropertyHooks sNativePropertyHooks = {
  nullptr,
  nullptr,
  { nullptr, nullptr },
  prototypes::id::SVGPathSegClosePath,
  constructors::id::SVGPathSegClosePath,
  &SVGPathSegBinding::sNativePropertyHooks
};

JSNativeHolder _constructor_holder = {
  ThrowingConstructor,
  &sNativePropertyHooks
};

static DOMIfaceAndProtoJSClass PrototypeClass = {
  {
    "SVGPathSegClosePathPrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(2),
    JS_PropertyStub,       /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    nullptr,               /* finalize */
    nullptr,               /* checkAccess */
    nullptr,               /* call */
    nullptr,               /* hasInstance */
    nullptr,               /* construct */
    nullptr,               /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  eInterfacePrototype,
  &sNativePropertyHooks
};

void
CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray)
{
  JSObject* parentProto = SVGPathSegBinding::GetProtoObject(aCx, aGlobal);
  if (!parentProto) {
    return;
  }


  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &PrototypeClass.mBase, &protoAndIfaceArray[prototypes::id::SVGPathSegClosePath],
                              nullptr, &_constructor_holder, 0, &protoAndIfaceArray[constructors::id::SVGPathSegClosePath],
                              &Class.mClass,
                              nullptr,
                              nullptr,
                              "SVGPathSegClosePath");
}

JSObject*
DefineDOMInterface(JSContext* aCx, JSObject* aGlobal, bool* aEnabled)
{

  *aEnabled = true;
  return GetConstructorObject(aCx, aGlobal);
}


DOMJSClass Class = {
  { "SVGPathSegClosePath",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(3),
    _addProperty, /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    _finalize, /* finalize */
    NULL,                  /* checkAccess */
    NULL,                  /* call */
    NULL,                  /* hasInstance */
    NULL,                  /* construct */
    NULL, /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  {
    { prototypes::id::SVGPathSeg, prototypes::id::SVGPathSegClosePath, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
    true,
    &sNativePropertyHooks,
    GetParentObject<mozilla::DOMSVGPathSegClosePath>::Get,
    GetProtoObject,
    nullptr
  }
};

JSObject*
Wrap(JSContext* aCx, JSObject* aScope, mozilla::DOMSVGPathSegClosePath* aObject, nsWrapperCache* aCache, bool* aTriedToWrap)
{
  MOZ_ASSERT(static_cast<mozilla::DOMSVGPathSegClosePath*>(aObject) ==
             reinterpret_cast<mozilla::DOMSVGPathSegClosePath*>(aObject));
  MOZ_ASSERT(static_cast<mozilla::DOMSVGPathSeg*>(aObject) ==
             reinterpret_cast<mozilla::DOMSVGPathSeg*>(aObject));

  *aTriedToWrap = true;

  JSObject* parent = WrapNativeParent(aCx, aScope, aObject->GetParentObject());
  if (!parent) {
    return NULL;
  }

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.  Scope so we don't
  // collide with the "obj" we declare in CreateBindingJSObject.
  {
    JSObject* obj = aCache->GetWrapper();
    if (obj) {
      return obj;
    }
  }

  JSAutoCompartment ac(aCx, parent);
  JSObject* global = JS_GetGlobalForObject(aCx, parent);

  JSObject* proto = GetProtoObject(aCx, global);
  if (!proto) {
    return NULL;
  }

  JSObject* obj = JS_NewObject(aCx, &Class.mBase, proto, parent);
  if (!obj) {
    return NULL;
  }

  js::SetReservedSlot(obj, DOM_OBJECT_SLOT, PRIVATE_TO_JSVAL(aObject));
  NS_ADDREF(aObject);


  aCache->SetWrapper(obj);

  return obj;
}

} // namespace SVGPathSegClosePathBinding



namespace SVGPathSegCurvetoCubicAbsBinding {

static bool
get_x(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegCurvetoCubicAbs* self, JS::Value* vp)
{
  float result;
  result = self->X();
  *vp = JS_NumberValue(double(result));
  return true;
}

static bool
set_x(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegCurvetoCubicAbs* self, JS::Value* argv)
{
  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[0], &arg0)) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg0)) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    ThrowErrorMessage(cx, MSG_NOT_FINITE);
    return false;
  }
  ErrorResult rv;
  self->SetX(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGPathSegCurvetoCubicAbs", "x");
  }

  return true;
}


const JSJitInfo x_getterinfo = {
  (JSJitPropertyOp)get_x,
  prototypes::id::SVGPathSegCurvetoCubicAbs,
  PrototypeTraits<prototypes::id::SVGPathSegCurvetoCubicAbs>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo x_setterinfo = {
  (JSJitPropertyOp)set_x,
  prototypes::id::SVGPathSegCurvetoCubicAbs,
  PrototypeTraits<prototypes::id::SVGPathSegCurvetoCubicAbs>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_y(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegCurvetoCubicAbs* self, JS::Value* vp)
{
  float result;
  result = self->Y();
  *vp = JS_NumberValue(double(result));
  return true;
}

static bool
set_y(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegCurvetoCubicAbs* self, JS::Value* argv)
{
  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[0], &arg0)) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg0)) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    ThrowErrorMessage(cx, MSG_NOT_FINITE);
    return false;
  }
  ErrorResult rv;
  self->SetY(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGPathSegCurvetoCubicAbs", "y");
  }

  return true;
}


const JSJitInfo y_getterinfo = {
  (JSJitPropertyOp)get_y,
  prototypes::id::SVGPathSegCurvetoCubicAbs,
  PrototypeTraits<prototypes::id::SVGPathSegCurvetoCubicAbs>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo y_setterinfo = {
  (JSJitPropertyOp)set_y,
  prototypes::id::SVGPathSegCurvetoCubicAbs,
  PrototypeTraits<prototypes::id::SVGPathSegCurvetoCubicAbs>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_x1(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegCurvetoCubicAbs* self, JS::Value* vp)
{
  float result;
  result = self->X1();
  *vp = JS_NumberValue(double(result));
  return true;
}

static bool
set_x1(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegCurvetoCubicAbs* self, JS::Value* argv)
{
  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[0], &arg0)) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg0)) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    ThrowErrorMessage(cx, MSG_NOT_FINITE);
    return false;
  }
  ErrorResult rv;
  self->SetX1(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGPathSegCurvetoCubicAbs", "x1");
  }

  return true;
}


const JSJitInfo x1_getterinfo = {
  (JSJitPropertyOp)get_x1,
  prototypes::id::SVGPathSegCurvetoCubicAbs,
  PrototypeTraits<prototypes::id::SVGPathSegCurvetoCubicAbs>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo x1_setterinfo = {
  (JSJitPropertyOp)set_x1,
  prototypes::id::SVGPathSegCurvetoCubicAbs,
  PrototypeTraits<prototypes::id::SVGPathSegCurvetoCubicAbs>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_y1(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegCurvetoCubicAbs* self, JS::Value* vp)
{
  float result;
  result = self->Y1();
  *vp = JS_NumberValue(double(result));
  return true;
}

static bool
set_y1(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegCurvetoCubicAbs* self, JS::Value* argv)
{
  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[0], &arg0)) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg0)) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    ThrowErrorMessage(cx, MSG_NOT_FINITE);
    return false;
  }
  ErrorResult rv;
  self->SetY1(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGPathSegCurvetoCubicAbs", "y1");
  }

  return true;
}


const JSJitInfo y1_getterinfo = {
  (JSJitPropertyOp)get_y1,
  prototypes::id::SVGPathSegCurvetoCubicAbs,
  PrototypeTraits<prototypes::id::SVGPathSegCurvetoCubicAbs>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo y1_setterinfo = {
  (JSJitPropertyOp)set_y1,
  prototypes::id::SVGPathSegCurvetoCubicAbs,
  PrototypeTraits<prototypes::id::SVGPathSegCurvetoCubicAbs>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_x2(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegCurvetoCubicAbs* self, JS::Value* vp)
{
  float result;
  result = self->X2();
  *vp = JS_NumberValue(double(result));
  return true;
}

static bool
set_x2(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegCurvetoCubicAbs* self, JS::Value* argv)
{
  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[0], &arg0)) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg0)) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    ThrowErrorMessage(cx, MSG_NOT_FINITE);
    return false;
  }
  ErrorResult rv;
  self->SetX2(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGPathSegCurvetoCubicAbs", "x2");
  }

  return true;
}


const JSJitInfo x2_getterinfo = {
  (JSJitPropertyOp)get_x2,
  prototypes::id::SVGPathSegCurvetoCubicAbs,
  PrototypeTraits<prototypes::id::SVGPathSegCurvetoCubicAbs>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo x2_setterinfo = {
  (JSJitPropertyOp)set_x2,
  prototypes::id::SVGPathSegCurvetoCubicAbs,
  PrototypeTraits<prototypes::id::SVGPathSegCurvetoCubicAbs>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_y2(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegCurvetoCubicAbs* self, JS::Value* vp)
{
  float result;
  result = self->Y2();
  *vp = JS_NumberValue(double(result));
  return true;
}

static bool
set_y2(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegCurvetoCubicAbs* self, JS::Value* argv)
{
  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[0], &arg0)) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg0)) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    ThrowErrorMessage(cx, MSG_NOT_FINITE);
    return false;
  }
  ErrorResult rv;
  self->SetY2(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGPathSegCurvetoCubicAbs", "y2");
  }

  return true;
}


const JSJitInfo y2_getterinfo = {
  (JSJitPropertyOp)get_y2,
  prototypes::id::SVGPathSegCurvetoCubicAbs,
  PrototypeTraits<prototypes::id::SVGPathSegCurvetoCubicAbs>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo y2_setterinfo = {
  (JSJitPropertyOp)set_y2,
  prototypes::id::SVGPathSegCurvetoCubicAbs,
  PrototypeTraits<prototypes::id::SVGPathSegCurvetoCubicAbs>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static JSBool
genericGetter(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  mozilla::DOMSVGPathSegCurvetoCubicAbs* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::SVGPathSegCurvetoCubicAbs, mozilla::DOMSVGPathSegCurvetoCubicAbs>(cx, obj, self);
    if (NS_FAILED(rv)) {
      return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "SVGPathSegCurvetoCubicAbs");
    }
  }
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Getter);
  JSJitPropertyOp getter = info->op;
  return getter(cx, obj, self, vp);
}

static JSBool
genericSetter(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  mozilla::DOMSVGPathSegCurvetoCubicAbs* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::SVGPathSegCurvetoCubicAbs, mozilla::DOMSVGPathSegCurvetoCubicAbs>(cx, obj, self);
    if (NS_FAILED(rv)) {
      return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "SVGPathSegCurvetoCubicAbs");
    }
  }
  if (argc == 0) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "SVGPathSegCurvetoCubicAbs attribute setter");
  }
  JS::Value* argv = JS_ARGV(cx, vp);
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Setter);
  JSJitPropertyOp setter = info->op;
  if (!setter(cx, obj, self, argv)) {
    return false;
  }
  *vp = JSVAL_VOID;
  return true;
}

static JSBool
_addProperty(JSContext* cx, JSHandleObject obj, JSHandleId id, JSMutableHandleValue vp)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::DOMSVGPathSegCurvetoCubicAbs>::value), "Must be an nsISupports class");
  mozilla::DOMSVGPathSegCurvetoCubicAbs* self = UnwrapDOMObject<mozilla::DOMSVGPathSegCurvetoCubicAbs>(obj);
  nsContentUtils::PreserveWrapper(reinterpret_cast<nsISupports*>(self), self);
  return true;
}

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::DOMSVGPathSegCurvetoCubicAbs>::value), "Must be an nsISupports class");
  mozilla::DOMSVGPathSegCurvetoCubicAbs* self = UnwrapDOMObject<mozilla::DOMSVGPathSegCurvetoCubicAbs>(obj);
  if (self) {
    ClearWrapper(self, self);
    XPCJSRuntime *rt = nsXPConnect::GetRuntimeInstance();
    if (rt) {
      rt->DeferredRelease(reinterpret_cast<nsISupports*>(self));
    } else {
      NS_RELEASE(self);
    }
  }
}

static JSPropertySpec sAttributes_specs[] = {
  { "x", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &x_getterinfo }, { (JSStrictPropertyOp)genericSetter, &x_setterinfo }},
  { "y", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &y_getterinfo }, { (JSStrictPropertyOp)genericSetter, &y_setterinfo }},
  { "x1", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &x1_getterinfo }, { (JSStrictPropertyOp)genericSetter, &x1_setterinfo }},
  { "y1", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &y1_getterinfo }, { (JSStrictPropertyOp)genericSetter, &y1_setterinfo }},
  { "x2", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &x2_getterinfo }, { (JSStrictPropertyOp)genericSetter, &x2_setterinfo }},
  { "y2", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &y2_getterinfo }, { (JSStrictPropertyOp)genericSetter, &y2_setterinfo }},
  { 0, 0, 0, JSOP_NULLWRAPPER, JSOP_NULLWRAPPER }
};

static Prefable<JSPropertySpec> sAttributes[] = {
  { true, &sAttributes_specs[0] },
  { false, NULL }
};

static jsid sAttributes_ids[7] = { JSID_VOID };


static const NativeProperties sNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sAttributes, sAttributes_ids, sAttributes_specs,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr
};
const NativePropertyHooks sNativePropertyHooks = {
  nullptr,
  nullptr,
  { &sNativeProperties, nullptr },
  prototypes::id::SVGPathSegCurvetoCubicAbs,
  constructors::id::SVGPathSegCurvetoCubicAbs,
  &SVGPathSegBinding::sNativePropertyHooks
};

JSNativeHolder _constructor_holder = {
  ThrowingConstructor,
  &sNativePropertyHooks
};

static DOMIfaceAndProtoJSClass PrototypeClass = {
  {
    "SVGPathSegCurvetoCubicAbsPrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(2),
    JS_PropertyStub,       /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    nullptr,               /* finalize */
    nullptr,               /* checkAccess */
    nullptr,               /* call */
    nullptr,               /* hasInstance */
    nullptr,               /* construct */
    nullptr,               /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  eInterfacePrototype,
  &sNativePropertyHooks
};

void
CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray)
{
  JSObject* parentProto = SVGPathSegBinding::GetProtoObject(aCx, aGlobal);
  if (!parentProto) {
    return;
  }


  if (sAttributes_ids[0] == JSID_VOID &&
      !InitIds(aCx, sAttributes, sAttributes_ids)) {
    sAttributes_ids[0] = JSID_VOID;
    return;
  }

  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &PrototypeClass.mBase, &protoAndIfaceArray[prototypes::id::SVGPathSegCurvetoCubicAbs],
                              nullptr, &_constructor_holder, 0, &protoAndIfaceArray[constructors::id::SVGPathSegCurvetoCubicAbs],
                              &Class.mClass,
                              &sNativeProperties,
                              nullptr,
                              "SVGPathSegCurvetoCubicAbs");
}

JSObject*
DefineDOMInterface(JSContext* aCx, JSObject* aGlobal, bool* aEnabled)
{

  *aEnabled = true;
  return GetConstructorObject(aCx, aGlobal);
}


DOMJSClass Class = {
  { "SVGPathSegCurvetoCubicAbs",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(3),
    _addProperty, /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    _finalize, /* finalize */
    NULL,                  /* checkAccess */
    NULL,                  /* call */
    NULL,                  /* hasInstance */
    NULL,                  /* construct */
    NULL, /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  {
    { prototypes::id::SVGPathSeg, prototypes::id::SVGPathSegCurvetoCubicAbs, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
    true,
    &sNativePropertyHooks,
    GetParentObject<mozilla::DOMSVGPathSegCurvetoCubicAbs>::Get,
    GetProtoObject,
    nullptr
  }
};

JSObject*
Wrap(JSContext* aCx, JSObject* aScope, mozilla::DOMSVGPathSegCurvetoCubicAbs* aObject, nsWrapperCache* aCache, bool* aTriedToWrap)
{
  MOZ_ASSERT(static_cast<mozilla::DOMSVGPathSegCurvetoCubicAbs*>(aObject) ==
             reinterpret_cast<mozilla::DOMSVGPathSegCurvetoCubicAbs*>(aObject));
  MOZ_ASSERT(static_cast<mozilla::DOMSVGPathSeg*>(aObject) ==
             reinterpret_cast<mozilla::DOMSVGPathSeg*>(aObject));

  *aTriedToWrap = true;

  JSObject* parent = WrapNativeParent(aCx, aScope, aObject->GetParentObject());
  if (!parent) {
    return NULL;
  }

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.  Scope so we don't
  // collide with the "obj" we declare in CreateBindingJSObject.
  {
    JSObject* obj = aCache->GetWrapper();
    if (obj) {
      return obj;
    }
  }

  JSAutoCompartment ac(aCx, parent);
  JSObject* global = JS_GetGlobalForObject(aCx, parent);

  JSObject* proto = GetProtoObject(aCx, global);
  if (!proto) {
    return NULL;
  }

  JSObject* obj = JS_NewObject(aCx, &Class.mBase, proto, parent);
  if (!obj) {
    return NULL;
  }

  js::SetReservedSlot(obj, DOM_OBJECT_SLOT, PRIVATE_TO_JSVAL(aObject));
  NS_ADDREF(aObject);


  aCache->SetWrapper(obj);

  return obj;
}

} // namespace SVGPathSegCurvetoCubicAbsBinding



namespace SVGPathSegCurvetoCubicRelBinding {

static bool
get_x(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegCurvetoCubicRel* self, JS::Value* vp)
{
  float result;
  result = self->X();
  *vp = JS_NumberValue(double(result));
  return true;
}

static bool
set_x(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegCurvetoCubicRel* self, JS::Value* argv)
{
  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[0], &arg0)) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg0)) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    ThrowErrorMessage(cx, MSG_NOT_FINITE);
    return false;
  }
  ErrorResult rv;
  self->SetX(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGPathSegCurvetoCubicRel", "x");
  }

  return true;
}


const JSJitInfo x_getterinfo = {
  (JSJitPropertyOp)get_x,
  prototypes::id::SVGPathSegCurvetoCubicRel,
  PrototypeTraits<prototypes::id::SVGPathSegCurvetoCubicRel>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo x_setterinfo = {
  (JSJitPropertyOp)set_x,
  prototypes::id::SVGPathSegCurvetoCubicRel,
  PrototypeTraits<prototypes::id::SVGPathSegCurvetoCubicRel>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_y(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegCurvetoCubicRel* self, JS::Value* vp)
{
  float result;
  result = self->Y();
  *vp = JS_NumberValue(double(result));
  return true;
}

static bool
set_y(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegCurvetoCubicRel* self, JS::Value* argv)
{
  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[0], &arg0)) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg0)) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    ThrowErrorMessage(cx, MSG_NOT_FINITE);
    return false;
  }
  ErrorResult rv;
  self->SetY(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGPathSegCurvetoCubicRel", "y");
  }

  return true;
}


const JSJitInfo y_getterinfo = {
  (JSJitPropertyOp)get_y,
  prototypes::id::SVGPathSegCurvetoCubicRel,
  PrototypeTraits<prototypes::id::SVGPathSegCurvetoCubicRel>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo y_setterinfo = {
  (JSJitPropertyOp)set_y,
  prototypes::id::SVGPathSegCurvetoCubicRel,
  PrototypeTraits<prototypes::id::SVGPathSegCurvetoCubicRel>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_x1(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegCurvetoCubicRel* self, JS::Value* vp)
{
  float result;
  result = self->X1();
  *vp = JS_NumberValue(double(result));
  return true;
}

static bool
set_x1(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegCurvetoCubicRel* self, JS::Value* argv)
{
  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[0], &arg0)) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg0)) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    ThrowErrorMessage(cx, MSG_NOT_FINITE);
    return false;
  }
  ErrorResult rv;
  self->SetX1(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGPathSegCurvetoCubicRel", "x1");
  }

  return true;
}


const JSJitInfo x1_getterinfo = {
  (JSJitPropertyOp)get_x1,
  prototypes::id::SVGPathSegCurvetoCubicRel,
  PrototypeTraits<prototypes::id::SVGPathSegCurvetoCubicRel>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo x1_setterinfo = {
  (JSJitPropertyOp)set_x1,
  prototypes::id::SVGPathSegCurvetoCubicRel,
  PrototypeTraits<prototypes::id::SVGPathSegCurvetoCubicRel>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_y1(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegCurvetoCubicRel* self, JS::Value* vp)
{
  float result;
  result = self->Y1();
  *vp = JS_NumberValue(double(result));
  return true;
}

static bool
set_y1(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegCurvetoCubicRel* self, JS::Value* argv)
{
  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[0], &arg0)) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg0)) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    ThrowErrorMessage(cx, MSG_NOT_FINITE);
    return false;
  }
  ErrorResult rv;
  self->SetY1(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGPathSegCurvetoCubicRel", "y1");
  }

  return true;
}


const JSJitInfo y1_getterinfo = {
  (JSJitPropertyOp)get_y1,
  prototypes::id::SVGPathSegCurvetoCubicRel,
  PrototypeTraits<prototypes::id::SVGPathSegCurvetoCubicRel>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo y1_setterinfo = {
  (JSJitPropertyOp)set_y1,
  prototypes::id::SVGPathSegCurvetoCubicRel,
  PrototypeTraits<prototypes::id::SVGPathSegCurvetoCubicRel>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_x2(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegCurvetoCubicRel* self, JS::Value* vp)
{
  float result;
  result = self->X2();
  *vp = JS_NumberValue(double(result));
  return true;
}

static bool
set_x2(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegCurvetoCubicRel* self, JS::Value* argv)
{
  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[0], &arg0)) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg0)) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    ThrowErrorMessage(cx, MSG_NOT_FINITE);
    return false;
  }
  ErrorResult rv;
  self->SetX2(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGPathSegCurvetoCubicRel", "x2");
  }

  return true;
}


const JSJitInfo x2_getterinfo = {
  (JSJitPropertyOp)get_x2,
  prototypes::id::SVGPathSegCurvetoCubicRel,
  PrototypeTraits<prototypes::id::SVGPathSegCurvetoCubicRel>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo x2_setterinfo = {
  (JSJitPropertyOp)set_x2,
  prototypes::id::SVGPathSegCurvetoCubicRel,
  PrototypeTraits<prototypes::id::SVGPathSegCurvetoCubicRel>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_y2(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegCurvetoCubicRel* self, JS::Value* vp)
{
  float result;
  result = self->Y2();
  *vp = JS_NumberValue(double(result));
  return true;
}

static bool
set_y2(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegCurvetoCubicRel* self, JS::Value* argv)
{
  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[0], &arg0)) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg0)) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    ThrowErrorMessage(cx, MSG_NOT_FINITE);
    return false;
  }
  ErrorResult rv;
  self->SetY2(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGPathSegCurvetoCubicRel", "y2");
  }

  return true;
}


const JSJitInfo y2_getterinfo = {
  (JSJitPropertyOp)get_y2,
  prototypes::id::SVGPathSegCurvetoCubicRel,
  PrototypeTraits<prototypes::id::SVGPathSegCurvetoCubicRel>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo y2_setterinfo = {
  (JSJitPropertyOp)set_y2,
  prototypes::id::SVGPathSegCurvetoCubicRel,
  PrototypeTraits<prototypes::id::SVGPathSegCurvetoCubicRel>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static JSBool
genericGetter(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  mozilla::DOMSVGPathSegCurvetoCubicRel* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::SVGPathSegCurvetoCubicRel, mozilla::DOMSVGPathSegCurvetoCubicRel>(cx, obj, self);
    if (NS_FAILED(rv)) {
      return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "SVGPathSegCurvetoCubicRel");
    }
  }
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Getter);
  JSJitPropertyOp getter = info->op;
  return getter(cx, obj, self, vp);
}

static JSBool
genericSetter(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  mozilla::DOMSVGPathSegCurvetoCubicRel* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::SVGPathSegCurvetoCubicRel, mozilla::DOMSVGPathSegCurvetoCubicRel>(cx, obj, self);
    if (NS_FAILED(rv)) {
      return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "SVGPathSegCurvetoCubicRel");
    }
  }
  if (argc == 0) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "SVGPathSegCurvetoCubicRel attribute setter");
  }
  JS::Value* argv = JS_ARGV(cx, vp);
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Setter);
  JSJitPropertyOp setter = info->op;
  if (!setter(cx, obj, self, argv)) {
    return false;
  }
  *vp = JSVAL_VOID;
  return true;
}

static JSBool
_addProperty(JSContext* cx, JSHandleObject obj, JSHandleId id, JSMutableHandleValue vp)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::DOMSVGPathSegCurvetoCubicRel>::value), "Must be an nsISupports class");
  mozilla::DOMSVGPathSegCurvetoCubicRel* self = UnwrapDOMObject<mozilla::DOMSVGPathSegCurvetoCubicRel>(obj);
  nsContentUtils::PreserveWrapper(reinterpret_cast<nsISupports*>(self), self);
  return true;
}

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::DOMSVGPathSegCurvetoCubicRel>::value), "Must be an nsISupports class");
  mozilla::DOMSVGPathSegCurvetoCubicRel* self = UnwrapDOMObject<mozilla::DOMSVGPathSegCurvetoCubicRel>(obj);
  if (self) {
    ClearWrapper(self, self);
    XPCJSRuntime *rt = nsXPConnect::GetRuntimeInstance();
    if (rt) {
      rt->DeferredRelease(reinterpret_cast<nsISupports*>(self));
    } else {
      NS_RELEASE(self);
    }
  }
}

static JSPropertySpec sAttributes_specs[] = {
  { "x", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &x_getterinfo }, { (JSStrictPropertyOp)genericSetter, &x_setterinfo }},
  { "y", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &y_getterinfo }, { (JSStrictPropertyOp)genericSetter, &y_setterinfo }},
  { "x1", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &x1_getterinfo }, { (JSStrictPropertyOp)genericSetter, &x1_setterinfo }},
  { "y1", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &y1_getterinfo }, { (JSStrictPropertyOp)genericSetter, &y1_setterinfo }},
  { "x2", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &x2_getterinfo }, { (JSStrictPropertyOp)genericSetter, &x2_setterinfo }},
  { "y2", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &y2_getterinfo }, { (JSStrictPropertyOp)genericSetter, &y2_setterinfo }},
  { 0, 0, 0, JSOP_NULLWRAPPER, JSOP_NULLWRAPPER }
};

static Prefable<JSPropertySpec> sAttributes[] = {
  { true, &sAttributes_specs[0] },
  { false, NULL }
};

static jsid sAttributes_ids[7] = { JSID_VOID };


static const NativeProperties sNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sAttributes, sAttributes_ids, sAttributes_specs,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr
};
const NativePropertyHooks sNativePropertyHooks = {
  nullptr,
  nullptr,
  { &sNativeProperties, nullptr },
  prototypes::id::SVGPathSegCurvetoCubicRel,
  constructors::id::SVGPathSegCurvetoCubicRel,
  &SVGPathSegBinding::sNativePropertyHooks
};

JSNativeHolder _constructor_holder = {
  ThrowingConstructor,
  &sNativePropertyHooks
};

static DOMIfaceAndProtoJSClass PrototypeClass = {
  {
    "SVGPathSegCurvetoCubicRelPrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(2),
    JS_PropertyStub,       /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    nullptr,               /* finalize */
    nullptr,               /* checkAccess */
    nullptr,               /* call */
    nullptr,               /* hasInstance */
    nullptr,               /* construct */
    nullptr,               /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  eInterfacePrototype,
  &sNativePropertyHooks
};

void
CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray)
{
  JSObject* parentProto = SVGPathSegBinding::GetProtoObject(aCx, aGlobal);
  if (!parentProto) {
    return;
  }


  if (sAttributes_ids[0] == JSID_VOID &&
      !InitIds(aCx, sAttributes, sAttributes_ids)) {
    sAttributes_ids[0] = JSID_VOID;
    return;
  }

  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &PrototypeClass.mBase, &protoAndIfaceArray[prototypes::id::SVGPathSegCurvetoCubicRel],
                              nullptr, &_constructor_holder, 0, &protoAndIfaceArray[constructors::id::SVGPathSegCurvetoCubicRel],
                              &Class.mClass,
                              &sNativeProperties,
                              nullptr,
                              "SVGPathSegCurvetoCubicRel");
}

JSObject*
DefineDOMInterface(JSContext* aCx, JSObject* aGlobal, bool* aEnabled)
{

  *aEnabled = true;
  return GetConstructorObject(aCx, aGlobal);
}


DOMJSClass Class = {
  { "SVGPathSegCurvetoCubicRel",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(3),
    _addProperty, /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    _finalize, /* finalize */
    NULL,                  /* checkAccess */
    NULL,                  /* call */
    NULL,                  /* hasInstance */
    NULL,                  /* construct */
    NULL, /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  {
    { prototypes::id::SVGPathSeg, prototypes::id::SVGPathSegCurvetoCubicRel, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
    true,
    &sNativePropertyHooks,
    GetParentObject<mozilla::DOMSVGPathSegCurvetoCubicRel>::Get,
    GetProtoObject,
    nullptr
  }
};

JSObject*
Wrap(JSContext* aCx, JSObject* aScope, mozilla::DOMSVGPathSegCurvetoCubicRel* aObject, nsWrapperCache* aCache, bool* aTriedToWrap)
{
  MOZ_ASSERT(static_cast<mozilla::DOMSVGPathSegCurvetoCubicRel*>(aObject) ==
             reinterpret_cast<mozilla::DOMSVGPathSegCurvetoCubicRel*>(aObject));
  MOZ_ASSERT(static_cast<mozilla::DOMSVGPathSeg*>(aObject) ==
             reinterpret_cast<mozilla::DOMSVGPathSeg*>(aObject));

  *aTriedToWrap = true;

  JSObject* parent = WrapNativeParent(aCx, aScope, aObject->GetParentObject());
  if (!parent) {
    return NULL;
  }

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.  Scope so we don't
  // collide with the "obj" we declare in CreateBindingJSObject.
  {
    JSObject* obj = aCache->GetWrapper();
    if (obj) {
      return obj;
    }
  }

  JSAutoCompartment ac(aCx, parent);
  JSObject* global = JS_GetGlobalForObject(aCx, parent);

  JSObject* proto = GetProtoObject(aCx, global);
  if (!proto) {
    return NULL;
  }

  JSObject* obj = JS_NewObject(aCx, &Class.mBase, proto, parent);
  if (!obj) {
    return NULL;
  }

  js::SetReservedSlot(obj, DOM_OBJECT_SLOT, PRIVATE_TO_JSVAL(aObject));
  NS_ADDREF(aObject);


  aCache->SetWrapper(obj);

  return obj;
}

} // namespace SVGPathSegCurvetoCubicRelBinding



namespace SVGPathSegCurvetoCubicSmoothAbsBinding {

static bool
get_x(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegCurvetoCubicSmoothAbs* self, JS::Value* vp)
{
  float result;
  result = self->X();
  *vp = JS_NumberValue(double(result));
  return true;
}

static bool
set_x(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegCurvetoCubicSmoothAbs* self, JS::Value* argv)
{
  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[0], &arg0)) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg0)) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    ThrowErrorMessage(cx, MSG_NOT_FINITE);
    return false;
  }
  ErrorResult rv;
  self->SetX(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGPathSegCurvetoCubicSmoothAbs", "x");
  }

  return true;
}


const JSJitInfo x_getterinfo = {
  (JSJitPropertyOp)get_x,
  prototypes::id::SVGPathSegCurvetoCubicSmoothAbs,
  PrototypeTraits<prototypes::id::SVGPathSegCurvetoCubicSmoothAbs>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo x_setterinfo = {
  (JSJitPropertyOp)set_x,
  prototypes::id::SVGPathSegCurvetoCubicSmoothAbs,
  PrototypeTraits<prototypes::id::SVGPathSegCurvetoCubicSmoothAbs>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_y(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegCurvetoCubicSmoothAbs* self, JS::Value* vp)
{
  float result;
  result = self->Y();
  *vp = JS_NumberValue(double(result));
  return true;
}

static bool
set_y(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegCurvetoCubicSmoothAbs* self, JS::Value* argv)
{
  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[0], &arg0)) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg0)) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    ThrowErrorMessage(cx, MSG_NOT_FINITE);
    return false;
  }
  ErrorResult rv;
  self->SetY(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGPathSegCurvetoCubicSmoothAbs", "y");
  }

  return true;
}


const JSJitInfo y_getterinfo = {
  (JSJitPropertyOp)get_y,
  prototypes::id::SVGPathSegCurvetoCubicSmoothAbs,
  PrototypeTraits<prototypes::id::SVGPathSegCurvetoCubicSmoothAbs>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo y_setterinfo = {
  (JSJitPropertyOp)set_y,
  prototypes::id::SVGPathSegCurvetoCubicSmoothAbs,
  PrototypeTraits<prototypes::id::SVGPathSegCurvetoCubicSmoothAbs>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_x2(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegCurvetoCubicSmoothAbs* self, JS::Value* vp)
{
  float result;
  result = self->X2();
  *vp = JS_NumberValue(double(result));
  return true;
}

static bool
set_x2(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegCurvetoCubicSmoothAbs* self, JS::Value* argv)
{
  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[0], &arg0)) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg0)) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    ThrowErrorMessage(cx, MSG_NOT_FINITE);
    return false;
  }
  ErrorResult rv;
  self->SetX2(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGPathSegCurvetoCubicSmoothAbs", "x2");
  }

  return true;
}


const JSJitInfo x2_getterinfo = {
  (JSJitPropertyOp)get_x2,
  prototypes::id::SVGPathSegCurvetoCubicSmoothAbs,
  PrototypeTraits<prototypes::id::SVGPathSegCurvetoCubicSmoothAbs>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo x2_setterinfo = {
  (JSJitPropertyOp)set_x2,
  prototypes::id::SVGPathSegCurvetoCubicSmoothAbs,
  PrototypeTraits<prototypes::id::SVGPathSegCurvetoCubicSmoothAbs>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_y2(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegCurvetoCubicSmoothAbs* self, JS::Value* vp)
{
  float result;
  result = self->Y2();
  *vp = JS_NumberValue(double(result));
  return true;
}

static bool
set_y2(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegCurvetoCubicSmoothAbs* self, JS::Value* argv)
{
  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[0], &arg0)) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg0)) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    ThrowErrorMessage(cx, MSG_NOT_FINITE);
    return false;
  }
  ErrorResult rv;
  self->SetY2(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGPathSegCurvetoCubicSmoothAbs", "y2");
  }

  return true;
}


const JSJitInfo y2_getterinfo = {
  (JSJitPropertyOp)get_y2,
  prototypes::id::SVGPathSegCurvetoCubicSmoothAbs,
  PrototypeTraits<prototypes::id::SVGPathSegCurvetoCubicSmoothAbs>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo y2_setterinfo = {
  (JSJitPropertyOp)set_y2,
  prototypes::id::SVGPathSegCurvetoCubicSmoothAbs,
  PrototypeTraits<prototypes::id::SVGPathSegCurvetoCubicSmoothAbs>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static JSBool
genericGetter(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  mozilla::DOMSVGPathSegCurvetoCubicSmoothAbs* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::SVGPathSegCurvetoCubicSmoothAbs, mozilla::DOMSVGPathSegCurvetoCubicSmoothAbs>(cx, obj, self);
    if (NS_FAILED(rv)) {
      return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "SVGPathSegCurvetoCubicSmoothAbs");
    }
  }
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Getter);
  JSJitPropertyOp getter = info->op;
  return getter(cx, obj, self, vp);
}

static JSBool
genericSetter(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  mozilla::DOMSVGPathSegCurvetoCubicSmoothAbs* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::SVGPathSegCurvetoCubicSmoothAbs, mozilla::DOMSVGPathSegCurvetoCubicSmoothAbs>(cx, obj, self);
    if (NS_FAILED(rv)) {
      return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "SVGPathSegCurvetoCubicSmoothAbs");
    }
  }
  if (argc == 0) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "SVGPathSegCurvetoCubicSmoothAbs attribute setter");
  }
  JS::Value* argv = JS_ARGV(cx, vp);
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Setter);
  JSJitPropertyOp setter = info->op;
  if (!setter(cx, obj, self, argv)) {
    return false;
  }
  *vp = JSVAL_VOID;
  return true;
}

static JSBool
_addProperty(JSContext* cx, JSHandleObject obj, JSHandleId id, JSMutableHandleValue vp)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::DOMSVGPathSegCurvetoCubicSmoothAbs>::value), "Must be an nsISupports class");
  mozilla::DOMSVGPathSegCurvetoCubicSmoothAbs* self = UnwrapDOMObject<mozilla::DOMSVGPathSegCurvetoCubicSmoothAbs>(obj);
  nsContentUtils::PreserveWrapper(reinterpret_cast<nsISupports*>(self), self);
  return true;
}

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::DOMSVGPathSegCurvetoCubicSmoothAbs>::value), "Must be an nsISupports class");
  mozilla::DOMSVGPathSegCurvetoCubicSmoothAbs* self = UnwrapDOMObject<mozilla::DOMSVGPathSegCurvetoCubicSmoothAbs>(obj);
  if (self) {
    ClearWrapper(self, self);
    XPCJSRuntime *rt = nsXPConnect::GetRuntimeInstance();
    if (rt) {
      rt->DeferredRelease(reinterpret_cast<nsISupports*>(self));
    } else {
      NS_RELEASE(self);
    }
  }
}

static JSPropertySpec sAttributes_specs[] = {
  { "x", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &x_getterinfo }, { (JSStrictPropertyOp)genericSetter, &x_setterinfo }},
  { "y", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &y_getterinfo }, { (JSStrictPropertyOp)genericSetter, &y_setterinfo }},
  { "x2", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &x2_getterinfo }, { (JSStrictPropertyOp)genericSetter, &x2_setterinfo }},
  { "y2", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &y2_getterinfo }, { (JSStrictPropertyOp)genericSetter, &y2_setterinfo }},
  { 0, 0, 0, JSOP_NULLWRAPPER, JSOP_NULLWRAPPER }
};

static Prefable<JSPropertySpec> sAttributes[] = {
  { true, &sAttributes_specs[0] },
  { false, NULL }
};

static jsid sAttributes_ids[5] = { JSID_VOID };


static const NativeProperties sNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sAttributes, sAttributes_ids, sAttributes_specs,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr
};
const NativePropertyHooks sNativePropertyHooks = {
  nullptr,
  nullptr,
  { &sNativeProperties, nullptr },
  prototypes::id::SVGPathSegCurvetoCubicSmoothAbs,
  constructors::id::SVGPathSegCurvetoCubicSmoothAbs,
  &SVGPathSegBinding::sNativePropertyHooks
};

JSNativeHolder _constructor_holder = {
  ThrowingConstructor,
  &sNativePropertyHooks
};

static DOMIfaceAndProtoJSClass PrototypeClass = {
  {
    "SVGPathSegCurvetoCubicSmoothAbsPrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(2),
    JS_PropertyStub,       /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    nullptr,               /* finalize */
    nullptr,               /* checkAccess */
    nullptr,               /* call */
    nullptr,               /* hasInstance */
    nullptr,               /* construct */
    nullptr,               /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  eInterfacePrototype,
  &sNativePropertyHooks
};

void
CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray)
{
  JSObject* parentProto = SVGPathSegBinding::GetProtoObject(aCx, aGlobal);
  if (!parentProto) {
    return;
  }


  if (sAttributes_ids[0] == JSID_VOID &&
      !InitIds(aCx, sAttributes, sAttributes_ids)) {
    sAttributes_ids[0] = JSID_VOID;
    return;
  }

  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &PrototypeClass.mBase, &protoAndIfaceArray[prototypes::id::SVGPathSegCurvetoCubicSmoothAbs],
                              nullptr, &_constructor_holder, 0, &protoAndIfaceArray[constructors::id::SVGPathSegCurvetoCubicSmoothAbs],
                              &Class.mClass,
                              &sNativeProperties,
                              nullptr,
                              "SVGPathSegCurvetoCubicSmoothAbs");
}

JSObject*
DefineDOMInterface(JSContext* aCx, JSObject* aGlobal, bool* aEnabled)
{

  *aEnabled = true;
  return GetConstructorObject(aCx, aGlobal);
}


DOMJSClass Class = {
  { "SVGPathSegCurvetoCubicSmoothAbs",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(3),
    _addProperty, /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    _finalize, /* finalize */
    NULL,                  /* checkAccess */
    NULL,                  /* call */
    NULL,                  /* hasInstance */
    NULL,                  /* construct */
    NULL, /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  {
    { prototypes::id::SVGPathSeg, prototypes::id::SVGPathSegCurvetoCubicSmoothAbs, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
    true,
    &sNativePropertyHooks,
    GetParentObject<mozilla::DOMSVGPathSegCurvetoCubicSmoothAbs>::Get,
    GetProtoObject,
    nullptr
  }
};

JSObject*
Wrap(JSContext* aCx, JSObject* aScope, mozilla::DOMSVGPathSegCurvetoCubicSmoothAbs* aObject, nsWrapperCache* aCache, bool* aTriedToWrap)
{
  MOZ_ASSERT(static_cast<mozilla::DOMSVGPathSegCurvetoCubicSmoothAbs*>(aObject) ==
             reinterpret_cast<mozilla::DOMSVGPathSegCurvetoCubicSmoothAbs*>(aObject));
  MOZ_ASSERT(static_cast<mozilla::DOMSVGPathSeg*>(aObject) ==
             reinterpret_cast<mozilla::DOMSVGPathSeg*>(aObject));

  *aTriedToWrap = true;

  JSObject* parent = WrapNativeParent(aCx, aScope, aObject->GetParentObject());
  if (!parent) {
    return NULL;
  }

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.  Scope so we don't
  // collide with the "obj" we declare in CreateBindingJSObject.
  {
    JSObject* obj = aCache->GetWrapper();
    if (obj) {
      return obj;
    }
  }

  JSAutoCompartment ac(aCx, parent);
  JSObject* global = JS_GetGlobalForObject(aCx, parent);

  JSObject* proto = GetProtoObject(aCx, global);
  if (!proto) {
    return NULL;
  }

  JSObject* obj = JS_NewObject(aCx, &Class.mBase, proto, parent);
  if (!obj) {
    return NULL;
  }

  js::SetReservedSlot(obj, DOM_OBJECT_SLOT, PRIVATE_TO_JSVAL(aObject));
  NS_ADDREF(aObject);


  aCache->SetWrapper(obj);

  return obj;
}

} // namespace SVGPathSegCurvetoCubicSmoothAbsBinding



namespace SVGPathSegCurvetoCubicSmoothRelBinding {

static bool
get_x(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegCurvetoCubicSmoothRel* self, JS::Value* vp)
{
  float result;
  result = self->X();
  *vp = JS_NumberValue(double(result));
  return true;
}

static bool
set_x(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegCurvetoCubicSmoothRel* self, JS::Value* argv)
{
  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[0], &arg0)) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg0)) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    ThrowErrorMessage(cx, MSG_NOT_FINITE);
    return false;
  }
  ErrorResult rv;
  self->SetX(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGPathSegCurvetoCubicSmoothRel", "x");
  }

  return true;
}


const JSJitInfo x_getterinfo = {
  (JSJitPropertyOp)get_x,
  prototypes::id::SVGPathSegCurvetoCubicSmoothRel,
  PrototypeTraits<prototypes::id::SVGPathSegCurvetoCubicSmoothRel>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo x_setterinfo = {
  (JSJitPropertyOp)set_x,
  prototypes::id::SVGPathSegCurvetoCubicSmoothRel,
  PrototypeTraits<prototypes::id::SVGPathSegCurvetoCubicSmoothRel>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_y(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegCurvetoCubicSmoothRel* self, JS::Value* vp)
{
  float result;
  result = self->Y();
  *vp = JS_NumberValue(double(result));
  return true;
}

static bool
set_y(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegCurvetoCubicSmoothRel* self, JS::Value* argv)
{
  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[0], &arg0)) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg0)) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    ThrowErrorMessage(cx, MSG_NOT_FINITE);
    return false;
  }
  ErrorResult rv;
  self->SetY(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGPathSegCurvetoCubicSmoothRel", "y");
  }

  return true;
}


const JSJitInfo y_getterinfo = {
  (JSJitPropertyOp)get_y,
  prototypes::id::SVGPathSegCurvetoCubicSmoothRel,
  PrototypeTraits<prototypes::id::SVGPathSegCurvetoCubicSmoothRel>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo y_setterinfo = {
  (JSJitPropertyOp)set_y,
  prototypes::id::SVGPathSegCurvetoCubicSmoothRel,
  PrototypeTraits<prototypes::id::SVGPathSegCurvetoCubicSmoothRel>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_x2(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegCurvetoCubicSmoothRel* self, JS::Value* vp)
{
  float result;
  result = self->X2();
  *vp = JS_NumberValue(double(result));
  return true;
}

static bool
set_x2(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegCurvetoCubicSmoothRel* self, JS::Value* argv)
{
  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[0], &arg0)) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg0)) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    ThrowErrorMessage(cx, MSG_NOT_FINITE);
    return false;
  }
  ErrorResult rv;
  self->SetX2(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGPathSegCurvetoCubicSmoothRel", "x2");
  }

  return true;
}


const JSJitInfo x2_getterinfo = {
  (JSJitPropertyOp)get_x2,
  prototypes::id::SVGPathSegCurvetoCubicSmoothRel,
  PrototypeTraits<prototypes::id::SVGPathSegCurvetoCubicSmoothRel>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo x2_setterinfo = {
  (JSJitPropertyOp)set_x2,
  prototypes::id::SVGPathSegCurvetoCubicSmoothRel,
  PrototypeTraits<prototypes::id::SVGPathSegCurvetoCubicSmoothRel>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_y2(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegCurvetoCubicSmoothRel* self, JS::Value* vp)
{
  float result;
  result = self->Y2();
  *vp = JS_NumberValue(double(result));
  return true;
}

static bool
set_y2(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegCurvetoCubicSmoothRel* self, JS::Value* argv)
{
  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[0], &arg0)) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg0)) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    ThrowErrorMessage(cx, MSG_NOT_FINITE);
    return false;
  }
  ErrorResult rv;
  self->SetY2(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGPathSegCurvetoCubicSmoothRel", "y2");
  }

  return true;
}


const JSJitInfo y2_getterinfo = {
  (JSJitPropertyOp)get_y2,
  prototypes::id::SVGPathSegCurvetoCubicSmoothRel,
  PrototypeTraits<prototypes::id::SVGPathSegCurvetoCubicSmoothRel>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo y2_setterinfo = {
  (JSJitPropertyOp)set_y2,
  prototypes::id::SVGPathSegCurvetoCubicSmoothRel,
  PrototypeTraits<prototypes::id::SVGPathSegCurvetoCubicSmoothRel>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static JSBool
genericGetter(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  mozilla::DOMSVGPathSegCurvetoCubicSmoothRel* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::SVGPathSegCurvetoCubicSmoothRel, mozilla::DOMSVGPathSegCurvetoCubicSmoothRel>(cx, obj, self);
    if (NS_FAILED(rv)) {
      return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "SVGPathSegCurvetoCubicSmoothRel");
    }
  }
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Getter);
  JSJitPropertyOp getter = info->op;
  return getter(cx, obj, self, vp);
}

static JSBool
genericSetter(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  mozilla::DOMSVGPathSegCurvetoCubicSmoothRel* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::SVGPathSegCurvetoCubicSmoothRel, mozilla::DOMSVGPathSegCurvetoCubicSmoothRel>(cx, obj, self);
    if (NS_FAILED(rv)) {
      return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "SVGPathSegCurvetoCubicSmoothRel");
    }
  }
  if (argc == 0) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "SVGPathSegCurvetoCubicSmoothRel attribute setter");
  }
  JS::Value* argv = JS_ARGV(cx, vp);
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Setter);
  JSJitPropertyOp setter = info->op;
  if (!setter(cx, obj, self, argv)) {
    return false;
  }
  *vp = JSVAL_VOID;
  return true;
}

static JSBool
_addProperty(JSContext* cx, JSHandleObject obj, JSHandleId id, JSMutableHandleValue vp)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::DOMSVGPathSegCurvetoCubicSmoothRel>::value), "Must be an nsISupports class");
  mozilla::DOMSVGPathSegCurvetoCubicSmoothRel* self = UnwrapDOMObject<mozilla::DOMSVGPathSegCurvetoCubicSmoothRel>(obj);
  nsContentUtils::PreserveWrapper(reinterpret_cast<nsISupports*>(self), self);
  return true;
}

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::DOMSVGPathSegCurvetoCubicSmoothRel>::value), "Must be an nsISupports class");
  mozilla::DOMSVGPathSegCurvetoCubicSmoothRel* self = UnwrapDOMObject<mozilla::DOMSVGPathSegCurvetoCubicSmoothRel>(obj);
  if (self) {
    ClearWrapper(self, self);
    XPCJSRuntime *rt = nsXPConnect::GetRuntimeInstance();
    if (rt) {
      rt->DeferredRelease(reinterpret_cast<nsISupports*>(self));
    } else {
      NS_RELEASE(self);
    }
  }
}

static JSPropertySpec sAttributes_specs[] = {
  { "x", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &x_getterinfo }, { (JSStrictPropertyOp)genericSetter, &x_setterinfo }},
  { "y", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &y_getterinfo }, { (JSStrictPropertyOp)genericSetter, &y_setterinfo }},
  { "x2", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &x2_getterinfo }, { (JSStrictPropertyOp)genericSetter, &x2_setterinfo }},
  { "y2", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &y2_getterinfo }, { (JSStrictPropertyOp)genericSetter, &y2_setterinfo }},
  { 0, 0, 0, JSOP_NULLWRAPPER, JSOP_NULLWRAPPER }
};

static Prefable<JSPropertySpec> sAttributes[] = {
  { true, &sAttributes_specs[0] },
  { false, NULL }
};

static jsid sAttributes_ids[5] = { JSID_VOID };


static const NativeProperties sNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sAttributes, sAttributes_ids, sAttributes_specs,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr
};
const NativePropertyHooks sNativePropertyHooks = {
  nullptr,
  nullptr,
  { &sNativeProperties, nullptr },
  prototypes::id::SVGPathSegCurvetoCubicSmoothRel,
  constructors::id::SVGPathSegCurvetoCubicSmoothRel,
  &SVGPathSegBinding::sNativePropertyHooks
};

JSNativeHolder _constructor_holder = {
  ThrowingConstructor,
  &sNativePropertyHooks
};

static DOMIfaceAndProtoJSClass PrototypeClass = {
  {
    "SVGPathSegCurvetoCubicSmoothRelPrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(2),
    JS_PropertyStub,       /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    nullptr,               /* finalize */
    nullptr,               /* checkAccess */
    nullptr,               /* call */
    nullptr,               /* hasInstance */
    nullptr,               /* construct */
    nullptr,               /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  eInterfacePrototype,
  &sNativePropertyHooks
};

void
CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray)
{
  JSObject* parentProto = SVGPathSegBinding::GetProtoObject(aCx, aGlobal);
  if (!parentProto) {
    return;
  }


  if (sAttributes_ids[0] == JSID_VOID &&
      !InitIds(aCx, sAttributes, sAttributes_ids)) {
    sAttributes_ids[0] = JSID_VOID;
    return;
  }

  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &PrototypeClass.mBase, &protoAndIfaceArray[prototypes::id::SVGPathSegCurvetoCubicSmoothRel],
                              nullptr, &_constructor_holder, 0, &protoAndIfaceArray[constructors::id::SVGPathSegCurvetoCubicSmoothRel],
                              &Class.mClass,
                              &sNativeProperties,
                              nullptr,
                              "SVGPathSegCurvetoCubicSmoothRel");
}

JSObject*
DefineDOMInterface(JSContext* aCx, JSObject* aGlobal, bool* aEnabled)
{

  *aEnabled = true;
  return GetConstructorObject(aCx, aGlobal);
}


DOMJSClass Class = {
  { "SVGPathSegCurvetoCubicSmoothRel",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(3),
    _addProperty, /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    _finalize, /* finalize */
    NULL,                  /* checkAccess */
    NULL,                  /* call */
    NULL,                  /* hasInstance */
    NULL,                  /* construct */
    NULL, /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  {
    { prototypes::id::SVGPathSeg, prototypes::id::SVGPathSegCurvetoCubicSmoothRel, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
    true,
    &sNativePropertyHooks,
    GetParentObject<mozilla::DOMSVGPathSegCurvetoCubicSmoothRel>::Get,
    GetProtoObject,
    nullptr
  }
};

JSObject*
Wrap(JSContext* aCx, JSObject* aScope, mozilla::DOMSVGPathSegCurvetoCubicSmoothRel* aObject, nsWrapperCache* aCache, bool* aTriedToWrap)
{
  MOZ_ASSERT(static_cast<mozilla::DOMSVGPathSegCurvetoCubicSmoothRel*>(aObject) ==
             reinterpret_cast<mozilla::DOMSVGPathSegCurvetoCubicSmoothRel*>(aObject));
  MOZ_ASSERT(static_cast<mozilla::DOMSVGPathSeg*>(aObject) ==
             reinterpret_cast<mozilla::DOMSVGPathSeg*>(aObject));

  *aTriedToWrap = true;

  JSObject* parent = WrapNativeParent(aCx, aScope, aObject->GetParentObject());
  if (!parent) {
    return NULL;
  }

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.  Scope so we don't
  // collide with the "obj" we declare in CreateBindingJSObject.
  {
    JSObject* obj = aCache->GetWrapper();
    if (obj) {
      return obj;
    }
  }

  JSAutoCompartment ac(aCx, parent);
  JSObject* global = JS_GetGlobalForObject(aCx, parent);

  JSObject* proto = GetProtoObject(aCx, global);
  if (!proto) {
    return NULL;
  }

  JSObject* obj = JS_NewObject(aCx, &Class.mBase, proto, parent);
  if (!obj) {
    return NULL;
  }

  js::SetReservedSlot(obj, DOM_OBJECT_SLOT, PRIVATE_TO_JSVAL(aObject));
  NS_ADDREF(aObject);


  aCache->SetWrapper(obj);

  return obj;
}

} // namespace SVGPathSegCurvetoCubicSmoothRelBinding



namespace SVGPathSegCurvetoQuadraticAbsBinding {

static bool
get_x(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegCurvetoQuadraticAbs* self, JS::Value* vp)
{
  float result;
  result = self->X();
  *vp = JS_NumberValue(double(result));
  return true;
}

static bool
set_x(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegCurvetoQuadraticAbs* self, JS::Value* argv)
{
  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[0], &arg0)) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg0)) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    ThrowErrorMessage(cx, MSG_NOT_FINITE);
    return false;
  }
  ErrorResult rv;
  self->SetX(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGPathSegCurvetoQuadraticAbs", "x");
  }

  return true;
}


const JSJitInfo x_getterinfo = {
  (JSJitPropertyOp)get_x,
  prototypes::id::SVGPathSegCurvetoQuadraticAbs,
  PrototypeTraits<prototypes::id::SVGPathSegCurvetoQuadraticAbs>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo x_setterinfo = {
  (JSJitPropertyOp)set_x,
  prototypes::id::SVGPathSegCurvetoQuadraticAbs,
  PrototypeTraits<prototypes::id::SVGPathSegCurvetoQuadraticAbs>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_y(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegCurvetoQuadraticAbs* self, JS::Value* vp)
{
  float result;
  result = self->Y();
  *vp = JS_NumberValue(double(result));
  return true;
}

static bool
set_y(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegCurvetoQuadraticAbs* self, JS::Value* argv)
{
  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[0], &arg0)) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg0)) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    ThrowErrorMessage(cx, MSG_NOT_FINITE);
    return false;
  }
  ErrorResult rv;
  self->SetY(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGPathSegCurvetoQuadraticAbs", "y");
  }

  return true;
}


const JSJitInfo y_getterinfo = {
  (JSJitPropertyOp)get_y,
  prototypes::id::SVGPathSegCurvetoQuadraticAbs,
  PrototypeTraits<prototypes::id::SVGPathSegCurvetoQuadraticAbs>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo y_setterinfo = {
  (JSJitPropertyOp)set_y,
  prototypes::id::SVGPathSegCurvetoQuadraticAbs,
  PrototypeTraits<prototypes::id::SVGPathSegCurvetoQuadraticAbs>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_x1(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegCurvetoQuadraticAbs* self, JS::Value* vp)
{
  float result;
  result = self->X1();
  *vp = JS_NumberValue(double(result));
  return true;
}

static bool
set_x1(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegCurvetoQuadraticAbs* self, JS::Value* argv)
{
  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[0], &arg0)) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg0)) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    ThrowErrorMessage(cx, MSG_NOT_FINITE);
    return false;
  }
  ErrorResult rv;
  self->SetX1(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGPathSegCurvetoQuadraticAbs", "x1");
  }

  return true;
}


const JSJitInfo x1_getterinfo = {
  (JSJitPropertyOp)get_x1,
  prototypes::id::SVGPathSegCurvetoQuadraticAbs,
  PrototypeTraits<prototypes::id::SVGPathSegCurvetoQuadraticAbs>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo x1_setterinfo = {
  (JSJitPropertyOp)set_x1,
  prototypes::id::SVGPathSegCurvetoQuadraticAbs,
  PrototypeTraits<prototypes::id::SVGPathSegCurvetoQuadraticAbs>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_y1(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegCurvetoQuadraticAbs* self, JS::Value* vp)
{
  float result;
  result = self->Y1();
  *vp = JS_NumberValue(double(result));
  return true;
}

static bool
set_y1(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegCurvetoQuadraticAbs* self, JS::Value* argv)
{
  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[0], &arg0)) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg0)) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    ThrowErrorMessage(cx, MSG_NOT_FINITE);
    return false;
  }
  ErrorResult rv;
  self->SetY1(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGPathSegCurvetoQuadraticAbs", "y1");
  }

  return true;
}


const JSJitInfo y1_getterinfo = {
  (JSJitPropertyOp)get_y1,
  prototypes::id::SVGPathSegCurvetoQuadraticAbs,
  PrototypeTraits<prototypes::id::SVGPathSegCurvetoQuadraticAbs>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo y1_setterinfo = {
  (JSJitPropertyOp)set_y1,
  prototypes::id::SVGPathSegCurvetoQuadraticAbs,
  PrototypeTraits<prototypes::id::SVGPathSegCurvetoQuadraticAbs>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static JSBool
genericGetter(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  mozilla::DOMSVGPathSegCurvetoQuadraticAbs* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::SVGPathSegCurvetoQuadraticAbs, mozilla::DOMSVGPathSegCurvetoQuadraticAbs>(cx, obj, self);
    if (NS_FAILED(rv)) {
      return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "SVGPathSegCurvetoQuadraticAbs");
    }
  }
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Getter);
  JSJitPropertyOp getter = info->op;
  return getter(cx, obj, self, vp);
}

static JSBool
genericSetter(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  mozilla::DOMSVGPathSegCurvetoQuadraticAbs* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::SVGPathSegCurvetoQuadraticAbs, mozilla::DOMSVGPathSegCurvetoQuadraticAbs>(cx, obj, self);
    if (NS_FAILED(rv)) {
      return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "SVGPathSegCurvetoQuadraticAbs");
    }
  }
  if (argc == 0) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "SVGPathSegCurvetoQuadraticAbs attribute setter");
  }
  JS::Value* argv = JS_ARGV(cx, vp);
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Setter);
  JSJitPropertyOp setter = info->op;
  if (!setter(cx, obj, self, argv)) {
    return false;
  }
  *vp = JSVAL_VOID;
  return true;
}

static JSBool
_addProperty(JSContext* cx, JSHandleObject obj, JSHandleId id, JSMutableHandleValue vp)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::DOMSVGPathSegCurvetoQuadraticAbs>::value), "Must be an nsISupports class");
  mozilla::DOMSVGPathSegCurvetoQuadraticAbs* self = UnwrapDOMObject<mozilla::DOMSVGPathSegCurvetoQuadraticAbs>(obj);
  nsContentUtils::PreserveWrapper(reinterpret_cast<nsISupports*>(self), self);
  return true;
}

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::DOMSVGPathSegCurvetoQuadraticAbs>::value), "Must be an nsISupports class");
  mozilla::DOMSVGPathSegCurvetoQuadraticAbs* self = UnwrapDOMObject<mozilla::DOMSVGPathSegCurvetoQuadraticAbs>(obj);
  if (self) {
    ClearWrapper(self, self);
    XPCJSRuntime *rt = nsXPConnect::GetRuntimeInstance();
    if (rt) {
      rt->DeferredRelease(reinterpret_cast<nsISupports*>(self));
    } else {
      NS_RELEASE(self);
    }
  }
}

static JSPropertySpec sAttributes_specs[] = {
  { "x", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &x_getterinfo }, { (JSStrictPropertyOp)genericSetter, &x_setterinfo }},
  { "y", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &y_getterinfo }, { (JSStrictPropertyOp)genericSetter, &y_setterinfo }},
  { "x1", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &x1_getterinfo }, { (JSStrictPropertyOp)genericSetter, &x1_setterinfo }},
  { "y1", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &y1_getterinfo }, { (JSStrictPropertyOp)genericSetter, &y1_setterinfo }},
  { 0, 0, 0, JSOP_NULLWRAPPER, JSOP_NULLWRAPPER }
};

static Prefable<JSPropertySpec> sAttributes[] = {
  { true, &sAttributes_specs[0] },
  { false, NULL }
};

static jsid sAttributes_ids[5] = { JSID_VOID };


static const NativeProperties sNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sAttributes, sAttributes_ids, sAttributes_specs,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr
};
const NativePropertyHooks sNativePropertyHooks = {
  nullptr,
  nullptr,
  { &sNativeProperties, nullptr },
  prototypes::id::SVGPathSegCurvetoQuadraticAbs,
  constructors::id::SVGPathSegCurvetoQuadraticAbs,
  &SVGPathSegBinding::sNativePropertyHooks
};

JSNativeHolder _constructor_holder = {
  ThrowingConstructor,
  &sNativePropertyHooks
};

static DOMIfaceAndProtoJSClass PrototypeClass = {
  {
    "SVGPathSegCurvetoQuadraticAbsPrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(2),
    JS_PropertyStub,       /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    nullptr,               /* finalize */
    nullptr,               /* checkAccess */
    nullptr,               /* call */
    nullptr,               /* hasInstance */
    nullptr,               /* construct */
    nullptr,               /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  eInterfacePrototype,
  &sNativePropertyHooks
};

void
CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray)
{
  JSObject* parentProto = SVGPathSegBinding::GetProtoObject(aCx, aGlobal);
  if (!parentProto) {
    return;
  }


  if (sAttributes_ids[0] == JSID_VOID &&
      !InitIds(aCx, sAttributes, sAttributes_ids)) {
    sAttributes_ids[0] = JSID_VOID;
    return;
  }

  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &PrototypeClass.mBase, &protoAndIfaceArray[prototypes::id::SVGPathSegCurvetoQuadraticAbs],
                              nullptr, &_constructor_holder, 0, &protoAndIfaceArray[constructors::id::SVGPathSegCurvetoQuadraticAbs],
                              &Class.mClass,
                              &sNativeProperties,
                              nullptr,
                              "SVGPathSegCurvetoQuadraticAbs");
}

JSObject*
DefineDOMInterface(JSContext* aCx, JSObject* aGlobal, bool* aEnabled)
{

  *aEnabled = true;
  return GetConstructorObject(aCx, aGlobal);
}


DOMJSClass Class = {
  { "SVGPathSegCurvetoQuadraticAbs",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(3),
    _addProperty, /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    _finalize, /* finalize */
    NULL,                  /* checkAccess */
    NULL,                  /* call */
    NULL,                  /* hasInstance */
    NULL,                  /* construct */
    NULL, /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  {
    { prototypes::id::SVGPathSeg, prototypes::id::SVGPathSegCurvetoQuadraticAbs, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
    true,
    &sNativePropertyHooks,
    GetParentObject<mozilla::DOMSVGPathSegCurvetoQuadraticAbs>::Get,
    GetProtoObject,
    nullptr
  }
};

JSObject*
Wrap(JSContext* aCx, JSObject* aScope, mozilla::DOMSVGPathSegCurvetoQuadraticAbs* aObject, nsWrapperCache* aCache, bool* aTriedToWrap)
{
  MOZ_ASSERT(static_cast<mozilla::DOMSVGPathSegCurvetoQuadraticAbs*>(aObject) ==
             reinterpret_cast<mozilla::DOMSVGPathSegCurvetoQuadraticAbs*>(aObject));
  MOZ_ASSERT(static_cast<mozilla::DOMSVGPathSeg*>(aObject) ==
             reinterpret_cast<mozilla::DOMSVGPathSeg*>(aObject));

  *aTriedToWrap = true;

  JSObject* parent = WrapNativeParent(aCx, aScope, aObject->GetParentObject());
  if (!parent) {
    return NULL;
  }

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.  Scope so we don't
  // collide with the "obj" we declare in CreateBindingJSObject.
  {
    JSObject* obj = aCache->GetWrapper();
    if (obj) {
      return obj;
    }
  }

  JSAutoCompartment ac(aCx, parent);
  JSObject* global = JS_GetGlobalForObject(aCx, parent);

  JSObject* proto = GetProtoObject(aCx, global);
  if (!proto) {
    return NULL;
  }

  JSObject* obj = JS_NewObject(aCx, &Class.mBase, proto, parent);
  if (!obj) {
    return NULL;
  }

  js::SetReservedSlot(obj, DOM_OBJECT_SLOT, PRIVATE_TO_JSVAL(aObject));
  NS_ADDREF(aObject);


  aCache->SetWrapper(obj);

  return obj;
}

} // namespace SVGPathSegCurvetoQuadraticAbsBinding



namespace SVGPathSegCurvetoQuadraticRelBinding {

static bool
get_x(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegCurvetoQuadraticRel* self, JS::Value* vp)
{
  float result;
  result = self->X();
  *vp = JS_NumberValue(double(result));
  return true;
}

static bool
set_x(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegCurvetoQuadraticRel* self, JS::Value* argv)
{
  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[0], &arg0)) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg0)) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    ThrowErrorMessage(cx, MSG_NOT_FINITE);
    return false;
  }
  ErrorResult rv;
  self->SetX(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGPathSegCurvetoQuadraticRel", "x");
  }

  return true;
}


const JSJitInfo x_getterinfo = {
  (JSJitPropertyOp)get_x,
  prototypes::id::SVGPathSegCurvetoQuadraticRel,
  PrototypeTraits<prototypes::id::SVGPathSegCurvetoQuadraticRel>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo x_setterinfo = {
  (JSJitPropertyOp)set_x,
  prototypes::id::SVGPathSegCurvetoQuadraticRel,
  PrototypeTraits<prototypes::id::SVGPathSegCurvetoQuadraticRel>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_y(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegCurvetoQuadraticRel* self, JS::Value* vp)
{
  float result;
  result = self->Y();
  *vp = JS_NumberValue(double(result));
  return true;
}

static bool
set_y(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegCurvetoQuadraticRel* self, JS::Value* argv)
{
  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[0], &arg0)) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg0)) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    ThrowErrorMessage(cx, MSG_NOT_FINITE);
    return false;
  }
  ErrorResult rv;
  self->SetY(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGPathSegCurvetoQuadraticRel", "y");
  }

  return true;
}


const JSJitInfo y_getterinfo = {
  (JSJitPropertyOp)get_y,
  prototypes::id::SVGPathSegCurvetoQuadraticRel,
  PrototypeTraits<prototypes::id::SVGPathSegCurvetoQuadraticRel>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo y_setterinfo = {
  (JSJitPropertyOp)set_y,
  prototypes::id::SVGPathSegCurvetoQuadraticRel,
  PrototypeTraits<prototypes::id::SVGPathSegCurvetoQuadraticRel>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_x1(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegCurvetoQuadraticRel* self, JS::Value* vp)
{
  float result;
  result = self->X1();
  *vp = JS_NumberValue(double(result));
  return true;
}

static bool
set_x1(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegCurvetoQuadraticRel* self, JS::Value* argv)
{
  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[0], &arg0)) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg0)) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    ThrowErrorMessage(cx, MSG_NOT_FINITE);
    return false;
  }
  ErrorResult rv;
  self->SetX1(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGPathSegCurvetoQuadraticRel", "x1");
  }

  return true;
}


const JSJitInfo x1_getterinfo = {
  (JSJitPropertyOp)get_x1,
  prototypes::id::SVGPathSegCurvetoQuadraticRel,
  PrototypeTraits<prototypes::id::SVGPathSegCurvetoQuadraticRel>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo x1_setterinfo = {
  (JSJitPropertyOp)set_x1,
  prototypes::id::SVGPathSegCurvetoQuadraticRel,
  PrototypeTraits<prototypes::id::SVGPathSegCurvetoQuadraticRel>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_y1(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegCurvetoQuadraticRel* self, JS::Value* vp)
{
  float result;
  result = self->Y1();
  *vp = JS_NumberValue(double(result));
  return true;
}

static bool
set_y1(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegCurvetoQuadraticRel* self, JS::Value* argv)
{
  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[0], &arg0)) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg0)) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    ThrowErrorMessage(cx, MSG_NOT_FINITE);
    return false;
  }
  ErrorResult rv;
  self->SetY1(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGPathSegCurvetoQuadraticRel", "y1");
  }

  return true;
}


const JSJitInfo y1_getterinfo = {
  (JSJitPropertyOp)get_y1,
  prototypes::id::SVGPathSegCurvetoQuadraticRel,
  PrototypeTraits<prototypes::id::SVGPathSegCurvetoQuadraticRel>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo y1_setterinfo = {
  (JSJitPropertyOp)set_y1,
  prototypes::id::SVGPathSegCurvetoQuadraticRel,
  PrototypeTraits<prototypes::id::SVGPathSegCurvetoQuadraticRel>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static JSBool
genericGetter(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  mozilla::DOMSVGPathSegCurvetoQuadraticRel* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::SVGPathSegCurvetoQuadraticRel, mozilla::DOMSVGPathSegCurvetoQuadraticRel>(cx, obj, self);
    if (NS_FAILED(rv)) {
      return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "SVGPathSegCurvetoQuadraticRel");
    }
  }
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Getter);
  JSJitPropertyOp getter = info->op;
  return getter(cx, obj, self, vp);
}

static JSBool
genericSetter(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  mozilla::DOMSVGPathSegCurvetoQuadraticRel* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::SVGPathSegCurvetoQuadraticRel, mozilla::DOMSVGPathSegCurvetoQuadraticRel>(cx, obj, self);
    if (NS_FAILED(rv)) {
      return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "SVGPathSegCurvetoQuadraticRel");
    }
  }
  if (argc == 0) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "SVGPathSegCurvetoQuadraticRel attribute setter");
  }
  JS::Value* argv = JS_ARGV(cx, vp);
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Setter);
  JSJitPropertyOp setter = info->op;
  if (!setter(cx, obj, self, argv)) {
    return false;
  }
  *vp = JSVAL_VOID;
  return true;
}

static JSBool
_addProperty(JSContext* cx, JSHandleObject obj, JSHandleId id, JSMutableHandleValue vp)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::DOMSVGPathSegCurvetoQuadraticRel>::value), "Must be an nsISupports class");
  mozilla::DOMSVGPathSegCurvetoQuadraticRel* self = UnwrapDOMObject<mozilla::DOMSVGPathSegCurvetoQuadraticRel>(obj);
  nsContentUtils::PreserveWrapper(reinterpret_cast<nsISupports*>(self), self);
  return true;
}

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::DOMSVGPathSegCurvetoQuadraticRel>::value), "Must be an nsISupports class");
  mozilla::DOMSVGPathSegCurvetoQuadraticRel* self = UnwrapDOMObject<mozilla::DOMSVGPathSegCurvetoQuadraticRel>(obj);
  if (self) {
    ClearWrapper(self, self);
    XPCJSRuntime *rt = nsXPConnect::GetRuntimeInstance();
    if (rt) {
      rt->DeferredRelease(reinterpret_cast<nsISupports*>(self));
    } else {
      NS_RELEASE(self);
    }
  }
}

static JSPropertySpec sAttributes_specs[] = {
  { "x", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &x_getterinfo }, { (JSStrictPropertyOp)genericSetter, &x_setterinfo }},
  { "y", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &y_getterinfo }, { (JSStrictPropertyOp)genericSetter, &y_setterinfo }},
  { "x1", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &x1_getterinfo }, { (JSStrictPropertyOp)genericSetter, &x1_setterinfo }},
  { "y1", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &y1_getterinfo }, { (JSStrictPropertyOp)genericSetter, &y1_setterinfo }},
  { 0, 0, 0, JSOP_NULLWRAPPER, JSOP_NULLWRAPPER }
};

static Prefable<JSPropertySpec> sAttributes[] = {
  { true, &sAttributes_specs[0] },
  { false, NULL }
};

static jsid sAttributes_ids[5] = { JSID_VOID };


static const NativeProperties sNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sAttributes, sAttributes_ids, sAttributes_specs,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr
};
const NativePropertyHooks sNativePropertyHooks = {
  nullptr,
  nullptr,
  { &sNativeProperties, nullptr },
  prototypes::id::SVGPathSegCurvetoQuadraticRel,
  constructors::id::SVGPathSegCurvetoQuadraticRel,
  &SVGPathSegBinding::sNativePropertyHooks
};

JSNativeHolder _constructor_holder = {
  ThrowingConstructor,
  &sNativePropertyHooks
};

static DOMIfaceAndProtoJSClass PrototypeClass = {
  {
    "SVGPathSegCurvetoQuadraticRelPrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(2),
    JS_PropertyStub,       /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    nullptr,               /* finalize */
    nullptr,               /* checkAccess */
    nullptr,               /* call */
    nullptr,               /* hasInstance */
    nullptr,               /* construct */
    nullptr,               /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  eInterfacePrototype,
  &sNativePropertyHooks
};

void
CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray)
{
  JSObject* parentProto = SVGPathSegBinding::GetProtoObject(aCx, aGlobal);
  if (!parentProto) {
    return;
  }


  if (sAttributes_ids[0] == JSID_VOID &&
      !InitIds(aCx, sAttributes, sAttributes_ids)) {
    sAttributes_ids[0] = JSID_VOID;
    return;
  }

  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &PrototypeClass.mBase, &protoAndIfaceArray[prototypes::id::SVGPathSegCurvetoQuadraticRel],
                              nullptr, &_constructor_holder, 0, &protoAndIfaceArray[constructors::id::SVGPathSegCurvetoQuadraticRel],
                              &Class.mClass,
                              &sNativeProperties,
                              nullptr,
                              "SVGPathSegCurvetoQuadraticRel");
}

JSObject*
DefineDOMInterface(JSContext* aCx, JSObject* aGlobal, bool* aEnabled)
{

  *aEnabled = true;
  return GetConstructorObject(aCx, aGlobal);
}


DOMJSClass Class = {
  { "SVGPathSegCurvetoQuadraticRel",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(3),
    _addProperty, /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    _finalize, /* finalize */
    NULL,                  /* checkAccess */
    NULL,                  /* call */
    NULL,                  /* hasInstance */
    NULL,                  /* construct */
    NULL, /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  {
    { prototypes::id::SVGPathSeg, prototypes::id::SVGPathSegCurvetoQuadraticRel, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
    true,
    &sNativePropertyHooks,
    GetParentObject<mozilla::DOMSVGPathSegCurvetoQuadraticRel>::Get,
    GetProtoObject,
    nullptr
  }
};

JSObject*
Wrap(JSContext* aCx, JSObject* aScope, mozilla::DOMSVGPathSegCurvetoQuadraticRel* aObject, nsWrapperCache* aCache, bool* aTriedToWrap)
{
  MOZ_ASSERT(static_cast<mozilla::DOMSVGPathSegCurvetoQuadraticRel*>(aObject) ==
             reinterpret_cast<mozilla::DOMSVGPathSegCurvetoQuadraticRel*>(aObject));
  MOZ_ASSERT(static_cast<mozilla::DOMSVGPathSeg*>(aObject) ==
             reinterpret_cast<mozilla::DOMSVGPathSeg*>(aObject));

  *aTriedToWrap = true;

  JSObject* parent = WrapNativeParent(aCx, aScope, aObject->GetParentObject());
  if (!parent) {
    return NULL;
  }

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.  Scope so we don't
  // collide with the "obj" we declare in CreateBindingJSObject.
  {
    JSObject* obj = aCache->GetWrapper();
    if (obj) {
      return obj;
    }
  }

  JSAutoCompartment ac(aCx, parent);
  JSObject* global = JS_GetGlobalForObject(aCx, parent);

  JSObject* proto = GetProtoObject(aCx, global);
  if (!proto) {
    return NULL;
  }

  JSObject* obj = JS_NewObject(aCx, &Class.mBase, proto, parent);
  if (!obj) {
    return NULL;
  }

  js::SetReservedSlot(obj, DOM_OBJECT_SLOT, PRIVATE_TO_JSVAL(aObject));
  NS_ADDREF(aObject);


  aCache->SetWrapper(obj);

  return obj;
}

} // namespace SVGPathSegCurvetoQuadraticRelBinding



namespace SVGPathSegCurvetoQuadraticSmoothAbsBinding {

static bool
get_x(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegCurvetoQuadraticSmoothAbs* self, JS::Value* vp)
{
  float result;
  result = self->X();
  *vp = JS_NumberValue(double(result));
  return true;
}

static bool
set_x(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegCurvetoQuadraticSmoothAbs* self, JS::Value* argv)
{
  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[0], &arg0)) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg0)) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    ThrowErrorMessage(cx, MSG_NOT_FINITE);
    return false;
  }
  ErrorResult rv;
  self->SetX(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGPathSegCurvetoQuadraticSmoothAbs", "x");
  }

  return true;
}


const JSJitInfo x_getterinfo = {
  (JSJitPropertyOp)get_x,
  prototypes::id::SVGPathSegCurvetoQuadraticSmoothAbs,
  PrototypeTraits<prototypes::id::SVGPathSegCurvetoQuadraticSmoothAbs>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo x_setterinfo = {
  (JSJitPropertyOp)set_x,
  prototypes::id::SVGPathSegCurvetoQuadraticSmoothAbs,
  PrototypeTraits<prototypes::id::SVGPathSegCurvetoQuadraticSmoothAbs>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_y(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegCurvetoQuadraticSmoothAbs* self, JS::Value* vp)
{
  float result;
  result = self->Y();
  *vp = JS_NumberValue(double(result));
  return true;
}

static bool
set_y(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegCurvetoQuadraticSmoothAbs* self, JS::Value* argv)
{
  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[0], &arg0)) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg0)) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    ThrowErrorMessage(cx, MSG_NOT_FINITE);
    return false;
  }
  ErrorResult rv;
  self->SetY(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGPathSegCurvetoQuadraticSmoothAbs", "y");
  }

  return true;
}


const JSJitInfo y_getterinfo = {
  (JSJitPropertyOp)get_y,
  prototypes::id::SVGPathSegCurvetoQuadraticSmoothAbs,
  PrototypeTraits<prototypes::id::SVGPathSegCurvetoQuadraticSmoothAbs>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo y_setterinfo = {
  (JSJitPropertyOp)set_y,
  prototypes::id::SVGPathSegCurvetoQuadraticSmoothAbs,
  PrototypeTraits<prototypes::id::SVGPathSegCurvetoQuadraticSmoothAbs>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static JSBool
genericGetter(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  mozilla::DOMSVGPathSegCurvetoQuadraticSmoothAbs* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::SVGPathSegCurvetoQuadraticSmoothAbs, mozilla::DOMSVGPathSegCurvetoQuadraticSmoothAbs>(cx, obj, self);
    if (NS_FAILED(rv)) {
      return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "SVGPathSegCurvetoQuadraticSmoothAbs");
    }
  }
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Getter);
  JSJitPropertyOp getter = info->op;
  return getter(cx, obj, self, vp);
}

static JSBool
genericSetter(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  mozilla::DOMSVGPathSegCurvetoQuadraticSmoothAbs* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::SVGPathSegCurvetoQuadraticSmoothAbs, mozilla::DOMSVGPathSegCurvetoQuadraticSmoothAbs>(cx, obj, self);
    if (NS_FAILED(rv)) {
      return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "SVGPathSegCurvetoQuadraticSmoothAbs");
    }
  }
  if (argc == 0) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "SVGPathSegCurvetoQuadraticSmoothAbs attribute setter");
  }
  JS::Value* argv = JS_ARGV(cx, vp);
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Setter);
  JSJitPropertyOp setter = info->op;
  if (!setter(cx, obj, self, argv)) {
    return false;
  }
  *vp = JSVAL_VOID;
  return true;
}

static JSBool
_addProperty(JSContext* cx, JSHandleObject obj, JSHandleId id, JSMutableHandleValue vp)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::DOMSVGPathSegCurvetoQuadraticSmoothAbs>::value), "Must be an nsISupports class");
  mozilla::DOMSVGPathSegCurvetoQuadraticSmoothAbs* self = UnwrapDOMObject<mozilla::DOMSVGPathSegCurvetoQuadraticSmoothAbs>(obj);
  nsContentUtils::PreserveWrapper(reinterpret_cast<nsISupports*>(self), self);
  return true;
}

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::DOMSVGPathSegCurvetoQuadraticSmoothAbs>::value), "Must be an nsISupports class");
  mozilla::DOMSVGPathSegCurvetoQuadraticSmoothAbs* self = UnwrapDOMObject<mozilla::DOMSVGPathSegCurvetoQuadraticSmoothAbs>(obj);
  if (self) {
    ClearWrapper(self, self);
    XPCJSRuntime *rt = nsXPConnect::GetRuntimeInstance();
    if (rt) {
      rt->DeferredRelease(reinterpret_cast<nsISupports*>(self));
    } else {
      NS_RELEASE(self);
    }
  }
}

static JSPropertySpec sAttributes_specs[] = {
  { "x", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &x_getterinfo }, { (JSStrictPropertyOp)genericSetter, &x_setterinfo }},
  { "y", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &y_getterinfo }, { (JSStrictPropertyOp)genericSetter, &y_setterinfo }},
  { 0, 0, 0, JSOP_NULLWRAPPER, JSOP_NULLWRAPPER }
};

static Prefable<JSPropertySpec> sAttributes[] = {
  { true, &sAttributes_specs[0] },
  { false, NULL }
};

static jsid sAttributes_ids[3] = { JSID_VOID };


static const NativeProperties sNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sAttributes, sAttributes_ids, sAttributes_specs,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr
};
const NativePropertyHooks sNativePropertyHooks = {
  nullptr,
  nullptr,
  { &sNativeProperties, nullptr },
  prototypes::id::SVGPathSegCurvetoQuadraticSmoothAbs,
  constructors::id::SVGPathSegCurvetoQuadraticSmoothAbs,
  &SVGPathSegBinding::sNativePropertyHooks
};

JSNativeHolder _constructor_holder = {
  ThrowingConstructor,
  &sNativePropertyHooks
};

static DOMIfaceAndProtoJSClass PrototypeClass = {
  {
    "SVGPathSegCurvetoQuadraticSmoothAbsPrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(2),
    JS_PropertyStub,       /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    nullptr,               /* finalize */
    nullptr,               /* checkAccess */
    nullptr,               /* call */
    nullptr,               /* hasInstance */
    nullptr,               /* construct */
    nullptr,               /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  eInterfacePrototype,
  &sNativePropertyHooks
};

void
CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray)
{
  JSObject* parentProto = SVGPathSegBinding::GetProtoObject(aCx, aGlobal);
  if (!parentProto) {
    return;
  }


  if (sAttributes_ids[0] == JSID_VOID &&
      !InitIds(aCx, sAttributes, sAttributes_ids)) {
    sAttributes_ids[0] = JSID_VOID;
    return;
  }

  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &PrototypeClass.mBase, &protoAndIfaceArray[prototypes::id::SVGPathSegCurvetoQuadraticSmoothAbs],
                              nullptr, &_constructor_holder, 0, &protoAndIfaceArray[constructors::id::SVGPathSegCurvetoQuadraticSmoothAbs],
                              &Class.mClass,
                              &sNativeProperties,
                              nullptr,
                              "SVGPathSegCurvetoQuadraticSmoothAbs");
}

JSObject*
DefineDOMInterface(JSContext* aCx, JSObject* aGlobal, bool* aEnabled)
{

  *aEnabled = true;
  return GetConstructorObject(aCx, aGlobal);
}


DOMJSClass Class = {
  { "SVGPathSegCurvetoQuadraticSmoothAbs",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(3),
    _addProperty, /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    _finalize, /* finalize */
    NULL,                  /* checkAccess */
    NULL,                  /* call */
    NULL,                  /* hasInstance */
    NULL,                  /* construct */
    NULL, /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  {
    { prototypes::id::SVGPathSeg, prototypes::id::SVGPathSegCurvetoQuadraticSmoothAbs, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
    true,
    &sNativePropertyHooks,
    GetParentObject<mozilla::DOMSVGPathSegCurvetoQuadraticSmoothAbs>::Get,
    GetProtoObject,
    nullptr
  }
};

JSObject*
Wrap(JSContext* aCx, JSObject* aScope, mozilla::DOMSVGPathSegCurvetoQuadraticSmoothAbs* aObject, nsWrapperCache* aCache, bool* aTriedToWrap)
{
  MOZ_ASSERT(static_cast<mozilla::DOMSVGPathSegCurvetoQuadraticSmoothAbs*>(aObject) ==
             reinterpret_cast<mozilla::DOMSVGPathSegCurvetoQuadraticSmoothAbs*>(aObject));
  MOZ_ASSERT(static_cast<mozilla::DOMSVGPathSeg*>(aObject) ==
             reinterpret_cast<mozilla::DOMSVGPathSeg*>(aObject));

  *aTriedToWrap = true;

  JSObject* parent = WrapNativeParent(aCx, aScope, aObject->GetParentObject());
  if (!parent) {
    return NULL;
  }

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.  Scope so we don't
  // collide with the "obj" we declare in CreateBindingJSObject.
  {
    JSObject* obj = aCache->GetWrapper();
    if (obj) {
      return obj;
    }
  }

  JSAutoCompartment ac(aCx, parent);
  JSObject* global = JS_GetGlobalForObject(aCx, parent);

  JSObject* proto = GetProtoObject(aCx, global);
  if (!proto) {
    return NULL;
  }

  JSObject* obj = JS_NewObject(aCx, &Class.mBase, proto, parent);
  if (!obj) {
    return NULL;
  }

  js::SetReservedSlot(obj, DOM_OBJECT_SLOT, PRIVATE_TO_JSVAL(aObject));
  NS_ADDREF(aObject);


  aCache->SetWrapper(obj);

  return obj;
}

} // namespace SVGPathSegCurvetoQuadraticSmoothAbsBinding



namespace SVGPathSegCurvetoQuadraticSmoothRelBinding {

static bool
get_x(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegCurvetoQuadraticSmoothRel* self, JS::Value* vp)
{
  float result;
  result = self->X();
  *vp = JS_NumberValue(double(result));
  return true;
}

static bool
set_x(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegCurvetoQuadraticSmoothRel* self, JS::Value* argv)
{
  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[0], &arg0)) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg0)) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    ThrowErrorMessage(cx, MSG_NOT_FINITE);
    return false;
  }
  ErrorResult rv;
  self->SetX(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGPathSegCurvetoQuadraticSmoothRel", "x");
  }

  return true;
}


const JSJitInfo x_getterinfo = {
  (JSJitPropertyOp)get_x,
  prototypes::id::SVGPathSegCurvetoQuadraticSmoothRel,
  PrototypeTraits<prototypes::id::SVGPathSegCurvetoQuadraticSmoothRel>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo x_setterinfo = {
  (JSJitPropertyOp)set_x,
  prototypes::id::SVGPathSegCurvetoQuadraticSmoothRel,
  PrototypeTraits<prototypes::id::SVGPathSegCurvetoQuadraticSmoothRel>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_y(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegCurvetoQuadraticSmoothRel* self, JS::Value* vp)
{
  float result;
  result = self->Y();
  *vp = JS_NumberValue(double(result));
  return true;
}

static bool
set_y(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegCurvetoQuadraticSmoothRel* self, JS::Value* argv)
{
  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[0], &arg0)) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg0)) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    ThrowErrorMessage(cx, MSG_NOT_FINITE);
    return false;
  }
  ErrorResult rv;
  self->SetY(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGPathSegCurvetoQuadraticSmoothRel", "y");
  }

  return true;
}


const JSJitInfo y_getterinfo = {
  (JSJitPropertyOp)get_y,
  prototypes::id::SVGPathSegCurvetoQuadraticSmoothRel,
  PrototypeTraits<prototypes::id::SVGPathSegCurvetoQuadraticSmoothRel>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo y_setterinfo = {
  (JSJitPropertyOp)set_y,
  prototypes::id::SVGPathSegCurvetoQuadraticSmoothRel,
  PrototypeTraits<prototypes::id::SVGPathSegCurvetoQuadraticSmoothRel>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static JSBool
genericGetter(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  mozilla::DOMSVGPathSegCurvetoQuadraticSmoothRel* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::SVGPathSegCurvetoQuadraticSmoothRel, mozilla::DOMSVGPathSegCurvetoQuadraticSmoothRel>(cx, obj, self);
    if (NS_FAILED(rv)) {
      return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "SVGPathSegCurvetoQuadraticSmoothRel");
    }
  }
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Getter);
  JSJitPropertyOp getter = info->op;
  return getter(cx, obj, self, vp);
}

static JSBool
genericSetter(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  mozilla::DOMSVGPathSegCurvetoQuadraticSmoothRel* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::SVGPathSegCurvetoQuadraticSmoothRel, mozilla::DOMSVGPathSegCurvetoQuadraticSmoothRel>(cx, obj, self);
    if (NS_FAILED(rv)) {
      return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "SVGPathSegCurvetoQuadraticSmoothRel");
    }
  }
  if (argc == 0) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "SVGPathSegCurvetoQuadraticSmoothRel attribute setter");
  }
  JS::Value* argv = JS_ARGV(cx, vp);
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Setter);
  JSJitPropertyOp setter = info->op;
  if (!setter(cx, obj, self, argv)) {
    return false;
  }
  *vp = JSVAL_VOID;
  return true;
}

static JSBool
_addProperty(JSContext* cx, JSHandleObject obj, JSHandleId id, JSMutableHandleValue vp)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::DOMSVGPathSegCurvetoQuadraticSmoothRel>::value), "Must be an nsISupports class");
  mozilla::DOMSVGPathSegCurvetoQuadraticSmoothRel* self = UnwrapDOMObject<mozilla::DOMSVGPathSegCurvetoQuadraticSmoothRel>(obj);
  nsContentUtils::PreserveWrapper(reinterpret_cast<nsISupports*>(self), self);
  return true;
}

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::DOMSVGPathSegCurvetoQuadraticSmoothRel>::value), "Must be an nsISupports class");
  mozilla::DOMSVGPathSegCurvetoQuadraticSmoothRel* self = UnwrapDOMObject<mozilla::DOMSVGPathSegCurvetoQuadraticSmoothRel>(obj);
  if (self) {
    ClearWrapper(self, self);
    XPCJSRuntime *rt = nsXPConnect::GetRuntimeInstance();
    if (rt) {
      rt->DeferredRelease(reinterpret_cast<nsISupports*>(self));
    } else {
      NS_RELEASE(self);
    }
  }
}

static JSPropertySpec sAttributes_specs[] = {
  { "x", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &x_getterinfo }, { (JSStrictPropertyOp)genericSetter, &x_setterinfo }},
  { "y", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &y_getterinfo }, { (JSStrictPropertyOp)genericSetter, &y_setterinfo }},
  { 0, 0, 0, JSOP_NULLWRAPPER, JSOP_NULLWRAPPER }
};

static Prefable<JSPropertySpec> sAttributes[] = {
  { true, &sAttributes_specs[0] },
  { false, NULL }
};

static jsid sAttributes_ids[3] = { JSID_VOID };


static const NativeProperties sNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sAttributes, sAttributes_ids, sAttributes_specs,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr
};
const NativePropertyHooks sNativePropertyHooks = {
  nullptr,
  nullptr,
  { &sNativeProperties, nullptr },
  prototypes::id::SVGPathSegCurvetoQuadraticSmoothRel,
  constructors::id::SVGPathSegCurvetoQuadraticSmoothRel,
  &SVGPathSegBinding::sNativePropertyHooks
};

JSNativeHolder _constructor_holder = {
  ThrowingConstructor,
  &sNativePropertyHooks
};

static DOMIfaceAndProtoJSClass PrototypeClass = {
  {
    "SVGPathSegCurvetoQuadraticSmoothRelPrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(2),
    JS_PropertyStub,       /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    nullptr,               /* finalize */
    nullptr,               /* checkAccess */
    nullptr,               /* call */
    nullptr,               /* hasInstance */
    nullptr,               /* construct */
    nullptr,               /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  eInterfacePrototype,
  &sNativePropertyHooks
};

void
CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray)
{
  JSObject* parentProto = SVGPathSegBinding::GetProtoObject(aCx, aGlobal);
  if (!parentProto) {
    return;
  }


  if (sAttributes_ids[0] == JSID_VOID &&
      !InitIds(aCx, sAttributes, sAttributes_ids)) {
    sAttributes_ids[0] = JSID_VOID;
    return;
  }

  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &PrototypeClass.mBase, &protoAndIfaceArray[prototypes::id::SVGPathSegCurvetoQuadraticSmoothRel],
                              nullptr, &_constructor_holder, 0, &protoAndIfaceArray[constructors::id::SVGPathSegCurvetoQuadraticSmoothRel],
                              &Class.mClass,
                              &sNativeProperties,
                              nullptr,
                              "SVGPathSegCurvetoQuadraticSmoothRel");
}

JSObject*
DefineDOMInterface(JSContext* aCx, JSObject* aGlobal, bool* aEnabled)
{

  *aEnabled = true;
  return GetConstructorObject(aCx, aGlobal);
}


DOMJSClass Class = {
  { "SVGPathSegCurvetoQuadraticSmoothRel",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(3),
    _addProperty, /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    _finalize, /* finalize */
    NULL,                  /* checkAccess */
    NULL,                  /* call */
    NULL,                  /* hasInstance */
    NULL,                  /* construct */
    NULL, /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  {
    { prototypes::id::SVGPathSeg, prototypes::id::SVGPathSegCurvetoQuadraticSmoothRel, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
    true,
    &sNativePropertyHooks,
    GetParentObject<mozilla::DOMSVGPathSegCurvetoQuadraticSmoothRel>::Get,
    GetProtoObject,
    nullptr
  }
};

JSObject*
Wrap(JSContext* aCx, JSObject* aScope, mozilla::DOMSVGPathSegCurvetoQuadraticSmoothRel* aObject, nsWrapperCache* aCache, bool* aTriedToWrap)
{
  MOZ_ASSERT(static_cast<mozilla::DOMSVGPathSegCurvetoQuadraticSmoothRel*>(aObject) ==
             reinterpret_cast<mozilla::DOMSVGPathSegCurvetoQuadraticSmoothRel*>(aObject));
  MOZ_ASSERT(static_cast<mozilla::DOMSVGPathSeg*>(aObject) ==
             reinterpret_cast<mozilla::DOMSVGPathSeg*>(aObject));

  *aTriedToWrap = true;

  JSObject* parent = WrapNativeParent(aCx, aScope, aObject->GetParentObject());
  if (!parent) {
    return NULL;
  }

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.  Scope so we don't
  // collide with the "obj" we declare in CreateBindingJSObject.
  {
    JSObject* obj = aCache->GetWrapper();
    if (obj) {
      return obj;
    }
  }

  JSAutoCompartment ac(aCx, parent);
  JSObject* global = JS_GetGlobalForObject(aCx, parent);

  JSObject* proto = GetProtoObject(aCx, global);
  if (!proto) {
    return NULL;
  }

  JSObject* obj = JS_NewObject(aCx, &Class.mBase, proto, parent);
  if (!obj) {
    return NULL;
  }

  js::SetReservedSlot(obj, DOM_OBJECT_SLOT, PRIVATE_TO_JSVAL(aObject));
  NS_ADDREF(aObject);


  aCache->SetWrapper(obj);

  return obj;
}

} // namespace SVGPathSegCurvetoQuadraticSmoothRelBinding



namespace SVGPathSegLinetoAbsBinding {

static bool
get_x(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegLinetoAbs* self, JS::Value* vp)
{
  float result;
  result = self->X();
  *vp = JS_NumberValue(double(result));
  return true;
}

static bool
set_x(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegLinetoAbs* self, JS::Value* argv)
{
  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[0], &arg0)) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg0)) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    ThrowErrorMessage(cx, MSG_NOT_FINITE);
    return false;
  }
  ErrorResult rv;
  self->SetX(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGPathSegLinetoAbs", "x");
  }

  return true;
}


const JSJitInfo x_getterinfo = {
  (JSJitPropertyOp)get_x,
  prototypes::id::SVGPathSegLinetoAbs,
  PrototypeTraits<prototypes::id::SVGPathSegLinetoAbs>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo x_setterinfo = {
  (JSJitPropertyOp)set_x,
  prototypes::id::SVGPathSegLinetoAbs,
  PrototypeTraits<prototypes::id::SVGPathSegLinetoAbs>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_y(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegLinetoAbs* self, JS::Value* vp)
{
  float result;
  result = self->Y();
  *vp = JS_NumberValue(double(result));
  return true;
}

static bool
set_y(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegLinetoAbs* self, JS::Value* argv)
{
  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[0], &arg0)) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg0)) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    ThrowErrorMessage(cx, MSG_NOT_FINITE);
    return false;
  }
  ErrorResult rv;
  self->SetY(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGPathSegLinetoAbs", "y");
  }

  return true;
}


const JSJitInfo y_getterinfo = {
  (JSJitPropertyOp)get_y,
  prototypes::id::SVGPathSegLinetoAbs,
  PrototypeTraits<prototypes::id::SVGPathSegLinetoAbs>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo y_setterinfo = {
  (JSJitPropertyOp)set_y,
  prototypes::id::SVGPathSegLinetoAbs,
  PrototypeTraits<prototypes::id::SVGPathSegLinetoAbs>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static JSBool
genericGetter(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  mozilla::DOMSVGPathSegLinetoAbs* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::SVGPathSegLinetoAbs, mozilla::DOMSVGPathSegLinetoAbs>(cx, obj, self);
    if (NS_FAILED(rv)) {
      return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "SVGPathSegLinetoAbs");
    }
  }
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Getter);
  JSJitPropertyOp getter = info->op;
  return getter(cx, obj, self, vp);
}

static JSBool
genericSetter(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  mozilla::DOMSVGPathSegLinetoAbs* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::SVGPathSegLinetoAbs, mozilla::DOMSVGPathSegLinetoAbs>(cx, obj, self);
    if (NS_FAILED(rv)) {
      return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "SVGPathSegLinetoAbs");
    }
  }
  if (argc == 0) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "SVGPathSegLinetoAbs attribute setter");
  }
  JS::Value* argv = JS_ARGV(cx, vp);
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Setter);
  JSJitPropertyOp setter = info->op;
  if (!setter(cx, obj, self, argv)) {
    return false;
  }
  *vp = JSVAL_VOID;
  return true;
}

static JSBool
_addProperty(JSContext* cx, JSHandleObject obj, JSHandleId id, JSMutableHandleValue vp)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::DOMSVGPathSegLinetoAbs>::value), "Must be an nsISupports class");
  mozilla::DOMSVGPathSegLinetoAbs* self = UnwrapDOMObject<mozilla::DOMSVGPathSegLinetoAbs>(obj);
  nsContentUtils::PreserveWrapper(reinterpret_cast<nsISupports*>(self), self);
  return true;
}

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::DOMSVGPathSegLinetoAbs>::value), "Must be an nsISupports class");
  mozilla::DOMSVGPathSegLinetoAbs* self = UnwrapDOMObject<mozilla::DOMSVGPathSegLinetoAbs>(obj);
  if (self) {
    ClearWrapper(self, self);
    XPCJSRuntime *rt = nsXPConnect::GetRuntimeInstance();
    if (rt) {
      rt->DeferredRelease(reinterpret_cast<nsISupports*>(self));
    } else {
      NS_RELEASE(self);
    }
  }
}

static JSPropertySpec sAttributes_specs[] = {
  { "x", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &x_getterinfo }, { (JSStrictPropertyOp)genericSetter, &x_setterinfo }},
  { "y", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &y_getterinfo }, { (JSStrictPropertyOp)genericSetter, &y_setterinfo }},
  { 0, 0, 0, JSOP_NULLWRAPPER, JSOP_NULLWRAPPER }
};

static Prefable<JSPropertySpec> sAttributes[] = {
  { true, &sAttributes_specs[0] },
  { false, NULL }
};

static jsid sAttributes_ids[3] = { JSID_VOID };


static const NativeProperties sNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sAttributes, sAttributes_ids, sAttributes_specs,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr
};
const NativePropertyHooks sNativePropertyHooks = {
  nullptr,
  nullptr,
  { &sNativeProperties, nullptr },
  prototypes::id::SVGPathSegLinetoAbs,
  constructors::id::SVGPathSegLinetoAbs,
  &SVGPathSegBinding::sNativePropertyHooks
};

JSNativeHolder _constructor_holder = {
  ThrowingConstructor,
  &sNativePropertyHooks
};

static DOMIfaceAndProtoJSClass PrototypeClass = {
  {
    "SVGPathSegLinetoAbsPrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(2),
    JS_PropertyStub,       /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    nullptr,               /* finalize */
    nullptr,               /* checkAccess */
    nullptr,               /* call */
    nullptr,               /* hasInstance */
    nullptr,               /* construct */
    nullptr,               /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  eInterfacePrototype,
  &sNativePropertyHooks
};

void
CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray)
{
  JSObject* parentProto = SVGPathSegBinding::GetProtoObject(aCx, aGlobal);
  if (!parentProto) {
    return;
  }


  if (sAttributes_ids[0] == JSID_VOID &&
      !InitIds(aCx, sAttributes, sAttributes_ids)) {
    sAttributes_ids[0] = JSID_VOID;
    return;
  }

  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &PrototypeClass.mBase, &protoAndIfaceArray[prototypes::id::SVGPathSegLinetoAbs],
                              nullptr, &_constructor_holder, 0, &protoAndIfaceArray[constructors::id::SVGPathSegLinetoAbs],
                              &Class.mClass,
                              &sNativeProperties,
                              nullptr,
                              "SVGPathSegLinetoAbs");
}

JSObject*
DefineDOMInterface(JSContext* aCx, JSObject* aGlobal, bool* aEnabled)
{

  *aEnabled = true;
  return GetConstructorObject(aCx, aGlobal);
}


DOMJSClass Class = {
  { "SVGPathSegLinetoAbs",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(3),
    _addProperty, /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    _finalize, /* finalize */
    NULL,                  /* checkAccess */
    NULL,                  /* call */
    NULL,                  /* hasInstance */
    NULL,                  /* construct */
    NULL, /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  {
    { prototypes::id::SVGPathSeg, prototypes::id::SVGPathSegLinetoAbs, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
    true,
    &sNativePropertyHooks,
    GetParentObject<mozilla::DOMSVGPathSegLinetoAbs>::Get,
    GetProtoObject,
    nullptr
  }
};

JSObject*
Wrap(JSContext* aCx, JSObject* aScope, mozilla::DOMSVGPathSegLinetoAbs* aObject, nsWrapperCache* aCache, bool* aTriedToWrap)
{
  MOZ_ASSERT(static_cast<mozilla::DOMSVGPathSegLinetoAbs*>(aObject) ==
             reinterpret_cast<mozilla::DOMSVGPathSegLinetoAbs*>(aObject));
  MOZ_ASSERT(static_cast<mozilla::DOMSVGPathSeg*>(aObject) ==
             reinterpret_cast<mozilla::DOMSVGPathSeg*>(aObject));

  *aTriedToWrap = true;

  JSObject* parent = WrapNativeParent(aCx, aScope, aObject->GetParentObject());
  if (!parent) {
    return NULL;
  }

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.  Scope so we don't
  // collide with the "obj" we declare in CreateBindingJSObject.
  {
    JSObject* obj = aCache->GetWrapper();
    if (obj) {
      return obj;
    }
  }

  JSAutoCompartment ac(aCx, parent);
  JSObject* global = JS_GetGlobalForObject(aCx, parent);

  JSObject* proto = GetProtoObject(aCx, global);
  if (!proto) {
    return NULL;
  }

  JSObject* obj = JS_NewObject(aCx, &Class.mBase, proto, parent);
  if (!obj) {
    return NULL;
  }

  js::SetReservedSlot(obj, DOM_OBJECT_SLOT, PRIVATE_TO_JSVAL(aObject));
  NS_ADDREF(aObject);


  aCache->SetWrapper(obj);

  return obj;
}

} // namespace SVGPathSegLinetoAbsBinding



namespace SVGPathSegLinetoHorizontalAbsBinding {

static bool
get_x(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegLinetoHorizontalAbs* self, JS::Value* vp)
{
  float result;
  result = self->X();
  *vp = JS_NumberValue(double(result));
  return true;
}

static bool
set_x(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegLinetoHorizontalAbs* self, JS::Value* argv)
{
  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[0], &arg0)) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg0)) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    ThrowErrorMessage(cx, MSG_NOT_FINITE);
    return false;
  }
  ErrorResult rv;
  self->SetX(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGPathSegLinetoHorizontalAbs", "x");
  }

  return true;
}


const JSJitInfo x_getterinfo = {
  (JSJitPropertyOp)get_x,
  prototypes::id::SVGPathSegLinetoHorizontalAbs,
  PrototypeTraits<prototypes::id::SVGPathSegLinetoHorizontalAbs>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo x_setterinfo = {
  (JSJitPropertyOp)set_x,
  prototypes::id::SVGPathSegLinetoHorizontalAbs,
  PrototypeTraits<prototypes::id::SVGPathSegLinetoHorizontalAbs>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static JSBool
genericGetter(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  mozilla::DOMSVGPathSegLinetoHorizontalAbs* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::SVGPathSegLinetoHorizontalAbs, mozilla::DOMSVGPathSegLinetoHorizontalAbs>(cx, obj, self);
    if (NS_FAILED(rv)) {
      return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "SVGPathSegLinetoHorizontalAbs");
    }
  }
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Getter);
  JSJitPropertyOp getter = info->op;
  return getter(cx, obj, self, vp);
}

static JSBool
genericSetter(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  mozilla::DOMSVGPathSegLinetoHorizontalAbs* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::SVGPathSegLinetoHorizontalAbs, mozilla::DOMSVGPathSegLinetoHorizontalAbs>(cx, obj, self);
    if (NS_FAILED(rv)) {
      return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "SVGPathSegLinetoHorizontalAbs");
    }
  }
  if (argc == 0) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "SVGPathSegLinetoHorizontalAbs attribute setter");
  }
  JS::Value* argv = JS_ARGV(cx, vp);
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Setter);
  JSJitPropertyOp setter = info->op;
  if (!setter(cx, obj, self, argv)) {
    return false;
  }
  *vp = JSVAL_VOID;
  return true;
}

static JSBool
_addProperty(JSContext* cx, JSHandleObject obj, JSHandleId id, JSMutableHandleValue vp)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::DOMSVGPathSegLinetoHorizontalAbs>::value), "Must be an nsISupports class");
  mozilla::DOMSVGPathSegLinetoHorizontalAbs* self = UnwrapDOMObject<mozilla::DOMSVGPathSegLinetoHorizontalAbs>(obj);
  nsContentUtils::PreserveWrapper(reinterpret_cast<nsISupports*>(self), self);
  return true;
}

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::DOMSVGPathSegLinetoHorizontalAbs>::value), "Must be an nsISupports class");
  mozilla::DOMSVGPathSegLinetoHorizontalAbs* self = UnwrapDOMObject<mozilla::DOMSVGPathSegLinetoHorizontalAbs>(obj);
  if (self) {
    ClearWrapper(self, self);
    XPCJSRuntime *rt = nsXPConnect::GetRuntimeInstance();
    if (rt) {
      rt->DeferredRelease(reinterpret_cast<nsISupports*>(self));
    } else {
      NS_RELEASE(self);
    }
  }
}

static JSPropertySpec sAttributes_specs[] = {
  { "x", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &x_getterinfo }, { (JSStrictPropertyOp)genericSetter, &x_setterinfo }},
  { 0, 0, 0, JSOP_NULLWRAPPER, JSOP_NULLWRAPPER }
};

static Prefable<JSPropertySpec> sAttributes[] = {
  { true, &sAttributes_specs[0] },
  { false, NULL }
};

static jsid sAttributes_ids[2] = { JSID_VOID };


static const NativeProperties sNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sAttributes, sAttributes_ids, sAttributes_specs,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr
};
const NativePropertyHooks sNativePropertyHooks = {
  nullptr,
  nullptr,
  { &sNativeProperties, nullptr },
  prototypes::id::SVGPathSegLinetoHorizontalAbs,
  constructors::id::SVGPathSegLinetoHorizontalAbs,
  &SVGPathSegBinding::sNativePropertyHooks
};

JSNativeHolder _constructor_holder = {
  ThrowingConstructor,
  &sNativePropertyHooks
};

static DOMIfaceAndProtoJSClass PrototypeClass = {
  {
    "SVGPathSegLinetoHorizontalAbsPrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(2),
    JS_PropertyStub,       /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    nullptr,               /* finalize */
    nullptr,               /* checkAccess */
    nullptr,               /* call */
    nullptr,               /* hasInstance */
    nullptr,               /* construct */
    nullptr,               /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  eInterfacePrototype,
  &sNativePropertyHooks
};

void
CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray)
{
  JSObject* parentProto = SVGPathSegBinding::GetProtoObject(aCx, aGlobal);
  if (!parentProto) {
    return;
  }


  if (sAttributes_ids[0] == JSID_VOID &&
      !InitIds(aCx, sAttributes, sAttributes_ids)) {
    sAttributes_ids[0] = JSID_VOID;
    return;
  }

  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &PrototypeClass.mBase, &protoAndIfaceArray[prototypes::id::SVGPathSegLinetoHorizontalAbs],
                              nullptr, &_constructor_holder, 0, &protoAndIfaceArray[constructors::id::SVGPathSegLinetoHorizontalAbs],
                              &Class.mClass,
                              &sNativeProperties,
                              nullptr,
                              "SVGPathSegLinetoHorizontalAbs");
}

JSObject*
DefineDOMInterface(JSContext* aCx, JSObject* aGlobal, bool* aEnabled)
{

  *aEnabled = true;
  return GetConstructorObject(aCx, aGlobal);
}


DOMJSClass Class = {
  { "SVGPathSegLinetoHorizontalAbs",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(3),
    _addProperty, /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    _finalize, /* finalize */
    NULL,                  /* checkAccess */
    NULL,                  /* call */
    NULL,                  /* hasInstance */
    NULL,                  /* construct */
    NULL, /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  {
    { prototypes::id::SVGPathSeg, prototypes::id::SVGPathSegLinetoHorizontalAbs, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
    true,
    &sNativePropertyHooks,
    GetParentObject<mozilla::DOMSVGPathSegLinetoHorizontalAbs>::Get,
    GetProtoObject,
    nullptr
  }
};

JSObject*
Wrap(JSContext* aCx, JSObject* aScope, mozilla::DOMSVGPathSegLinetoHorizontalAbs* aObject, nsWrapperCache* aCache, bool* aTriedToWrap)
{
  MOZ_ASSERT(static_cast<mozilla::DOMSVGPathSegLinetoHorizontalAbs*>(aObject) ==
             reinterpret_cast<mozilla::DOMSVGPathSegLinetoHorizontalAbs*>(aObject));
  MOZ_ASSERT(static_cast<mozilla::DOMSVGPathSeg*>(aObject) ==
             reinterpret_cast<mozilla::DOMSVGPathSeg*>(aObject));

  *aTriedToWrap = true;

  JSObject* parent = WrapNativeParent(aCx, aScope, aObject->GetParentObject());
  if (!parent) {
    return NULL;
  }

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.  Scope so we don't
  // collide with the "obj" we declare in CreateBindingJSObject.
  {
    JSObject* obj = aCache->GetWrapper();
    if (obj) {
      return obj;
    }
  }

  JSAutoCompartment ac(aCx, parent);
  JSObject* global = JS_GetGlobalForObject(aCx, parent);

  JSObject* proto = GetProtoObject(aCx, global);
  if (!proto) {
    return NULL;
  }

  JSObject* obj = JS_NewObject(aCx, &Class.mBase, proto, parent);
  if (!obj) {
    return NULL;
  }

  js::SetReservedSlot(obj, DOM_OBJECT_SLOT, PRIVATE_TO_JSVAL(aObject));
  NS_ADDREF(aObject);


  aCache->SetWrapper(obj);

  return obj;
}

} // namespace SVGPathSegLinetoHorizontalAbsBinding



namespace SVGPathSegLinetoHorizontalRelBinding {

static bool
get_x(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegLinetoHorizontalRel* self, JS::Value* vp)
{
  float result;
  result = self->X();
  *vp = JS_NumberValue(double(result));
  return true;
}

static bool
set_x(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegLinetoHorizontalRel* self, JS::Value* argv)
{
  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[0], &arg0)) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg0)) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    ThrowErrorMessage(cx, MSG_NOT_FINITE);
    return false;
  }
  ErrorResult rv;
  self->SetX(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGPathSegLinetoHorizontalRel", "x");
  }

  return true;
}


const JSJitInfo x_getterinfo = {
  (JSJitPropertyOp)get_x,
  prototypes::id::SVGPathSegLinetoHorizontalRel,
  PrototypeTraits<prototypes::id::SVGPathSegLinetoHorizontalRel>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo x_setterinfo = {
  (JSJitPropertyOp)set_x,
  prototypes::id::SVGPathSegLinetoHorizontalRel,
  PrototypeTraits<prototypes::id::SVGPathSegLinetoHorizontalRel>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static JSBool
genericGetter(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  mozilla::DOMSVGPathSegLinetoHorizontalRel* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::SVGPathSegLinetoHorizontalRel, mozilla::DOMSVGPathSegLinetoHorizontalRel>(cx, obj, self);
    if (NS_FAILED(rv)) {
      return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "SVGPathSegLinetoHorizontalRel");
    }
  }
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Getter);
  JSJitPropertyOp getter = info->op;
  return getter(cx, obj, self, vp);
}

static JSBool
genericSetter(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  mozilla::DOMSVGPathSegLinetoHorizontalRel* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::SVGPathSegLinetoHorizontalRel, mozilla::DOMSVGPathSegLinetoHorizontalRel>(cx, obj, self);
    if (NS_FAILED(rv)) {
      return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "SVGPathSegLinetoHorizontalRel");
    }
  }
  if (argc == 0) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "SVGPathSegLinetoHorizontalRel attribute setter");
  }
  JS::Value* argv = JS_ARGV(cx, vp);
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Setter);
  JSJitPropertyOp setter = info->op;
  if (!setter(cx, obj, self, argv)) {
    return false;
  }
  *vp = JSVAL_VOID;
  return true;
}

static JSBool
_addProperty(JSContext* cx, JSHandleObject obj, JSHandleId id, JSMutableHandleValue vp)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::DOMSVGPathSegLinetoHorizontalRel>::value), "Must be an nsISupports class");
  mozilla::DOMSVGPathSegLinetoHorizontalRel* self = UnwrapDOMObject<mozilla::DOMSVGPathSegLinetoHorizontalRel>(obj);
  nsContentUtils::PreserveWrapper(reinterpret_cast<nsISupports*>(self), self);
  return true;
}

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::DOMSVGPathSegLinetoHorizontalRel>::value), "Must be an nsISupports class");
  mozilla::DOMSVGPathSegLinetoHorizontalRel* self = UnwrapDOMObject<mozilla::DOMSVGPathSegLinetoHorizontalRel>(obj);
  if (self) {
    ClearWrapper(self, self);
    XPCJSRuntime *rt = nsXPConnect::GetRuntimeInstance();
    if (rt) {
      rt->DeferredRelease(reinterpret_cast<nsISupports*>(self));
    } else {
      NS_RELEASE(self);
    }
  }
}

static JSPropertySpec sAttributes_specs[] = {
  { "x", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &x_getterinfo }, { (JSStrictPropertyOp)genericSetter, &x_setterinfo }},
  { 0, 0, 0, JSOP_NULLWRAPPER, JSOP_NULLWRAPPER }
};

static Prefable<JSPropertySpec> sAttributes[] = {
  { true, &sAttributes_specs[0] },
  { false, NULL }
};

static jsid sAttributes_ids[2] = { JSID_VOID };


static const NativeProperties sNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sAttributes, sAttributes_ids, sAttributes_specs,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr
};
const NativePropertyHooks sNativePropertyHooks = {
  nullptr,
  nullptr,
  { &sNativeProperties, nullptr },
  prototypes::id::SVGPathSegLinetoHorizontalRel,
  constructors::id::SVGPathSegLinetoHorizontalRel,
  &SVGPathSegBinding::sNativePropertyHooks
};

JSNativeHolder _constructor_holder = {
  ThrowingConstructor,
  &sNativePropertyHooks
};

static DOMIfaceAndProtoJSClass PrototypeClass = {
  {
    "SVGPathSegLinetoHorizontalRelPrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(2),
    JS_PropertyStub,       /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    nullptr,               /* finalize */
    nullptr,               /* checkAccess */
    nullptr,               /* call */
    nullptr,               /* hasInstance */
    nullptr,               /* construct */
    nullptr,               /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  eInterfacePrototype,
  &sNativePropertyHooks
};

void
CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray)
{
  JSObject* parentProto = SVGPathSegBinding::GetProtoObject(aCx, aGlobal);
  if (!parentProto) {
    return;
  }


  if (sAttributes_ids[0] == JSID_VOID &&
      !InitIds(aCx, sAttributes, sAttributes_ids)) {
    sAttributes_ids[0] = JSID_VOID;
    return;
  }

  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &PrototypeClass.mBase, &protoAndIfaceArray[prototypes::id::SVGPathSegLinetoHorizontalRel],
                              nullptr, &_constructor_holder, 0, &protoAndIfaceArray[constructors::id::SVGPathSegLinetoHorizontalRel],
                              &Class.mClass,
                              &sNativeProperties,
                              nullptr,
                              "SVGPathSegLinetoHorizontalRel");
}

JSObject*
DefineDOMInterface(JSContext* aCx, JSObject* aGlobal, bool* aEnabled)
{

  *aEnabled = true;
  return GetConstructorObject(aCx, aGlobal);
}


DOMJSClass Class = {
  { "SVGPathSegLinetoHorizontalRel",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(3),
    _addProperty, /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    _finalize, /* finalize */
    NULL,                  /* checkAccess */
    NULL,                  /* call */
    NULL,                  /* hasInstance */
    NULL,                  /* construct */
    NULL, /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  {
    { prototypes::id::SVGPathSeg, prototypes::id::SVGPathSegLinetoHorizontalRel, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
    true,
    &sNativePropertyHooks,
    GetParentObject<mozilla::DOMSVGPathSegLinetoHorizontalRel>::Get,
    GetProtoObject,
    nullptr
  }
};

JSObject*
Wrap(JSContext* aCx, JSObject* aScope, mozilla::DOMSVGPathSegLinetoHorizontalRel* aObject, nsWrapperCache* aCache, bool* aTriedToWrap)
{
  MOZ_ASSERT(static_cast<mozilla::DOMSVGPathSegLinetoHorizontalRel*>(aObject) ==
             reinterpret_cast<mozilla::DOMSVGPathSegLinetoHorizontalRel*>(aObject));
  MOZ_ASSERT(static_cast<mozilla::DOMSVGPathSeg*>(aObject) ==
             reinterpret_cast<mozilla::DOMSVGPathSeg*>(aObject));

  *aTriedToWrap = true;

  JSObject* parent = WrapNativeParent(aCx, aScope, aObject->GetParentObject());
  if (!parent) {
    return NULL;
  }

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.  Scope so we don't
  // collide with the "obj" we declare in CreateBindingJSObject.
  {
    JSObject* obj = aCache->GetWrapper();
    if (obj) {
      return obj;
    }
  }

  JSAutoCompartment ac(aCx, parent);
  JSObject* global = JS_GetGlobalForObject(aCx, parent);

  JSObject* proto = GetProtoObject(aCx, global);
  if (!proto) {
    return NULL;
  }

  JSObject* obj = JS_NewObject(aCx, &Class.mBase, proto, parent);
  if (!obj) {
    return NULL;
  }

  js::SetReservedSlot(obj, DOM_OBJECT_SLOT, PRIVATE_TO_JSVAL(aObject));
  NS_ADDREF(aObject);


  aCache->SetWrapper(obj);

  return obj;
}

} // namespace SVGPathSegLinetoHorizontalRelBinding



namespace SVGPathSegLinetoRelBinding {

static bool
get_x(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegLinetoRel* self, JS::Value* vp)
{
  float result;
  result = self->X();
  *vp = JS_NumberValue(double(result));
  return true;
}

static bool
set_x(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegLinetoRel* self, JS::Value* argv)
{
  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[0], &arg0)) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg0)) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    ThrowErrorMessage(cx, MSG_NOT_FINITE);
    return false;
  }
  ErrorResult rv;
  self->SetX(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGPathSegLinetoRel", "x");
  }

  return true;
}


const JSJitInfo x_getterinfo = {
  (JSJitPropertyOp)get_x,
  prototypes::id::SVGPathSegLinetoRel,
  PrototypeTraits<prototypes::id::SVGPathSegLinetoRel>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo x_setterinfo = {
  (JSJitPropertyOp)set_x,
  prototypes::id::SVGPathSegLinetoRel,
  PrototypeTraits<prototypes::id::SVGPathSegLinetoRel>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_y(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegLinetoRel* self, JS::Value* vp)
{
  float result;
  result = self->Y();
  *vp = JS_NumberValue(double(result));
  return true;
}

static bool
set_y(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegLinetoRel* self, JS::Value* argv)
{
  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[0], &arg0)) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg0)) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    ThrowErrorMessage(cx, MSG_NOT_FINITE);
    return false;
  }
  ErrorResult rv;
  self->SetY(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGPathSegLinetoRel", "y");
  }

  return true;
}


const JSJitInfo y_getterinfo = {
  (JSJitPropertyOp)get_y,
  prototypes::id::SVGPathSegLinetoRel,
  PrototypeTraits<prototypes::id::SVGPathSegLinetoRel>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo y_setterinfo = {
  (JSJitPropertyOp)set_y,
  prototypes::id::SVGPathSegLinetoRel,
  PrototypeTraits<prototypes::id::SVGPathSegLinetoRel>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static JSBool
genericGetter(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  mozilla::DOMSVGPathSegLinetoRel* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::SVGPathSegLinetoRel, mozilla::DOMSVGPathSegLinetoRel>(cx, obj, self);
    if (NS_FAILED(rv)) {
      return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "SVGPathSegLinetoRel");
    }
  }
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Getter);
  JSJitPropertyOp getter = info->op;
  return getter(cx, obj, self, vp);
}

static JSBool
genericSetter(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  mozilla::DOMSVGPathSegLinetoRel* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::SVGPathSegLinetoRel, mozilla::DOMSVGPathSegLinetoRel>(cx, obj, self);
    if (NS_FAILED(rv)) {
      return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "SVGPathSegLinetoRel");
    }
  }
  if (argc == 0) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "SVGPathSegLinetoRel attribute setter");
  }
  JS::Value* argv = JS_ARGV(cx, vp);
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Setter);
  JSJitPropertyOp setter = info->op;
  if (!setter(cx, obj, self, argv)) {
    return false;
  }
  *vp = JSVAL_VOID;
  return true;
}

static JSBool
_addProperty(JSContext* cx, JSHandleObject obj, JSHandleId id, JSMutableHandleValue vp)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::DOMSVGPathSegLinetoRel>::value), "Must be an nsISupports class");
  mozilla::DOMSVGPathSegLinetoRel* self = UnwrapDOMObject<mozilla::DOMSVGPathSegLinetoRel>(obj);
  nsContentUtils::PreserveWrapper(reinterpret_cast<nsISupports*>(self), self);
  return true;
}

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::DOMSVGPathSegLinetoRel>::value), "Must be an nsISupports class");
  mozilla::DOMSVGPathSegLinetoRel* self = UnwrapDOMObject<mozilla::DOMSVGPathSegLinetoRel>(obj);
  if (self) {
    ClearWrapper(self, self);
    XPCJSRuntime *rt = nsXPConnect::GetRuntimeInstance();
    if (rt) {
      rt->DeferredRelease(reinterpret_cast<nsISupports*>(self));
    } else {
      NS_RELEASE(self);
    }
  }
}

static JSPropertySpec sAttributes_specs[] = {
  { "x", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &x_getterinfo }, { (JSStrictPropertyOp)genericSetter, &x_setterinfo }},
  { "y", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &y_getterinfo }, { (JSStrictPropertyOp)genericSetter, &y_setterinfo }},
  { 0, 0, 0, JSOP_NULLWRAPPER, JSOP_NULLWRAPPER }
};

static Prefable<JSPropertySpec> sAttributes[] = {
  { true, &sAttributes_specs[0] },
  { false, NULL }
};

static jsid sAttributes_ids[3] = { JSID_VOID };


static const NativeProperties sNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sAttributes, sAttributes_ids, sAttributes_specs,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr
};
const NativePropertyHooks sNativePropertyHooks = {
  nullptr,
  nullptr,
  { &sNativeProperties, nullptr },
  prototypes::id::SVGPathSegLinetoRel,
  constructors::id::SVGPathSegLinetoRel,
  &SVGPathSegBinding::sNativePropertyHooks
};

JSNativeHolder _constructor_holder = {
  ThrowingConstructor,
  &sNativePropertyHooks
};

static DOMIfaceAndProtoJSClass PrototypeClass = {
  {
    "SVGPathSegLinetoRelPrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(2),
    JS_PropertyStub,       /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    nullptr,               /* finalize */
    nullptr,               /* checkAccess */
    nullptr,               /* call */
    nullptr,               /* hasInstance */
    nullptr,               /* construct */
    nullptr,               /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  eInterfacePrototype,
  &sNativePropertyHooks
};

void
CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray)
{
  JSObject* parentProto = SVGPathSegBinding::GetProtoObject(aCx, aGlobal);
  if (!parentProto) {
    return;
  }


  if (sAttributes_ids[0] == JSID_VOID &&
      !InitIds(aCx, sAttributes, sAttributes_ids)) {
    sAttributes_ids[0] = JSID_VOID;
    return;
  }

  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &PrototypeClass.mBase, &protoAndIfaceArray[prototypes::id::SVGPathSegLinetoRel],
                              nullptr, &_constructor_holder, 0, &protoAndIfaceArray[constructors::id::SVGPathSegLinetoRel],
                              &Class.mClass,
                              &sNativeProperties,
                              nullptr,
                              "SVGPathSegLinetoRel");
}

JSObject*
DefineDOMInterface(JSContext* aCx, JSObject* aGlobal, bool* aEnabled)
{

  *aEnabled = true;
  return GetConstructorObject(aCx, aGlobal);
}


DOMJSClass Class = {
  { "SVGPathSegLinetoRel",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(3),
    _addProperty, /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    _finalize, /* finalize */
    NULL,                  /* checkAccess */
    NULL,                  /* call */
    NULL,                  /* hasInstance */
    NULL,                  /* construct */
    NULL, /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  {
    { prototypes::id::SVGPathSeg, prototypes::id::SVGPathSegLinetoRel, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
    true,
    &sNativePropertyHooks,
    GetParentObject<mozilla::DOMSVGPathSegLinetoRel>::Get,
    GetProtoObject,
    nullptr
  }
};

JSObject*
Wrap(JSContext* aCx, JSObject* aScope, mozilla::DOMSVGPathSegLinetoRel* aObject, nsWrapperCache* aCache, bool* aTriedToWrap)
{
  MOZ_ASSERT(static_cast<mozilla::DOMSVGPathSegLinetoRel*>(aObject) ==
             reinterpret_cast<mozilla::DOMSVGPathSegLinetoRel*>(aObject));
  MOZ_ASSERT(static_cast<mozilla::DOMSVGPathSeg*>(aObject) ==
             reinterpret_cast<mozilla::DOMSVGPathSeg*>(aObject));

  *aTriedToWrap = true;

  JSObject* parent = WrapNativeParent(aCx, aScope, aObject->GetParentObject());
  if (!parent) {
    return NULL;
  }

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.  Scope so we don't
  // collide with the "obj" we declare in CreateBindingJSObject.
  {
    JSObject* obj = aCache->GetWrapper();
    if (obj) {
      return obj;
    }
  }

  JSAutoCompartment ac(aCx, parent);
  JSObject* global = JS_GetGlobalForObject(aCx, parent);

  JSObject* proto = GetProtoObject(aCx, global);
  if (!proto) {
    return NULL;
  }

  JSObject* obj = JS_NewObject(aCx, &Class.mBase, proto, parent);
  if (!obj) {
    return NULL;
  }

  js::SetReservedSlot(obj, DOM_OBJECT_SLOT, PRIVATE_TO_JSVAL(aObject));
  NS_ADDREF(aObject);


  aCache->SetWrapper(obj);

  return obj;
}

} // namespace SVGPathSegLinetoRelBinding



namespace SVGPathSegLinetoVerticalAbsBinding {

static bool
get_y(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegLinetoVerticalAbs* self, JS::Value* vp)
{
  float result;
  result = self->Y();
  *vp = JS_NumberValue(double(result));
  return true;
}

static bool
set_y(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegLinetoVerticalAbs* self, JS::Value* argv)
{
  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[0], &arg0)) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg0)) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    ThrowErrorMessage(cx, MSG_NOT_FINITE);
    return false;
  }
  ErrorResult rv;
  self->SetY(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGPathSegLinetoVerticalAbs", "y");
  }

  return true;
}


const JSJitInfo y_getterinfo = {
  (JSJitPropertyOp)get_y,
  prototypes::id::SVGPathSegLinetoVerticalAbs,
  PrototypeTraits<prototypes::id::SVGPathSegLinetoVerticalAbs>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo y_setterinfo = {
  (JSJitPropertyOp)set_y,
  prototypes::id::SVGPathSegLinetoVerticalAbs,
  PrototypeTraits<prototypes::id::SVGPathSegLinetoVerticalAbs>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static JSBool
genericGetter(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  mozilla::DOMSVGPathSegLinetoVerticalAbs* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::SVGPathSegLinetoVerticalAbs, mozilla::DOMSVGPathSegLinetoVerticalAbs>(cx, obj, self);
    if (NS_FAILED(rv)) {
      return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "SVGPathSegLinetoVerticalAbs");
    }
  }
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Getter);
  JSJitPropertyOp getter = info->op;
  return getter(cx, obj, self, vp);
}

static JSBool
genericSetter(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  mozilla::DOMSVGPathSegLinetoVerticalAbs* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::SVGPathSegLinetoVerticalAbs, mozilla::DOMSVGPathSegLinetoVerticalAbs>(cx, obj, self);
    if (NS_FAILED(rv)) {
      return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "SVGPathSegLinetoVerticalAbs");
    }
  }
  if (argc == 0) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "SVGPathSegLinetoVerticalAbs attribute setter");
  }
  JS::Value* argv = JS_ARGV(cx, vp);
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Setter);
  JSJitPropertyOp setter = info->op;
  if (!setter(cx, obj, self, argv)) {
    return false;
  }
  *vp = JSVAL_VOID;
  return true;
}

static JSBool
_addProperty(JSContext* cx, JSHandleObject obj, JSHandleId id, JSMutableHandleValue vp)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::DOMSVGPathSegLinetoVerticalAbs>::value), "Must be an nsISupports class");
  mozilla::DOMSVGPathSegLinetoVerticalAbs* self = UnwrapDOMObject<mozilla::DOMSVGPathSegLinetoVerticalAbs>(obj);
  nsContentUtils::PreserveWrapper(reinterpret_cast<nsISupports*>(self), self);
  return true;
}

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::DOMSVGPathSegLinetoVerticalAbs>::value), "Must be an nsISupports class");
  mozilla::DOMSVGPathSegLinetoVerticalAbs* self = UnwrapDOMObject<mozilla::DOMSVGPathSegLinetoVerticalAbs>(obj);
  if (self) {
    ClearWrapper(self, self);
    XPCJSRuntime *rt = nsXPConnect::GetRuntimeInstance();
    if (rt) {
      rt->DeferredRelease(reinterpret_cast<nsISupports*>(self));
    } else {
      NS_RELEASE(self);
    }
  }
}

static JSPropertySpec sAttributes_specs[] = {
  { "y", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &y_getterinfo }, { (JSStrictPropertyOp)genericSetter, &y_setterinfo }},
  { 0, 0, 0, JSOP_NULLWRAPPER, JSOP_NULLWRAPPER }
};

static Prefable<JSPropertySpec> sAttributes[] = {
  { true, &sAttributes_specs[0] },
  { false, NULL }
};

static jsid sAttributes_ids[2] = { JSID_VOID };


static const NativeProperties sNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sAttributes, sAttributes_ids, sAttributes_specs,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr
};
const NativePropertyHooks sNativePropertyHooks = {
  nullptr,
  nullptr,
  { &sNativeProperties, nullptr },
  prototypes::id::SVGPathSegLinetoVerticalAbs,
  constructors::id::SVGPathSegLinetoVerticalAbs,
  &SVGPathSegBinding::sNativePropertyHooks
};

JSNativeHolder _constructor_holder = {
  ThrowingConstructor,
  &sNativePropertyHooks
};

static DOMIfaceAndProtoJSClass PrototypeClass = {
  {
    "SVGPathSegLinetoVerticalAbsPrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(2),
    JS_PropertyStub,       /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    nullptr,               /* finalize */
    nullptr,               /* checkAccess */
    nullptr,               /* call */
    nullptr,               /* hasInstance */
    nullptr,               /* construct */
    nullptr,               /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  eInterfacePrototype,
  &sNativePropertyHooks
};

void
CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray)
{
  JSObject* parentProto = SVGPathSegBinding::GetProtoObject(aCx, aGlobal);
  if (!parentProto) {
    return;
  }


  if (sAttributes_ids[0] == JSID_VOID &&
      !InitIds(aCx, sAttributes, sAttributes_ids)) {
    sAttributes_ids[0] = JSID_VOID;
    return;
  }

  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &PrototypeClass.mBase, &protoAndIfaceArray[prototypes::id::SVGPathSegLinetoVerticalAbs],
                              nullptr, &_constructor_holder, 0, &protoAndIfaceArray[constructors::id::SVGPathSegLinetoVerticalAbs],
                              &Class.mClass,
                              &sNativeProperties,
                              nullptr,
                              "SVGPathSegLinetoVerticalAbs");
}

JSObject*
DefineDOMInterface(JSContext* aCx, JSObject* aGlobal, bool* aEnabled)
{

  *aEnabled = true;
  return GetConstructorObject(aCx, aGlobal);
}


DOMJSClass Class = {
  { "SVGPathSegLinetoVerticalAbs",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(3),
    _addProperty, /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    _finalize, /* finalize */
    NULL,                  /* checkAccess */
    NULL,                  /* call */
    NULL,                  /* hasInstance */
    NULL,                  /* construct */
    NULL, /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  {
    { prototypes::id::SVGPathSeg, prototypes::id::SVGPathSegLinetoVerticalAbs, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
    true,
    &sNativePropertyHooks,
    GetParentObject<mozilla::DOMSVGPathSegLinetoVerticalAbs>::Get,
    GetProtoObject,
    nullptr
  }
};

JSObject*
Wrap(JSContext* aCx, JSObject* aScope, mozilla::DOMSVGPathSegLinetoVerticalAbs* aObject, nsWrapperCache* aCache, bool* aTriedToWrap)
{
  MOZ_ASSERT(static_cast<mozilla::DOMSVGPathSegLinetoVerticalAbs*>(aObject) ==
             reinterpret_cast<mozilla::DOMSVGPathSegLinetoVerticalAbs*>(aObject));
  MOZ_ASSERT(static_cast<mozilla::DOMSVGPathSeg*>(aObject) ==
             reinterpret_cast<mozilla::DOMSVGPathSeg*>(aObject));

  *aTriedToWrap = true;

  JSObject* parent = WrapNativeParent(aCx, aScope, aObject->GetParentObject());
  if (!parent) {
    return NULL;
  }

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.  Scope so we don't
  // collide with the "obj" we declare in CreateBindingJSObject.
  {
    JSObject* obj = aCache->GetWrapper();
    if (obj) {
      return obj;
    }
  }

  JSAutoCompartment ac(aCx, parent);
  JSObject* global = JS_GetGlobalForObject(aCx, parent);

  JSObject* proto = GetProtoObject(aCx, global);
  if (!proto) {
    return NULL;
  }

  JSObject* obj = JS_NewObject(aCx, &Class.mBase, proto, parent);
  if (!obj) {
    return NULL;
  }

  js::SetReservedSlot(obj, DOM_OBJECT_SLOT, PRIVATE_TO_JSVAL(aObject));
  NS_ADDREF(aObject);


  aCache->SetWrapper(obj);

  return obj;
}

} // namespace SVGPathSegLinetoVerticalAbsBinding



namespace SVGPathSegLinetoVerticalRelBinding {

static bool
get_y(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegLinetoVerticalRel* self, JS::Value* vp)
{
  float result;
  result = self->Y();
  *vp = JS_NumberValue(double(result));
  return true;
}

static bool
set_y(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegLinetoVerticalRel* self, JS::Value* argv)
{
  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[0], &arg0)) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg0)) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    ThrowErrorMessage(cx, MSG_NOT_FINITE);
    return false;
  }
  ErrorResult rv;
  self->SetY(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGPathSegLinetoVerticalRel", "y");
  }

  return true;
}


const JSJitInfo y_getterinfo = {
  (JSJitPropertyOp)get_y,
  prototypes::id::SVGPathSegLinetoVerticalRel,
  PrototypeTraits<prototypes::id::SVGPathSegLinetoVerticalRel>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo y_setterinfo = {
  (JSJitPropertyOp)set_y,
  prototypes::id::SVGPathSegLinetoVerticalRel,
  PrototypeTraits<prototypes::id::SVGPathSegLinetoVerticalRel>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static JSBool
genericGetter(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  mozilla::DOMSVGPathSegLinetoVerticalRel* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::SVGPathSegLinetoVerticalRel, mozilla::DOMSVGPathSegLinetoVerticalRel>(cx, obj, self);
    if (NS_FAILED(rv)) {
      return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "SVGPathSegLinetoVerticalRel");
    }
  }
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Getter);
  JSJitPropertyOp getter = info->op;
  return getter(cx, obj, self, vp);
}

static JSBool
genericSetter(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  mozilla::DOMSVGPathSegLinetoVerticalRel* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::SVGPathSegLinetoVerticalRel, mozilla::DOMSVGPathSegLinetoVerticalRel>(cx, obj, self);
    if (NS_FAILED(rv)) {
      return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "SVGPathSegLinetoVerticalRel");
    }
  }
  if (argc == 0) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "SVGPathSegLinetoVerticalRel attribute setter");
  }
  JS::Value* argv = JS_ARGV(cx, vp);
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Setter);
  JSJitPropertyOp setter = info->op;
  if (!setter(cx, obj, self, argv)) {
    return false;
  }
  *vp = JSVAL_VOID;
  return true;
}

static JSBool
_addProperty(JSContext* cx, JSHandleObject obj, JSHandleId id, JSMutableHandleValue vp)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::DOMSVGPathSegLinetoVerticalRel>::value), "Must be an nsISupports class");
  mozilla::DOMSVGPathSegLinetoVerticalRel* self = UnwrapDOMObject<mozilla::DOMSVGPathSegLinetoVerticalRel>(obj);
  nsContentUtils::PreserveWrapper(reinterpret_cast<nsISupports*>(self), self);
  return true;
}

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::DOMSVGPathSegLinetoVerticalRel>::value), "Must be an nsISupports class");
  mozilla::DOMSVGPathSegLinetoVerticalRel* self = UnwrapDOMObject<mozilla::DOMSVGPathSegLinetoVerticalRel>(obj);
  if (self) {
    ClearWrapper(self, self);
    XPCJSRuntime *rt = nsXPConnect::GetRuntimeInstance();
    if (rt) {
      rt->DeferredRelease(reinterpret_cast<nsISupports*>(self));
    } else {
      NS_RELEASE(self);
    }
  }
}

static JSPropertySpec sAttributes_specs[] = {
  { "y", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &y_getterinfo }, { (JSStrictPropertyOp)genericSetter, &y_setterinfo }},
  { 0, 0, 0, JSOP_NULLWRAPPER, JSOP_NULLWRAPPER }
};

static Prefable<JSPropertySpec> sAttributes[] = {
  { true, &sAttributes_specs[0] },
  { false, NULL }
};

static jsid sAttributes_ids[2] = { JSID_VOID };


static const NativeProperties sNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sAttributes, sAttributes_ids, sAttributes_specs,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr
};
const NativePropertyHooks sNativePropertyHooks = {
  nullptr,
  nullptr,
  { &sNativeProperties, nullptr },
  prototypes::id::SVGPathSegLinetoVerticalRel,
  constructors::id::SVGPathSegLinetoVerticalRel,
  &SVGPathSegBinding::sNativePropertyHooks
};

JSNativeHolder _constructor_holder = {
  ThrowingConstructor,
  &sNativePropertyHooks
};

static DOMIfaceAndProtoJSClass PrototypeClass = {
  {
    "SVGPathSegLinetoVerticalRelPrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(2),
    JS_PropertyStub,       /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    nullptr,               /* finalize */
    nullptr,               /* checkAccess */
    nullptr,               /* call */
    nullptr,               /* hasInstance */
    nullptr,               /* construct */
    nullptr,               /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  eInterfacePrototype,
  &sNativePropertyHooks
};

void
CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray)
{
  JSObject* parentProto = SVGPathSegBinding::GetProtoObject(aCx, aGlobal);
  if (!parentProto) {
    return;
  }


  if (sAttributes_ids[0] == JSID_VOID &&
      !InitIds(aCx, sAttributes, sAttributes_ids)) {
    sAttributes_ids[0] = JSID_VOID;
    return;
  }

  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &PrototypeClass.mBase, &protoAndIfaceArray[prototypes::id::SVGPathSegLinetoVerticalRel],
                              nullptr, &_constructor_holder, 0, &protoAndIfaceArray[constructors::id::SVGPathSegLinetoVerticalRel],
                              &Class.mClass,
                              &sNativeProperties,
                              nullptr,
                              "SVGPathSegLinetoVerticalRel");
}

JSObject*
DefineDOMInterface(JSContext* aCx, JSObject* aGlobal, bool* aEnabled)
{

  *aEnabled = true;
  return GetConstructorObject(aCx, aGlobal);
}


DOMJSClass Class = {
  { "SVGPathSegLinetoVerticalRel",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(3),
    _addProperty, /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    _finalize, /* finalize */
    NULL,                  /* checkAccess */
    NULL,                  /* call */
    NULL,                  /* hasInstance */
    NULL,                  /* construct */
    NULL, /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  {
    { prototypes::id::SVGPathSeg, prototypes::id::SVGPathSegLinetoVerticalRel, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
    true,
    &sNativePropertyHooks,
    GetParentObject<mozilla::DOMSVGPathSegLinetoVerticalRel>::Get,
    GetProtoObject,
    nullptr
  }
};

JSObject*
Wrap(JSContext* aCx, JSObject* aScope, mozilla::DOMSVGPathSegLinetoVerticalRel* aObject, nsWrapperCache* aCache, bool* aTriedToWrap)
{
  MOZ_ASSERT(static_cast<mozilla::DOMSVGPathSegLinetoVerticalRel*>(aObject) ==
             reinterpret_cast<mozilla::DOMSVGPathSegLinetoVerticalRel*>(aObject));
  MOZ_ASSERT(static_cast<mozilla::DOMSVGPathSeg*>(aObject) ==
             reinterpret_cast<mozilla::DOMSVGPathSeg*>(aObject));

  *aTriedToWrap = true;

  JSObject* parent = WrapNativeParent(aCx, aScope, aObject->GetParentObject());
  if (!parent) {
    return NULL;
  }

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.  Scope so we don't
  // collide with the "obj" we declare in CreateBindingJSObject.
  {
    JSObject* obj = aCache->GetWrapper();
    if (obj) {
      return obj;
    }
  }

  JSAutoCompartment ac(aCx, parent);
  JSObject* global = JS_GetGlobalForObject(aCx, parent);

  JSObject* proto = GetProtoObject(aCx, global);
  if (!proto) {
    return NULL;
  }

  JSObject* obj = JS_NewObject(aCx, &Class.mBase, proto, parent);
  if (!obj) {
    return NULL;
  }

  js::SetReservedSlot(obj, DOM_OBJECT_SLOT, PRIVATE_TO_JSVAL(aObject));
  NS_ADDREF(aObject);


  aCache->SetWrapper(obj);

  return obj;
}

} // namespace SVGPathSegLinetoVerticalRelBinding



namespace SVGPathSegMovetoAbsBinding {

static bool
get_x(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegMovetoAbs* self, JS::Value* vp)
{
  float result;
  result = self->X();
  *vp = JS_NumberValue(double(result));
  return true;
}

static bool
set_x(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegMovetoAbs* self, JS::Value* argv)
{
  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[0], &arg0)) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg0)) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    ThrowErrorMessage(cx, MSG_NOT_FINITE);
    return false;
  }
  ErrorResult rv;
  self->SetX(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGPathSegMovetoAbs", "x");
  }

  return true;
}


const JSJitInfo x_getterinfo = {
  (JSJitPropertyOp)get_x,
  prototypes::id::SVGPathSegMovetoAbs,
  PrototypeTraits<prototypes::id::SVGPathSegMovetoAbs>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo x_setterinfo = {
  (JSJitPropertyOp)set_x,
  prototypes::id::SVGPathSegMovetoAbs,
  PrototypeTraits<prototypes::id::SVGPathSegMovetoAbs>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_y(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegMovetoAbs* self, JS::Value* vp)
{
  float result;
  result = self->Y();
  *vp = JS_NumberValue(double(result));
  return true;
}

static bool
set_y(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegMovetoAbs* self, JS::Value* argv)
{
  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[0], &arg0)) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg0)) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    ThrowErrorMessage(cx, MSG_NOT_FINITE);
    return false;
  }
  ErrorResult rv;
  self->SetY(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGPathSegMovetoAbs", "y");
  }

  return true;
}


const JSJitInfo y_getterinfo = {
  (JSJitPropertyOp)get_y,
  prototypes::id::SVGPathSegMovetoAbs,
  PrototypeTraits<prototypes::id::SVGPathSegMovetoAbs>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo y_setterinfo = {
  (JSJitPropertyOp)set_y,
  prototypes::id::SVGPathSegMovetoAbs,
  PrototypeTraits<prototypes::id::SVGPathSegMovetoAbs>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static JSBool
genericGetter(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  mozilla::DOMSVGPathSegMovetoAbs* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::SVGPathSegMovetoAbs, mozilla::DOMSVGPathSegMovetoAbs>(cx, obj, self);
    if (NS_FAILED(rv)) {
      return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "SVGPathSegMovetoAbs");
    }
  }
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Getter);
  JSJitPropertyOp getter = info->op;
  return getter(cx, obj, self, vp);
}

static JSBool
genericSetter(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  mozilla::DOMSVGPathSegMovetoAbs* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::SVGPathSegMovetoAbs, mozilla::DOMSVGPathSegMovetoAbs>(cx, obj, self);
    if (NS_FAILED(rv)) {
      return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "SVGPathSegMovetoAbs");
    }
  }
  if (argc == 0) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "SVGPathSegMovetoAbs attribute setter");
  }
  JS::Value* argv = JS_ARGV(cx, vp);
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Setter);
  JSJitPropertyOp setter = info->op;
  if (!setter(cx, obj, self, argv)) {
    return false;
  }
  *vp = JSVAL_VOID;
  return true;
}

static JSBool
_addProperty(JSContext* cx, JSHandleObject obj, JSHandleId id, JSMutableHandleValue vp)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::DOMSVGPathSegMovetoAbs>::value), "Must be an nsISupports class");
  mozilla::DOMSVGPathSegMovetoAbs* self = UnwrapDOMObject<mozilla::DOMSVGPathSegMovetoAbs>(obj);
  nsContentUtils::PreserveWrapper(reinterpret_cast<nsISupports*>(self), self);
  return true;
}

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::DOMSVGPathSegMovetoAbs>::value), "Must be an nsISupports class");
  mozilla::DOMSVGPathSegMovetoAbs* self = UnwrapDOMObject<mozilla::DOMSVGPathSegMovetoAbs>(obj);
  if (self) {
    ClearWrapper(self, self);
    XPCJSRuntime *rt = nsXPConnect::GetRuntimeInstance();
    if (rt) {
      rt->DeferredRelease(reinterpret_cast<nsISupports*>(self));
    } else {
      NS_RELEASE(self);
    }
  }
}

static JSPropertySpec sAttributes_specs[] = {
  { "x", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &x_getterinfo }, { (JSStrictPropertyOp)genericSetter, &x_setterinfo }},
  { "y", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &y_getterinfo }, { (JSStrictPropertyOp)genericSetter, &y_setterinfo }},
  { 0, 0, 0, JSOP_NULLWRAPPER, JSOP_NULLWRAPPER }
};

static Prefable<JSPropertySpec> sAttributes[] = {
  { true, &sAttributes_specs[0] },
  { false, NULL }
};

static jsid sAttributes_ids[3] = { JSID_VOID };


static const NativeProperties sNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sAttributes, sAttributes_ids, sAttributes_specs,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr
};
const NativePropertyHooks sNativePropertyHooks = {
  nullptr,
  nullptr,
  { &sNativeProperties, nullptr },
  prototypes::id::SVGPathSegMovetoAbs,
  constructors::id::SVGPathSegMovetoAbs,
  &SVGPathSegBinding::sNativePropertyHooks
};

JSNativeHolder _constructor_holder = {
  ThrowingConstructor,
  &sNativePropertyHooks
};

static DOMIfaceAndProtoJSClass PrototypeClass = {
  {
    "SVGPathSegMovetoAbsPrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(2),
    JS_PropertyStub,       /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    nullptr,               /* finalize */
    nullptr,               /* checkAccess */
    nullptr,               /* call */
    nullptr,               /* hasInstance */
    nullptr,               /* construct */
    nullptr,               /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  eInterfacePrototype,
  &sNativePropertyHooks
};

void
CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray)
{
  JSObject* parentProto = SVGPathSegBinding::GetProtoObject(aCx, aGlobal);
  if (!parentProto) {
    return;
  }


  if (sAttributes_ids[0] == JSID_VOID &&
      !InitIds(aCx, sAttributes, sAttributes_ids)) {
    sAttributes_ids[0] = JSID_VOID;
    return;
  }

  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &PrototypeClass.mBase, &protoAndIfaceArray[prototypes::id::SVGPathSegMovetoAbs],
                              nullptr, &_constructor_holder, 0, &protoAndIfaceArray[constructors::id::SVGPathSegMovetoAbs],
                              &Class.mClass,
                              &sNativeProperties,
                              nullptr,
                              "SVGPathSegMovetoAbs");
}

JSObject*
DefineDOMInterface(JSContext* aCx, JSObject* aGlobal, bool* aEnabled)
{

  *aEnabled = true;
  return GetConstructorObject(aCx, aGlobal);
}


DOMJSClass Class = {
  { "SVGPathSegMovetoAbs",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(3),
    _addProperty, /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    _finalize, /* finalize */
    NULL,                  /* checkAccess */
    NULL,                  /* call */
    NULL,                  /* hasInstance */
    NULL,                  /* construct */
    NULL, /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  {
    { prototypes::id::SVGPathSeg, prototypes::id::SVGPathSegMovetoAbs, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
    true,
    &sNativePropertyHooks,
    GetParentObject<mozilla::DOMSVGPathSegMovetoAbs>::Get,
    GetProtoObject,
    nullptr
  }
};

JSObject*
Wrap(JSContext* aCx, JSObject* aScope, mozilla::DOMSVGPathSegMovetoAbs* aObject, nsWrapperCache* aCache, bool* aTriedToWrap)
{
  MOZ_ASSERT(static_cast<mozilla::DOMSVGPathSegMovetoAbs*>(aObject) ==
             reinterpret_cast<mozilla::DOMSVGPathSegMovetoAbs*>(aObject));
  MOZ_ASSERT(static_cast<mozilla::DOMSVGPathSeg*>(aObject) ==
             reinterpret_cast<mozilla::DOMSVGPathSeg*>(aObject));

  *aTriedToWrap = true;

  JSObject* parent = WrapNativeParent(aCx, aScope, aObject->GetParentObject());
  if (!parent) {
    return NULL;
  }

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.  Scope so we don't
  // collide with the "obj" we declare in CreateBindingJSObject.
  {
    JSObject* obj = aCache->GetWrapper();
    if (obj) {
      return obj;
    }
  }

  JSAutoCompartment ac(aCx, parent);
  JSObject* global = JS_GetGlobalForObject(aCx, parent);

  JSObject* proto = GetProtoObject(aCx, global);
  if (!proto) {
    return NULL;
  }

  JSObject* obj = JS_NewObject(aCx, &Class.mBase, proto, parent);
  if (!obj) {
    return NULL;
  }

  js::SetReservedSlot(obj, DOM_OBJECT_SLOT, PRIVATE_TO_JSVAL(aObject));
  NS_ADDREF(aObject);


  aCache->SetWrapper(obj);

  return obj;
}

} // namespace SVGPathSegMovetoAbsBinding



namespace SVGPathSegMovetoRelBinding {

static bool
get_x(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegMovetoRel* self, JS::Value* vp)
{
  float result;
  result = self->X();
  *vp = JS_NumberValue(double(result));
  return true;
}

static bool
set_x(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegMovetoRel* self, JS::Value* argv)
{
  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[0], &arg0)) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg0)) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    ThrowErrorMessage(cx, MSG_NOT_FINITE);
    return false;
  }
  ErrorResult rv;
  self->SetX(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGPathSegMovetoRel", "x");
  }

  return true;
}


const JSJitInfo x_getterinfo = {
  (JSJitPropertyOp)get_x,
  prototypes::id::SVGPathSegMovetoRel,
  PrototypeTraits<prototypes::id::SVGPathSegMovetoRel>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo x_setterinfo = {
  (JSJitPropertyOp)set_x,
  prototypes::id::SVGPathSegMovetoRel,
  PrototypeTraits<prototypes::id::SVGPathSegMovetoRel>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_y(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegMovetoRel* self, JS::Value* vp)
{
  float result;
  result = self->Y();
  *vp = JS_NumberValue(double(result));
  return true;
}

static bool
set_y(JSContext* cx, JSHandleObject obj, mozilla::DOMSVGPathSegMovetoRel* self, JS::Value* argv)
{
  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[0], &arg0)) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg0)) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    ThrowErrorMessage(cx, MSG_NOT_FINITE);
    return false;
  }
  ErrorResult rv;
  self->SetY(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "SVGPathSegMovetoRel", "y");
  }

  return true;
}


const JSJitInfo y_getterinfo = {
  (JSJitPropertyOp)get_y,
  prototypes::id::SVGPathSegMovetoRel,
  PrototypeTraits<prototypes::id::SVGPathSegMovetoRel>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo y_setterinfo = {
  (JSJitPropertyOp)set_y,
  prototypes::id::SVGPathSegMovetoRel,
  PrototypeTraits<prototypes::id::SVGPathSegMovetoRel>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static JSBool
genericGetter(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  mozilla::DOMSVGPathSegMovetoRel* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::SVGPathSegMovetoRel, mozilla::DOMSVGPathSegMovetoRel>(cx, obj, self);
    if (NS_FAILED(rv)) {
      return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "SVGPathSegMovetoRel");
    }
  }
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Getter);
  JSJitPropertyOp getter = info->op;
  return getter(cx, obj, self, vp);
}

static JSBool
genericSetter(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  mozilla::DOMSVGPathSegMovetoRel* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::SVGPathSegMovetoRel, mozilla::DOMSVGPathSegMovetoRel>(cx, obj, self);
    if (NS_FAILED(rv)) {
      return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "SVGPathSegMovetoRel");
    }
  }
  if (argc == 0) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "SVGPathSegMovetoRel attribute setter");
  }
  JS::Value* argv = JS_ARGV(cx, vp);
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Setter);
  JSJitPropertyOp setter = info->op;
  if (!setter(cx, obj, self, argv)) {
    return false;
  }
  *vp = JSVAL_VOID;
  return true;
}

static JSBool
_addProperty(JSContext* cx, JSHandleObject obj, JSHandleId id, JSMutableHandleValue vp)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::DOMSVGPathSegMovetoRel>::value), "Must be an nsISupports class");
  mozilla::DOMSVGPathSegMovetoRel* self = UnwrapDOMObject<mozilla::DOMSVGPathSegMovetoRel>(obj);
  nsContentUtils::PreserveWrapper(reinterpret_cast<nsISupports*>(self), self);
  return true;
}

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::DOMSVGPathSegMovetoRel>::value), "Must be an nsISupports class");
  mozilla::DOMSVGPathSegMovetoRel* self = UnwrapDOMObject<mozilla::DOMSVGPathSegMovetoRel>(obj);
  if (self) {
    ClearWrapper(self, self);
    XPCJSRuntime *rt = nsXPConnect::GetRuntimeInstance();
    if (rt) {
      rt->DeferredRelease(reinterpret_cast<nsISupports*>(self));
    } else {
      NS_RELEASE(self);
    }
  }
}

static JSPropertySpec sAttributes_specs[] = {
  { "x", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &x_getterinfo }, { (JSStrictPropertyOp)genericSetter, &x_setterinfo }},
  { "y", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &y_getterinfo }, { (JSStrictPropertyOp)genericSetter, &y_setterinfo }},
  { 0, 0, 0, JSOP_NULLWRAPPER, JSOP_NULLWRAPPER }
};

static Prefable<JSPropertySpec> sAttributes[] = {
  { true, &sAttributes_specs[0] },
  { false, NULL }
};

static jsid sAttributes_ids[3] = { JSID_VOID };


static const NativeProperties sNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sAttributes, sAttributes_ids, sAttributes_specs,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr
};
const NativePropertyHooks sNativePropertyHooks = {
  nullptr,
  nullptr,
  { &sNativeProperties, nullptr },
  prototypes::id::SVGPathSegMovetoRel,
  constructors::id::SVGPathSegMovetoRel,
  &SVGPathSegBinding::sNativePropertyHooks
};

JSNativeHolder _constructor_holder = {
  ThrowingConstructor,
  &sNativePropertyHooks
};

static DOMIfaceAndProtoJSClass PrototypeClass = {
  {
    "SVGPathSegMovetoRelPrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(2),
    JS_PropertyStub,       /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    nullptr,               /* finalize */
    nullptr,               /* checkAccess */
    nullptr,               /* call */
    nullptr,               /* hasInstance */
    nullptr,               /* construct */
    nullptr,               /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  eInterfacePrototype,
  &sNativePropertyHooks
};

void
CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray)
{
  JSObject* parentProto = SVGPathSegBinding::GetProtoObject(aCx, aGlobal);
  if (!parentProto) {
    return;
  }


  if (sAttributes_ids[0] == JSID_VOID &&
      !InitIds(aCx, sAttributes, sAttributes_ids)) {
    sAttributes_ids[0] = JSID_VOID;
    return;
  }

  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &PrototypeClass.mBase, &protoAndIfaceArray[prototypes::id::SVGPathSegMovetoRel],
                              nullptr, &_constructor_holder, 0, &protoAndIfaceArray[constructors::id::SVGPathSegMovetoRel],
                              &Class.mClass,
                              &sNativeProperties,
                              nullptr,
                              "SVGPathSegMovetoRel");
}

JSObject*
DefineDOMInterface(JSContext* aCx, JSObject* aGlobal, bool* aEnabled)
{

  *aEnabled = true;
  return GetConstructorObject(aCx, aGlobal);
}


DOMJSClass Class = {
  { "SVGPathSegMovetoRel",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(3),
    _addProperty, /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    _finalize, /* finalize */
    NULL,                  /* checkAccess */
    NULL,                  /* call */
    NULL,                  /* hasInstance */
    NULL,                  /* construct */
    NULL, /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  {
    { prototypes::id::SVGPathSeg, prototypes::id::SVGPathSegMovetoRel, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
    true,
    &sNativePropertyHooks,
    GetParentObject<mozilla::DOMSVGPathSegMovetoRel>::Get,
    GetProtoObject,
    nullptr
  }
};

JSObject*
Wrap(JSContext* aCx, JSObject* aScope, mozilla::DOMSVGPathSegMovetoRel* aObject, nsWrapperCache* aCache, bool* aTriedToWrap)
{
  MOZ_ASSERT(static_cast<mozilla::DOMSVGPathSegMovetoRel*>(aObject) ==
             reinterpret_cast<mozilla::DOMSVGPathSegMovetoRel*>(aObject));
  MOZ_ASSERT(static_cast<mozilla::DOMSVGPathSeg*>(aObject) ==
             reinterpret_cast<mozilla::DOMSVGPathSeg*>(aObject));

  *aTriedToWrap = true;

  JSObject* parent = WrapNativeParent(aCx, aScope, aObject->GetParentObject());
  if (!parent) {
    return NULL;
  }

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.  Scope so we don't
  // collide with the "obj" we declare in CreateBindingJSObject.
  {
    JSObject* obj = aCache->GetWrapper();
    if (obj) {
      return obj;
    }
  }

  JSAutoCompartment ac(aCx, parent);
  JSObject* global = JS_GetGlobalForObject(aCx, parent);

  JSObject* proto = GetProtoObject(aCx, global);
  if (!proto) {
    return NULL;
  }

  JSObject* obj = JS_NewObject(aCx, &Class.mBase, proto, parent);
  if (!obj) {
    return NULL;
  }

  js::SetReservedSlot(obj, DOM_OBJECT_SLOT, PRIVATE_TO_JSVAL(aObject));
  NS_ADDREF(aObject);


  aCache->SetWrapper(obj);

  return obj;
}

} // namespace SVGPathSegMovetoRelBinding



} // namespace dom
} // namespace mozilla
