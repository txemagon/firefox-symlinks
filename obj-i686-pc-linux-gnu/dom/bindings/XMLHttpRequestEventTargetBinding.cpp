/* THIS FILE IS AUTOGENERATED - DO NOT EDIT */

#include "AccessCheck.h"
#include "EventHandlerBinding.h"
#include "EventTargetBinding.h"
#include "PrimitiveConversions.h"
#include "WorkerPrivate.h"
#include "XMLHttpRequestEventTargetBinding.h"
#include "XPCQuickStubs.h"
#include "XPCWrapper.h"
#include "mozilla/Preferences.h"
#include "mozilla/dom/BindingUtils.h"
#include "mozilla/dom/NonRefcountedDOMObject.h"
#include "mozilla/dom/Nullable.h"
#include "mozilla/dom/workers/bindings/XMLHttpRequestEventTarget.h"
#include "nsContentUtils.h"
#include "nsDOMQS.h"
#include "nsXMLHttpRequest.h"

using namespace mozilla::dom;
namespace mozilla {
namespace dom {

namespace XMLHttpRequestEventTargetBinding {

static bool
get_onloadstart(JSContext* cx, JSHandleObject obj, nsXHREventTarget* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnloadstart();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onloadstart(JSContext* cx, JSHandleObject obj, nsXHREventTarget* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnloadstart(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "XMLHttpRequestEventTarget", "onloadstart");
  }

  return true;
}


const JSJitInfo onloadstart_getterinfo = {
  (JSJitPropertyOp)get_onloadstart,
  prototypes::id::XMLHttpRequestEventTarget,
  PrototypeTraits<prototypes::id::XMLHttpRequestEventTarget>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onloadstart_setterinfo = {
  (JSJitPropertyOp)set_onloadstart,
  prototypes::id::XMLHttpRequestEventTarget,
  PrototypeTraits<prototypes::id::XMLHttpRequestEventTarget>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onprogress(JSContext* cx, JSHandleObject obj, nsXHREventTarget* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnprogress();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onprogress(JSContext* cx, JSHandleObject obj, nsXHREventTarget* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnprogress(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "XMLHttpRequestEventTarget", "onprogress");
  }

  return true;
}


const JSJitInfo onprogress_getterinfo = {
  (JSJitPropertyOp)get_onprogress,
  prototypes::id::XMLHttpRequestEventTarget,
  PrototypeTraits<prototypes::id::XMLHttpRequestEventTarget>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onprogress_setterinfo = {
  (JSJitPropertyOp)set_onprogress,
  prototypes::id::XMLHttpRequestEventTarget,
  PrototypeTraits<prototypes::id::XMLHttpRequestEventTarget>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onabort(JSContext* cx, JSHandleObject obj, nsXHREventTarget* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnabort();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onabort(JSContext* cx, JSHandleObject obj, nsXHREventTarget* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnabort(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "XMLHttpRequestEventTarget", "onabort");
  }

  return true;
}


const JSJitInfo onabort_getterinfo = {
  (JSJitPropertyOp)get_onabort,
  prototypes::id::XMLHttpRequestEventTarget,
  PrototypeTraits<prototypes::id::XMLHttpRequestEventTarget>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onabort_setterinfo = {
  (JSJitPropertyOp)set_onabort,
  prototypes::id::XMLHttpRequestEventTarget,
  PrototypeTraits<prototypes::id::XMLHttpRequestEventTarget>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onerror(JSContext* cx, JSHandleObject obj, nsXHREventTarget* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnerror();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onerror(JSContext* cx, JSHandleObject obj, nsXHREventTarget* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnerror(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "XMLHttpRequestEventTarget", "onerror");
  }

  return true;
}


const JSJitInfo onerror_getterinfo = {
  (JSJitPropertyOp)get_onerror,
  prototypes::id::XMLHttpRequestEventTarget,
  PrototypeTraits<prototypes::id::XMLHttpRequestEventTarget>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onerror_setterinfo = {
  (JSJitPropertyOp)set_onerror,
  prototypes::id::XMLHttpRequestEventTarget,
  PrototypeTraits<prototypes::id::XMLHttpRequestEventTarget>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onload(JSContext* cx, JSHandleObject obj, nsXHREventTarget* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnload();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onload(JSContext* cx, JSHandleObject obj, nsXHREventTarget* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnload(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "XMLHttpRequestEventTarget", "onload");
  }

  return true;
}


const JSJitInfo onload_getterinfo = {
  (JSJitPropertyOp)get_onload,
  prototypes::id::XMLHttpRequestEventTarget,
  PrototypeTraits<prototypes::id::XMLHttpRequestEventTarget>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onload_setterinfo = {
  (JSJitPropertyOp)set_onload,
  prototypes::id::XMLHttpRequestEventTarget,
  PrototypeTraits<prototypes::id::XMLHttpRequestEventTarget>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_ontimeout(JSContext* cx, JSHandleObject obj, nsXHREventTarget* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOntimeout();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_ontimeout(JSContext* cx, JSHandleObject obj, nsXHREventTarget* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOntimeout(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "XMLHttpRequestEventTarget", "ontimeout");
  }

  return true;
}


const JSJitInfo ontimeout_getterinfo = {
  (JSJitPropertyOp)get_ontimeout,
  prototypes::id::XMLHttpRequestEventTarget,
  PrototypeTraits<prototypes::id::XMLHttpRequestEventTarget>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo ontimeout_setterinfo = {
  (JSJitPropertyOp)set_ontimeout,
  prototypes::id::XMLHttpRequestEventTarget,
  PrototypeTraits<prototypes::id::XMLHttpRequestEventTarget>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onloadend(JSContext* cx, JSHandleObject obj, nsXHREventTarget* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnloadend();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onloadend(JSContext* cx, JSHandleObject obj, nsXHREventTarget* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnloadend(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "XMLHttpRequestEventTarget", "onloadend");
  }

  return true;
}


const JSJitInfo onloadend_getterinfo = {
  (JSJitPropertyOp)get_onloadend,
  prototypes::id::XMLHttpRequestEventTarget,
  PrototypeTraits<prototypes::id::XMLHttpRequestEventTarget>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onloadend_setterinfo = {
  (JSJitPropertyOp)set_onloadend,
  prototypes::id::XMLHttpRequestEventTarget,
  PrototypeTraits<prototypes::id::XMLHttpRequestEventTarget>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static JSBool
genericGetter(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  nsXHREventTarget* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::XMLHttpRequestEventTarget, nsXHREventTarget>(cx, obj, self);
    if (NS_FAILED(rv)) {
      return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "XMLHttpRequestEventTarget");
    }
  }
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Getter);
  JSJitPropertyOp getter = info->op;
  return getter(cx, obj, self, vp);
}

static JSBool
genericSetter(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  nsXHREventTarget* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::XMLHttpRequestEventTarget, nsXHREventTarget>(cx, obj, self);
    if (NS_FAILED(rv)) {
      return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "XMLHttpRequestEventTarget");
    }
  }
  if (argc == 0) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "XMLHttpRequestEventTarget attribute setter");
  }
  JS::Value* argv = JS_ARGV(cx, vp);
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Setter);
  JSJitPropertyOp setter = info->op;
  if (!setter(cx, obj, self, argv)) {
    return false;
  }
  *vp = JSVAL_VOID;
  return true;
}

static JSPropertySpec sAttributes_specs[] = {
  { "onloadstart", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onloadstart_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onloadstart_setterinfo }},
  { "onprogress", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onprogress_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onprogress_setterinfo }},
  { "onabort", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onabort_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onabort_setterinfo }},
  { "onerror", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onerror_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onerror_setterinfo }},
  { "onload", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onload_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onload_setterinfo }},
  { "ontimeout", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &ontimeout_getterinfo }, { (JSStrictPropertyOp)genericSetter, &ontimeout_setterinfo }},
  { "onloadend", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onloadend_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onloadend_setterinfo }},
  { 0, 0, 0, JSOP_NULLWRAPPER, JSOP_NULLWRAPPER }
};

static Prefable<JSPropertySpec> sAttributes[] = {
  { true, &sAttributes_specs[0] },
  { false, NULL }
};

static jsid sAttributes_ids[8] = { JSID_VOID };


static const NativeProperties sNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sAttributes, sAttributes_ids, sAttributes_specs,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr
};
const NativePropertyHooks sNativePropertyHooks = {
  nullptr,
  nullptr,
  { &sNativeProperties, nullptr },
  prototypes::id::XMLHttpRequestEventTarget,
  constructors::id::_ID_Count,
  &EventTargetBinding::sNativePropertyHooks
};

static DOMIfaceAndProtoJSClass PrototypeClass = {
  {
    "XMLHttpRequestEventTargetPrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(2),
    JS_PropertyStub,       /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    nullptr,               /* finalize */
    nullptr,               /* checkAccess */
    nullptr,               /* call */
    nullptr,               /* hasInstance */
    nullptr,               /* construct */
    nullptr,               /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  eInterfacePrototype,
  &sNativePropertyHooks
};

void
CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray)
{
  JSObject* parentProto = EventTargetBinding::GetProtoObject(aCx, aGlobal);
  if (!parentProto) {
    return;
  }


  if (sAttributes_ids[0] == JSID_VOID &&
      !InitIds(aCx, sAttributes, sAttributes_ids)) {
    sAttributes_ids[0] = JSID_VOID;
    return;
  }

  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &PrototypeClass.mBase, &protoAndIfaceArray[prototypes::id::XMLHttpRequestEventTarget],
                              nullptr, nullptr, 0, nullptr,
                              nullptr,
                              &sNativeProperties,
                              nullptr,
                              NULL);
}

} // namespace XMLHttpRequestEventTargetBinding



namespace XMLHttpRequestEventTargetBinding_workers {

static bool
get_onloadstart(JSContext* cx, JSHandleObject obj, mozilla::dom::workers::XMLHttpRequestEventTarget* self, JS::Value* vp)
{
  ErrorResult rv;
  JSObject* result;
  result = self->GetOnloadstart(cx, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<false>(cx, rv, "XMLHttpRequestEventTarget", "onloadstart");
  }
  *vp = JS::ObjectOrNullValue(result);
  if (!MaybeWrapValue(cx, vp)) {
    return false;
  }
  return true;
}

static bool
set_onloadstart(JSContext* cx, JSHandleObject obj, mozilla::dom::workers::XMLHttpRequestEventTarget* self, JS::Value* argv)
{
  JSObject* arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    arg0 = &argv[0].toObject();
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnloadstart(cx, arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<false>(cx, rv, "XMLHttpRequestEventTarget", "onloadstart");
  }

  return true;
}


const JSJitInfo onloadstart_getterinfo = {
  (JSJitPropertyOp)get_onloadstart,
  prototypes::id::XMLHttpRequestEventTarget_workers,
  PrototypeTraits<prototypes::id::XMLHttpRequestEventTarget_workers>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onloadstart_setterinfo = {
  (JSJitPropertyOp)set_onloadstart,
  prototypes::id::XMLHttpRequestEventTarget_workers,
  PrototypeTraits<prototypes::id::XMLHttpRequestEventTarget_workers>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onprogress(JSContext* cx, JSHandleObject obj, mozilla::dom::workers::XMLHttpRequestEventTarget* self, JS::Value* vp)
{
  ErrorResult rv;
  JSObject* result;
  result = self->GetOnprogress(cx, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<false>(cx, rv, "XMLHttpRequestEventTarget", "onprogress");
  }
  *vp = JS::ObjectOrNullValue(result);
  if (!MaybeWrapValue(cx, vp)) {
    return false;
  }
  return true;
}

static bool
set_onprogress(JSContext* cx, JSHandleObject obj, mozilla::dom::workers::XMLHttpRequestEventTarget* self, JS::Value* argv)
{
  JSObject* arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    arg0 = &argv[0].toObject();
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnprogress(cx, arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<false>(cx, rv, "XMLHttpRequestEventTarget", "onprogress");
  }

  return true;
}


const JSJitInfo onprogress_getterinfo = {
  (JSJitPropertyOp)get_onprogress,
  prototypes::id::XMLHttpRequestEventTarget_workers,
  PrototypeTraits<prototypes::id::XMLHttpRequestEventTarget_workers>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onprogress_setterinfo = {
  (JSJitPropertyOp)set_onprogress,
  prototypes::id::XMLHttpRequestEventTarget_workers,
  PrototypeTraits<prototypes::id::XMLHttpRequestEventTarget_workers>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onabort(JSContext* cx, JSHandleObject obj, mozilla::dom::workers::XMLHttpRequestEventTarget* self, JS::Value* vp)
{
  ErrorResult rv;
  JSObject* result;
  result = self->GetOnabort(cx, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<false>(cx, rv, "XMLHttpRequestEventTarget", "onabort");
  }
  *vp = JS::ObjectOrNullValue(result);
  if (!MaybeWrapValue(cx, vp)) {
    return false;
  }
  return true;
}

static bool
set_onabort(JSContext* cx, JSHandleObject obj, mozilla::dom::workers::XMLHttpRequestEventTarget* self, JS::Value* argv)
{
  JSObject* arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    arg0 = &argv[0].toObject();
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnabort(cx, arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<false>(cx, rv, "XMLHttpRequestEventTarget", "onabort");
  }

  return true;
}


const JSJitInfo onabort_getterinfo = {
  (JSJitPropertyOp)get_onabort,
  prototypes::id::XMLHttpRequestEventTarget_workers,
  PrototypeTraits<prototypes::id::XMLHttpRequestEventTarget_workers>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onabort_setterinfo = {
  (JSJitPropertyOp)set_onabort,
  prototypes::id::XMLHttpRequestEventTarget_workers,
  PrototypeTraits<prototypes::id::XMLHttpRequestEventTarget_workers>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onerror(JSContext* cx, JSHandleObject obj, mozilla::dom::workers::XMLHttpRequestEventTarget* self, JS::Value* vp)
{
  ErrorResult rv;
  JSObject* result;
  result = self->GetOnerror(cx, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<false>(cx, rv, "XMLHttpRequestEventTarget", "onerror");
  }
  *vp = JS::ObjectOrNullValue(result);
  if (!MaybeWrapValue(cx, vp)) {
    return false;
  }
  return true;
}

static bool
set_onerror(JSContext* cx, JSHandleObject obj, mozilla::dom::workers::XMLHttpRequestEventTarget* self, JS::Value* argv)
{
  JSObject* arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    arg0 = &argv[0].toObject();
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnerror(cx, arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<false>(cx, rv, "XMLHttpRequestEventTarget", "onerror");
  }

  return true;
}


const JSJitInfo onerror_getterinfo = {
  (JSJitPropertyOp)get_onerror,
  prototypes::id::XMLHttpRequestEventTarget_workers,
  PrototypeTraits<prototypes::id::XMLHttpRequestEventTarget_workers>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onerror_setterinfo = {
  (JSJitPropertyOp)set_onerror,
  prototypes::id::XMLHttpRequestEventTarget_workers,
  PrototypeTraits<prototypes::id::XMLHttpRequestEventTarget_workers>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onload(JSContext* cx, JSHandleObject obj, mozilla::dom::workers::XMLHttpRequestEventTarget* self, JS::Value* vp)
{
  ErrorResult rv;
  JSObject* result;
  result = self->GetOnload(cx, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<false>(cx, rv, "XMLHttpRequestEventTarget", "onload");
  }
  *vp = JS::ObjectOrNullValue(result);
  if (!MaybeWrapValue(cx, vp)) {
    return false;
  }
  return true;
}

static bool
set_onload(JSContext* cx, JSHandleObject obj, mozilla::dom::workers::XMLHttpRequestEventTarget* self, JS::Value* argv)
{
  JSObject* arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    arg0 = &argv[0].toObject();
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnload(cx, arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<false>(cx, rv, "XMLHttpRequestEventTarget", "onload");
  }

  return true;
}


const JSJitInfo onload_getterinfo = {
  (JSJitPropertyOp)get_onload,
  prototypes::id::XMLHttpRequestEventTarget_workers,
  PrototypeTraits<prototypes::id::XMLHttpRequestEventTarget_workers>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onload_setterinfo = {
  (JSJitPropertyOp)set_onload,
  prototypes::id::XMLHttpRequestEventTarget_workers,
  PrototypeTraits<prototypes::id::XMLHttpRequestEventTarget_workers>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_ontimeout(JSContext* cx, JSHandleObject obj, mozilla::dom::workers::XMLHttpRequestEventTarget* self, JS::Value* vp)
{
  ErrorResult rv;
  JSObject* result;
  result = self->GetOntimeout(cx, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<false>(cx, rv, "XMLHttpRequestEventTarget", "ontimeout");
  }
  *vp = JS::ObjectOrNullValue(result);
  if (!MaybeWrapValue(cx, vp)) {
    return false;
  }
  return true;
}

static bool
set_ontimeout(JSContext* cx, JSHandleObject obj, mozilla::dom::workers::XMLHttpRequestEventTarget* self, JS::Value* argv)
{
  JSObject* arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    arg0 = &argv[0].toObject();
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOntimeout(cx, arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<false>(cx, rv, "XMLHttpRequestEventTarget", "ontimeout");
  }

  return true;
}


const JSJitInfo ontimeout_getterinfo = {
  (JSJitPropertyOp)get_ontimeout,
  prototypes::id::XMLHttpRequestEventTarget_workers,
  PrototypeTraits<prototypes::id::XMLHttpRequestEventTarget_workers>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo ontimeout_setterinfo = {
  (JSJitPropertyOp)set_ontimeout,
  prototypes::id::XMLHttpRequestEventTarget_workers,
  PrototypeTraits<prototypes::id::XMLHttpRequestEventTarget_workers>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onloadend(JSContext* cx, JSHandleObject obj, mozilla::dom::workers::XMLHttpRequestEventTarget* self, JS::Value* vp)
{
  ErrorResult rv;
  JSObject* result;
  result = self->GetOnloadend(cx, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<false>(cx, rv, "XMLHttpRequestEventTarget", "onloadend");
  }
  *vp = JS::ObjectOrNullValue(result);
  if (!MaybeWrapValue(cx, vp)) {
    return false;
  }
  return true;
}

static bool
set_onloadend(JSContext* cx, JSHandleObject obj, mozilla::dom::workers::XMLHttpRequestEventTarget* self, JS::Value* argv)
{
  JSObject* arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    arg0 = &argv[0].toObject();
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnloadend(cx, arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<false>(cx, rv, "XMLHttpRequestEventTarget", "onloadend");
  }

  return true;
}


const JSJitInfo onloadend_getterinfo = {
  (JSJitPropertyOp)get_onloadend,
  prototypes::id::XMLHttpRequestEventTarget_workers,
  PrototypeTraits<prototypes::id::XMLHttpRequestEventTarget_workers>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onloadend_setterinfo = {
  (JSJitPropertyOp)set_onloadend,
  prototypes::id::XMLHttpRequestEventTarget_workers,
  PrototypeTraits<prototypes::id::XMLHttpRequestEventTarget_workers>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static JSBool
genericGetter(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  mozilla::dom::workers::XMLHttpRequestEventTarget* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::XMLHttpRequestEventTarget_workers, mozilla::dom::workers::XMLHttpRequestEventTarget>(cx, obj, self);
    if (NS_FAILED(rv)) {
      return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "XMLHttpRequestEventTarget_workers");
    }
  }
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Getter);
  JSJitPropertyOp getter = info->op;
  return getter(cx, obj, self, vp);
}

static JSBool
genericSetter(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  mozilla::dom::workers::XMLHttpRequestEventTarget* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::XMLHttpRequestEventTarget_workers, mozilla::dom::workers::XMLHttpRequestEventTarget>(cx, obj, self);
    if (NS_FAILED(rv)) {
      return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "XMLHttpRequestEventTarget_workers");
    }
  }
  if (argc == 0) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "XMLHttpRequestEventTarget attribute setter");
  }
  JS::Value* argv = JS_ARGV(cx, vp);
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Setter);
  JSJitPropertyOp setter = info->op;
  if (!setter(cx, obj, self, argv)) {
    return false;
  }
  *vp = JSVAL_VOID;
  return true;
}

static JSPropertySpec sAttributes_specs[] = {
  { "onloadstart", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onloadstart_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onloadstart_setterinfo }},
  { "onprogress", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onprogress_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onprogress_setterinfo }},
  { "onabort", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onabort_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onabort_setterinfo }},
  { "onerror", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onerror_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onerror_setterinfo }},
  { "onload", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onload_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onload_setterinfo }},
  { "ontimeout", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &ontimeout_getterinfo }, { (JSStrictPropertyOp)genericSetter, &ontimeout_setterinfo }},
  { "onloadend", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onloadend_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onloadend_setterinfo }},
  { 0, 0, 0, JSOP_NULLWRAPPER, JSOP_NULLWRAPPER }
};

static Prefable<JSPropertySpec> sAttributes[] = {
  { true, &sAttributes_specs[0] },
  { false, NULL }
};


static const NativeProperties sNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sAttributes, nullptr, sAttributes_specs,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr
};
static DOMIfaceAndProtoJSClass PrototypeClass = {
  {
    "XMLHttpRequestEventTargetPrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(2),
    JS_PropertyStub,       /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    nullptr,               /* finalize */
    nullptr,               /* checkAccess */
    nullptr,               /* call */
    nullptr,               /* hasInstance */
    nullptr,               /* construct */
    nullptr,               /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  eInterfacePrototype,
  &sWorkerNativePropertyHooks
};

void
CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray)
{
  JSObject* parentProto = EventTargetBinding_workers::GetProtoObject(aCx, aGlobal);
  if (!parentProto) {
    return;
  }


  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &PrototypeClass.mBase, &protoAndIfaceArray[prototypes::id::XMLHttpRequestEventTarget_workers],
                              nullptr, nullptr, 0, nullptr,
                              nullptr,
                              &sNativeProperties,
                              nullptr,
                              NULL);
}

} // namespace XMLHttpRequestEventTargetBinding_workers



} // namespace dom
} // namespace mozilla
