/* THIS FILE IS AUTOGENERATED - DO NOT EDIT */

#include "AccessCheck.h"
#include "CanvasRenderingContext2DBinding.h"
#include "HTMLImageElementBinding.h"
#include "ImageDataBinding.h"
#include "PrimitiveConversions.h"
#include "WebGLBuffer.h"
#include "WebGLContext.h"
#include "WebGLExtensions.h"
#include "WebGLFramebuffer.h"
#include "WebGLProgram.h"
#include "WebGLRenderbuffer.h"
#include "WebGLRenderingContextBinding.h"
#include "WebGLShader.h"
#include "WebGLShaderPrecisionFormat.h"
#include "WebGLTexture.h"
#include "WebGLUniformLocation.h"
#include "WorkerPrivate.h"
#include "XPCQuickStubs.h"
#include "XPCWrapper.h"
#include "jsfriendapi.h"
#include "mozilla/Preferences.h"
#include "mozilla/dom/BindingUtils.h"
#include "mozilla/dom/HTMLCanvasElement.h"
#include "mozilla/dom/HTMLImageElement.h"
#include "mozilla/dom/ImageData.h"
#include "mozilla/dom/NonRefcountedDOMObject.h"
#include "mozilla/dom/Nullable.h"
#include "mozilla/dom/TypedArray.h"
#include "nsContentUtils.h"
#include "nsDOMQS.h"
#include "nsHTMLVideoElement.h"

using namespace mozilla::dom;
namespace mozilla {
namespace dom {

bool
WebGLContextAttributesWorkers::Init(JSContext* cx, JSObject* scopeObj, const JS::Value& val)
{
  // Passing a null JSContext is OK only if we're initing from null,
  // Since in that case we will not have to do any property gets
  MOZ_ASSERT_IF(!cx, val.isNull());
  JSBool found;
  JS::Value temp;
  bool isNull = val.isNullOrUndefined();
  if (!IsConvertibleToDictionary(cx, val)) {
    return ThrowErrorMessage(cx, MSG_NOT_DICTIONARY);
  }

  if (isNull) {
    found = false;
  } else if (!JS_HasProperty(cx, &val.toObject(), "alpha", &found)) {
    return false;
  }
  if (found) {
    if (!JS_GetProperty(cx, &val.toObject(), "alpha", &temp)) {
      return false;
    }
  }
  if (found) {
    if (!ValueToPrimitive<bool, eDefault>(cx, temp, &mAlpha)) {
      return false;
    }
  } else {
    mAlpha = true;
  }

  if (isNull) {
    found = false;
  } else if (!JS_HasProperty(cx, &val.toObject(), "antialias", &found)) {
    return false;
  }
  if (found) {
    if (!JS_GetProperty(cx, &val.toObject(), "antialias", &temp)) {
      return false;
    }
  }
  if (found) {
    if (!ValueToPrimitive<bool, eDefault>(cx, temp, &mAntialias)) {
      return false;
    }
  } else {
    mAntialias = true;
  }

  if (isNull) {
    found = false;
  } else if (!JS_HasProperty(cx, &val.toObject(), "depth", &found)) {
    return false;
  }
  if (found) {
    if (!JS_GetProperty(cx, &val.toObject(), "depth", &temp)) {
      return false;
    }
  }
  if (found) {
    if (!ValueToPrimitive<bool, eDefault>(cx, temp, &mDepth)) {
      return false;
    }
  } else {
    mDepth = true;
  }

  if (isNull) {
    found = false;
  } else if (!JS_HasProperty(cx, &val.toObject(), "premultipliedAlpha", &found)) {
    return false;
  }
  if (found) {
    if (!JS_GetProperty(cx, &val.toObject(), "premultipliedAlpha", &temp)) {
      return false;
    }
  }
  if (found) {
    if (!ValueToPrimitive<bool, eDefault>(cx, temp, &mPremultipliedAlpha)) {
      return false;
    }
  } else {
    mPremultipliedAlpha = true;
  }

  if (isNull) {
    found = false;
  } else if (!JS_HasProperty(cx, &val.toObject(), "preserveDrawingBuffer", &found)) {
    return false;
  }
  if (found) {
    if (!JS_GetProperty(cx, &val.toObject(), "preserveDrawingBuffer", &temp)) {
      return false;
    }
  }
  if (found) {
    if (!ValueToPrimitive<bool, eDefault>(cx, temp, &mPreserveDrawingBuffer)) {
      return false;
    }
  } else {
    mPreserveDrawingBuffer = false;
  }

  if (isNull) {
    found = false;
  } else if (!JS_HasProperty(cx, &val.toObject(), "stencil", &found)) {
    return false;
  }
  if (found) {
    if (!JS_GetProperty(cx, &val.toObject(), "stencil", &temp)) {
      return false;
    }
  }
  if (found) {
    if (!ValueToPrimitive<bool, eDefault>(cx, temp, &mStencil)) {
      return false;
    }
  } else {
    mStencil = false;
  }
  return true;
}

bool
WebGLContextAttributesWorkers::ToObject(JSContext* cx, JSObject* parentObject, JS::Value *vp)
{
  JSObject* obj = JS_NewObject(cx, nullptr, nullptr, nullptr);
  if (!obj) {
    return false;
  }
  *vp = JS::ObjectValue(*obj);

  {
    // scope for 'temp' and 'currentValue'
    JS::Value temp;
    bool& currentValue = mAlpha;
    temp = BOOLEAN_TO_JSVAL(currentValue);
    if (!JS_DefineProperty(cx, obj, "alpha", temp, nullptr, nullptr, JSPROP_ENUMERATE)) {
      return false;
    }
  }

  {
    // scope for 'temp' and 'currentValue'
    JS::Value temp;
    bool& currentValue = mAntialias;
    temp = BOOLEAN_TO_JSVAL(currentValue);
    if (!JS_DefineProperty(cx, obj, "antialias", temp, nullptr, nullptr, JSPROP_ENUMERATE)) {
      return false;
    }
  }

  {
    // scope for 'temp' and 'currentValue'
    JS::Value temp;
    bool& currentValue = mDepth;
    temp = BOOLEAN_TO_JSVAL(currentValue);
    if (!JS_DefineProperty(cx, obj, "depth", temp, nullptr, nullptr, JSPROP_ENUMERATE)) {
      return false;
    }
  }

  {
    // scope for 'temp' and 'currentValue'
    JS::Value temp;
    bool& currentValue = mPremultipliedAlpha;
    temp = BOOLEAN_TO_JSVAL(currentValue);
    if (!JS_DefineProperty(cx, obj, "premultipliedAlpha", temp, nullptr, nullptr, JSPROP_ENUMERATE)) {
      return false;
    }
  }

  {
    // scope for 'temp' and 'currentValue'
    JS::Value temp;
    bool& currentValue = mPreserveDrawingBuffer;
    temp = BOOLEAN_TO_JSVAL(currentValue);
    if (!JS_DefineProperty(cx, obj, "preserveDrawingBuffer", temp, nullptr, nullptr, JSPROP_ENUMERATE)) {
      return false;
    }
  }

  {
    // scope for 'temp' and 'currentValue'
    JS::Value temp;
    bool& currentValue = mStencil;
    temp = BOOLEAN_TO_JSVAL(currentValue);
    if (!JS_DefineProperty(cx, obj, "stencil", temp, nullptr, nullptr, JSPROP_ENUMERATE)) {
      return false;
    }
  }

  return true;
}

bool WebGLContextAttributes::initedIds = false;
jsid WebGLContextAttributes::alpha_id = JSID_VOID;
jsid WebGLContextAttributes::antialias_id = JSID_VOID;
jsid WebGLContextAttributes::depth_id = JSID_VOID;
jsid WebGLContextAttributes::premultipliedAlpha_id = JSID_VOID;
jsid WebGLContextAttributes::preserveDrawingBuffer_id = JSID_VOID;
jsid WebGLContextAttributes::stencil_id = JSID_VOID;

bool
WebGLContextAttributes::InitIds(JSContext* cx)
{
  MOZ_ASSERT(!initedIds);
  if (!InternJSString(cx, alpha_id, "alpha") ||
      !InternJSString(cx, antialias_id, "antialias") ||
      !InternJSString(cx, depth_id, "depth") ||
      !InternJSString(cx, premultipliedAlpha_id, "premultipliedAlpha") ||
      !InternJSString(cx, preserveDrawingBuffer_id, "preserveDrawingBuffer") ||
      !InternJSString(cx, stencil_id, "stencil")) {
    return false;
  }
  initedIds = true;
  return true;
}

bool
WebGLContextAttributes::Init(JSContext* cx, JSObject* scopeObj, const JS::Value& val)
{
  // Passing a null JSContext is OK only if we're initing from null,
  // Since in that case we will not have to do any property gets
  MOZ_ASSERT_IF(!cx, val.isNull());
  if (cx && !initedIds && !InitIds(cx)) {
    return false;
  }
  JSBool found;
  JS::Value temp;
  bool isNull = val.isNullOrUndefined();
  if (!IsConvertibleToDictionary(cx, val)) {
    return ThrowErrorMessage(cx, MSG_NOT_DICTIONARY);
  }

  if (isNull) {
    found = false;
  } else if (!JS_HasPropertyById(cx, &val.toObject(), alpha_id, &found)) {
    return false;
  }
  if (found) {
    if (!JS_GetPropertyById(cx, &val.toObject(), alpha_id, &temp)) {
      return false;
    }
  }
  if (found) {
    if (!ValueToPrimitive<bool, eDefault>(cx, temp, &mAlpha)) {
      return false;
    }
  } else {
    mAlpha = true;
  }

  if (isNull) {
    found = false;
  } else if (!JS_HasPropertyById(cx, &val.toObject(), antialias_id, &found)) {
    return false;
  }
  if (found) {
    if (!JS_GetPropertyById(cx, &val.toObject(), antialias_id, &temp)) {
      return false;
    }
  }
  if (found) {
    if (!ValueToPrimitive<bool, eDefault>(cx, temp, &mAntialias)) {
      return false;
    }
  } else {
    mAntialias = true;
  }

  if (isNull) {
    found = false;
  } else if (!JS_HasPropertyById(cx, &val.toObject(), depth_id, &found)) {
    return false;
  }
  if (found) {
    if (!JS_GetPropertyById(cx, &val.toObject(), depth_id, &temp)) {
      return false;
    }
  }
  if (found) {
    if (!ValueToPrimitive<bool, eDefault>(cx, temp, &mDepth)) {
      return false;
    }
  } else {
    mDepth = true;
  }

  if (isNull) {
    found = false;
  } else if (!JS_HasPropertyById(cx, &val.toObject(), premultipliedAlpha_id, &found)) {
    return false;
  }
  if (found) {
    if (!JS_GetPropertyById(cx, &val.toObject(), premultipliedAlpha_id, &temp)) {
      return false;
    }
  }
  if (found) {
    if (!ValueToPrimitive<bool, eDefault>(cx, temp, &mPremultipliedAlpha)) {
      return false;
    }
  } else {
    mPremultipliedAlpha = true;
  }

  if (isNull) {
    found = false;
  } else if (!JS_HasPropertyById(cx, &val.toObject(), preserveDrawingBuffer_id, &found)) {
    return false;
  }
  if (found) {
    if (!JS_GetPropertyById(cx, &val.toObject(), preserveDrawingBuffer_id, &temp)) {
      return false;
    }
  }
  if (found) {
    if (!ValueToPrimitive<bool, eDefault>(cx, temp, &mPreserveDrawingBuffer)) {
      return false;
    }
  } else {
    mPreserveDrawingBuffer = false;
  }

  if (isNull) {
    found = false;
  } else if (!JS_HasPropertyById(cx, &val.toObject(), stencil_id, &found)) {
    return false;
  }
  if (found) {
    if (!JS_GetPropertyById(cx, &val.toObject(), stencil_id, &temp)) {
      return false;
    }
  }
  if (found) {
    if (!ValueToPrimitive<bool, eDefault>(cx, temp, &mStencil)) {
      return false;
    }
  } else {
    mStencil = false;
  }
  return true;
}

bool
WebGLContextAttributes::ToObject(JSContext* cx, JSObject* parentObject, JS::Value *vp)
{
  if (!initedIds && !InitIds(cx)) {
    return false;
  }
  JSObject* obj = JS_NewObject(cx, nullptr, nullptr, nullptr);
  if (!obj) {
    return false;
  }
  *vp = JS::ObjectValue(*obj);

  {
    // scope for 'temp' and 'currentValue'
    JS::Value temp;
    bool& currentValue = mAlpha;
    temp = BOOLEAN_TO_JSVAL(currentValue);
    if (!JS_DefinePropertyById(cx, obj, alpha_id, temp, nullptr, nullptr, JSPROP_ENUMERATE)) {
      return false;
    }
  }

  {
    // scope for 'temp' and 'currentValue'
    JS::Value temp;
    bool& currentValue = mAntialias;
    temp = BOOLEAN_TO_JSVAL(currentValue);
    if (!JS_DefinePropertyById(cx, obj, antialias_id, temp, nullptr, nullptr, JSPROP_ENUMERATE)) {
      return false;
    }
  }

  {
    // scope for 'temp' and 'currentValue'
    JS::Value temp;
    bool& currentValue = mDepth;
    temp = BOOLEAN_TO_JSVAL(currentValue);
    if (!JS_DefinePropertyById(cx, obj, depth_id, temp, nullptr, nullptr, JSPROP_ENUMERATE)) {
      return false;
    }
  }

  {
    // scope for 'temp' and 'currentValue'
    JS::Value temp;
    bool& currentValue = mPremultipliedAlpha;
    temp = BOOLEAN_TO_JSVAL(currentValue);
    if (!JS_DefinePropertyById(cx, obj, premultipliedAlpha_id, temp, nullptr, nullptr, JSPROP_ENUMERATE)) {
      return false;
    }
  }

  {
    // scope for 'temp' and 'currentValue'
    JS::Value temp;
    bool& currentValue = mPreserveDrawingBuffer;
    temp = BOOLEAN_TO_JSVAL(currentValue);
    if (!JS_DefinePropertyById(cx, obj, preserveDrawingBuffer_id, temp, nullptr, nullptr, JSPROP_ENUMERATE)) {
      return false;
    }
  }

  {
    // scope for 'temp' and 'currentValue'
    JS::Value temp;
    bool& currentValue = mStencil;
    temp = BOOLEAN_TO_JSVAL(currentValue);
    if (!JS_DefinePropertyById(cx, obj, stencil_id, temp, nullptr, nullptr, JSPROP_ENUMERATE)) {
      return false;
    }
  }

  return true;
}

namespace WebGLActiveInfoBinding {

static bool
get_size(JSContext* cx, JSHandleObject obj, mozilla::WebGLActiveInfo* self, JS::Value* vp)
{
  int32_t result;
  result = self->Size();
  *vp = INT_TO_JSVAL(int32_t(result));
  return true;
}


const JSJitInfo size_getterinfo = {
  (JSJitPropertyOp)get_size,
  prototypes::id::WebGLActiveInfo,
  PrototypeTraits<prototypes::id::WebGLActiveInfo>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_type(JSContext* cx, JSHandleObject obj, mozilla::WebGLActiveInfo* self, JS::Value* vp)
{
  uint32_t result;
  result = self->Type();
  *vp = UINT_TO_JSVAL(result);
  return true;
}


const JSJitInfo type_getterinfo = {
  (JSJitPropertyOp)get_type,
  prototypes::id::WebGLActiveInfo,
  PrototypeTraits<prototypes::id::WebGLActiveInfo>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_name(JSContext* cx, JSHandleObject obj, mozilla::WebGLActiveInfo* self, JS::Value* vp)
{
  nsString result;
  self->GetName(result);
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}


const JSJitInfo name_getterinfo = {
  (JSJitPropertyOp)get_name,
  prototypes::id::WebGLActiveInfo,
  PrototypeTraits<prototypes::id::WebGLActiveInfo>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

static JSBool
genericGetter(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  mozilla::WebGLActiveInfo* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::WebGLActiveInfo, mozilla::WebGLActiveInfo>(cx, obj, self);
    if (NS_FAILED(rv)) {
      return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "WebGLActiveInfo");
    }
  }
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Getter);
  JSJitPropertyOp getter = info->op;
  return getter(cx, obj, self, vp);
}

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::WebGLActiveInfo>::value), "Must be an nsISupports class");
  mozilla::WebGLActiveInfo* self = UnwrapDOMObject<mozilla::WebGLActiveInfo>(obj);
  if (self) {
    XPCJSRuntime *rt = nsXPConnect::GetRuntimeInstance();
    if (rt) {
      rt->DeferredRelease(reinterpret_cast<nsISupports*>(self));
    } else {
      NS_RELEASE(self);
    }
  }
}

static JSFunctionSpec sChromeMethods_specs[] = {
  JS_FNINFO("QueryInterface", QueryInterface, nullptr, 1, 0),
  JS_FS_END
};

static Prefable<JSFunctionSpec> sChromeMethods[] = {
  { true, &sChromeMethods_specs[0] },
  { false, NULL }
};

static jsid sChromeMethods_ids[2] = { JSID_VOID };

static JSPropertySpec sAttributes_specs[] = {
  { "size", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &size_getterinfo }, JSOP_NULLWRAPPER},
  { "type", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &type_getterinfo }, JSOP_NULLWRAPPER},
  { "name", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &name_getterinfo }, JSOP_NULLWRAPPER},
  { 0, 0, 0, JSOP_NULLWRAPPER, JSOP_NULLWRAPPER }
};

static Prefable<JSPropertySpec> sAttributes[] = {
  { true, &sAttributes_specs[0] },
  { false, NULL }
};

static jsid sAttributes_ids[4] = { JSID_VOID };


static const NativeProperties sNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sAttributes, sAttributes_ids, sAttributes_specs,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr
};

static const NativeProperties sChromeOnlyNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sChromeMethods, sChromeMethods_ids, sChromeMethods_specs,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr
};
const NativePropertyHooks sNativePropertyHooks = {
  nullptr,
  nullptr,
  { &sNativeProperties, &sChromeOnlyNativeProperties },
  prototypes::id::WebGLActiveInfo,
  constructors::id::WebGLActiveInfo,
  NULL
};

JSNativeHolder _constructor_holder = {
  ThrowingConstructor,
  &sNativePropertyHooks
};

static DOMIfaceAndProtoJSClass PrototypeClass = {
  {
    "WebGLActiveInfoPrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(2),
    JS_PropertyStub,       /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    nullptr,               /* finalize */
    nullptr,               /* checkAccess */
    nullptr,               /* call */
    nullptr,               /* hasInstance */
    nullptr,               /* construct */
    nullptr,               /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  eInterfacePrototype,
  &sNativePropertyHooks
};

void
CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray)
{
  JSObject* parentProto = JS_GetObjectPrototype(aCx, aGlobal);
  if (!parentProto) {
    return;
  }


  if (sChromeMethods_ids[0] == JSID_VOID &&
      (!InitIds(aCx, sChromeMethods, sChromeMethods_ids) ||
       !InitIds(aCx, sAttributes, sAttributes_ids))) {
    sChromeMethods_ids[0] = JSID_VOID;
    return;
  }

  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &PrototypeClass.mBase, &protoAndIfaceArray[prototypes::id::WebGLActiveInfo],
                              nullptr, &_constructor_holder, 0, &protoAndIfaceArray[constructors::id::WebGLActiveInfo],
                              &Class.mClass,
                              &sNativeProperties,
                              xpc::AccessCheck::isChrome(aGlobal) ? &sChromeOnlyNativeProperties : nullptr,
                              "WebGLActiveInfo");
}

JSObject*
DefineDOMInterface(JSContext* aCx, JSObject* aGlobal, bool* aEnabled)
{

  *aEnabled = true;
  return GetConstructorObject(aCx, aGlobal);
}


DOMJSClass Class = {
  { "WebGLActiveInfo",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(3),
    JS_PropertyStub, /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    _finalize, /* finalize */
    NULL,                  /* checkAccess */
    NULL,                  /* call */
    NULL,                  /* hasInstance */
    NULL,                  /* construct */
    NULL, /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  {
    { prototypes::id::WebGLActiveInfo, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
    true,
    &sNativePropertyHooks,
    GetParentObject<mozilla::WebGLActiveInfo>::Get,
    GetProtoObject,
    nullptr
  }
};

JSObject*
Wrap(JSContext* aCx, JSObject* aScope, mozilla::WebGLActiveInfo* aObject)
{
  MOZ_ASSERT(static_cast<mozilla::WebGLActiveInfo*>(aObject) ==
             reinterpret_cast<mozilla::WebGLActiveInfo*>(aObject));

  JSObject* global = JS_GetGlobalForObject(aCx, aScope);
  JSObject* proto = GetProtoObject(aCx, global);
  if (!proto) {
    return NULL;
  }

  JSObject* obj = JS_NewObject(aCx, &Class.mBase, proto, global);
  if (!obj) {
    return NULL;
  }

  js::SetReservedSlot(obj, DOM_OBJECT_SLOT, PRIVATE_TO_JSVAL(aObject));
  NS_ADDREF(aObject);


  return obj;
}

} // namespace WebGLActiveInfoBinding



namespace WebGLBufferBinding {

static JSBool
_addProperty(JSContext* cx, JSHandleObject obj, JSHandleId id, JSMutableHandleValue vp)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::WebGLBuffer>::value), "Must be an nsISupports class");
  mozilla::WebGLBuffer* self = UnwrapDOMObject<mozilla::WebGLBuffer>(obj);
  nsContentUtils::PreserveWrapper(reinterpret_cast<nsISupports*>(self), self);
  return true;
}

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::WebGLBuffer>::value), "Must be an nsISupports class");
  mozilla::WebGLBuffer* self = UnwrapDOMObject<mozilla::WebGLBuffer>(obj);
  if (self) {
    ClearWrapper(self, self);
    XPCJSRuntime *rt = nsXPConnect::GetRuntimeInstance();
    if (rt) {
      rt->DeferredRelease(reinterpret_cast<nsISupports*>(self));
    } else {
      NS_RELEASE(self);
    }
  }
}

static JSFunctionSpec sChromeMethods_specs[] = {
  JS_FNINFO("QueryInterface", QueryInterface, nullptr, 1, 0),
  JS_FS_END
};

static Prefable<JSFunctionSpec> sChromeMethods[] = {
  { true, &sChromeMethods_specs[0] },
  { false, NULL }
};

static jsid sChromeMethods_ids[2] = { JSID_VOID };


static const NativeProperties sChromeOnlyNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sChromeMethods, sChromeMethods_ids, sChromeMethods_specs,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr
};
const NativePropertyHooks sNativePropertyHooks = {
  nullptr,
  nullptr,
  { nullptr, &sChromeOnlyNativeProperties },
  prototypes::id::WebGLBuffer,
  constructors::id::WebGLBuffer,
  NULL
};

JSNativeHolder _constructor_holder = {
  ThrowingConstructor,
  &sNativePropertyHooks
};

static DOMIfaceAndProtoJSClass PrototypeClass = {
  {
    "WebGLBufferPrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(2),
    JS_PropertyStub,       /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    nullptr,               /* finalize */
    nullptr,               /* checkAccess */
    nullptr,               /* call */
    nullptr,               /* hasInstance */
    nullptr,               /* construct */
    nullptr,               /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  eInterfacePrototype,
  &sNativePropertyHooks
};

void
CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray)
{
  JSObject* parentProto = JS_GetObjectPrototype(aCx, aGlobal);
  if (!parentProto) {
    return;
  }


  if (sChromeMethods_ids[0] == JSID_VOID &&
      !InitIds(aCx, sChromeMethods, sChromeMethods_ids)) {
    sChromeMethods_ids[0] = JSID_VOID;
    return;
  }

  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &PrototypeClass.mBase, &protoAndIfaceArray[prototypes::id::WebGLBuffer],
                              nullptr, &_constructor_holder, 0, &protoAndIfaceArray[constructors::id::WebGLBuffer],
                              &Class.mClass,
                              nullptr,
                              xpc::AccessCheck::isChrome(aGlobal) ? &sChromeOnlyNativeProperties : nullptr,
                              "WebGLBuffer");
}

JSObject*
DefineDOMInterface(JSContext* aCx, JSObject* aGlobal, bool* aEnabled)
{

  *aEnabled = true;
  return GetConstructorObject(aCx, aGlobal);
}


DOMJSClass Class = {
  { "WebGLBuffer",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(3),
    _addProperty, /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    _finalize, /* finalize */
    NULL,                  /* checkAccess */
    NULL,                  /* call */
    NULL,                  /* hasInstance */
    NULL,                  /* construct */
    NULL, /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  {
    { prototypes::id::WebGLBuffer, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
    true,
    &sNativePropertyHooks,
    GetParentObject<mozilla::WebGLBuffer>::Get,
    GetProtoObject,
    nullptr
  }
};

JSObject*
Wrap(JSContext* aCx, JSObject* aScope, mozilla::WebGLBuffer* aObject, nsWrapperCache* aCache, bool* aTriedToWrap)
{
  MOZ_ASSERT(static_cast<mozilla::WebGLBuffer*>(aObject) ==
             reinterpret_cast<mozilla::WebGLBuffer*>(aObject));

  *aTriedToWrap = true;

  JSObject* parent = WrapNativeParent(aCx, aScope, aObject->GetParentObject());
  if (!parent) {
    return NULL;
  }

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.  Scope so we don't
  // collide with the "obj" we declare in CreateBindingJSObject.
  {
    JSObject* obj = aCache->GetWrapper();
    if (obj) {
      return obj;
    }
  }

  JSAutoCompartment ac(aCx, parent);
  JSObject* global = JS_GetGlobalForObject(aCx, parent);

  JSObject* proto = GetProtoObject(aCx, global);
  if (!proto) {
    return NULL;
  }

  JSObject* obj = JS_NewObject(aCx, &Class.mBase, proto, parent);
  if (!obj) {
    return NULL;
  }

  js::SetReservedSlot(obj, DOM_OBJECT_SLOT, PRIVATE_TO_JSVAL(aObject));
  NS_ADDREF(aObject);


  aCache->SetWrapper(obj);

  return obj;
}

} // namespace WebGLBufferBinding



namespace WebGLExtensionCompressedTextureATCBinding {

static JSBool
_addProperty(JSContext* cx, JSHandleObject obj, JSHandleId id, JSMutableHandleValue vp)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::WebGLExtensionCompressedTextureATC>::value), "Must be an nsISupports class");
  mozilla::WebGLExtensionCompressedTextureATC* self = UnwrapDOMObject<mozilla::WebGLExtensionCompressedTextureATC>(obj);
  nsContentUtils::PreserveWrapper(reinterpret_cast<nsISupports*>(self), self);
  return true;
}

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::WebGLExtensionCompressedTextureATC>::value), "Must be an nsISupports class");
  mozilla::WebGLExtensionCompressedTextureATC* self = UnwrapDOMObject<mozilla::WebGLExtensionCompressedTextureATC>(obj);
  if (self) {
    ClearWrapper(self, self);
    XPCJSRuntime *rt = nsXPConnect::GetRuntimeInstance();
    if (rt) {
      rt->DeferredRelease(reinterpret_cast<nsISupports*>(self));
    } else {
      NS_RELEASE(self);
    }
  }
}

static JSFunctionSpec sChromeMethods_specs[] = {
  JS_FNINFO("QueryInterface", QueryInterface, nullptr, 1, 0),
  JS_FS_END
};

static Prefable<JSFunctionSpec> sChromeMethods[] = {
  { true, &sChromeMethods_specs[0] },
  { false, NULL }
};

static jsid sChromeMethods_ids[2] = { JSID_VOID };

static ConstantSpec sConstants_specs[] = {
  { "COMPRESSED_RGB_ATC_WEBGL", UINT_TO_JSVAL(35986) },
  { "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL", UINT_TO_JSVAL(35987) },
  { "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL", UINT_TO_JSVAL(34798) },
  { 0, JSVAL_VOID }
};

static Prefable<ConstantSpec> sConstants[] = {
  { true, &sConstants_specs[0] },
  { false, NULL }
};

static jsid sConstants_ids[4] = { JSID_VOID };


static const NativeProperties sNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sConstants, sConstants_ids, sConstants_specs
};

static const NativeProperties sChromeOnlyNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sChromeMethods, sChromeMethods_ids, sChromeMethods_specs,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr
};
const NativePropertyHooks sNativePropertyHooks = {
  nullptr,
  nullptr,
  { &sNativeProperties, &sChromeOnlyNativeProperties },
  prototypes::id::WebGLExtensionCompressedTextureATC,
  constructors::id::_ID_Count,
  NULL
};

static DOMIfaceAndProtoJSClass PrototypeClass = {
  {
    "WebGLExtensionCompressedTextureATCPrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(2),
    JS_PropertyStub,       /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    nullptr,               /* finalize */
    nullptr,               /* checkAccess */
    nullptr,               /* call */
    nullptr,               /* hasInstance */
    nullptr,               /* construct */
    nullptr,               /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  eInterfacePrototype,
  &sNativePropertyHooks
};

void
CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray)
{
  JSObject* parentProto = JS_GetObjectPrototype(aCx, aGlobal);
  if (!parentProto) {
    return;
  }


  if (sChromeMethods_ids[0] == JSID_VOID &&
      (!InitIds(aCx, sChromeMethods, sChromeMethods_ids) ||
       !InitIds(aCx, sConstants, sConstants_ids))) {
    sChromeMethods_ids[0] = JSID_VOID;
    return;
  }

  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &PrototypeClass.mBase, &protoAndIfaceArray[prototypes::id::WebGLExtensionCompressedTextureATC],
                              nullptr, nullptr, 0, nullptr,
                              &Class.mClass,
                              &sNativeProperties,
                              xpc::AccessCheck::isChrome(aGlobal) ? &sChromeOnlyNativeProperties : nullptr,
                              NULL);
}


DOMJSClass Class = {
  { "WebGLExtensionCompressedTextureATC",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(3),
    _addProperty, /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    _finalize, /* finalize */
    NULL,                  /* checkAccess */
    NULL,                  /* call */
    NULL,                  /* hasInstance */
    NULL,                  /* construct */
    NULL, /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  {
    { prototypes::id::WebGLExtensionCompressedTextureATC, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
    true,
    &sNativePropertyHooks,
    GetParentObject<mozilla::WebGLExtensionCompressedTextureATC>::Get,
    GetProtoObject,
    nullptr
  }
};

JSObject*
Wrap(JSContext* aCx, JSObject* aScope, mozilla::WebGLExtensionCompressedTextureATC* aObject, nsWrapperCache* aCache, bool* aTriedToWrap)
{
  MOZ_ASSERT(static_cast<mozilla::WebGLExtensionCompressedTextureATC*>(aObject) ==
             reinterpret_cast<mozilla::WebGLExtensionCompressedTextureATC*>(aObject));

  *aTriedToWrap = true;

  JSObject* parent = WrapNativeParent(aCx, aScope, aObject->GetParentObject());
  if (!parent) {
    return NULL;
  }

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.  Scope so we don't
  // collide with the "obj" we declare in CreateBindingJSObject.
  {
    JSObject* obj = aCache->GetWrapper();
    if (obj) {
      return obj;
    }
  }

  JSAutoCompartment ac(aCx, parent);
  JSObject* global = JS_GetGlobalForObject(aCx, parent);

  JSObject* proto = GetProtoObject(aCx, global);
  if (!proto) {
    return NULL;
  }

  JSObject* obj = JS_NewObject(aCx, &Class.mBase, proto, parent);
  if (!obj) {
    return NULL;
  }

  js::SetReservedSlot(obj, DOM_OBJECT_SLOT, PRIVATE_TO_JSVAL(aObject));
  NS_ADDREF(aObject);


  aCache->SetWrapper(obj);

  return obj;
}

} // namespace WebGLExtensionCompressedTextureATCBinding



namespace WebGLExtensionCompressedTexturePVRTCBinding {

static JSBool
_addProperty(JSContext* cx, JSHandleObject obj, JSHandleId id, JSMutableHandleValue vp)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::WebGLExtensionCompressedTexturePVRTC>::value), "Must be an nsISupports class");
  mozilla::WebGLExtensionCompressedTexturePVRTC* self = UnwrapDOMObject<mozilla::WebGLExtensionCompressedTexturePVRTC>(obj);
  nsContentUtils::PreserveWrapper(reinterpret_cast<nsISupports*>(self), self);
  return true;
}

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::WebGLExtensionCompressedTexturePVRTC>::value), "Must be an nsISupports class");
  mozilla::WebGLExtensionCompressedTexturePVRTC* self = UnwrapDOMObject<mozilla::WebGLExtensionCompressedTexturePVRTC>(obj);
  if (self) {
    ClearWrapper(self, self);
    XPCJSRuntime *rt = nsXPConnect::GetRuntimeInstance();
    if (rt) {
      rt->DeferredRelease(reinterpret_cast<nsISupports*>(self));
    } else {
      NS_RELEASE(self);
    }
  }
}

static JSFunctionSpec sChromeMethods_specs[] = {
  JS_FNINFO("QueryInterface", QueryInterface, nullptr, 1, 0),
  JS_FS_END
};

static Prefable<JSFunctionSpec> sChromeMethods[] = {
  { true, &sChromeMethods_specs[0] },
  { false, NULL }
};

static jsid sChromeMethods_ids[2] = { JSID_VOID };

static ConstantSpec sConstants_specs[] = {
  { "COMPRESSED_RGB_PVRTC_4BPPV1", UINT_TO_JSVAL(35840) },
  { "COMPRESSED_RGB_PVRTC_2BPPV1", UINT_TO_JSVAL(35841) },
  { "COMPRESSED_RGBA_PVRTC_4BPPV1", UINT_TO_JSVAL(35842) },
  { "COMPRESSED_RGBA_PVRTC_2BPPV1", UINT_TO_JSVAL(35843) },
  { 0, JSVAL_VOID }
};

static Prefable<ConstantSpec> sConstants[] = {
  { true, &sConstants_specs[0] },
  { false, NULL }
};

static jsid sConstants_ids[5] = { JSID_VOID };


static const NativeProperties sNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sConstants, sConstants_ids, sConstants_specs
};

static const NativeProperties sChromeOnlyNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sChromeMethods, sChromeMethods_ids, sChromeMethods_specs,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr
};
const NativePropertyHooks sNativePropertyHooks = {
  nullptr,
  nullptr,
  { &sNativeProperties, &sChromeOnlyNativeProperties },
  prototypes::id::WebGLExtensionCompressedTexturePVRTC,
  constructors::id::_ID_Count,
  NULL
};

static DOMIfaceAndProtoJSClass PrototypeClass = {
  {
    "WebGLExtensionCompressedTexturePVRTCPrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(2),
    JS_PropertyStub,       /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    nullptr,               /* finalize */
    nullptr,               /* checkAccess */
    nullptr,               /* call */
    nullptr,               /* hasInstance */
    nullptr,               /* construct */
    nullptr,               /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  eInterfacePrototype,
  &sNativePropertyHooks
};

void
CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray)
{
  JSObject* parentProto = JS_GetObjectPrototype(aCx, aGlobal);
  if (!parentProto) {
    return;
  }


  if (sChromeMethods_ids[0] == JSID_VOID &&
      (!InitIds(aCx, sChromeMethods, sChromeMethods_ids) ||
       !InitIds(aCx, sConstants, sConstants_ids))) {
    sChromeMethods_ids[0] = JSID_VOID;
    return;
  }

  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &PrototypeClass.mBase, &protoAndIfaceArray[prototypes::id::WebGLExtensionCompressedTexturePVRTC],
                              nullptr, nullptr, 0, nullptr,
                              &Class.mClass,
                              &sNativeProperties,
                              xpc::AccessCheck::isChrome(aGlobal) ? &sChromeOnlyNativeProperties : nullptr,
                              NULL);
}


DOMJSClass Class = {
  { "WebGLExtensionCompressedTexturePVRTC",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(3),
    _addProperty, /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    _finalize, /* finalize */
    NULL,                  /* checkAccess */
    NULL,                  /* call */
    NULL,                  /* hasInstance */
    NULL,                  /* construct */
    NULL, /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  {
    { prototypes::id::WebGLExtensionCompressedTexturePVRTC, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
    true,
    &sNativePropertyHooks,
    GetParentObject<mozilla::WebGLExtensionCompressedTexturePVRTC>::Get,
    GetProtoObject,
    nullptr
  }
};

JSObject*
Wrap(JSContext* aCx, JSObject* aScope, mozilla::WebGLExtensionCompressedTexturePVRTC* aObject, nsWrapperCache* aCache, bool* aTriedToWrap)
{
  MOZ_ASSERT(static_cast<mozilla::WebGLExtensionCompressedTexturePVRTC*>(aObject) ==
             reinterpret_cast<mozilla::WebGLExtensionCompressedTexturePVRTC*>(aObject));

  *aTriedToWrap = true;

  JSObject* parent = WrapNativeParent(aCx, aScope, aObject->GetParentObject());
  if (!parent) {
    return NULL;
  }

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.  Scope so we don't
  // collide with the "obj" we declare in CreateBindingJSObject.
  {
    JSObject* obj = aCache->GetWrapper();
    if (obj) {
      return obj;
    }
  }

  JSAutoCompartment ac(aCx, parent);
  JSObject* global = JS_GetGlobalForObject(aCx, parent);

  JSObject* proto = GetProtoObject(aCx, global);
  if (!proto) {
    return NULL;
  }

  JSObject* obj = JS_NewObject(aCx, &Class.mBase, proto, parent);
  if (!obj) {
    return NULL;
  }

  js::SetReservedSlot(obj, DOM_OBJECT_SLOT, PRIVATE_TO_JSVAL(aObject));
  NS_ADDREF(aObject);


  aCache->SetWrapper(obj);

  return obj;
}

} // namespace WebGLExtensionCompressedTexturePVRTCBinding



namespace WebGLExtensionCompressedTextureS3TCBinding {

static JSBool
_addProperty(JSContext* cx, JSHandleObject obj, JSHandleId id, JSMutableHandleValue vp)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::WebGLExtensionCompressedTextureS3TC>::value), "Must be an nsISupports class");
  mozilla::WebGLExtensionCompressedTextureS3TC* self = UnwrapDOMObject<mozilla::WebGLExtensionCompressedTextureS3TC>(obj);
  nsContentUtils::PreserveWrapper(reinterpret_cast<nsISupports*>(self), self);
  return true;
}

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::WebGLExtensionCompressedTextureS3TC>::value), "Must be an nsISupports class");
  mozilla::WebGLExtensionCompressedTextureS3TC* self = UnwrapDOMObject<mozilla::WebGLExtensionCompressedTextureS3TC>(obj);
  if (self) {
    ClearWrapper(self, self);
    XPCJSRuntime *rt = nsXPConnect::GetRuntimeInstance();
    if (rt) {
      rt->DeferredRelease(reinterpret_cast<nsISupports*>(self));
    } else {
      NS_RELEASE(self);
    }
  }
}

static JSFunctionSpec sChromeMethods_specs[] = {
  JS_FNINFO("QueryInterface", QueryInterface, nullptr, 1, 0),
  JS_FS_END
};

static Prefable<JSFunctionSpec> sChromeMethods[] = {
  { true, &sChromeMethods_specs[0] },
  { false, NULL }
};

static jsid sChromeMethods_ids[2] = { JSID_VOID };

static ConstantSpec sConstants_specs[] = {
  { "COMPRESSED_RGB_S3TC_DXT1_EXT", UINT_TO_JSVAL(33776) },
  { "COMPRESSED_RGBA_S3TC_DXT1_EXT", UINT_TO_JSVAL(33777) },
  { "COMPRESSED_RGBA_S3TC_DXT3_EXT", UINT_TO_JSVAL(33778) },
  { "COMPRESSED_RGBA_S3TC_DXT5_EXT", UINT_TO_JSVAL(33779) },
  { 0, JSVAL_VOID }
};

static Prefable<ConstantSpec> sConstants[] = {
  { true, &sConstants_specs[0] },
  { false, NULL }
};

static jsid sConstants_ids[5] = { JSID_VOID };


static const NativeProperties sNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sConstants, sConstants_ids, sConstants_specs
};

static const NativeProperties sChromeOnlyNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sChromeMethods, sChromeMethods_ids, sChromeMethods_specs,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr
};
const NativePropertyHooks sNativePropertyHooks = {
  nullptr,
  nullptr,
  { &sNativeProperties, &sChromeOnlyNativeProperties },
  prototypes::id::WebGLExtensionCompressedTextureS3TC,
  constructors::id::_ID_Count,
  NULL
};

static DOMIfaceAndProtoJSClass PrototypeClass = {
  {
    "WebGLExtensionCompressedTextureS3TCPrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(2),
    JS_PropertyStub,       /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    nullptr,               /* finalize */
    nullptr,               /* checkAccess */
    nullptr,               /* call */
    nullptr,               /* hasInstance */
    nullptr,               /* construct */
    nullptr,               /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  eInterfacePrototype,
  &sNativePropertyHooks
};

void
CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray)
{
  JSObject* parentProto = JS_GetObjectPrototype(aCx, aGlobal);
  if (!parentProto) {
    return;
  }


  if (sChromeMethods_ids[0] == JSID_VOID &&
      (!InitIds(aCx, sChromeMethods, sChromeMethods_ids) ||
       !InitIds(aCx, sConstants, sConstants_ids))) {
    sChromeMethods_ids[0] = JSID_VOID;
    return;
  }

  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &PrototypeClass.mBase, &protoAndIfaceArray[prototypes::id::WebGLExtensionCompressedTextureS3TC],
                              nullptr, nullptr, 0, nullptr,
                              &Class.mClass,
                              &sNativeProperties,
                              xpc::AccessCheck::isChrome(aGlobal) ? &sChromeOnlyNativeProperties : nullptr,
                              NULL);
}


DOMJSClass Class = {
  { "WebGLExtensionCompressedTextureS3TC",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(3),
    _addProperty, /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    _finalize, /* finalize */
    NULL,                  /* checkAccess */
    NULL,                  /* call */
    NULL,                  /* hasInstance */
    NULL,                  /* construct */
    NULL, /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  {
    { prototypes::id::WebGLExtensionCompressedTextureS3TC, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
    true,
    &sNativePropertyHooks,
    GetParentObject<mozilla::WebGLExtensionCompressedTextureS3TC>::Get,
    GetProtoObject,
    nullptr
  }
};

JSObject*
Wrap(JSContext* aCx, JSObject* aScope, mozilla::WebGLExtensionCompressedTextureS3TC* aObject, nsWrapperCache* aCache, bool* aTriedToWrap)
{
  MOZ_ASSERT(static_cast<mozilla::WebGLExtensionCompressedTextureS3TC*>(aObject) ==
             reinterpret_cast<mozilla::WebGLExtensionCompressedTextureS3TC*>(aObject));

  *aTriedToWrap = true;

  JSObject* parent = WrapNativeParent(aCx, aScope, aObject->GetParentObject());
  if (!parent) {
    return NULL;
  }

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.  Scope so we don't
  // collide with the "obj" we declare in CreateBindingJSObject.
  {
    JSObject* obj = aCache->GetWrapper();
    if (obj) {
      return obj;
    }
  }

  JSAutoCompartment ac(aCx, parent);
  JSObject* global = JS_GetGlobalForObject(aCx, parent);

  JSObject* proto = GetProtoObject(aCx, global);
  if (!proto) {
    return NULL;
  }

  JSObject* obj = JS_NewObject(aCx, &Class.mBase, proto, parent);
  if (!obj) {
    return NULL;
  }

  js::SetReservedSlot(obj, DOM_OBJECT_SLOT, PRIVATE_TO_JSVAL(aObject));
  NS_ADDREF(aObject);


  aCache->SetWrapper(obj);

  return obj;
}

} // namespace WebGLExtensionCompressedTextureS3TCBinding



namespace WebGLExtensionDebugRendererInfoBinding {

static JSBool
_addProperty(JSContext* cx, JSHandleObject obj, JSHandleId id, JSMutableHandleValue vp)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::WebGLExtensionDebugRendererInfo>::value), "Must be an nsISupports class");
  mozilla::WebGLExtensionDebugRendererInfo* self = UnwrapDOMObject<mozilla::WebGLExtensionDebugRendererInfo>(obj);
  nsContentUtils::PreserveWrapper(reinterpret_cast<nsISupports*>(self), self);
  return true;
}

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::WebGLExtensionDebugRendererInfo>::value), "Must be an nsISupports class");
  mozilla::WebGLExtensionDebugRendererInfo* self = UnwrapDOMObject<mozilla::WebGLExtensionDebugRendererInfo>(obj);
  if (self) {
    ClearWrapper(self, self);
    XPCJSRuntime *rt = nsXPConnect::GetRuntimeInstance();
    if (rt) {
      rt->DeferredRelease(reinterpret_cast<nsISupports*>(self));
    } else {
      NS_RELEASE(self);
    }
  }
}

static JSFunctionSpec sChromeMethods_specs[] = {
  JS_FNINFO("QueryInterface", QueryInterface, nullptr, 1, 0),
  JS_FS_END
};

static Prefable<JSFunctionSpec> sChromeMethods[] = {
  { true, &sChromeMethods_specs[0] },
  { false, NULL }
};

static jsid sChromeMethods_ids[2] = { JSID_VOID };

static ConstantSpec sConstants_specs[] = {
  { "UNMASKED_VENDOR_WEBGL", UINT_TO_JSVAL(37445) },
  { "UNMASKED_RENDERER_WEBGL", UINT_TO_JSVAL(37446) },
  { 0, JSVAL_VOID }
};

static Prefable<ConstantSpec> sConstants[] = {
  { true, &sConstants_specs[0] },
  { false, NULL }
};

static jsid sConstants_ids[3] = { JSID_VOID };


static const NativeProperties sNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sConstants, sConstants_ids, sConstants_specs
};

static const NativeProperties sChromeOnlyNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sChromeMethods, sChromeMethods_ids, sChromeMethods_specs,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr
};
const NativePropertyHooks sNativePropertyHooks = {
  nullptr,
  nullptr,
  { &sNativeProperties, &sChromeOnlyNativeProperties },
  prototypes::id::WebGLExtensionDebugRendererInfo,
  constructors::id::_ID_Count,
  NULL
};

static DOMIfaceAndProtoJSClass PrototypeClass = {
  {
    "WebGLExtensionDebugRendererInfoPrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(2),
    JS_PropertyStub,       /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    nullptr,               /* finalize */
    nullptr,               /* checkAccess */
    nullptr,               /* call */
    nullptr,               /* hasInstance */
    nullptr,               /* construct */
    nullptr,               /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  eInterfacePrototype,
  &sNativePropertyHooks
};

void
CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray)
{
  JSObject* parentProto = JS_GetObjectPrototype(aCx, aGlobal);
  if (!parentProto) {
    return;
  }


  if (sChromeMethods_ids[0] == JSID_VOID &&
      (!InitIds(aCx, sChromeMethods, sChromeMethods_ids) ||
       !InitIds(aCx, sConstants, sConstants_ids))) {
    sChromeMethods_ids[0] = JSID_VOID;
    return;
  }

  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &PrototypeClass.mBase, &protoAndIfaceArray[prototypes::id::WebGLExtensionDebugRendererInfo],
                              nullptr, nullptr, 0, nullptr,
                              &Class.mClass,
                              &sNativeProperties,
                              xpc::AccessCheck::isChrome(aGlobal) ? &sChromeOnlyNativeProperties : nullptr,
                              NULL);
}


DOMJSClass Class = {
  { "WebGLExtensionDebugRendererInfo",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(3),
    _addProperty, /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    _finalize, /* finalize */
    NULL,                  /* checkAccess */
    NULL,                  /* call */
    NULL,                  /* hasInstance */
    NULL,                  /* construct */
    NULL, /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  {
    { prototypes::id::WebGLExtensionDebugRendererInfo, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
    true,
    &sNativePropertyHooks,
    GetParentObject<mozilla::WebGLExtensionDebugRendererInfo>::Get,
    GetProtoObject,
    nullptr
  }
};

JSObject*
Wrap(JSContext* aCx, JSObject* aScope, mozilla::WebGLExtensionDebugRendererInfo* aObject, nsWrapperCache* aCache, bool* aTriedToWrap)
{
  MOZ_ASSERT(static_cast<mozilla::WebGLExtensionDebugRendererInfo*>(aObject) ==
             reinterpret_cast<mozilla::WebGLExtensionDebugRendererInfo*>(aObject));

  *aTriedToWrap = true;

  JSObject* parent = WrapNativeParent(aCx, aScope, aObject->GetParentObject());
  if (!parent) {
    return NULL;
  }

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.  Scope so we don't
  // collide with the "obj" we declare in CreateBindingJSObject.
  {
    JSObject* obj = aCache->GetWrapper();
    if (obj) {
      return obj;
    }
  }

  JSAutoCompartment ac(aCx, parent);
  JSObject* global = JS_GetGlobalForObject(aCx, parent);

  JSObject* proto = GetProtoObject(aCx, global);
  if (!proto) {
    return NULL;
  }

  JSObject* obj = JS_NewObject(aCx, &Class.mBase, proto, parent);
  if (!obj) {
    return NULL;
  }

  js::SetReservedSlot(obj, DOM_OBJECT_SLOT, PRIVATE_TO_JSVAL(aObject));
  NS_ADDREF(aObject);


  aCache->SetWrapper(obj);

  return obj;
}

} // namespace WebGLExtensionDebugRendererInfoBinding



namespace WebGLExtensionDepthTextureBinding {

static JSBool
_addProperty(JSContext* cx, JSHandleObject obj, JSHandleId id, JSMutableHandleValue vp)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::WebGLExtensionDepthTexture>::value), "Must be an nsISupports class");
  mozilla::WebGLExtensionDepthTexture* self = UnwrapDOMObject<mozilla::WebGLExtensionDepthTexture>(obj);
  nsContentUtils::PreserveWrapper(reinterpret_cast<nsISupports*>(self), self);
  return true;
}

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::WebGLExtensionDepthTexture>::value), "Must be an nsISupports class");
  mozilla::WebGLExtensionDepthTexture* self = UnwrapDOMObject<mozilla::WebGLExtensionDepthTexture>(obj);
  if (self) {
    ClearWrapper(self, self);
    XPCJSRuntime *rt = nsXPConnect::GetRuntimeInstance();
    if (rt) {
      rt->DeferredRelease(reinterpret_cast<nsISupports*>(self));
    } else {
      NS_RELEASE(self);
    }
  }
}

static JSFunctionSpec sChromeMethods_specs[] = {
  JS_FNINFO("QueryInterface", QueryInterface, nullptr, 1, 0),
  JS_FS_END
};

static Prefable<JSFunctionSpec> sChromeMethods[] = {
  { true, &sChromeMethods_specs[0] },
  { false, NULL }
};

static jsid sChromeMethods_ids[2] = { JSID_VOID };

static ConstantSpec sConstants_specs[] = {
  { "UNSIGNED_INT_24_8_WEBGL", UINT_TO_JSVAL(34042) },
  { 0, JSVAL_VOID }
};

static Prefable<ConstantSpec> sConstants[] = {
  { true, &sConstants_specs[0] },
  { false, NULL }
};

static jsid sConstants_ids[2] = { JSID_VOID };


static const NativeProperties sNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sConstants, sConstants_ids, sConstants_specs
};

static const NativeProperties sChromeOnlyNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sChromeMethods, sChromeMethods_ids, sChromeMethods_specs,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr
};
const NativePropertyHooks sNativePropertyHooks = {
  nullptr,
  nullptr,
  { &sNativeProperties, &sChromeOnlyNativeProperties },
  prototypes::id::WebGLExtensionDepthTexture,
  constructors::id::_ID_Count,
  NULL
};

static DOMIfaceAndProtoJSClass PrototypeClass = {
  {
    "WebGLExtensionDepthTexturePrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(2),
    JS_PropertyStub,       /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    nullptr,               /* finalize */
    nullptr,               /* checkAccess */
    nullptr,               /* call */
    nullptr,               /* hasInstance */
    nullptr,               /* construct */
    nullptr,               /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  eInterfacePrototype,
  &sNativePropertyHooks
};

void
CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray)
{
  JSObject* parentProto = JS_GetObjectPrototype(aCx, aGlobal);
  if (!parentProto) {
    return;
  }


  if (sChromeMethods_ids[0] == JSID_VOID &&
      (!InitIds(aCx, sChromeMethods, sChromeMethods_ids) ||
       !InitIds(aCx, sConstants, sConstants_ids))) {
    sChromeMethods_ids[0] = JSID_VOID;
    return;
  }

  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &PrototypeClass.mBase, &protoAndIfaceArray[prototypes::id::WebGLExtensionDepthTexture],
                              nullptr, nullptr, 0, nullptr,
                              &Class.mClass,
                              &sNativeProperties,
                              xpc::AccessCheck::isChrome(aGlobal) ? &sChromeOnlyNativeProperties : nullptr,
                              NULL);
}


DOMJSClass Class = {
  { "WebGLExtensionDepthTexture",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(3),
    _addProperty, /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    _finalize, /* finalize */
    NULL,                  /* checkAccess */
    NULL,                  /* call */
    NULL,                  /* hasInstance */
    NULL,                  /* construct */
    NULL, /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  {
    { prototypes::id::WebGLExtensionDepthTexture, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
    true,
    &sNativePropertyHooks,
    GetParentObject<mozilla::WebGLExtensionDepthTexture>::Get,
    GetProtoObject,
    nullptr
  }
};

JSObject*
Wrap(JSContext* aCx, JSObject* aScope, mozilla::WebGLExtensionDepthTexture* aObject, nsWrapperCache* aCache, bool* aTriedToWrap)
{
  MOZ_ASSERT(static_cast<mozilla::WebGLExtensionDepthTexture*>(aObject) ==
             reinterpret_cast<mozilla::WebGLExtensionDepthTexture*>(aObject));

  *aTriedToWrap = true;

  JSObject* parent = WrapNativeParent(aCx, aScope, aObject->GetParentObject());
  if (!parent) {
    return NULL;
  }

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.  Scope so we don't
  // collide with the "obj" we declare in CreateBindingJSObject.
  {
    JSObject* obj = aCache->GetWrapper();
    if (obj) {
      return obj;
    }
  }

  JSAutoCompartment ac(aCx, parent);
  JSObject* global = JS_GetGlobalForObject(aCx, parent);

  JSObject* proto = GetProtoObject(aCx, global);
  if (!proto) {
    return NULL;
  }

  JSObject* obj = JS_NewObject(aCx, &Class.mBase, proto, parent);
  if (!obj) {
    return NULL;
  }

  js::SetReservedSlot(obj, DOM_OBJECT_SLOT, PRIVATE_TO_JSVAL(aObject));
  NS_ADDREF(aObject);


  aCache->SetWrapper(obj);

  return obj;
}

} // namespace WebGLExtensionDepthTextureBinding



namespace WebGLExtensionLoseContextBinding {

static bool
loseContext(JSContext* cx, JSHandleObject obj, mozilla::WebGLExtensionLoseContext* self, unsigned argc, JS::Value* vp)
{
  self->LoseContext();
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo loseContext_methodinfo = {
  (JSJitPropertyOp)loseContext,
  prototypes::id::WebGLExtensionLoseContext,
  PrototypeTraits<prototypes::id::WebGLExtensionLoseContext>::Depth,
  JSJitInfo::Method,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
restoreContext(JSContext* cx, JSHandleObject obj, mozilla::WebGLExtensionLoseContext* self, unsigned argc, JS::Value* vp)
{
  self->RestoreContext();
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo restoreContext_methodinfo = {
  (JSJitPropertyOp)restoreContext,
  prototypes::id::WebGLExtensionLoseContext,
  PrototypeTraits<prototypes::id::WebGLExtensionLoseContext>::Depth,
  JSJitInfo::Method,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static JSBool
genericMethod(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  mozilla::WebGLExtensionLoseContext* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::WebGLExtensionLoseContext, mozilla::WebGLExtensionLoseContext>(cx, obj, self);
    if (NS_FAILED(rv)) {
      return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "WebGLExtensionLoseContext");
    }
  }
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Method);
  JSJitMethodOp method = (JSJitMethodOp)info->op;
  return method(cx, obj, self, argc, vp);
}

static JSBool
_addProperty(JSContext* cx, JSHandleObject obj, JSHandleId id, JSMutableHandleValue vp)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::WebGLExtensionLoseContext>::value), "Must be an nsISupports class");
  mozilla::WebGLExtensionLoseContext* self = UnwrapDOMObject<mozilla::WebGLExtensionLoseContext>(obj);
  nsContentUtils::PreserveWrapper(reinterpret_cast<nsISupports*>(self), self);
  return true;
}

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::WebGLExtensionLoseContext>::value), "Must be an nsISupports class");
  mozilla::WebGLExtensionLoseContext* self = UnwrapDOMObject<mozilla::WebGLExtensionLoseContext>(obj);
  if (self) {
    ClearWrapper(self, self);
    XPCJSRuntime *rt = nsXPConnect::GetRuntimeInstance();
    if (rt) {
      rt->DeferredRelease(reinterpret_cast<nsISupports*>(self));
    } else {
      NS_RELEASE(self);
    }
  }
}

static JSFunctionSpec sMethods_specs[] = {
  JS_FNINFO("loseContext", genericMethod, &loseContext_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("restoreContext", genericMethod, &restoreContext_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FS_END
};

static Prefable<JSFunctionSpec> sMethods[] = {
  { true, &sMethods_specs[0] },
  { false, NULL }
};

static jsid sMethods_ids[3] = { JSID_VOID };

static JSFunctionSpec sChromeMethods_specs[] = {
  JS_FNINFO("QueryInterface", QueryInterface, nullptr, 1, 0),
  JS_FS_END
};

static Prefable<JSFunctionSpec> sChromeMethods[] = {
  { true, &sChromeMethods_specs[0] },
  { false, NULL }
};

static jsid sChromeMethods_ids[2] = { JSID_VOID };


static const NativeProperties sNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sMethods, sMethods_ids, sMethods_specs,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr
};

static const NativeProperties sChromeOnlyNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sChromeMethods, sChromeMethods_ids, sChromeMethods_specs,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr
};
const NativePropertyHooks sNativePropertyHooks = {
  nullptr,
  nullptr,
  { &sNativeProperties, &sChromeOnlyNativeProperties },
  prototypes::id::WebGLExtensionLoseContext,
  constructors::id::_ID_Count,
  NULL
};

static DOMIfaceAndProtoJSClass PrototypeClass = {
  {
    "WebGLExtensionLoseContextPrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(2),
    JS_PropertyStub,       /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    nullptr,               /* finalize */
    nullptr,               /* checkAccess */
    nullptr,               /* call */
    nullptr,               /* hasInstance */
    nullptr,               /* construct */
    nullptr,               /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  eInterfacePrototype,
  &sNativePropertyHooks
};

void
CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray)
{
  JSObject* parentProto = JS_GetObjectPrototype(aCx, aGlobal);
  if (!parentProto) {
    return;
  }


  if (sChromeMethods_ids[0] == JSID_VOID &&
      (!InitIds(aCx, sChromeMethods, sChromeMethods_ids) ||
       !InitIds(aCx, sMethods, sMethods_ids))) {
    sChromeMethods_ids[0] = JSID_VOID;
    return;
  }

  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &PrototypeClass.mBase, &protoAndIfaceArray[prototypes::id::WebGLExtensionLoseContext],
                              nullptr, nullptr, 0, nullptr,
                              &Class.mClass,
                              &sNativeProperties,
                              xpc::AccessCheck::isChrome(aGlobal) ? &sChromeOnlyNativeProperties : nullptr,
                              NULL);
}


DOMJSClass Class = {
  { "WebGLExtensionLoseContext",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(3),
    _addProperty, /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    _finalize, /* finalize */
    NULL,                  /* checkAccess */
    NULL,                  /* call */
    NULL,                  /* hasInstance */
    NULL,                  /* construct */
    NULL, /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  {
    { prototypes::id::WebGLExtensionLoseContext, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
    true,
    &sNativePropertyHooks,
    GetParentObject<mozilla::WebGLExtensionLoseContext>::Get,
    GetProtoObject,
    nullptr
  }
};

JSObject*
Wrap(JSContext* aCx, JSObject* aScope, mozilla::WebGLExtensionLoseContext* aObject, nsWrapperCache* aCache, bool* aTriedToWrap)
{
  MOZ_ASSERT(static_cast<mozilla::WebGLExtensionLoseContext*>(aObject) ==
             reinterpret_cast<mozilla::WebGLExtensionLoseContext*>(aObject));

  *aTriedToWrap = true;

  JSObject* parent = WrapNativeParent(aCx, aScope, aObject->GetParentObject());
  if (!parent) {
    return NULL;
  }

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.  Scope so we don't
  // collide with the "obj" we declare in CreateBindingJSObject.
  {
    JSObject* obj = aCache->GetWrapper();
    if (obj) {
      return obj;
    }
  }

  JSAutoCompartment ac(aCx, parent);
  JSObject* global = JS_GetGlobalForObject(aCx, parent);

  JSObject* proto = GetProtoObject(aCx, global);
  if (!proto) {
    return NULL;
  }

  JSObject* obj = JS_NewObject(aCx, &Class.mBase, proto, parent);
  if (!obj) {
    return NULL;
  }

  js::SetReservedSlot(obj, DOM_OBJECT_SLOT, PRIVATE_TO_JSVAL(aObject));
  NS_ADDREF(aObject);


  aCache->SetWrapper(obj);

  return obj;
}

} // namespace WebGLExtensionLoseContextBinding



namespace WebGLExtensionStandardDerivativesBinding {

static JSBool
_addProperty(JSContext* cx, JSHandleObject obj, JSHandleId id, JSMutableHandleValue vp)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::WebGLExtensionStandardDerivatives>::value), "Must be an nsISupports class");
  mozilla::WebGLExtensionStandardDerivatives* self = UnwrapDOMObject<mozilla::WebGLExtensionStandardDerivatives>(obj);
  nsContentUtils::PreserveWrapper(reinterpret_cast<nsISupports*>(self), self);
  return true;
}

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::WebGLExtensionStandardDerivatives>::value), "Must be an nsISupports class");
  mozilla::WebGLExtensionStandardDerivatives* self = UnwrapDOMObject<mozilla::WebGLExtensionStandardDerivatives>(obj);
  if (self) {
    ClearWrapper(self, self);
    XPCJSRuntime *rt = nsXPConnect::GetRuntimeInstance();
    if (rt) {
      rt->DeferredRelease(reinterpret_cast<nsISupports*>(self));
    } else {
      NS_RELEASE(self);
    }
  }
}

static JSFunctionSpec sChromeMethods_specs[] = {
  JS_FNINFO("QueryInterface", QueryInterface, nullptr, 1, 0),
  JS_FS_END
};

static Prefable<JSFunctionSpec> sChromeMethods[] = {
  { true, &sChromeMethods_specs[0] },
  { false, NULL }
};

static jsid sChromeMethods_ids[2] = { JSID_VOID };

static ConstantSpec sConstants_specs[] = {
  { "FRAGMENT_SHADER_DERIVATIVE_HINT_OES", UINT_TO_JSVAL(35723) },
  { 0, JSVAL_VOID }
};

static Prefable<ConstantSpec> sConstants[] = {
  { true, &sConstants_specs[0] },
  { false, NULL }
};

static jsid sConstants_ids[2] = { JSID_VOID };


static const NativeProperties sNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sConstants, sConstants_ids, sConstants_specs
};

static const NativeProperties sChromeOnlyNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sChromeMethods, sChromeMethods_ids, sChromeMethods_specs,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr
};
const NativePropertyHooks sNativePropertyHooks = {
  nullptr,
  nullptr,
  { &sNativeProperties, &sChromeOnlyNativeProperties },
  prototypes::id::WebGLExtensionStandardDerivatives,
  constructors::id::_ID_Count,
  NULL
};

static DOMIfaceAndProtoJSClass PrototypeClass = {
  {
    "WebGLExtensionStandardDerivativesPrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(2),
    JS_PropertyStub,       /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    nullptr,               /* finalize */
    nullptr,               /* checkAccess */
    nullptr,               /* call */
    nullptr,               /* hasInstance */
    nullptr,               /* construct */
    nullptr,               /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  eInterfacePrototype,
  &sNativePropertyHooks
};

void
CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray)
{
  JSObject* parentProto = JS_GetObjectPrototype(aCx, aGlobal);
  if (!parentProto) {
    return;
  }


  if (sChromeMethods_ids[0] == JSID_VOID &&
      (!InitIds(aCx, sChromeMethods, sChromeMethods_ids) ||
       !InitIds(aCx, sConstants, sConstants_ids))) {
    sChromeMethods_ids[0] = JSID_VOID;
    return;
  }

  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &PrototypeClass.mBase, &protoAndIfaceArray[prototypes::id::WebGLExtensionStandardDerivatives],
                              nullptr, nullptr, 0, nullptr,
                              &Class.mClass,
                              &sNativeProperties,
                              xpc::AccessCheck::isChrome(aGlobal) ? &sChromeOnlyNativeProperties : nullptr,
                              NULL);
}


DOMJSClass Class = {
  { "WebGLExtensionStandardDerivatives",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(3),
    _addProperty, /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    _finalize, /* finalize */
    NULL,                  /* checkAccess */
    NULL,                  /* call */
    NULL,                  /* hasInstance */
    NULL,                  /* construct */
    NULL, /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  {
    { prototypes::id::WebGLExtensionStandardDerivatives, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
    true,
    &sNativePropertyHooks,
    GetParentObject<mozilla::WebGLExtensionStandardDerivatives>::Get,
    GetProtoObject,
    nullptr
  }
};

JSObject*
Wrap(JSContext* aCx, JSObject* aScope, mozilla::WebGLExtensionStandardDerivatives* aObject, nsWrapperCache* aCache, bool* aTriedToWrap)
{
  MOZ_ASSERT(static_cast<mozilla::WebGLExtensionStandardDerivatives*>(aObject) ==
             reinterpret_cast<mozilla::WebGLExtensionStandardDerivatives*>(aObject));

  *aTriedToWrap = true;

  JSObject* parent = WrapNativeParent(aCx, aScope, aObject->GetParentObject());
  if (!parent) {
    return NULL;
  }

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.  Scope so we don't
  // collide with the "obj" we declare in CreateBindingJSObject.
  {
    JSObject* obj = aCache->GetWrapper();
    if (obj) {
      return obj;
    }
  }

  JSAutoCompartment ac(aCx, parent);
  JSObject* global = JS_GetGlobalForObject(aCx, parent);

  JSObject* proto = GetProtoObject(aCx, global);
  if (!proto) {
    return NULL;
  }

  JSObject* obj = JS_NewObject(aCx, &Class.mBase, proto, parent);
  if (!obj) {
    return NULL;
  }

  js::SetReservedSlot(obj, DOM_OBJECT_SLOT, PRIVATE_TO_JSVAL(aObject));
  NS_ADDREF(aObject);


  aCache->SetWrapper(obj);

  return obj;
}

} // namespace WebGLExtensionStandardDerivativesBinding



namespace WebGLExtensionTextureFilterAnisotropicBinding {

static JSBool
_addProperty(JSContext* cx, JSHandleObject obj, JSHandleId id, JSMutableHandleValue vp)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::WebGLExtensionTextureFilterAnisotropic>::value), "Must be an nsISupports class");
  mozilla::WebGLExtensionTextureFilterAnisotropic* self = UnwrapDOMObject<mozilla::WebGLExtensionTextureFilterAnisotropic>(obj);
  nsContentUtils::PreserveWrapper(reinterpret_cast<nsISupports*>(self), self);
  return true;
}

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::WebGLExtensionTextureFilterAnisotropic>::value), "Must be an nsISupports class");
  mozilla::WebGLExtensionTextureFilterAnisotropic* self = UnwrapDOMObject<mozilla::WebGLExtensionTextureFilterAnisotropic>(obj);
  if (self) {
    ClearWrapper(self, self);
    XPCJSRuntime *rt = nsXPConnect::GetRuntimeInstance();
    if (rt) {
      rt->DeferredRelease(reinterpret_cast<nsISupports*>(self));
    } else {
      NS_RELEASE(self);
    }
  }
}

static JSFunctionSpec sChromeMethods_specs[] = {
  JS_FNINFO("QueryInterface", QueryInterface, nullptr, 1, 0),
  JS_FS_END
};

static Prefable<JSFunctionSpec> sChromeMethods[] = {
  { true, &sChromeMethods_specs[0] },
  { false, NULL }
};

static jsid sChromeMethods_ids[2] = { JSID_VOID };

static ConstantSpec sConstants_specs[] = {
  { "TEXTURE_MAX_ANISOTROPY_EXT", UINT_TO_JSVAL(34046) },
  { "MAX_TEXTURE_MAX_ANISOTROPY_EXT", UINT_TO_JSVAL(34047) },
  { 0, JSVAL_VOID }
};

static Prefable<ConstantSpec> sConstants[] = {
  { true, &sConstants_specs[0] },
  { false, NULL }
};

static jsid sConstants_ids[3] = { JSID_VOID };


static const NativeProperties sNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sConstants, sConstants_ids, sConstants_specs
};

static const NativeProperties sChromeOnlyNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sChromeMethods, sChromeMethods_ids, sChromeMethods_specs,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr
};
const NativePropertyHooks sNativePropertyHooks = {
  nullptr,
  nullptr,
  { &sNativeProperties, &sChromeOnlyNativeProperties },
  prototypes::id::WebGLExtensionTextureFilterAnisotropic,
  constructors::id::_ID_Count,
  NULL
};

static DOMIfaceAndProtoJSClass PrototypeClass = {
  {
    "WebGLExtensionTextureFilterAnisotropicPrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(2),
    JS_PropertyStub,       /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    nullptr,               /* finalize */
    nullptr,               /* checkAccess */
    nullptr,               /* call */
    nullptr,               /* hasInstance */
    nullptr,               /* construct */
    nullptr,               /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  eInterfacePrototype,
  &sNativePropertyHooks
};

void
CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray)
{
  JSObject* parentProto = JS_GetObjectPrototype(aCx, aGlobal);
  if (!parentProto) {
    return;
  }


  if (sChromeMethods_ids[0] == JSID_VOID &&
      (!InitIds(aCx, sChromeMethods, sChromeMethods_ids) ||
       !InitIds(aCx, sConstants, sConstants_ids))) {
    sChromeMethods_ids[0] = JSID_VOID;
    return;
  }

  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &PrototypeClass.mBase, &protoAndIfaceArray[prototypes::id::WebGLExtensionTextureFilterAnisotropic],
                              nullptr, nullptr, 0, nullptr,
                              &Class.mClass,
                              &sNativeProperties,
                              xpc::AccessCheck::isChrome(aGlobal) ? &sChromeOnlyNativeProperties : nullptr,
                              NULL);
}


DOMJSClass Class = {
  { "WebGLExtensionTextureFilterAnisotropic",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(3),
    _addProperty, /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    _finalize, /* finalize */
    NULL,                  /* checkAccess */
    NULL,                  /* call */
    NULL,                  /* hasInstance */
    NULL,                  /* construct */
    NULL, /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  {
    { prototypes::id::WebGLExtensionTextureFilterAnisotropic, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
    true,
    &sNativePropertyHooks,
    GetParentObject<mozilla::WebGLExtensionTextureFilterAnisotropic>::Get,
    GetProtoObject,
    nullptr
  }
};

JSObject*
Wrap(JSContext* aCx, JSObject* aScope, mozilla::WebGLExtensionTextureFilterAnisotropic* aObject, nsWrapperCache* aCache, bool* aTriedToWrap)
{
  MOZ_ASSERT(static_cast<mozilla::WebGLExtensionTextureFilterAnisotropic*>(aObject) ==
             reinterpret_cast<mozilla::WebGLExtensionTextureFilterAnisotropic*>(aObject));

  *aTriedToWrap = true;

  JSObject* parent = WrapNativeParent(aCx, aScope, aObject->GetParentObject());
  if (!parent) {
    return NULL;
  }

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.  Scope so we don't
  // collide with the "obj" we declare in CreateBindingJSObject.
  {
    JSObject* obj = aCache->GetWrapper();
    if (obj) {
      return obj;
    }
  }

  JSAutoCompartment ac(aCx, parent);
  JSObject* global = JS_GetGlobalForObject(aCx, parent);

  JSObject* proto = GetProtoObject(aCx, global);
  if (!proto) {
    return NULL;
  }

  JSObject* obj = JS_NewObject(aCx, &Class.mBase, proto, parent);
  if (!obj) {
    return NULL;
  }

  js::SetReservedSlot(obj, DOM_OBJECT_SLOT, PRIVATE_TO_JSVAL(aObject));
  NS_ADDREF(aObject);


  aCache->SetWrapper(obj);

  return obj;
}

} // namespace WebGLExtensionTextureFilterAnisotropicBinding



namespace WebGLExtensionTextureFloatBinding {

static JSBool
_addProperty(JSContext* cx, JSHandleObject obj, JSHandleId id, JSMutableHandleValue vp)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::WebGLExtensionTextureFloat>::value), "Must be an nsISupports class");
  mozilla::WebGLExtensionTextureFloat* self = UnwrapDOMObject<mozilla::WebGLExtensionTextureFloat>(obj);
  nsContentUtils::PreserveWrapper(reinterpret_cast<nsISupports*>(self), self);
  return true;
}

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::WebGLExtensionTextureFloat>::value), "Must be an nsISupports class");
  mozilla::WebGLExtensionTextureFloat* self = UnwrapDOMObject<mozilla::WebGLExtensionTextureFloat>(obj);
  if (self) {
    ClearWrapper(self, self);
    XPCJSRuntime *rt = nsXPConnect::GetRuntimeInstance();
    if (rt) {
      rt->DeferredRelease(reinterpret_cast<nsISupports*>(self));
    } else {
      NS_RELEASE(self);
    }
  }
}

static JSFunctionSpec sChromeMethods_specs[] = {
  JS_FNINFO("QueryInterface", QueryInterface, nullptr, 1, 0),
  JS_FS_END
};

static Prefable<JSFunctionSpec> sChromeMethods[] = {
  { true, &sChromeMethods_specs[0] },
  { false, NULL }
};

static jsid sChromeMethods_ids[2] = { JSID_VOID };


static const NativeProperties sChromeOnlyNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sChromeMethods, sChromeMethods_ids, sChromeMethods_specs,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr
};
const NativePropertyHooks sNativePropertyHooks = {
  nullptr,
  nullptr,
  { nullptr, &sChromeOnlyNativeProperties },
  prototypes::id::WebGLExtensionTextureFloat,
  constructors::id::_ID_Count,
  NULL
};

static DOMIfaceAndProtoJSClass PrototypeClass = {
  {
    "WebGLExtensionTextureFloatPrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(2),
    JS_PropertyStub,       /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    nullptr,               /* finalize */
    nullptr,               /* checkAccess */
    nullptr,               /* call */
    nullptr,               /* hasInstance */
    nullptr,               /* construct */
    nullptr,               /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  eInterfacePrototype,
  &sNativePropertyHooks
};

void
CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray)
{
  JSObject* parentProto = JS_GetObjectPrototype(aCx, aGlobal);
  if (!parentProto) {
    return;
  }


  if (sChromeMethods_ids[0] == JSID_VOID &&
      !InitIds(aCx, sChromeMethods, sChromeMethods_ids)) {
    sChromeMethods_ids[0] = JSID_VOID;
    return;
  }

  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &PrototypeClass.mBase, &protoAndIfaceArray[prototypes::id::WebGLExtensionTextureFloat],
                              nullptr, nullptr, 0, nullptr,
                              &Class.mClass,
                              nullptr,
                              xpc::AccessCheck::isChrome(aGlobal) ? &sChromeOnlyNativeProperties : nullptr,
                              NULL);
}


DOMJSClass Class = {
  { "WebGLExtensionTextureFloat",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(3),
    _addProperty, /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    _finalize, /* finalize */
    NULL,                  /* checkAccess */
    NULL,                  /* call */
    NULL,                  /* hasInstance */
    NULL,                  /* construct */
    NULL, /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  {
    { prototypes::id::WebGLExtensionTextureFloat, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
    true,
    &sNativePropertyHooks,
    GetParentObject<mozilla::WebGLExtensionTextureFloat>::Get,
    GetProtoObject,
    nullptr
  }
};

JSObject*
Wrap(JSContext* aCx, JSObject* aScope, mozilla::WebGLExtensionTextureFloat* aObject, nsWrapperCache* aCache, bool* aTriedToWrap)
{
  MOZ_ASSERT(static_cast<mozilla::WebGLExtensionTextureFloat*>(aObject) ==
             reinterpret_cast<mozilla::WebGLExtensionTextureFloat*>(aObject));

  *aTriedToWrap = true;

  JSObject* parent = WrapNativeParent(aCx, aScope, aObject->GetParentObject());
  if (!parent) {
    return NULL;
  }

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.  Scope so we don't
  // collide with the "obj" we declare in CreateBindingJSObject.
  {
    JSObject* obj = aCache->GetWrapper();
    if (obj) {
      return obj;
    }
  }

  JSAutoCompartment ac(aCx, parent);
  JSObject* global = JS_GetGlobalForObject(aCx, parent);

  JSObject* proto = GetProtoObject(aCx, global);
  if (!proto) {
    return NULL;
  }

  JSObject* obj = JS_NewObject(aCx, &Class.mBase, proto, parent);
  if (!obj) {
    return NULL;
  }

  js::SetReservedSlot(obj, DOM_OBJECT_SLOT, PRIVATE_TO_JSVAL(aObject));
  NS_ADDREF(aObject);


  aCache->SetWrapper(obj);

  return obj;
}

} // namespace WebGLExtensionTextureFloatBinding



namespace WebGLFramebufferBinding {

static JSBool
_addProperty(JSContext* cx, JSHandleObject obj, JSHandleId id, JSMutableHandleValue vp)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::WebGLFramebuffer>::value), "Must be an nsISupports class");
  mozilla::WebGLFramebuffer* self = UnwrapDOMObject<mozilla::WebGLFramebuffer>(obj);
  nsContentUtils::PreserveWrapper(reinterpret_cast<nsISupports*>(self), self);
  return true;
}

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::WebGLFramebuffer>::value), "Must be an nsISupports class");
  mozilla::WebGLFramebuffer* self = UnwrapDOMObject<mozilla::WebGLFramebuffer>(obj);
  if (self) {
    ClearWrapper(self, self);
    XPCJSRuntime *rt = nsXPConnect::GetRuntimeInstance();
    if (rt) {
      rt->DeferredRelease(reinterpret_cast<nsISupports*>(self));
    } else {
      NS_RELEASE(self);
    }
  }
}

static JSFunctionSpec sChromeMethods_specs[] = {
  JS_FNINFO("QueryInterface", QueryInterface, nullptr, 1, 0),
  JS_FS_END
};

static Prefable<JSFunctionSpec> sChromeMethods[] = {
  { true, &sChromeMethods_specs[0] },
  { false, NULL }
};

static jsid sChromeMethods_ids[2] = { JSID_VOID };


static const NativeProperties sChromeOnlyNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sChromeMethods, sChromeMethods_ids, sChromeMethods_specs,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr
};
const NativePropertyHooks sNativePropertyHooks = {
  nullptr,
  nullptr,
  { nullptr, &sChromeOnlyNativeProperties },
  prototypes::id::WebGLFramebuffer,
  constructors::id::WebGLFramebuffer,
  NULL
};

JSNativeHolder _constructor_holder = {
  ThrowingConstructor,
  &sNativePropertyHooks
};

static DOMIfaceAndProtoJSClass PrototypeClass = {
  {
    "WebGLFramebufferPrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(2),
    JS_PropertyStub,       /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    nullptr,               /* finalize */
    nullptr,               /* checkAccess */
    nullptr,               /* call */
    nullptr,               /* hasInstance */
    nullptr,               /* construct */
    nullptr,               /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  eInterfacePrototype,
  &sNativePropertyHooks
};

void
CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray)
{
  JSObject* parentProto = JS_GetObjectPrototype(aCx, aGlobal);
  if (!parentProto) {
    return;
  }


  if (sChromeMethods_ids[0] == JSID_VOID &&
      !InitIds(aCx, sChromeMethods, sChromeMethods_ids)) {
    sChromeMethods_ids[0] = JSID_VOID;
    return;
  }

  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &PrototypeClass.mBase, &protoAndIfaceArray[prototypes::id::WebGLFramebuffer],
                              nullptr, &_constructor_holder, 0, &protoAndIfaceArray[constructors::id::WebGLFramebuffer],
                              &Class.mClass,
                              nullptr,
                              xpc::AccessCheck::isChrome(aGlobal) ? &sChromeOnlyNativeProperties : nullptr,
                              "WebGLFramebuffer");
}

JSObject*
DefineDOMInterface(JSContext* aCx, JSObject* aGlobal, bool* aEnabled)
{

  *aEnabled = true;
  return GetConstructorObject(aCx, aGlobal);
}


DOMJSClass Class = {
  { "WebGLFramebuffer",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(3),
    _addProperty, /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    _finalize, /* finalize */
    NULL,                  /* checkAccess */
    NULL,                  /* call */
    NULL,                  /* hasInstance */
    NULL,                  /* construct */
    NULL, /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  {
    { prototypes::id::WebGLFramebuffer, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
    true,
    &sNativePropertyHooks,
    GetParentObject<mozilla::WebGLFramebuffer>::Get,
    GetProtoObject,
    nullptr
  }
};

JSObject*
Wrap(JSContext* aCx, JSObject* aScope, mozilla::WebGLFramebuffer* aObject, nsWrapperCache* aCache, bool* aTriedToWrap)
{
  MOZ_ASSERT(static_cast<mozilla::WebGLFramebuffer*>(aObject) ==
             reinterpret_cast<mozilla::WebGLFramebuffer*>(aObject));

  *aTriedToWrap = true;

  JSObject* parent = WrapNativeParent(aCx, aScope, aObject->GetParentObject());
  if (!parent) {
    return NULL;
  }

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.  Scope so we don't
  // collide with the "obj" we declare in CreateBindingJSObject.
  {
    JSObject* obj = aCache->GetWrapper();
    if (obj) {
      return obj;
    }
  }

  JSAutoCompartment ac(aCx, parent);
  JSObject* global = JS_GetGlobalForObject(aCx, parent);

  JSObject* proto = GetProtoObject(aCx, global);
  if (!proto) {
    return NULL;
  }

  JSObject* obj = JS_NewObject(aCx, &Class.mBase, proto, parent);
  if (!obj) {
    return NULL;
  }

  js::SetReservedSlot(obj, DOM_OBJECT_SLOT, PRIVATE_TO_JSVAL(aObject));
  NS_ADDREF(aObject);


  aCache->SetWrapper(obj);

  return obj;
}

} // namespace WebGLFramebufferBinding



namespace WebGLProgramBinding {

static JSBool
_addProperty(JSContext* cx, JSHandleObject obj, JSHandleId id, JSMutableHandleValue vp)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::WebGLProgram>::value), "Must be an nsISupports class");
  mozilla::WebGLProgram* self = UnwrapDOMObject<mozilla::WebGLProgram>(obj);
  nsContentUtils::PreserveWrapper(reinterpret_cast<nsISupports*>(self), self);
  return true;
}

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::WebGLProgram>::value), "Must be an nsISupports class");
  mozilla::WebGLProgram* self = UnwrapDOMObject<mozilla::WebGLProgram>(obj);
  if (self) {
    ClearWrapper(self, self);
    XPCJSRuntime *rt = nsXPConnect::GetRuntimeInstance();
    if (rt) {
      rt->DeferredRelease(reinterpret_cast<nsISupports*>(self));
    } else {
      NS_RELEASE(self);
    }
  }
}

static JSFunctionSpec sChromeMethods_specs[] = {
  JS_FNINFO("QueryInterface", QueryInterface, nullptr, 1, 0),
  JS_FS_END
};

static Prefable<JSFunctionSpec> sChromeMethods[] = {
  { true, &sChromeMethods_specs[0] },
  { false, NULL }
};

static jsid sChromeMethods_ids[2] = { JSID_VOID };


static const NativeProperties sChromeOnlyNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sChromeMethods, sChromeMethods_ids, sChromeMethods_specs,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr
};
const NativePropertyHooks sNativePropertyHooks = {
  nullptr,
  nullptr,
  { nullptr, &sChromeOnlyNativeProperties },
  prototypes::id::WebGLProgram,
  constructors::id::WebGLProgram,
  NULL
};

JSNativeHolder _constructor_holder = {
  ThrowingConstructor,
  &sNativePropertyHooks
};

static DOMIfaceAndProtoJSClass PrototypeClass = {
  {
    "WebGLProgramPrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(2),
    JS_PropertyStub,       /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    nullptr,               /* finalize */
    nullptr,               /* checkAccess */
    nullptr,               /* call */
    nullptr,               /* hasInstance */
    nullptr,               /* construct */
    nullptr,               /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  eInterfacePrototype,
  &sNativePropertyHooks
};

void
CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray)
{
  JSObject* parentProto = JS_GetObjectPrototype(aCx, aGlobal);
  if (!parentProto) {
    return;
  }


  if (sChromeMethods_ids[0] == JSID_VOID &&
      !InitIds(aCx, sChromeMethods, sChromeMethods_ids)) {
    sChromeMethods_ids[0] = JSID_VOID;
    return;
  }

  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &PrototypeClass.mBase, &protoAndIfaceArray[prototypes::id::WebGLProgram],
                              nullptr, &_constructor_holder, 0, &protoAndIfaceArray[constructors::id::WebGLProgram],
                              &Class.mClass,
                              nullptr,
                              xpc::AccessCheck::isChrome(aGlobal) ? &sChromeOnlyNativeProperties : nullptr,
                              "WebGLProgram");
}

JSObject*
DefineDOMInterface(JSContext* aCx, JSObject* aGlobal, bool* aEnabled)
{

  *aEnabled = true;
  return GetConstructorObject(aCx, aGlobal);
}


DOMJSClass Class = {
  { "WebGLProgram",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(3),
    _addProperty, /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    _finalize, /* finalize */
    NULL,                  /* checkAccess */
    NULL,                  /* call */
    NULL,                  /* hasInstance */
    NULL,                  /* construct */
    NULL, /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  {
    { prototypes::id::WebGLProgram, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
    true,
    &sNativePropertyHooks,
    GetParentObject<mozilla::WebGLProgram>::Get,
    GetProtoObject,
    nullptr
  }
};

JSObject*
Wrap(JSContext* aCx, JSObject* aScope, mozilla::WebGLProgram* aObject, nsWrapperCache* aCache, bool* aTriedToWrap)
{
  MOZ_ASSERT(static_cast<mozilla::WebGLProgram*>(aObject) ==
             reinterpret_cast<mozilla::WebGLProgram*>(aObject));

  *aTriedToWrap = true;

  JSObject* parent = WrapNativeParent(aCx, aScope, aObject->GetParentObject());
  if (!parent) {
    return NULL;
  }

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.  Scope so we don't
  // collide with the "obj" we declare in CreateBindingJSObject.
  {
    JSObject* obj = aCache->GetWrapper();
    if (obj) {
      return obj;
    }
  }

  JSAutoCompartment ac(aCx, parent);
  JSObject* global = JS_GetGlobalForObject(aCx, parent);

  JSObject* proto = GetProtoObject(aCx, global);
  if (!proto) {
    return NULL;
  }

  JSObject* obj = JS_NewObject(aCx, &Class.mBase, proto, parent);
  if (!obj) {
    return NULL;
  }

  js::SetReservedSlot(obj, DOM_OBJECT_SLOT, PRIVATE_TO_JSVAL(aObject));
  NS_ADDREF(aObject);


  aCache->SetWrapper(obj);

  return obj;
}

} // namespace WebGLProgramBinding



namespace WebGLRenderbufferBinding {

static JSBool
_addProperty(JSContext* cx, JSHandleObject obj, JSHandleId id, JSMutableHandleValue vp)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::WebGLRenderbuffer>::value), "Must be an nsISupports class");
  mozilla::WebGLRenderbuffer* self = UnwrapDOMObject<mozilla::WebGLRenderbuffer>(obj);
  nsContentUtils::PreserveWrapper(reinterpret_cast<nsISupports*>(self), self);
  return true;
}

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::WebGLRenderbuffer>::value), "Must be an nsISupports class");
  mozilla::WebGLRenderbuffer* self = UnwrapDOMObject<mozilla::WebGLRenderbuffer>(obj);
  if (self) {
    ClearWrapper(self, self);
    XPCJSRuntime *rt = nsXPConnect::GetRuntimeInstance();
    if (rt) {
      rt->DeferredRelease(reinterpret_cast<nsISupports*>(self));
    } else {
      NS_RELEASE(self);
    }
  }
}

static JSFunctionSpec sChromeMethods_specs[] = {
  JS_FNINFO("QueryInterface", QueryInterface, nullptr, 1, 0),
  JS_FS_END
};

static Prefable<JSFunctionSpec> sChromeMethods[] = {
  { true, &sChromeMethods_specs[0] },
  { false, NULL }
};

static jsid sChromeMethods_ids[2] = { JSID_VOID };


static const NativeProperties sChromeOnlyNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sChromeMethods, sChromeMethods_ids, sChromeMethods_specs,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr
};
const NativePropertyHooks sNativePropertyHooks = {
  nullptr,
  nullptr,
  { nullptr, &sChromeOnlyNativeProperties },
  prototypes::id::WebGLRenderbuffer,
  constructors::id::WebGLRenderbuffer,
  NULL
};

JSNativeHolder _constructor_holder = {
  ThrowingConstructor,
  &sNativePropertyHooks
};

static DOMIfaceAndProtoJSClass PrototypeClass = {
  {
    "WebGLRenderbufferPrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(2),
    JS_PropertyStub,       /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    nullptr,               /* finalize */
    nullptr,               /* checkAccess */
    nullptr,               /* call */
    nullptr,               /* hasInstance */
    nullptr,               /* construct */
    nullptr,               /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  eInterfacePrototype,
  &sNativePropertyHooks
};

void
CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray)
{
  JSObject* parentProto = JS_GetObjectPrototype(aCx, aGlobal);
  if (!parentProto) {
    return;
  }


  if (sChromeMethods_ids[0] == JSID_VOID &&
      !InitIds(aCx, sChromeMethods, sChromeMethods_ids)) {
    sChromeMethods_ids[0] = JSID_VOID;
    return;
  }

  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &PrototypeClass.mBase, &protoAndIfaceArray[prototypes::id::WebGLRenderbuffer],
                              nullptr, &_constructor_holder, 0, &protoAndIfaceArray[constructors::id::WebGLRenderbuffer],
                              &Class.mClass,
                              nullptr,
                              xpc::AccessCheck::isChrome(aGlobal) ? &sChromeOnlyNativeProperties : nullptr,
                              "WebGLRenderbuffer");
}

JSObject*
DefineDOMInterface(JSContext* aCx, JSObject* aGlobal, bool* aEnabled)
{

  *aEnabled = true;
  return GetConstructorObject(aCx, aGlobal);
}


DOMJSClass Class = {
  { "WebGLRenderbuffer",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(3),
    _addProperty, /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    _finalize, /* finalize */
    NULL,                  /* checkAccess */
    NULL,                  /* call */
    NULL,                  /* hasInstance */
    NULL,                  /* construct */
    NULL, /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  {
    { prototypes::id::WebGLRenderbuffer, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
    true,
    &sNativePropertyHooks,
    GetParentObject<mozilla::WebGLRenderbuffer>::Get,
    GetProtoObject,
    nullptr
  }
};

JSObject*
Wrap(JSContext* aCx, JSObject* aScope, mozilla::WebGLRenderbuffer* aObject, nsWrapperCache* aCache, bool* aTriedToWrap)
{
  MOZ_ASSERT(static_cast<mozilla::WebGLRenderbuffer*>(aObject) ==
             reinterpret_cast<mozilla::WebGLRenderbuffer*>(aObject));

  *aTriedToWrap = true;

  JSObject* parent = WrapNativeParent(aCx, aScope, aObject->GetParentObject());
  if (!parent) {
    return NULL;
  }

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.  Scope so we don't
  // collide with the "obj" we declare in CreateBindingJSObject.
  {
    JSObject* obj = aCache->GetWrapper();
    if (obj) {
      return obj;
    }
  }

  JSAutoCompartment ac(aCx, parent);
  JSObject* global = JS_GetGlobalForObject(aCx, parent);

  JSObject* proto = GetProtoObject(aCx, global);
  if (!proto) {
    return NULL;
  }

  JSObject* obj = JS_NewObject(aCx, &Class.mBase, proto, parent);
  if (!obj) {
    return NULL;
  }

  js::SetReservedSlot(obj, DOM_OBJECT_SLOT, PRIVATE_TO_JSVAL(aObject));
  NS_ADDREF(aObject);


  aCache->SetWrapper(obj);

  return obj;
}

} // namespace WebGLRenderbufferBinding



namespace WebGLRenderingContextBinding {

static bool
get_canvas(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, JS::Value* vp)
{
  mozilla::dom::HTMLCanvasElement* result;
  result = self->GetCanvas();
  if (!result) {
    *vp = JSVAL_NULL;
    return true;
  }
  if (!WrapObject(cx, obj, result, vp)) {
    return false;
  }
  return true;
}


const JSJitInfo canvas_getterinfo = {
  (JSJitPropertyOp)get_canvas,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_drawingBufferWidth(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, JS::Value* vp)
{
  int32_t result;
  result = self->DrawingBufferWidth();
  *vp = INT_TO_JSVAL(int32_t(result));
  return true;
}


const JSJitInfo drawingBufferWidth_getterinfo = {
  (JSJitPropertyOp)get_drawingBufferWidth,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_drawingBufferHeight(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, JS::Value* vp)
{
  int32_t result;
  result = self->DrawingBufferHeight();
  *vp = INT_TO_JSVAL(int32_t(result));
  return true;
}


const JSJitInfo drawingBufferHeight_getterinfo = {
  (JSJitPropertyOp)get_drawingBufferHeight,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

static bool
getContextAttributes(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{
  Nullable< WebGLContextAttributesInitializer > result;
  self->GetContextAttributes(result);
  if (result.IsNull()) {
    *vp = JSVAL_NULL;
    return true;
  }
  if (!result.Value().ToObject(cx, obj, vp)) {
    return false;
  }
  return true;
}


const JSJitInfo getContextAttributes_methodinfo = {
  (JSJitPropertyOp)getContextAttributes,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
isContextLost(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{
  bool result;
  result = self->IsContextLost();
  *vp = BOOLEAN_TO_JSVAL(result);
  return true;
}


const JSJitInfo isContextLost_methodinfo = {
  (JSJitPropertyOp)isContextLost,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

static bool
getSupportedExtensions(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{
  Nullable< nsTArray< nsString > > result;
  self->GetSupportedExtensions(cx, result);

  if (result.IsNull()) {
    *vp = JSVAL_NULL;
    return true;
  }

  uint32_t length = result.Value().Length();
  JSObject *returnArray = JS_NewArrayObject(cx, length, NULL);
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    jsval tmp;
    for (uint32_t i = 0; i < length; ++i) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!xpc::NonVoidStringToJsval(cx, result.Value()[i], &tmp)) {
          return false;
        }
        break;
      } while (0);
      if (!JS_DefineElement(cx, returnArray, i, tmp,
                            nullptr, nullptr, JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  *vp = JS::ObjectValue(*returnArray);
  return true;
}


const JSJitInfo getSupportedExtensions_methodinfo = {
  (JSJitPropertyOp)getSupportedExtensions,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
getExtension(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.getExtension");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eStringify, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  JSObject* result;
  result = self->GetExtension(cx, arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "WebGLRenderingContext", "getExtension");
  }
  *vp = JS::ObjectOrNullValue(result);
  if (!MaybeWrapValue(cx, vp)) {
    return false;
  }
  return true;
}


const JSJitInfo getExtension_methodinfo = {
  (JSJitPropertyOp)getExtension,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
activeTexture(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.activeTexture");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  self->ActiveTexture(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo activeTexture_methodinfo = {
  (JSJitPropertyOp)activeTexture,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
attachShader(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 2) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.attachShader");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  mozilla::WebGLProgram* arg0;
  if (argv[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::WebGLProgram, mozilla::WebGLProgram>(cx, &argv[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "WebGLProgram");
        return false;
      }
    }
  } else if (argv[0].isNullOrUndefined()) {
    arg0 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  mozilla::WebGLShader* arg1;
  if (argv[1].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::WebGLShader, mozilla::WebGLShader>(cx, &argv[1].toObject(), arg1);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "WebGLShader");
        return false;
      }
    }
  } else if (argv[1].isNullOrUndefined()) {
    arg1 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->AttachShader(arg0, arg1);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo attachShader_methodinfo = {
  (JSJitPropertyOp)attachShader,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
bindAttribLocation(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 3) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.bindAttribLocation");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  mozilla::WebGLProgram* arg0;
  if (argv[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::WebGLProgram, mozilla::WebGLProgram>(cx, &argv[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "WebGLProgram");
        return false;
      }
    }
  } else if (argv[0].isNullOrUndefined()) {
    arg0 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  uint32_t arg1;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[1], &arg1)) {
    return false;
  }
  FakeDependentString arg2_holder;
  const NonNull<nsAString> arg2;
  if (!ConvertJSValueToString(cx, argv[2], &argv[2], eStringify, eStringify, arg2_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg2) = &arg2_holder;
  self->BindAttribLocation(arg0, arg1, arg2);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo bindAttribLocation_methodinfo = {
  (JSJitPropertyOp)bindAttribLocation,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
bindBuffer(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 2) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.bindBuffer");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  mozilla::WebGLBuffer* arg1;
  if (argv[1].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::WebGLBuffer, mozilla::WebGLBuffer>(cx, &argv[1].toObject(), arg1);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "WebGLBuffer");
        return false;
      }
    }
  } else if (argv[1].isNullOrUndefined()) {
    arg1 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->BindBuffer(arg0, arg1);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo bindBuffer_methodinfo = {
  (JSJitPropertyOp)bindBuffer,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
bindFramebuffer(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 2) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.bindFramebuffer");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  mozilla::WebGLFramebuffer* arg1;
  if (argv[1].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::WebGLFramebuffer, mozilla::WebGLFramebuffer>(cx, &argv[1].toObject(), arg1);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "WebGLFramebuffer");
        return false;
      }
    }
  } else if (argv[1].isNullOrUndefined()) {
    arg1 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->BindFramebuffer(arg0, arg1);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo bindFramebuffer_methodinfo = {
  (JSJitPropertyOp)bindFramebuffer,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
bindRenderbuffer(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 2) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.bindRenderbuffer");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  mozilla::WebGLRenderbuffer* arg1;
  if (argv[1].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::WebGLRenderbuffer, mozilla::WebGLRenderbuffer>(cx, &argv[1].toObject(), arg1);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "WebGLRenderbuffer");
        return false;
      }
    }
  } else if (argv[1].isNullOrUndefined()) {
    arg1 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->BindRenderbuffer(arg0, arg1);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo bindRenderbuffer_methodinfo = {
  (JSJitPropertyOp)bindRenderbuffer,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
bindTexture(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 2) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.bindTexture");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  mozilla::WebGLTexture* arg1;
  if (argv[1].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::WebGLTexture, mozilla::WebGLTexture>(cx, &argv[1].toObject(), arg1);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "WebGLTexture");
        return false;
      }
    }
  } else if (argv[1].isNullOrUndefined()) {
    arg1 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->BindTexture(arg0, arg1);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo bindTexture_methodinfo = {
  (JSJitPropertyOp)bindTexture,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
blendColor(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 4) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.blendColor");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  float arg1;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[1], &arg1)) {
    return false;
  }
  float arg2;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[2], &arg2)) {
    return false;
  }
  float arg3;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[3], &arg3)) {
    return false;
  }
  self->BlendColor(arg0, arg1, arg2, arg3);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo blendColor_methodinfo = {
  (JSJitPropertyOp)blendColor,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
blendEquation(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.blendEquation");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  self->BlendEquation(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo blendEquation_methodinfo = {
  (JSJitPropertyOp)blendEquation,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
blendEquationSeparate(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 2) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.blendEquationSeparate");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  uint32_t arg1;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[1], &arg1)) {
    return false;
  }
  self->BlendEquationSeparate(arg0, arg1);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo blendEquationSeparate_methodinfo = {
  (JSJitPropertyOp)blendEquationSeparate,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
blendFunc(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 2) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.blendFunc");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  uint32_t arg1;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[1], &arg1)) {
    return false;
  }
  self->BlendFunc(arg0, arg1);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo blendFunc_methodinfo = {
  (JSJitPropertyOp)blendFunc,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
blendFuncSeparate(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 4) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.blendFuncSeparate");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  uint32_t arg1;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[1], &arg1)) {
    return false;
  }
  uint32_t arg2;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[2], &arg2)) {
    return false;
  }
  uint32_t arg3;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[3], &arg3)) {
    return false;
  }
  self->BlendFuncSeparate(arg0, arg1, arg2, arg3);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo blendFuncSeparate_methodinfo = {
  (JSJitPropertyOp)blendFuncSeparate,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
bufferData(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  unsigned argcount = NS_MIN(argc, 3u);
  switch (argcount) {
    case 3: {
      JS::Value* argv_start = JS_ARGV(cx, vp);
      uint32_t arg0;
      if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv_start[0], &arg0)) {
        return false;
      }
      if (argv_start[1].isNullOrUndefined()) {
        Maybe<ArrayBuffer> arg1_holder;
        ArrayBuffer* arg1;
        arg1 = NULL;

        JS::Value* argv = JS_ARGV(cx, vp);

        uint32_t arg2;
        if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[2], &arg2)) {
          return false;
        }
        self->BufferData(arg0, arg1, arg2);
        *vp = JSVAL_VOID;
        return true;
      }
      if (argv_start[1].isObject()) {
        do {
          Maybe<ArrayBufferView> arg1_holder;
          NonNull<ArrayBufferView> arg1;
          arg1_holder.construct(&argv_start[1].toObject());
          if (!arg1_holder.ref().inited()) {
            break;
          }
          arg1 = arg1_holder.addr();

          JS::Value* argv = JS_ARGV(cx, vp);

          uint32_t arg2;
          if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[2], &arg2)) {
            return false;
          }
          self->BufferData(arg0, arg1, arg2);
          *vp = JSVAL_VOID;
          return true;
        } while (0);
        do {
          Maybe<ArrayBuffer> arg1_holder;
          ArrayBuffer* arg1;
          arg1_holder.construct(&argv_start[1].toObject());
          if (!arg1_holder.ref().inited()) {
            break;
          }
          arg1 = arg1_holder.addr();

          JS::Value* argv = JS_ARGV(cx, vp);

          uint32_t arg2;
          if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[2], &arg2)) {
            return false;
          }
          self->BufferData(arg0, arg1, arg2);
          *vp = JSVAL_VOID;
          return true;
        } while (0);
      }

      JS::Value* argv = JS_ARGV(cx, vp);

      int64_t arg1;
      if (!ValueToPrimitive<int64_t, eDefault>(cx, argv[1], &arg1)) {
        return false;
      }
      uint32_t arg2;
      if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[2], &arg2)) {
        return false;
      }
      self->BufferData(arg0, arg1, arg2);
      *vp = JSVAL_VOID;
      return true;
      break;
    }
    default: {
      return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.bufferData");

      break;
    }
  }
  MOZ_NOT_REACHED("We have an always-returning default case");
  return false;
}


const JSJitInfo bufferData_methodinfo = {
  (JSJitPropertyOp)bufferData,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
bufferSubData(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  unsigned argcount = NS_MIN(argc, 3u);
  switch (argcount) {
    case 3: {
      JS::Value* argv_start = JS_ARGV(cx, vp);
      uint32_t arg0;
      if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv_start[0], &arg0)) {
        return false;
      }
      int64_t arg1;
      if (!ValueToPrimitive<int64_t, eDefault>(cx, argv_start[1], &arg1)) {
        return false;
      }
      if (argv_start[2].isNullOrUndefined()) {
        Maybe<ArrayBuffer> arg2_holder;
        ArrayBuffer* arg2;
        arg2 = NULL;
        self->BufferSubData(arg0, arg1, arg2);
        *vp = JSVAL_VOID;
        return true;
      }
      if (argv_start[2].isObject()) {
        do {
          Maybe<ArrayBufferView> arg2_holder;
          NonNull<ArrayBufferView> arg2;
          arg2_holder.construct(&argv_start[2].toObject());
          if (!arg2_holder.ref().inited()) {
            break;
          }
          arg2 = arg2_holder.addr();
          self->BufferSubData(arg0, arg1, arg2);
          *vp = JSVAL_VOID;
          return true;
        } while (0);
        do {
          Maybe<ArrayBuffer> arg2_holder;
          ArrayBuffer* arg2;
          arg2_holder.construct(&argv_start[2].toObject());
          if (!arg2_holder.ref().inited()) {
            break;
          }
          arg2 = arg2_holder.addr();
          self->BufferSubData(arg0, arg1, arg2);
          *vp = JSVAL_VOID;
          return true;
        } while (0);
      }
      return ThrowErrorMessage(cx, MSG_INVALID_ARG, "2", "3");
      break;
    }
    default: {
      return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.bufferSubData");

      break;
    }
  }
  MOZ_NOT_REACHED("We have an always-returning default case");
  return false;
}


const JSJitInfo bufferSubData_methodinfo = {
  (JSJitPropertyOp)bufferSubData,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
checkFramebufferStatus(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.checkFramebufferStatus");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  uint32_t result;
  result = self->CheckFramebufferStatus(arg0);
  *vp = UINT_TO_JSVAL(result);
  return true;
}


const JSJitInfo checkFramebufferStatus_methodinfo = {
  (JSJitPropertyOp)checkFramebufferStatus,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

static bool
clear(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.clear");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  self->Clear(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo clear_methodinfo = {
  (JSJitPropertyOp)clear,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
clearColor(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 4) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.clearColor");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  float arg1;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[1], &arg1)) {
    return false;
  }
  float arg2;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[2], &arg2)) {
    return false;
  }
  float arg3;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[3], &arg3)) {
    return false;
  }
  self->ClearColor(arg0, arg1, arg2, arg3);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo clearColor_methodinfo = {
  (JSJitPropertyOp)clearColor,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
clearDepth(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.clearDepth");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  self->ClearDepth(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo clearDepth_methodinfo = {
  (JSJitPropertyOp)clearDepth,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
clearStencil(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.clearStencil");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  int32_t arg0;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  self->ClearStencil(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo clearStencil_methodinfo = {
  (JSJitPropertyOp)clearStencil,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
colorMask(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 4) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.colorMask");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  bool arg0;
  if (!ValueToPrimitive<bool, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  bool arg1;
  if (!ValueToPrimitive<bool, eDefault>(cx, argv[1], &arg1)) {
    return false;
  }
  bool arg2;
  if (!ValueToPrimitive<bool, eDefault>(cx, argv[2], &arg2)) {
    return false;
  }
  bool arg3;
  if (!ValueToPrimitive<bool, eDefault>(cx, argv[3], &arg3)) {
    return false;
  }
  self->ColorMask(arg0, arg1, arg2, arg3);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo colorMask_methodinfo = {
  (JSJitPropertyOp)colorMask,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
compileShader(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.compileShader");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  mozilla::WebGLShader* arg0;
  if (argv[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::WebGLShader, mozilla::WebGLShader>(cx, &argv[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "WebGLShader");
        return false;
      }
    }
  } else if (argv[0].isNullOrUndefined()) {
    arg0 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->CompileShader(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo compileShader_methodinfo = {
  (JSJitPropertyOp)compileShader,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
compressedTexImage2D(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 7) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.compressedTexImage2D");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  int32_t arg1;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[1], &arg1)) {
    return false;
  }
  uint32_t arg2;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[2], &arg2)) {
    return false;
  }
  int32_t arg3;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[3], &arg3)) {
    return false;
  }
  int32_t arg4;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[4], &arg4)) {
    return false;
  }
  int32_t arg5;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[5], &arg5)) {
    return false;
  }
  Maybe<ArrayBufferView> arg6_holder;
  NonNull<ArrayBufferView> arg6;
  if (argv[6].isObject()) {
    arg6_holder.construct(&argv[6].toObject());
    if (!arg6_holder.ref().inited()) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "ArrayBufferView");return false;
    }
    arg6 = arg6_holder.addr();
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->CompressedTexImage2D(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo compressedTexImage2D_methodinfo = {
  (JSJitPropertyOp)compressedTexImage2D,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
compressedTexSubImage2D(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 8) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.compressedTexSubImage2D");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  int32_t arg1;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[1], &arg1)) {
    return false;
  }
  int32_t arg2;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[2], &arg2)) {
    return false;
  }
  int32_t arg3;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[3], &arg3)) {
    return false;
  }
  int32_t arg4;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[4], &arg4)) {
    return false;
  }
  int32_t arg5;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[5], &arg5)) {
    return false;
  }
  uint32_t arg6;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[6], &arg6)) {
    return false;
  }
  Maybe<ArrayBufferView> arg7_holder;
  NonNull<ArrayBufferView> arg7;
  if (argv[7].isObject()) {
    arg7_holder.construct(&argv[7].toObject());
    if (!arg7_holder.ref().inited()) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "ArrayBufferView");return false;
    }
    arg7 = arg7_holder.addr();
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->CompressedTexSubImage2D(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo compressedTexSubImage2D_methodinfo = {
  (JSJitPropertyOp)compressedTexSubImage2D,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
copyTexImage2D(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 8) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.copyTexImage2D");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  int32_t arg1;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[1], &arg1)) {
    return false;
  }
  uint32_t arg2;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[2], &arg2)) {
    return false;
  }
  int32_t arg3;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[3], &arg3)) {
    return false;
  }
  int32_t arg4;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[4], &arg4)) {
    return false;
  }
  int32_t arg5;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[5], &arg5)) {
    return false;
  }
  int32_t arg6;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[6], &arg6)) {
    return false;
  }
  int32_t arg7;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[7], &arg7)) {
    return false;
  }
  self->CopyTexImage2D(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo copyTexImage2D_methodinfo = {
  (JSJitPropertyOp)copyTexImage2D,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
copyTexSubImage2D(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 8) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.copyTexSubImage2D");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  int32_t arg1;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[1], &arg1)) {
    return false;
  }
  int32_t arg2;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[2], &arg2)) {
    return false;
  }
  int32_t arg3;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[3], &arg3)) {
    return false;
  }
  int32_t arg4;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[4], &arg4)) {
    return false;
  }
  int32_t arg5;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[5], &arg5)) {
    return false;
  }
  int32_t arg6;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[6], &arg6)) {
    return false;
  }
  int32_t arg7;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[7], &arg7)) {
    return false;
  }
  self->CopyTexSubImage2D(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo copyTexSubImage2D_methodinfo = {
  (JSJitPropertyOp)copyTexSubImage2D,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
createBuffer(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{
  nsRefPtr<mozilla::WebGLBuffer> result;
  result = self->CreateBuffer();
  if (!result) {
    *vp = JSVAL_NULL;
    return true;
  }
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}


const JSJitInfo createBuffer_methodinfo = {
  (JSJitPropertyOp)createBuffer,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
createFramebuffer(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{
  nsRefPtr<mozilla::WebGLFramebuffer> result;
  result = self->CreateFramebuffer();
  if (!result) {
    *vp = JSVAL_NULL;
    return true;
  }
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}


const JSJitInfo createFramebuffer_methodinfo = {
  (JSJitPropertyOp)createFramebuffer,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
createProgram(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{
  nsRefPtr<mozilla::WebGLProgram> result;
  result = self->CreateProgram();
  if (!result) {
    *vp = JSVAL_NULL;
    return true;
  }
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}


const JSJitInfo createProgram_methodinfo = {
  (JSJitPropertyOp)createProgram,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
createRenderbuffer(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{
  nsRefPtr<mozilla::WebGLRenderbuffer> result;
  result = self->CreateRenderbuffer();
  if (!result) {
    *vp = JSVAL_NULL;
    return true;
  }
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}


const JSJitInfo createRenderbuffer_methodinfo = {
  (JSJitPropertyOp)createRenderbuffer,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
createShader(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.createShader");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  nsRefPtr<mozilla::WebGLShader> result;
  result = self->CreateShader(arg0);
  if (!result) {
    *vp = JSVAL_NULL;
    return true;
  }
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}


const JSJitInfo createShader_methodinfo = {
  (JSJitPropertyOp)createShader,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
createTexture(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{
  nsRefPtr<mozilla::WebGLTexture> result;
  result = self->CreateTexture();
  if (!result) {
    *vp = JSVAL_NULL;
    return true;
  }
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}


const JSJitInfo createTexture_methodinfo = {
  (JSJitPropertyOp)createTexture,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
cullFace(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.cullFace");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  self->CullFace(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo cullFace_methodinfo = {
  (JSJitPropertyOp)cullFace,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
deleteBuffer(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.deleteBuffer");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  mozilla::WebGLBuffer* arg0;
  if (argv[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::WebGLBuffer, mozilla::WebGLBuffer>(cx, &argv[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "WebGLBuffer");
        return false;
      }
    }
  } else if (argv[0].isNullOrUndefined()) {
    arg0 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->DeleteBuffer(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo deleteBuffer_methodinfo = {
  (JSJitPropertyOp)deleteBuffer,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
deleteFramebuffer(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.deleteFramebuffer");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  mozilla::WebGLFramebuffer* arg0;
  if (argv[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::WebGLFramebuffer, mozilla::WebGLFramebuffer>(cx, &argv[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "WebGLFramebuffer");
        return false;
      }
    }
  } else if (argv[0].isNullOrUndefined()) {
    arg0 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->DeleteFramebuffer(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo deleteFramebuffer_methodinfo = {
  (JSJitPropertyOp)deleteFramebuffer,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
deleteProgram(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.deleteProgram");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  mozilla::WebGLProgram* arg0;
  if (argv[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::WebGLProgram, mozilla::WebGLProgram>(cx, &argv[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "WebGLProgram");
        return false;
      }
    }
  } else if (argv[0].isNullOrUndefined()) {
    arg0 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->DeleteProgram(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo deleteProgram_methodinfo = {
  (JSJitPropertyOp)deleteProgram,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
deleteRenderbuffer(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.deleteRenderbuffer");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  mozilla::WebGLRenderbuffer* arg0;
  if (argv[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::WebGLRenderbuffer, mozilla::WebGLRenderbuffer>(cx, &argv[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "WebGLRenderbuffer");
        return false;
      }
    }
  } else if (argv[0].isNullOrUndefined()) {
    arg0 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->DeleteRenderbuffer(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo deleteRenderbuffer_methodinfo = {
  (JSJitPropertyOp)deleteRenderbuffer,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
deleteShader(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.deleteShader");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  mozilla::WebGLShader* arg0;
  if (argv[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::WebGLShader, mozilla::WebGLShader>(cx, &argv[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "WebGLShader");
        return false;
      }
    }
  } else if (argv[0].isNullOrUndefined()) {
    arg0 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->DeleteShader(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo deleteShader_methodinfo = {
  (JSJitPropertyOp)deleteShader,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
deleteTexture(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.deleteTexture");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  mozilla::WebGLTexture* arg0;
  if (argv[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::WebGLTexture, mozilla::WebGLTexture>(cx, &argv[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "WebGLTexture");
        return false;
      }
    }
  } else if (argv[0].isNullOrUndefined()) {
    arg0 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->DeleteTexture(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo deleteTexture_methodinfo = {
  (JSJitPropertyOp)deleteTexture,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
depthFunc(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.depthFunc");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  self->DepthFunc(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo depthFunc_methodinfo = {
  (JSJitPropertyOp)depthFunc,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
depthMask(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.depthMask");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  bool arg0;
  if (!ValueToPrimitive<bool, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  self->DepthMask(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo depthMask_methodinfo = {
  (JSJitPropertyOp)depthMask,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
depthRange(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 2) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.depthRange");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  float arg1;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[1], &arg1)) {
    return false;
  }
  self->DepthRange(arg0, arg1);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo depthRange_methodinfo = {
  (JSJitPropertyOp)depthRange,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
detachShader(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 2) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.detachShader");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  mozilla::WebGLProgram* arg0;
  if (argv[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::WebGLProgram, mozilla::WebGLProgram>(cx, &argv[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "WebGLProgram");
        return false;
      }
    }
  } else if (argv[0].isNullOrUndefined()) {
    arg0 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  mozilla::WebGLShader* arg1;
  if (argv[1].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::WebGLShader, mozilla::WebGLShader>(cx, &argv[1].toObject(), arg1);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "WebGLShader");
        return false;
      }
    }
  } else if (argv[1].isNullOrUndefined()) {
    arg1 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->DetachShader(arg0, arg1);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo detachShader_methodinfo = {
  (JSJitPropertyOp)detachShader,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
disable(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.disable");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  self->Disable(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo disable_methodinfo = {
  (JSJitPropertyOp)disable,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
disableVertexAttribArray(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.disableVertexAttribArray");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  self->DisableVertexAttribArray(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo disableVertexAttribArray_methodinfo = {
  (JSJitPropertyOp)disableVertexAttribArray,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
drawArrays(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 3) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.drawArrays");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  int32_t arg1;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[1], &arg1)) {
    return false;
  }
  int32_t arg2;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[2], &arg2)) {
    return false;
  }
  self->DrawArrays(arg0, arg1, arg2);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo drawArrays_methodinfo = {
  (JSJitPropertyOp)drawArrays,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
drawElements(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 4) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.drawElements");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  int32_t arg1;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[1], &arg1)) {
    return false;
  }
  uint32_t arg2;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[2], &arg2)) {
    return false;
  }
  int64_t arg3;
  if (!ValueToPrimitive<int64_t, eDefault>(cx, argv[3], &arg3)) {
    return false;
  }
  self->DrawElements(arg0, arg1, arg2, arg3);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo drawElements_methodinfo = {
  (JSJitPropertyOp)drawElements,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
enable(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.enable");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  self->Enable(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo enable_methodinfo = {
  (JSJitPropertyOp)enable,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
enableVertexAttribArray(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.enableVertexAttribArray");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  self->EnableVertexAttribArray(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo enableVertexAttribArray_methodinfo = {
  (JSJitPropertyOp)enableVertexAttribArray,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
finish(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{
  self->Finish();
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo finish_methodinfo = {
  (JSJitPropertyOp)finish,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
flush(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{
  self->Flush();
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo flush_methodinfo = {
  (JSJitPropertyOp)flush,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
framebufferRenderbuffer(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 4) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.framebufferRenderbuffer");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  uint32_t arg1;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[1], &arg1)) {
    return false;
  }
  uint32_t arg2;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[2], &arg2)) {
    return false;
  }
  mozilla::WebGLRenderbuffer* arg3;
  if (argv[3].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::WebGLRenderbuffer, mozilla::WebGLRenderbuffer>(cx, &argv[3].toObject(), arg3);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "WebGLRenderbuffer");
        return false;
      }
    }
  } else if (argv[3].isNullOrUndefined()) {
    arg3 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->FramebufferRenderbuffer(arg0, arg1, arg2, arg3);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo framebufferRenderbuffer_methodinfo = {
  (JSJitPropertyOp)framebufferRenderbuffer,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
framebufferTexture2D(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 5) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.framebufferTexture2D");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  uint32_t arg1;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[1], &arg1)) {
    return false;
  }
  uint32_t arg2;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[2], &arg2)) {
    return false;
  }
  mozilla::WebGLTexture* arg3;
  if (argv[3].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::WebGLTexture, mozilla::WebGLTexture>(cx, &argv[3].toObject(), arg3);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "WebGLTexture");
        return false;
      }
    }
  } else if (argv[3].isNullOrUndefined()) {
    arg3 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  int32_t arg4;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[4], &arg4)) {
    return false;
  }
  self->FramebufferTexture2D(arg0, arg1, arg2, arg3, arg4);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo framebufferTexture2D_methodinfo = {
  (JSJitPropertyOp)framebufferTexture2D,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
frontFace(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.frontFace");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  self->FrontFace(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo frontFace_methodinfo = {
  (JSJitPropertyOp)frontFace,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
generateMipmap(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.generateMipmap");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  self->GenerateMipmap(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo generateMipmap_methodinfo = {
  (JSJitPropertyOp)generateMipmap,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
getActiveAttrib(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 2) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.getActiveAttrib");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  mozilla::WebGLProgram* arg0;
  if (argv[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::WebGLProgram, mozilla::WebGLProgram>(cx, &argv[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "WebGLProgram");
        return false;
      }
    }
  } else if (argv[0].isNullOrUndefined()) {
    arg0 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  uint32_t arg1;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[1], &arg1)) {
    return false;
  }
  nsRefPtr<mozilla::WebGLActiveInfo> result;
  result = self->GetActiveAttrib(arg0, arg1);
  if (!result) {
    *vp = JSVAL_NULL;
    return true;
  }
  if (!WrapNewBindingNonWrapperCachedObject(cx, obj, result, vp)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}


const JSJitInfo getActiveAttrib_methodinfo = {
  (JSJitPropertyOp)getActiveAttrib,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
getActiveUniform(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 2) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.getActiveUniform");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  mozilla::WebGLProgram* arg0;
  if (argv[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::WebGLProgram, mozilla::WebGLProgram>(cx, &argv[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "WebGLProgram");
        return false;
      }
    }
  } else if (argv[0].isNullOrUndefined()) {
    arg0 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  uint32_t arg1;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[1], &arg1)) {
    return false;
  }
  nsRefPtr<mozilla::WebGLActiveInfo> result;
  result = self->GetActiveUniform(arg0, arg1);
  if (!result) {
    *vp = JSVAL_NULL;
    return true;
  }
  if (!WrapNewBindingNonWrapperCachedObject(cx, obj, result, vp)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}


const JSJitInfo getActiveUniform_methodinfo = {
  (JSJitPropertyOp)getActiveUniform,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
getAttachedShaders(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.getAttachedShaders");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  mozilla::WebGLProgram* arg0;
  if (argv[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::WebGLProgram, mozilla::WebGLProgram>(cx, &argv[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "WebGLProgram");
        return false;
      }
    }
  } else if (argv[0].isNullOrUndefined()) {
    arg0 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  Nullable< nsTArray< mozilla::WebGLShader* > > result;
  self->GetAttachedShaders(arg0, result);

  if (result.IsNull()) {
    *vp = JSVAL_NULL;
    return true;
  }

  uint32_t length = result.Value().Length();
  JSObject *returnArray = JS_NewArrayObject(cx, length, NULL);
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    jsval tmp;
    for (uint32_t i = 0; i < length; ++i) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!WrapNewBindingObject(cx, returnArray, result.Value()[i], &tmp)) {
          MOZ_ASSERT(JS_IsExceptionPending(cx));
          return false;
        }
        break;
      } while (0);
      if (!JS_DefineElement(cx, returnArray, i, tmp,
                            nullptr, nullptr, JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  *vp = JS::ObjectValue(*returnArray);
  return true;
}


const JSJitInfo getAttachedShaders_methodinfo = {
  (JSJitPropertyOp)getAttachedShaders,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
getAttribLocation(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 2) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.getAttribLocation");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  mozilla::WebGLProgram* arg0;
  if (argv[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::WebGLProgram, mozilla::WebGLProgram>(cx, &argv[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "WebGLProgram");
        return false;
      }
    }
  } else if (argv[0].isNullOrUndefined()) {
    arg0 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  FakeDependentString arg1_holder;
  const NonNull<nsAString> arg1;
  if (!ConvertJSValueToString(cx, argv[1], &argv[1], eStringify, eStringify, arg1_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg1) = &arg1_holder;
  int32_t result;
  result = self->GetAttribLocation(arg0, arg1);
  *vp = INT_TO_JSVAL(int32_t(result));
  return true;
}


const JSJitInfo getAttribLocation_methodinfo = {
  (JSJitPropertyOp)getAttribLocation,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

static bool
getBufferParameter(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 2) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.getBufferParameter");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  uint32_t arg1;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[1], &arg1)) {
    return false;
  }
  JS::Value result;
  result = self->GetBufferParameter(cx, arg0, arg1);
  *vp = result;
  if (!MaybeWrapValue(cx, vp)) {
    return false;
  }
  return true;
}


const JSJitInfo getBufferParameter_methodinfo = {
  (JSJitPropertyOp)getBufferParameter,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
getParameter(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.getParameter");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  ErrorResult rv;
  JS::Value result;
  result = self->GetParameter(cx, arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "WebGLRenderingContext", "getParameter");
  }
  *vp = result;
  if (!MaybeWrapValue(cx, vp)) {
    return false;
  }
  return true;
}


const JSJitInfo getParameter_methodinfo = {
  (JSJitPropertyOp)getParameter,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
getError(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{
  uint32_t result;
  result = self->GetError();
  *vp = UINT_TO_JSVAL(result);
  return true;
}


const JSJitInfo getError_methodinfo = {
  (JSJitPropertyOp)getError,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

static bool
getFramebufferAttachmentParameter(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 3) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.getFramebufferAttachmentParameter");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  uint32_t arg1;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[1], &arg1)) {
    return false;
  }
  uint32_t arg2;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[2], &arg2)) {
    return false;
  }
  ErrorResult rv;
  JS::Value result;
  result = self->GetFramebufferAttachmentParameter(cx, arg0, arg1, arg2, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "WebGLRenderingContext", "getFramebufferAttachmentParameter");
  }
  *vp = result;
  if (!MaybeWrapValue(cx, vp)) {
    return false;
  }
  return true;
}


const JSJitInfo getFramebufferAttachmentParameter_methodinfo = {
  (JSJitPropertyOp)getFramebufferAttachmentParameter,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
getProgramParameter(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 2) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.getProgramParameter");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  mozilla::WebGLProgram* arg0;
  if (argv[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::WebGLProgram, mozilla::WebGLProgram>(cx, &argv[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "WebGLProgram");
        return false;
      }
    }
  } else if (argv[0].isNullOrUndefined()) {
    arg0 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  uint32_t arg1;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[1], &arg1)) {
    return false;
  }
  JS::Value result;
  result = self->GetProgramParameter(cx, arg0, arg1);
  *vp = result;
  if (!MaybeWrapValue(cx, vp)) {
    return false;
  }
  return true;
}


const JSJitInfo getProgramParameter_methodinfo = {
  (JSJitPropertyOp)getProgramParameter,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
getProgramInfoLog(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.getProgramInfoLog");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  mozilla::WebGLProgram* arg0;
  if (argv[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::WebGLProgram, mozilla::WebGLProgram>(cx, &argv[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "WebGLProgram");
        return false;
      }
    }
  } else if (argv[0].isNullOrUndefined()) {
    arg0 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  nsString result;
  self->GetProgramInfoLog(arg0, result);
  if (!xpc::StringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}


const JSJitInfo getProgramInfoLog_methodinfo = {
  (JSJitPropertyOp)getProgramInfoLog,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
getRenderbufferParameter(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 2) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.getRenderbufferParameter");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  uint32_t arg1;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[1], &arg1)) {
    return false;
  }
  JS::Value result;
  result = self->GetRenderbufferParameter(cx, arg0, arg1);
  *vp = result;
  if (!MaybeWrapValue(cx, vp)) {
    return false;
  }
  return true;
}


const JSJitInfo getRenderbufferParameter_methodinfo = {
  (JSJitPropertyOp)getRenderbufferParameter,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
getShaderParameter(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 2) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.getShaderParameter");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  mozilla::WebGLShader* arg0;
  if (argv[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::WebGLShader, mozilla::WebGLShader>(cx, &argv[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "WebGLShader");
        return false;
      }
    }
  } else if (argv[0].isNullOrUndefined()) {
    arg0 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  uint32_t arg1;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[1], &arg1)) {
    return false;
  }
  JS::Value result;
  result = self->GetShaderParameter(cx, arg0, arg1);
  *vp = result;
  if (!MaybeWrapValue(cx, vp)) {
    return false;
  }
  return true;
}


const JSJitInfo getShaderParameter_methodinfo = {
  (JSJitPropertyOp)getShaderParameter,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
getShaderPrecisionFormat(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 2) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.getShaderPrecisionFormat");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  uint32_t arg1;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[1], &arg1)) {
    return false;
  }
  nsRefPtr<mozilla::WebGLShaderPrecisionFormat> result;
  result = self->GetShaderPrecisionFormat(arg0, arg1);
  if (!result) {
    *vp = JSVAL_NULL;
    return true;
  }
  if (!WrapNewBindingNonWrapperCachedObject(cx, obj, result, vp)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}


const JSJitInfo getShaderPrecisionFormat_methodinfo = {
  (JSJitPropertyOp)getShaderPrecisionFormat,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
getShaderInfoLog(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.getShaderInfoLog");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  mozilla::WebGLShader* arg0;
  if (argv[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::WebGLShader, mozilla::WebGLShader>(cx, &argv[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "WebGLShader");
        return false;
      }
    }
  } else if (argv[0].isNullOrUndefined()) {
    arg0 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  nsString result;
  self->GetShaderInfoLog(arg0, result);
  if (!xpc::StringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}


const JSJitInfo getShaderInfoLog_methodinfo = {
  (JSJitPropertyOp)getShaderInfoLog,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
getShaderSource(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.getShaderSource");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  mozilla::WebGLShader* arg0;
  if (argv[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::WebGLShader, mozilla::WebGLShader>(cx, &argv[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "WebGLShader");
        return false;
      }
    }
  } else if (argv[0].isNullOrUndefined()) {
    arg0 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  nsString result;
  self->GetShaderSource(arg0, result);
  if (!xpc::StringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}


const JSJitInfo getShaderSource_methodinfo = {
  (JSJitPropertyOp)getShaderSource,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
getTexParameter(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 2) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.getTexParameter");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  uint32_t arg1;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[1], &arg1)) {
    return false;
  }
  JS::Value result;
  result = self->GetTexParameter(cx, arg0, arg1);
  *vp = result;
  if (!MaybeWrapValue(cx, vp)) {
    return false;
  }
  return true;
}


const JSJitInfo getTexParameter_methodinfo = {
  (JSJitPropertyOp)getTexParameter,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
getUniform(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 2) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.getUniform");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  mozilla::WebGLProgram* arg0;
  if (argv[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::WebGLProgram, mozilla::WebGLProgram>(cx, &argv[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "WebGLProgram");
        return false;
      }
    }
  } else if (argv[0].isNullOrUndefined()) {
    arg0 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  mozilla::WebGLUniformLocation* arg1;
  if (argv[1].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::WebGLUniformLocation, mozilla::WebGLUniformLocation>(cx, &argv[1].toObject(), arg1);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "WebGLUniformLocation");
        return false;
      }
    }
  } else if (argv[1].isNullOrUndefined()) {
    arg1 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  ErrorResult rv;
  JS::Value result;
  result = self->GetUniform(cx, arg0, arg1, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "WebGLRenderingContext", "getUniform");
  }
  *vp = result;
  if (!MaybeWrapValue(cx, vp)) {
    return false;
  }
  return true;
}


const JSJitInfo getUniform_methodinfo = {
  (JSJitPropertyOp)getUniform,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
getUniformLocation(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 2) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.getUniformLocation");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  mozilla::WebGLProgram* arg0;
  if (argv[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::WebGLProgram, mozilla::WebGLProgram>(cx, &argv[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "WebGLProgram");
        return false;
      }
    }
  } else if (argv[0].isNullOrUndefined()) {
    arg0 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  FakeDependentString arg1_holder;
  const NonNull<nsAString> arg1;
  if (!ConvertJSValueToString(cx, argv[1], &argv[1], eStringify, eStringify, arg1_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg1) = &arg1_holder;
  nsRefPtr<mozilla::WebGLUniformLocation> result;
  result = self->GetUniformLocation(arg0, arg1);
  if (!result) {
    *vp = JSVAL_NULL;
    return true;
  }
  if (!WrapNewBindingNonWrapperCachedObject(cx, obj, result, vp)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}


const JSJitInfo getUniformLocation_methodinfo = {
  (JSJitPropertyOp)getUniformLocation,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
getVertexAttrib(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 2) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.getVertexAttrib");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  uint32_t arg1;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[1], &arg1)) {
    return false;
  }
  ErrorResult rv;
  JS::Value result;
  result = self->GetVertexAttrib(cx, arg0, arg1, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "WebGLRenderingContext", "getVertexAttrib");
  }
  *vp = result;
  if (!MaybeWrapValue(cx, vp)) {
    return false;
  }
  return true;
}


const JSJitInfo getVertexAttrib_methodinfo = {
  (JSJitPropertyOp)getVertexAttrib,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
getVertexAttribOffset(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 2) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.getVertexAttribOffset");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  uint32_t arg1;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[1], &arg1)) {
    return false;
  }
  int64_t result;
  result = self->GetVertexAttribOffset(arg0, arg1);
  *vp = JS_NumberValue(double(result));
  return true;
}


const JSJitInfo getVertexAttribOffset_methodinfo = {
  (JSJitPropertyOp)getVertexAttribOffset,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

static bool
hint(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 2) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.hint");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  uint32_t arg1;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[1], &arg1)) {
    return false;
  }
  self->Hint(arg0, arg1);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo hint_methodinfo = {
  (JSJitPropertyOp)hint,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
isBuffer(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.isBuffer");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  mozilla::WebGLBuffer* arg0;
  if (argv[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::WebGLBuffer, mozilla::WebGLBuffer>(cx, &argv[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "WebGLBuffer");
        return false;
      }
    }
  } else if (argv[0].isNullOrUndefined()) {
    arg0 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  bool result;
  result = self->IsBuffer(arg0);
  *vp = BOOLEAN_TO_JSVAL(result);
  return true;
}


const JSJitInfo isBuffer_methodinfo = {
  (JSJitPropertyOp)isBuffer,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

static bool
isEnabled(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.isEnabled");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  bool result;
  result = self->IsEnabled(arg0);
  *vp = BOOLEAN_TO_JSVAL(result);
  return true;
}


const JSJitInfo isEnabled_methodinfo = {
  (JSJitPropertyOp)isEnabled,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

static bool
isFramebuffer(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.isFramebuffer");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  mozilla::WebGLFramebuffer* arg0;
  if (argv[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::WebGLFramebuffer, mozilla::WebGLFramebuffer>(cx, &argv[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "WebGLFramebuffer");
        return false;
      }
    }
  } else if (argv[0].isNullOrUndefined()) {
    arg0 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  bool result;
  result = self->IsFramebuffer(arg0);
  *vp = BOOLEAN_TO_JSVAL(result);
  return true;
}


const JSJitInfo isFramebuffer_methodinfo = {
  (JSJitPropertyOp)isFramebuffer,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

static bool
isProgram(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.isProgram");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  mozilla::WebGLProgram* arg0;
  if (argv[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::WebGLProgram, mozilla::WebGLProgram>(cx, &argv[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "WebGLProgram");
        return false;
      }
    }
  } else if (argv[0].isNullOrUndefined()) {
    arg0 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  bool result;
  result = self->IsProgram(arg0);
  *vp = BOOLEAN_TO_JSVAL(result);
  return true;
}


const JSJitInfo isProgram_methodinfo = {
  (JSJitPropertyOp)isProgram,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

static bool
isRenderbuffer(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.isRenderbuffer");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  mozilla::WebGLRenderbuffer* arg0;
  if (argv[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::WebGLRenderbuffer, mozilla::WebGLRenderbuffer>(cx, &argv[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "WebGLRenderbuffer");
        return false;
      }
    }
  } else if (argv[0].isNullOrUndefined()) {
    arg0 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  bool result;
  result = self->IsRenderbuffer(arg0);
  *vp = BOOLEAN_TO_JSVAL(result);
  return true;
}


const JSJitInfo isRenderbuffer_methodinfo = {
  (JSJitPropertyOp)isRenderbuffer,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

static bool
isShader(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.isShader");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  mozilla::WebGLShader* arg0;
  if (argv[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::WebGLShader, mozilla::WebGLShader>(cx, &argv[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "WebGLShader");
        return false;
      }
    }
  } else if (argv[0].isNullOrUndefined()) {
    arg0 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  bool result;
  result = self->IsShader(arg0);
  *vp = BOOLEAN_TO_JSVAL(result);
  return true;
}


const JSJitInfo isShader_methodinfo = {
  (JSJitPropertyOp)isShader,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

static bool
isTexture(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.isTexture");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  mozilla::WebGLTexture* arg0;
  if (argv[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::WebGLTexture, mozilla::WebGLTexture>(cx, &argv[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "WebGLTexture");
        return false;
      }
    }
  } else if (argv[0].isNullOrUndefined()) {
    arg0 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  bool result;
  result = self->IsTexture(arg0);
  *vp = BOOLEAN_TO_JSVAL(result);
  return true;
}


const JSJitInfo isTexture_methodinfo = {
  (JSJitPropertyOp)isTexture,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

static bool
lineWidth(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.lineWidth");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  self->LineWidth(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo lineWidth_methodinfo = {
  (JSJitPropertyOp)lineWidth,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
linkProgram(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.linkProgram");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  mozilla::WebGLProgram* arg0;
  if (argv[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::WebGLProgram, mozilla::WebGLProgram>(cx, &argv[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "WebGLProgram");
        return false;
      }
    }
  } else if (argv[0].isNullOrUndefined()) {
    arg0 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->LinkProgram(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo linkProgram_methodinfo = {
  (JSJitPropertyOp)linkProgram,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
pixelStorei(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 2) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.pixelStorei");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  int32_t arg1;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[1], &arg1)) {
    return false;
  }
  self->PixelStorei(arg0, arg1);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo pixelStorei_methodinfo = {
  (JSJitPropertyOp)pixelStorei,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
polygonOffset(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 2) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.polygonOffset");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  float arg1;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[1], &arg1)) {
    return false;
  }
  self->PolygonOffset(arg0, arg1);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo polygonOffset_methodinfo = {
  (JSJitPropertyOp)polygonOffset,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
readPixels(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 7) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.readPixels");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  int32_t arg0;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  int32_t arg1;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[1], &arg1)) {
    return false;
  }
  int32_t arg2;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[2], &arg2)) {
    return false;
  }
  int32_t arg3;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[3], &arg3)) {
    return false;
  }
  uint32_t arg4;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[4], &arg4)) {
    return false;
  }
  uint32_t arg5;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[5], &arg5)) {
    return false;
  }
  Maybe<ArrayBufferView> arg6_holder;
  ArrayBufferView* arg6;
  if (argv[6].isObject()) {
    arg6_holder.construct(&argv[6].toObject());
    if (!arg6_holder.ref().inited()) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "ArrayBufferView");return false;
    }
    arg6 = arg6_holder.addr();
  } else if (argv[6].isNullOrUndefined()) {
    arg6 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  ErrorResult rv;
  self->ReadPixels(arg0, arg1, arg2, arg3, arg4, arg5, arg6, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "WebGLRenderingContext", "readPixels");
  }
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo readPixels_methodinfo = {
  (JSJitPropertyOp)readPixels,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
renderbufferStorage(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 4) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.renderbufferStorage");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  uint32_t arg1;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[1], &arg1)) {
    return false;
  }
  int32_t arg2;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[2], &arg2)) {
    return false;
  }
  int32_t arg3;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[3], &arg3)) {
    return false;
  }
  self->RenderbufferStorage(arg0, arg1, arg2, arg3);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo renderbufferStorage_methodinfo = {
  (JSJitPropertyOp)renderbufferStorage,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
sampleCoverage(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 2) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.sampleCoverage");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  bool arg1;
  if (!ValueToPrimitive<bool, eDefault>(cx, argv[1], &arg1)) {
    return false;
  }
  self->SampleCoverage(arg0, arg1);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo sampleCoverage_methodinfo = {
  (JSJitPropertyOp)sampleCoverage,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
scissor(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 4) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.scissor");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  int32_t arg0;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  int32_t arg1;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[1], &arg1)) {
    return false;
  }
  int32_t arg2;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[2], &arg2)) {
    return false;
  }
  int32_t arg3;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[3], &arg3)) {
    return false;
  }
  self->Scissor(arg0, arg1, arg2, arg3);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo scissor_methodinfo = {
  (JSJitPropertyOp)scissor,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
shaderSource(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 2) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.shaderSource");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  mozilla::WebGLShader* arg0;
  if (argv[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::WebGLShader, mozilla::WebGLShader>(cx, &argv[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "WebGLShader");
        return false;
      }
    }
  } else if (argv[0].isNullOrUndefined()) {
    arg0 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  FakeDependentString arg1_holder;
  const NonNull<nsAString> arg1;
  if (!ConvertJSValueToString(cx, argv[1], &argv[1], eStringify, eStringify, arg1_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg1) = &arg1_holder;
  self->ShaderSource(arg0, arg1);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo shaderSource_methodinfo = {
  (JSJitPropertyOp)shaderSource,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
stencilFunc(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 3) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.stencilFunc");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  int32_t arg1;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[1], &arg1)) {
    return false;
  }
  uint32_t arg2;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[2], &arg2)) {
    return false;
  }
  self->StencilFunc(arg0, arg1, arg2);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo stencilFunc_methodinfo = {
  (JSJitPropertyOp)stencilFunc,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
stencilFuncSeparate(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 4) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.stencilFuncSeparate");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  uint32_t arg1;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[1], &arg1)) {
    return false;
  }
  int32_t arg2;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[2], &arg2)) {
    return false;
  }
  uint32_t arg3;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[3], &arg3)) {
    return false;
  }
  self->StencilFuncSeparate(arg0, arg1, arg2, arg3);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo stencilFuncSeparate_methodinfo = {
  (JSJitPropertyOp)stencilFuncSeparate,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
stencilMask(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.stencilMask");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  self->StencilMask(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo stencilMask_methodinfo = {
  (JSJitPropertyOp)stencilMask,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
stencilMaskSeparate(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 2) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.stencilMaskSeparate");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  uint32_t arg1;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[1], &arg1)) {
    return false;
  }
  self->StencilMaskSeparate(arg0, arg1);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo stencilMaskSeparate_methodinfo = {
  (JSJitPropertyOp)stencilMaskSeparate,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
stencilOp(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 3) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.stencilOp");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  uint32_t arg1;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[1], &arg1)) {
    return false;
  }
  uint32_t arg2;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[2], &arg2)) {
    return false;
  }
  self->StencilOp(arg0, arg1, arg2);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo stencilOp_methodinfo = {
  (JSJitPropertyOp)stencilOp,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
stencilOpSeparate(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 4) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.stencilOpSeparate");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  uint32_t arg1;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[1], &arg1)) {
    return false;
  }
  uint32_t arg2;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[2], &arg2)) {
    return false;
  }
  uint32_t arg3;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[3], &arg3)) {
    return false;
  }
  self->StencilOpSeparate(arg0, arg1, arg2, arg3);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo stencilOpSeparate_methodinfo = {
  (JSJitPropertyOp)stencilOpSeparate,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
texImage2D(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  unsigned argcount = NS_MIN(argc, 9u);
  switch (argcount) {
    case 6: {
      JS::Value* argv_start = JS_ARGV(cx, vp);
      uint32_t arg0;
      if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv_start[0], &arg0)) {
        return false;
      }
      int32_t arg1;
      if (!ValueToPrimitive<int32_t, eDefault>(cx, argv_start[1], &arg1)) {
        return false;
      }
      uint32_t arg2;
      if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv_start[2], &arg2)) {
        return false;
      }
      uint32_t arg3;
      if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv_start[3], &arg3)) {
        return false;
      }
      uint32_t arg4;
      if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv_start[4], &arg4)) {
        return false;
      }
      if (argv_start[5].isNullOrUndefined()) {
        mozilla::dom::ImageData* arg5;
        arg5 = NULL;
        ErrorResult rv;
        self->TexImage2D(arg0, arg1, arg2, arg3, arg4, arg5, rv);
        if (rv.Failed()) {
          return ThrowMethodFailedWithDetails<true>(cx, rv, "WebGLRenderingContext", "texImage2D");
        }
        *vp = JSVAL_VOID;
        return true;
      }
      if (argv_start[5].isObject()) {
        do {
          mozilla::dom::ImageData* arg5;
          {
            nsresult rv = UnwrapObject<prototypes::id::ImageData, mozilla::dom::ImageData>(cx, &argv_start[5].toObject(), arg5);
            if (NS_FAILED(rv)) {
              break;
            }
          }
          ErrorResult rv;
          self->TexImage2D(arg0, arg1, arg2, arg3, arg4, arg5, rv);
          if (rv.Failed()) {
            return ThrowMethodFailedWithDetails<true>(cx, rv, "WebGLRenderingContext", "texImage2D");
          }
          *vp = JSVAL_VOID;
          return true;
        } while (0);
        do {
          NonNull<mozilla::dom::HTMLImageElement> arg5;
          {
            nsresult rv = UnwrapObject<prototypes::id::HTMLImageElement, mozilla::dom::HTMLImageElement>(cx, &argv_start[5].toObject(), arg5);
            if (NS_FAILED(rv)) {
              break;
            }
          }
          ErrorResult rv;
          self->TexImage2D(arg0, arg1, arg2, arg3, arg4, arg5, rv);
          if (rv.Failed()) {
            return ThrowMethodFailedWithDetails<true>(cx, rv, "WebGLRenderingContext", "texImage2D");
          }
          *vp = JSVAL_VOID;
          return true;
        } while (0);
        do {
          nsRefPtr<mozilla::dom::HTMLCanvasElement> arg5_holder;
          mozilla::dom::HTMLCanvasElement* arg5;
          jsval tmpVal = argv_start[5];
          mozilla::dom::HTMLCanvasElement* tmp;
          if (NS_FAILED(xpc_qsUnwrapArg<mozilla::dom::HTMLCanvasElement>(cx, argv_start[5], &tmp, static_cast<mozilla::dom::HTMLCanvasElement**>(getter_AddRefs(arg5_holder)), &tmpVal))) {
            break;
          }
          MOZ_ASSERT(tmp);
          arg5 = tmp;
          ErrorResult rv;
          self->TexImage2D(arg0, arg1, arg2, arg3, arg4, arg5, rv);
          if (rv.Failed()) {
            return ThrowMethodFailedWithDetails<true>(cx, rv, "WebGLRenderingContext", "texImage2D");
          }
          *vp = JSVAL_VOID;
          return true;
        } while (0);
        do {
          nsRefPtr<nsHTMLVideoElement> arg5_holder;
          nsHTMLVideoElement* arg5;
          jsval tmpVal = argv_start[5];
          nsHTMLVideoElement* tmp;
          if (NS_FAILED(xpc_qsUnwrapArg<nsHTMLVideoElement>(cx, argv_start[5], &tmp, static_cast<nsHTMLVideoElement**>(getter_AddRefs(arg5_holder)), &tmpVal))) {
            break;
          }
          MOZ_ASSERT(tmp);
          arg5 = tmp;
          ErrorResult rv;
          self->TexImage2D(arg0, arg1, arg2, arg3, arg4, arg5, rv);
          if (rv.Failed()) {
            return ThrowMethodFailedWithDetails<true>(cx, rv, "WebGLRenderingContext", "texImage2D");
          }
          *vp = JSVAL_VOID;
          return true;
        } while (0);
      }
      return ThrowErrorMessage(cx, MSG_INVALID_ARG, "5", "6");
      break;
    }
    case 9: {

      JS::Value* argv = JS_ARGV(cx, vp);

      uint32_t arg0;
      if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[0], &arg0)) {
        return false;
      }
      int32_t arg1;
      if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[1], &arg1)) {
        return false;
      }
      uint32_t arg2;
      if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[2], &arg2)) {
        return false;
      }
      int32_t arg3;
      if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[3], &arg3)) {
        return false;
      }
      int32_t arg4;
      if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[4], &arg4)) {
        return false;
      }
      int32_t arg5;
      if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[5], &arg5)) {
        return false;
      }
      uint32_t arg6;
      if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[6], &arg6)) {
        return false;
      }
      uint32_t arg7;
      if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[7], &arg7)) {
        return false;
      }
      Maybe<ArrayBufferView> arg8_holder;
      ArrayBufferView* arg8;
      if (argv[8].isObject()) {
        arg8_holder.construct(&argv[8].toObject());
        if (!arg8_holder.ref().inited()) {
          ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "ArrayBufferView");return false;
        }
        arg8 = arg8_holder.addr();
      } else if (argv[8].isNullOrUndefined()) {
        arg8 = NULL;
      } else {
        ThrowErrorMessage(cx, MSG_NOT_OBJECT);
        return false;
      }
      ErrorResult rv;
      self->TexImage2D(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, rv);
      if (rv.Failed()) {
        return ThrowMethodFailedWithDetails<true>(cx, rv, "WebGLRenderingContext", "texImage2D");
      }
      *vp = JSVAL_VOID;
      return true;
      break;
    }
    default: {
      return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.texImage2D");

      break;
    }
  }
  MOZ_NOT_REACHED("We have an always-returning default case");
  return false;
}


const JSJitInfo texImage2D_methodinfo = {
  (JSJitPropertyOp)texImage2D,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
texParameterf(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 3) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.texParameterf");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  uint32_t arg1;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[1], &arg1)) {
    return false;
  }
  float arg2;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[2], &arg2)) {
    return false;
  }
  self->TexParameterf(arg0, arg1, arg2);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo texParameterf_methodinfo = {
  (JSJitPropertyOp)texParameterf,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
texParameteri(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 3) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.texParameteri");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  uint32_t arg1;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[1], &arg1)) {
    return false;
  }
  int32_t arg2;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[2], &arg2)) {
    return false;
  }
  self->TexParameteri(arg0, arg1, arg2);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo texParameteri_methodinfo = {
  (JSJitPropertyOp)texParameteri,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
texSubImage2D(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  unsigned argcount = NS_MIN(argc, 9u);
  switch (argcount) {
    case 7: {
      JS::Value* argv_start = JS_ARGV(cx, vp);
      uint32_t arg0;
      if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv_start[0], &arg0)) {
        return false;
      }
      int32_t arg1;
      if (!ValueToPrimitive<int32_t, eDefault>(cx, argv_start[1], &arg1)) {
        return false;
      }
      int32_t arg2;
      if (!ValueToPrimitive<int32_t, eDefault>(cx, argv_start[2], &arg2)) {
        return false;
      }
      int32_t arg3;
      if (!ValueToPrimitive<int32_t, eDefault>(cx, argv_start[3], &arg3)) {
        return false;
      }
      uint32_t arg4;
      if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv_start[4], &arg4)) {
        return false;
      }
      uint32_t arg5;
      if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv_start[5], &arg5)) {
        return false;
      }
      if (argv_start[6].isNullOrUndefined()) {
        mozilla::dom::ImageData* arg6;
        arg6 = NULL;
        ErrorResult rv;
        self->TexSubImage2D(arg0, arg1, arg2, arg3, arg4, arg5, arg6, rv);
        if (rv.Failed()) {
          return ThrowMethodFailedWithDetails<true>(cx, rv, "WebGLRenderingContext", "texSubImage2D");
        }
        *vp = JSVAL_VOID;
        return true;
      }
      if (argv_start[6].isObject()) {
        do {
          mozilla::dom::ImageData* arg6;
          {
            nsresult rv = UnwrapObject<prototypes::id::ImageData, mozilla::dom::ImageData>(cx, &argv_start[6].toObject(), arg6);
            if (NS_FAILED(rv)) {
              break;
            }
          }
          ErrorResult rv;
          self->TexSubImage2D(arg0, arg1, arg2, arg3, arg4, arg5, arg6, rv);
          if (rv.Failed()) {
            return ThrowMethodFailedWithDetails<true>(cx, rv, "WebGLRenderingContext", "texSubImage2D");
          }
          *vp = JSVAL_VOID;
          return true;
        } while (0);
        do {
          NonNull<mozilla::dom::HTMLImageElement> arg6;
          {
            nsresult rv = UnwrapObject<prototypes::id::HTMLImageElement, mozilla::dom::HTMLImageElement>(cx, &argv_start[6].toObject(), arg6);
            if (NS_FAILED(rv)) {
              break;
            }
          }
          ErrorResult rv;
          self->TexSubImage2D(arg0, arg1, arg2, arg3, arg4, arg5, arg6, rv);
          if (rv.Failed()) {
            return ThrowMethodFailedWithDetails<true>(cx, rv, "WebGLRenderingContext", "texSubImage2D");
          }
          *vp = JSVAL_VOID;
          return true;
        } while (0);
        do {
          nsRefPtr<mozilla::dom::HTMLCanvasElement> arg6_holder;
          mozilla::dom::HTMLCanvasElement* arg6;
          jsval tmpVal = argv_start[6];
          mozilla::dom::HTMLCanvasElement* tmp;
          if (NS_FAILED(xpc_qsUnwrapArg<mozilla::dom::HTMLCanvasElement>(cx, argv_start[6], &tmp, static_cast<mozilla::dom::HTMLCanvasElement**>(getter_AddRefs(arg6_holder)), &tmpVal))) {
            break;
          }
          MOZ_ASSERT(tmp);
          arg6 = tmp;
          ErrorResult rv;
          self->TexSubImage2D(arg0, arg1, arg2, arg3, arg4, arg5, arg6, rv);
          if (rv.Failed()) {
            return ThrowMethodFailedWithDetails<true>(cx, rv, "WebGLRenderingContext", "texSubImage2D");
          }
          *vp = JSVAL_VOID;
          return true;
        } while (0);
        do {
          nsRefPtr<nsHTMLVideoElement> arg6_holder;
          nsHTMLVideoElement* arg6;
          jsval tmpVal = argv_start[6];
          nsHTMLVideoElement* tmp;
          if (NS_FAILED(xpc_qsUnwrapArg<nsHTMLVideoElement>(cx, argv_start[6], &tmp, static_cast<nsHTMLVideoElement**>(getter_AddRefs(arg6_holder)), &tmpVal))) {
            break;
          }
          MOZ_ASSERT(tmp);
          arg6 = tmp;
          ErrorResult rv;
          self->TexSubImage2D(arg0, arg1, arg2, arg3, arg4, arg5, arg6, rv);
          if (rv.Failed()) {
            return ThrowMethodFailedWithDetails<true>(cx, rv, "WebGLRenderingContext", "texSubImage2D");
          }
          *vp = JSVAL_VOID;
          return true;
        } while (0);
      }
      return ThrowErrorMessage(cx, MSG_INVALID_ARG, "6", "7");
      break;
    }
    case 9: {

      JS::Value* argv = JS_ARGV(cx, vp);

      uint32_t arg0;
      if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[0], &arg0)) {
        return false;
      }
      int32_t arg1;
      if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[1], &arg1)) {
        return false;
      }
      int32_t arg2;
      if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[2], &arg2)) {
        return false;
      }
      int32_t arg3;
      if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[3], &arg3)) {
        return false;
      }
      int32_t arg4;
      if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[4], &arg4)) {
        return false;
      }
      int32_t arg5;
      if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[5], &arg5)) {
        return false;
      }
      uint32_t arg6;
      if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[6], &arg6)) {
        return false;
      }
      uint32_t arg7;
      if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[7], &arg7)) {
        return false;
      }
      Maybe<ArrayBufferView> arg8_holder;
      ArrayBufferView* arg8;
      if (argv[8].isObject()) {
        arg8_holder.construct(&argv[8].toObject());
        if (!arg8_holder.ref().inited()) {
          ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "ArrayBufferView");return false;
        }
        arg8 = arg8_holder.addr();
      } else if (argv[8].isNullOrUndefined()) {
        arg8 = NULL;
      } else {
        ThrowErrorMessage(cx, MSG_NOT_OBJECT);
        return false;
      }
      ErrorResult rv;
      self->TexSubImage2D(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, rv);
      if (rv.Failed()) {
        return ThrowMethodFailedWithDetails<true>(cx, rv, "WebGLRenderingContext", "texSubImage2D");
      }
      *vp = JSVAL_VOID;
      return true;
      break;
    }
    default: {
      return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.texSubImage2D");

      break;
    }
  }
  MOZ_NOT_REACHED("We have an always-returning default case");
  return false;
}


const JSJitInfo texSubImage2D_methodinfo = {
  (JSJitPropertyOp)texSubImage2D,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
uniform1f(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 2) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.uniform1f");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  mozilla::WebGLUniformLocation* arg0;
  if (argv[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::WebGLUniformLocation, mozilla::WebGLUniformLocation>(cx, &argv[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "WebGLUniformLocation");
        return false;
      }
    }
  } else if (argv[0].isNullOrUndefined()) {
    arg0 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  float arg1;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[1], &arg1)) {
    return false;
  }
  self->Uniform1f(arg0, arg1);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo uniform1f_methodinfo = {
  (JSJitPropertyOp)uniform1f,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
uniform1fv(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  unsigned argcount = NS_MIN(argc, 2u);
  switch (argcount) {
    case 2: {
      JS::Value* argv_start = JS_ARGV(cx, vp);
      mozilla::WebGLUniformLocation* arg0;
      if (argv_start[0].isObject()) {
        {
          nsresult rv = UnwrapObject<prototypes::id::WebGLUniformLocation, mozilla::WebGLUniformLocation>(cx, &argv_start[0].toObject(), arg0);
          if (NS_FAILED(rv)) {
            ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "WebGLUniformLocation");
            return false;
          }
        }
      } else if (argv_start[0].isNullOrUndefined()) {
        arg0 = NULL;
      } else {
        ThrowErrorMessage(cx, MSG_NOT_OBJECT);
        return false;
      }
      if (argv_start[1].isObject()) {
        do {
          Maybe<Float32Array> arg1_holder;
          NonNull<Float32Array> arg1;
          arg1_holder.construct(&argv_start[1].toObject());
          if (!arg1_holder.ref().inited()) {
            break;
          }
          arg1 = arg1_holder.addr();
          self->Uniform1fv(arg0, arg1);
          *vp = JSVAL_VOID;
          return true;
        } while (0);
        do {
          const Sequence< float > arg1;
          JSObject* seq = &argv_start[1].toObject();

          if (!IsArrayLike(cx, seq)) {
            break;
          }
          uint32_t length;
          // JS_GetArrayLength actually works on all objects
          if (!JS_GetArrayLength(cx, seq, &length)) {
            return false;
          }
          Sequence< float > &arr = const_cast< Sequence< float >& >(arg1);
          if (!arr.SetCapacity(length)) {
            JS_ReportOutOfMemory(cx);
            return false;
          }
          for (uint32_t i = 0; i < length; ++i) {
            jsval temp;
            if (!JS_GetElement(cx, seq, i, &temp)) {
              return false;
            }
            float& slot = *arr.AppendElement();
            if (!ValueToPrimitive<float, eDefault>(cx, temp, &slot)) {
              return false;
            }
          }
          self->Uniform1fv(arg0, arg1);
          *vp = JSVAL_VOID;
          return true;
        } while (0);
      }
      return ThrowErrorMessage(cx, MSG_INVALID_ARG, "1", "2");
      break;
    }
    default: {
      return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.uniform1fv");

      break;
    }
  }
  MOZ_NOT_REACHED("We have an always-returning default case");
  return false;
}


const JSJitInfo uniform1fv_methodinfo = {
  (JSJitPropertyOp)uniform1fv,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
uniform1i(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 2) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.uniform1i");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  mozilla::WebGLUniformLocation* arg0;
  if (argv[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::WebGLUniformLocation, mozilla::WebGLUniformLocation>(cx, &argv[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "WebGLUniformLocation");
        return false;
      }
    }
  } else if (argv[0].isNullOrUndefined()) {
    arg0 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  int32_t arg1;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[1], &arg1)) {
    return false;
  }
  self->Uniform1i(arg0, arg1);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo uniform1i_methodinfo = {
  (JSJitPropertyOp)uniform1i,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
uniform1iv(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  unsigned argcount = NS_MIN(argc, 2u);
  switch (argcount) {
    case 2: {
      JS::Value* argv_start = JS_ARGV(cx, vp);
      mozilla::WebGLUniformLocation* arg0;
      if (argv_start[0].isObject()) {
        {
          nsresult rv = UnwrapObject<prototypes::id::WebGLUniformLocation, mozilla::WebGLUniformLocation>(cx, &argv_start[0].toObject(), arg0);
          if (NS_FAILED(rv)) {
            ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "WebGLUniformLocation");
            return false;
          }
        }
      } else if (argv_start[0].isNullOrUndefined()) {
        arg0 = NULL;
      } else {
        ThrowErrorMessage(cx, MSG_NOT_OBJECT);
        return false;
      }
      if (argv_start[1].isObject()) {
        do {
          Maybe<Int32Array> arg1_holder;
          NonNull<Int32Array> arg1;
          arg1_holder.construct(&argv_start[1].toObject());
          if (!arg1_holder.ref().inited()) {
            break;
          }
          arg1 = arg1_holder.addr();
          self->Uniform1iv(arg0, arg1);
          *vp = JSVAL_VOID;
          return true;
        } while (0);
        do {
          const Sequence< int32_t > arg1;
          JSObject* seq = &argv_start[1].toObject();

          if (!IsArrayLike(cx, seq)) {
            break;
          }
          uint32_t length;
          // JS_GetArrayLength actually works on all objects
          if (!JS_GetArrayLength(cx, seq, &length)) {
            return false;
          }
          Sequence< int32_t > &arr = const_cast< Sequence< int32_t >& >(arg1);
          if (!arr.SetCapacity(length)) {
            JS_ReportOutOfMemory(cx);
            return false;
          }
          for (uint32_t i = 0; i < length; ++i) {
            jsval temp;
            if (!JS_GetElement(cx, seq, i, &temp)) {
              return false;
            }
            int32_t& slot = *arr.AppendElement();
            if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, &slot)) {
              return false;
            }
          }
          self->Uniform1iv(arg0, arg1);
          *vp = JSVAL_VOID;
          return true;
        } while (0);
      }
      return ThrowErrorMessage(cx, MSG_INVALID_ARG, "1", "2");
      break;
    }
    default: {
      return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.uniform1iv");

      break;
    }
  }
  MOZ_NOT_REACHED("We have an always-returning default case");
  return false;
}


const JSJitInfo uniform1iv_methodinfo = {
  (JSJitPropertyOp)uniform1iv,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
uniform2f(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 3) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.uniform2f");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  mozilla::WebGLUniformLocation* arg0;
  if (argv[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::WebGLUniformLocation, mozilla::WebGLUniformLocation>(cx, &argv[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "WebGLUniformLocation");
        return false;
      }
    }
  } else if (argv[0].isNullOrUndefined()) {
    arg0 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  float arg1;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[1], &arg1)) {
    return false;
  }
  float arg2;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[2], &arg2)) {
    return false;
  }
  self->Uniform2f(arg0, arg1, arg2);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo uniform2f_methodinfo = {
  (JSJitPropertyOp)uniform2f,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
uniform2fv(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  unsigned argcount = NS_MIN(argc, 2u);
  switch (argcount) {
    case 2: {
      JS::Value* argv_start = JS_ARGV(cx, vp);
      mozilla::WebGLUniformLocation* arg0;
      if (argv_start[0].isObject()) {
        {
          nsresult rv = UnwrapObject<prototypes::id::WebGLUniformLocation, mozilla::WebGLUniformLocation>(cx, &argv_start[0].toObject(), arg0);
          if (NS_FAILED(rv)) {
            ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "WebGLUniformLocation");
            return false;
          }
        }
      } else if (argv_start[0].isNullOrUndefined()) {
        arg0 = NULL;
      } else {
        ThrowErrorMessage(cx, MSG_NOT_OBJECT);
        return false;
      }
      if (argv_start[1].isObject()) {
        do {
          Maybe<Float32Array> arg1_holder;
          NonNull<Float32Array> arg1;
          arg1_holder.construct(&argv_start[1].toObject());
          if (!arg1_holder.ref().inited()) {
            break;
          }
          arg1 = arg1_holder.addr();
          self->Uniform2fv(arg0, arg1);
          *vp = JSVAL_VOID;
          return true;
        } while (0);
        do {
          const Sequence< float > arg1;
          JSObject* seq = &argv_start[1].toObject();

          if (!IsArrayLike(cx, seq)) {
            break;
          }
          uint32_t length;
          // JS_GetArrayLength actually works on all objects
          if (!JS_GetArrayLength(cx, seq, &length)) {
            return false;
          }
          Sequence< float > &arr = const_cast< Sequence< float >& >(arg1);
          if (!arr.SetCapacity(length)) {
            JS_ReportOutOfMemory(cx);
            return false;
          }
          for (uint32_t i = 0; i < length; ++i) {
            jsval temp;
            if (!JS_GetElement(cx, seq, i, &temp)) {
              return false;
            }
            float& slot = *arr.AppendElement();
            if (!ValueToPrimitive<float, eDefault>(cx, temp, &slot)) {
              return false;
            }
          }
          self->Uniform2fv(arg0, arg1);
          *vp = JSVAL_VOID;
          return true;
        } while (0);
      }
      return ThrowErrorMessage(cx, MSG_INVALID_ARG, "1", "2");
      break;
    }
    default: {
      return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.uniform2fv");

      break;
    }
  }
  MOZ_NOT_REACHED("We have an always-returning default case");
  return false;
}


const JSJitInfo uniform2fv_methodinfo = {
  (JSJitPropertyOp)uniform2fv,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
uniform2i(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 3) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.uniform2i");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  mozilla::WebGLUniformLocation* arg0;
  if (argv[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::WebGLUniformLocation, mozilla::WebGLUniformLocation>(cx, &argv[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "WebGLUniformLocation");
        return false;
      }
    }
  } else if (argv[0].isNullOrUndefined()) {
    arg0 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  int32_t arg1;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[1], &arg1)) {
    return false;
  }
  int32_t arg2;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[2], &arg2)) {
    return false;
  }
  self->Uniform2i(arg0, arg1, arg2);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo uniform2i_methodinfo = {
  (JSJitPropertyOp)uniform2i,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
uniform2iv(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  unsigned argcount = NS_MIN(argc, 2u);
  switch (argcount) {
    case 2: {
      JS::Value* argv_start = JS_ARGV(cx, vp);
      mozilla::WebGLUniformLocation* arg0;
      if (argv_start[0].isObject()) {
        {
          nsresult rv = UnwrapObject<prototypes::id::WebGLUniformLocation, mozilla::WebGLUniformLocation>(cx, &argv_start[0].toObject(), arg0);
          if (NS_FAILED(rv)) {
            ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "WebGLUniformLocation");
            return false;
          }
        }
      } else if (argv_start[0].isNullOrUndefined()) {
        arg0 = NULL;
      } else {
        ThrowErrorMessage(cx, MSG_NOT_OBJECT);
        return false;
      }
      if (argv_start[1].isObject()) {
        do {
          Maybe<Int32Array> arg1_holder;
          NonNull<Int32Array> arg1;
          arg1_holder.construct(&argv_start[1].toObject());
          if (!arg1_holder.ref().inited()) {
            break;
          }
          arg1 = arg1_holder.addr();
          self->Uniform2iv(arg0, arg1);
          *vp = JSVAL_VOID;
          return true;
        } while (0);
        do {
          const Sequence< int32_t > arg1;
          JSObject* seq = &argv_start[1].toObject();

          if (!IsArrayLike(cx, seq)) {
            break;
          }
          uint32_t length;
          // JS_GetArrayLength actually works on all objects
          if (!JS_GetArrayLength(cx, seq, &length)) {
            return false;
          }
          Sequence< int32_t > &arr = const_cast< Sequence< int32_t >& >(arg1);
          if (!arr.SetCapacity(length)) {
            JS_ReportOutOfMemory(cx);
            return false;
          }
          for (uint32_t i = 0; i < length; ++i) {
            jsval temp;
            if (!JS_GetElement(cx, seq, i, &temp)) {
              return false;
            }
            int32_t& slot = *arr.AppendElement();
            if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, &slot)) {
              return false;
            }
          }
          self->Uniform2iv(arg0, arg1);
          *vp = JSVAL_VOID;
          return true;
        } while (0);
      }
      return ThrowErrorMessage(cx, MSG_INVALID_ARG, "1", "2");
      break;
    }
    default: {
      return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.uniform2iv");

      break;
    }
  }
  MOZ_NOT_REACHED("We have an always-returning default case");
  return false;
}


const JSJitInfo uniform2iv_methodinfo = {
  (JSJitPropertyOp)uniform2iv,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
uniform3f(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 4) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.uniform3f");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  mozilla::WebGLUniformLocation* arg0;
  if (argv[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::WebGLUniformLocation, mozilla::WebGLUniformLocation>(cx, &argv[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "WebGLUniformLocation");
        return false;
      }
    }
  } else if (argv[0].isNullOrUndefined()) {
    arg0 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  float arg1;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[1], &arg1)) {
    return false;
  }
  float arg2;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[2], &arg2)) {
    return false;
  }
  float arg3;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[3], &arg3)) {
    return false;
  }
  self->Uniform3f(arg0, arg1, arg2, arg3);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo uniform3f_methodinfo = {
  (JSJitPropertyOp)uniform3f,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
uniform3fv(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  unsigned argcount = NS_MIN(argc, 2u);
  switch (argcount) {
    case 2: {
      JS::Value* argv_start = JS_ARGV(cx, vp);
      mozilla::WebGLUniformLocation* arg0;
      if (argv_start[0].isObject()) {
        {
          nsresult rv = UnwrapObject<prototypes::id::WebGLUniformLocation, mozilla::WebGLUniformLocation>(cx, &argv_start[0].toObject(), arg0);
          if (NS_FAILED(rv)) {
            ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "WebGLUniformLocation");
            return false;
          }
        }
      } else if (argv_start[0].isNullOrUndefined()) {
        arg0 = NULL;
      } else {
        ThrowErrorMessage(cx, MSG_NOT_OBJECT);
        return false;
      }
      if (argv_start[1].isObject()) {
        do {
          Maybe<Float32Array> arg1_holder;
          NonNull<Float32Array> arg1;
          arg1_holder.construct(&argv_start[1].toObject());
          if (!arg1_holder.ref().inited()) {
            break;
          }
          arg1 = arg1_holder.addr();
          self->Uniform3fv(arg0, arg1);
          *vp = JSVAL_VOID;
          return true;
        } while (0);
        do {
          const Sequence< float > arg1;
          JSObject* seq = &argv_start[1].toObject();

          if (!IsArrayLike(cx, seq)) {
            break;
          }
          uint32_t length;
          // JS_GetArrayLength actually works on all objects
          if (!JS_GetArrayLength(cx, seq, &length)) {
            return false;
          }
          Sequence< float > &arr = const_cast< Sequence< float >& >(arg1);
          if (!arr.SetCapacity(length)) {
            JS_ReportOutOfMemory(cx);
            return false;
          }
          for (uint32_t i = 0; i < length; ++i) {
            jsval temp;
            if (!JS_GetElement(cx, seq, i, &temp)) {
              return false;
            }
            float& slot = *arr.AppendElement();
            if (!ValueToPrimitive<float, eDefault>(cx, temp, &slot)) {
              return false;
            }
          }
          self->Uniform3fv(arg0, arg1);
          *vp = JSVAL_VOID;
          return true;
        } while (0);
      }
      return ThrowErrorMessage(cx, MSG_INVALID_ARG, "1", "2");
      break;
    }
    default: {
      return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.uniform3fv");

      break;
    }
  }
  MOZ_NOT_REACHED("We have an always-returning default case");
  return false;
}


const JSJitInfo uniform3fv_methodinfo = {
  (JSJitPropertyOp)uniform3fv,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
uniform3i(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 4) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.uniform3i");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  mozilla::WebGLUniformLocation* arg0;
  if (argv[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::WebGLUniformLocation, mozilla::WebGLUniformLocation>(cx, &argv[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "WebGLUniformLocation");
        return false;
      }
    }
  } else if (argv[0].isNullOrUndefined()) {
    arg0 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  int32_t arg1;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[1], &arg1)) {
    return false;
  }
  int32_t arg2;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[2], &arg2)) {
    return false;
  }
  int32_t arg3;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[3], &arg3)) {
    return false;
  }
  self->Uniform3i(arg0, arg1, arg2, arg3);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo uniform3i_methodinfo = {
  (JSJitPropertyOp)uniform3i,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
uniform3iv(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  unsigned argcount = NS_MIN(argc, 2u);
  switch (argcount) {
    case 2: {
      JS::Value* argv_start = JS_ARGV(cx, vp);
      mozilla::WebGLUniformLocation* arg0;
      if (argv_start[0].isObject()) {
        {
          nsresult rv = UnwrapObject<prototypes::id::WebGLUniformLocation, mozilla::WebGLUniformLocation>(cx, &argv_start[0].toObject(), arg0);
          if (NS_FAILED(rv)) {
            ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "WebGLUniformLocation");
            return false;
          }
        }
      } else if (argv_start[0].isNullOrUndefined()) {
        arg0 = NULL;
      } else {
        ThrowErrorMessage(cx, MSG_NOT_OBJECT);
        return false;
      }
      if (argv_start[1].isObject()) {
        do {
          Maybe<Int32Array> arg1_holder;
          NonNull<Int32Array> arg1;
          arg1_holder.construct(&argv_start[1].toObject());
          if (!arg1_holder.ref().inited()) {
            break;
          }
          arg1 = arg1_holder.addr();
          self->Uniform3iv(arg0, arg1);
          *vp = JSVAL_VOID;
          return true;
        } while (0);
        do {
          const Sequence< int32_t > arg1;
          JSObject* seq = &argv_start[1].toObject();

          if (!IsArrayLike(cx, seq)) {
            break;
          }
          uint32_t length;
          // JS_GetArrayLength actually works on all objects
          if (!JS_GetArrayLength(cx, seq, &length)) {
            return false;
          }
          Sequence< int32_t > &arr = const_cast< Sequence< int32_t >& >(arg1);
          if (!arr.SetCapacity(length)) {
            JS_ReportOutOfMemory(cx);
            return false;
          }
          for (uint32_t i = 0; i < length; ++i) {
            jsval temp;
            if (!JS_GetElement(cx, seq, i, &temp)) {
              return false;
            }
            int32_t& slot = *arr.AppendElement();
            if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, &slot)) {
              return false;
            }
          }
          self->Uniform3iv(arg0, arg1);
          *vp = JSVAL_VOID;
          return true;
        } while (0);
      }
      return ThrowErrorMessage(cx, MSG_INVALID_ARG, "1", "2");
      break;
    }
    default: {
      return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.uniform3iv");

      break;
    }
  }
  MOZ_NOT_REACHED("We have an always-returning default case");
  return false;
}


const JSJitInfo uniform3iv_methodinfo = {
  (JSJitPropertyOp)uniform3iv,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
uniform4f(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 5) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.uniform4f");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  mozilla::WebGLUniformLocation* arg0;
  if (argv[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::WebGLUniformLocation, mozilla::WebGLUniformLocation>(cx, &argv[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "WebGLUniformLocation");
        return false;
      }
    }
  } else if (argv[0].isNullOrUndefined()) {
    arg0 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  float arg1;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[1], &arg1)) {
    return false;
  }
  float arg2;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[2], &arg2)) {
    return false;
  }
  float arg3;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[3], &arg3)) {
    return false;
  }
  float arg4;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[4], &arg4)) {
    return false;
  }
  self->Uniform4f(arg0, arg1, arg2, arg3, arg4);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo uniform4f_methodinfo = {
  (JSJitPropertyOp)uniform4f,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
uniform4fv(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  unsigned argcount = NS_MIN(argc, 2u);
  switch (argcount) {
    case 2: {
      JS::Value* argv_start = JS_ARGV(cx, vp);
      mozilla::WebGLUniformLocation* arg0;
      if (argv_start[0].isObject()) {
        {
          nsresult rv = UnwrapObject<prototypes::id::WebGLUniformLocation, mozilla::WebGLUniformLocation>(cx, &argv_start[0].toObject(), arg0);
          if (NS_FAILED(rv)) {
            ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "WebGLUniformLocation");
            return false;
          }
        }
      } else if (argv_start[0].isNullOrUndefined()) {
        arg0 = NULL;
      } else {
        ThrowErrorMessage(cx, MSG_NOT_OBJECT);
        return false;
      }
      if (argv_start[1].isObject()) {
        do {
          Maybe<Float32Array> arg1_holder;
          NonNull<Float32Array> arg1;
          arg1_holder.construct(&argv_start[1].toObject());
          if (!arg1_holder.ref().inited()) {
            break;
          }
          arg1 = arg1_holder.addr();
          self->Uniform4fv(arg0, arg1);
          *vp = JSVAL_VOID;
          return true;
        } while (0);
        do {
          const Sequence< float > arg1;
          JSObject* seq = &argv_start[1].toObject();

          if (!IsArrayLike(cx, seq)) {
            break;
          }
          uint32_t length;
          // JS_GetArrayLength actually works on all objects
          if (!JS_GetArrayLength(cx, seq, &length)) {
            return false;
          }
          Sequence< float > &arr = const_cast< Sequence< float >& >(arg1);
          if (!arr.SetCapacity(length)) {
            JS_ReportOutOfMemory(cx);
            return false;
          }
          for (uint32_t i = 0; i < length; ++i) {
            jsval temp;
            if (!JS_GetElement(cx, seq, i, &temp)) {
              return false;
            }
            float& slot = *arr.AppendElement();
            if (!ValueToPrimitive<float, eDefault>(cx, temp, &slot)) {
              return false;
            }
          }
          self->Uniform4fv(arg0, arg1);
          *vp = JSVAL_VOID;
          return true;
        } while (0);
      }
      return ThrowErrorMessage(cx, MSG_INVALID_ARG, "1", "2");
      break;
    }
    default: {
      return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.uniform4fv");

      break;
    }
  }
  MOZ_NOT_REACHED("We have an always-returning default case");
  return false;
}


const JSJitInfo uniform4fv_methodinfo = {
  (JSJitPropertyOp)uniform4fv,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
uniform4i(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 5) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.uniform4i");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  mozilla::WebGLUniformLocation* arg0;
  if (argv[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::WebGLUniformLocation, mozilla::WebGLUniformLocation>(cx, &argv[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "WebGLUniformLocation");
        return false;
      }
    }
  } else if (argv[0].isNullOrUndefined()) {
    arg0 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  int32_t arg1;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[1], &arg1)) {
    return false;
  }
  int32_t arg2;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[2], &arg2)) {
    return false;
  }
  int32_t arg3;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[3], &arg3)) {
    return false;
  }
  int32_t arg4;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[4], &arg4)) {
    return false;
  }
  self->Uniform4i(arg0, arg1, arg2, arg3, arg4);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo uniform4i_methodinfo = {
  (JSJitPropertyOp)uniform4i,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
uniform4iv(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  unsigned argcount = NS_MIN(argc, 2u);
  switch (argcount) {
    case 2: {
      JS::Value* argv_start = JS_ARGV(cx, vp);
      mozilla::WebGLUniformLocation* arg0;
      if (argv_start[0].isObject()) {
        {
          nsresult rv = UnwrapObject<prototypes::id::WebGLUniformLocation, mozilla::WebGLUniformLocation>(cx, &argv_start[0].toObject(), arg0);
          if (NS_FAILED(rv)) {
            ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "WebGLUniformLocation");
            return false;
          }
        }
      } else if (argv_start[0].isNullOrUndefined()) {
        arg0 = NULL;
      } else {
        ThrowErrorMessage(cx, MSG_NOT_OBJECT);
        return false;
      }
      if (argv_start[1].isObject()) {
        do {
          Maybe<Int32Array> arg1_holder;
          NonNull<Int32Array> arg1;
          arg1_holder.construct(&argv_start[1].toObject());
          if (!arg1_holder.ref().inited()) {
            break;
          }
          arg1 = arg1_holder.addr();
          self->Uniform4iv(arg0, arg1);
          *vp = JSVAL_VOID;
          return true;
        } while (0);
        do {
          const Sequence< int32_t > arg1;
          JSObject* seq = &argv_start[1].toObject();

          if (!IsArrayLike(cx, seq)) {
            break;
          }
          uint32_t length;
          // JS_GetArrayLength actually works on all objects
          if (!JS_GetArrayLength(cx, seq, &length)) {
            return false;
          }
          Sequence< int32_t > &arr = const_cast< Sequence< int32_t >& >(arg1);
          if (!arr.SetCapacity(length)) {
            JS_ReportOutOfMemory(cx);
            return false;
          }
          for (uint32_t i = 0; i < length; ++i) {
            jsval temp;
            if (!JS_GetElement(cx, seq, i, &temp)) {
              return false;
            }
            int32_t& slot = *arr.AppendElement();
            if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, &slot)) {
              return false;
            }
          }
          self->Uniform4iv(arg0, arg1);
          *vp = JSVAL_VOID;
          return true;
        } while (0);
      }
      return ThrowErrorMessage(cx, MSG_INVALID_ARG, "1", "2");
      break;
    }
    default: {
      return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.uniform4iv");

      break;
    }
  }
  MOZ_NOT_REACHED("We have an always-returning default case");
  return false;
}


const JSJitInfo uniform4iv_methodinfo = {
  (JSJitPropertyOp)uniform4iv,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
uniformMatrix2fv(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  unsigned argcount = NS_MIN(argc, 3u);
  switch (argcount) {
    case 3: {
      JS::Value* argv_start = JS_ARGV(cx, vp);
      mozilla::WebGLUniformLocation* arg0;
      if (argv_start[0].isObject()) {
        {
          nsresult rv = UnwrapObject<prototypes::id::WebGLUniformLocation, mozilla::WebGLUniformLocation>(cx, &argv_start[0].toObject(), arg0);
          if (NS_FAILED(rv)) {
            ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "WebGLUniformLocation");
            return false;
          }
        }
      } else if (argv_start[0].isNullOrUndefined()) {
        arg0 = NULL;
      } else {
        ThrowErrorMessage(cx, MSG_NOT_OBJECT);
        return false;
      }
      bool arg1;
      if (!ValueToPrimitive<bool, eDefault>(cx, argv_start[1], &arg1)) {
        return false;
      }
      if (argv_start[2].isObject()) {
        do {
          Maybe<Float32Array> arg2_holder;
          NonNull<Float32Array> arg2;
          arg2_holder.construct(&argv_start[2].toObject());
          if (!arg2_holder.ref().inited()) {
            break;
          }
          arg2 = arg2_holder.addr();
          self->UniformMatrix2fv(arg0, arg1, arg2);
          *vp = JSVAL_VOID;
          return true;
        } while (0);
        do {
          const Sequence< float > arg2;
          JSObject* seq = &argv_start[2].toObject();

          if (!IsArrayLike(cx, seq)) {
            break;
          }
          uint32_t length;
          // JS_GetArrayLength actually works on all objects
          if (!JS_GetArrayLength(cx, seq, &length)) {
            return false;
          }
          Sequence< float > &arr = const_cast< Sequence< float >& >(arg2);
          if (!arr.SetCapacity(length)) {
            JS_ReportOutOfMemory(cx);
            return false;
          }
          for (uint32_t i = 0; i < length; ++i) {
            jsval temp;
            if (!JS_GetElement(cx, seq, i, &temp)) {
              return false;
            }
            float& slot = *arr.AppendElement();
            if (!ValueToPrimitive<float, eDefault>(cx, temp, &slot)) {
              return false;
            }
          }
          self->UniformMatrix2fv(arg0, arg1, arg2);
          *vp = JSVAL_VOID;
          return true;
        } while (0);
      }
      return ThrowErrorMessage(cx, MSG_INVALID_ARG, "2", "3");
      break;
    }
    default: {
      return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.uniformMatrix2fv");

      break;
    }
  }
  MOZ_NOT_REACHED("We have an always-returning default case");
  return false;
}


const JSJitInfo uniformMatrix2fv_methodinfo = {
  (JSJitPropertyOp)uniformMatrix2fv,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
uniformMatrix3fv(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  unsigned argcount = NS_MIN(argc, 3u);
  switch (argcount) {
    case 3: {
      JS::Value* argv_start = JS_ARGV(cx, vp);
      mozilla::WebGLUniformLocation* arg0;
      if (argv_start[0].isObject()) {
        {
          nsresult rv = UnwrapObject<prototypes::id::WebGLUniformLocation, mozilla::WebGLUniformLocation>(cx, &argv_start[0].toObject(), arg0);
          if (NS_FAILED(rv)) {
            ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "WebGLUniformLocation");
            return false;
          }
        }
      } else if (argv_start[0].isNullOrUndefined()) {
        arg0 = NULL;
      } else {
        ThrowErrorMessage(cx, MSG_NOT_OBJECT);
        return false;
      }
      bool arg1;
      if (!ValueToPrimitive<bool, eDefault>(cx, argv_start[1], &arg1)) {
        return false;
      }
      if (argv_start[2].isObject()) {
        do {
          Maybe<Float32Array> arg2_holder;
          NonNull<Float32Array> arg2;
          arg2_holder.construct(&argv_start[2].toObject());
          if (!arg2_holder.ref().inited()) {
            break;
          }
          arg2 = arg2_holder.addr();
          self->UniformMatrix3fv(arg0, arg1, arg2);
          *vp = JSVAL_VOID;
          return true;
        } while (0);
        do {
          const Sequence< float > arg2;
          JSObject* seq = &argv_start[2].toObject();

          if (!IsArrayLike(cx, seq)) {
            break;
          }
          uint32_t length;
          // JS_GetArrayLength actually works on all objects
          if (!JS_GetArrayLength(cx, seq, &length)) {
            return false;
          }
          Sequence< float > &arr = const_cast< Sequence< float >& >(arg2);
          if (!arr.SetCapacity(length)) {
            JS_ReportOutOfMemory(cx);
            return false;
          }
          for (uint32_t i = 0; i < length; ++i) {
            jsval temp;
            if (!JS_GetElement(cx, seq, i, &temp)) {
              return false;
            }
            float& slot = *arr.AppendElement();
            if (!ValueToPrimitive<float, eDefault>(cx, temp, &slot)) {
              return false;
            }
          }
          self->UniformMatrix3fv(arg0, arg1, arg2);
          *vp = JSVAL_VOID;
          return true;
        } while (0);
      }
      return ThrowErrorMessage(cx, MSG_INVALID_ARG, "2", "3");
      break;
    }
    default: {
      return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.uniformMatrix3fv");

      break;
    }
  }
  MOZ_NOT_REACHED("We have an always-returning default case");
  return false;
}


const JSJitInfo uniformMatrix3fv_methodinfo = {
  (JSJitPropertyOp)uniformMatrix3fv,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
uniformMatrix4fv(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  unsigned argcount = NS_MIN(argc, 3u);
  switch (argcount) {
    case 3: {
      JS::Value* argv_start = JS_ARGV(cx, vp);
      mozilla::WebGLUniformLocation* arg0;
      if (argv_start[0].isObject()) {
        {
          nsresult rv = UnwrapObject<prototypes::id::WebGLUniformLocation, mozilla::WebGLUniformLocation>(cx, &argv_start[0].toObject(), arg0);
          if (NS_FAILED(rv)) {
            ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "WebGLUniformLocation");
            return false;
          }
        }
      } else if (argv_start[0].isNullOrUndefined()) {
        arg0 = NULL;
      } else {
        ThrowErrorMessage(cx, MSG_NOT_OBJECT);
        return false;
      }
      bool arg1;
      if (!ValueToPrimitive<bool, eDefault>(cx, argv_start[1], &arg1)) {
        return false;
      }
      if (argv_start[2].isObject()) {
        do {
          Maybe<Float32Array> arg2_holder;
          NonNull<Float32Array> arg2;
          arg2_holder.construct(&argv_start[2].toObject());
          if (!arg2_holder.ref().inited()) {
            break;
          }
          arg2 = arg2_holder.addr();
          self->UniformMatrix4fv(arg0, arg1, arg2);
          *vp = JSVAL_VOID;
          return true;
        } while (0);
        do {
          const Sequence< float > arg2;
          JSObject* seq = &argv_start[2].toObject();

          if (!IsArrayLike(cx, seq)) {
            break;
          }
          uint32_t length;
          // JS_GetArrayLength actually works on all objects
          if (!JS_GetArrayLength(cx, seq, &length)) {
            return false;
          }
          Sequence< float > &arr = const_cast< Sequence< float >& >(arg2);
          if (!arr.SetCapacity(length)) {
            JS_ReportOutOfMemory(cx);
            return false;
          }
          for (uint32_t i = 0; i < length; ++i) {
            jsval temp;
            if (!JS_GetElement(cx, seq, i, &temp)) {
              return false;
            }
            float& slot = *arr.AppendElement();
            if (!ValueToPrimitive<float, eDefault>(cx, temp, &slot)) {
              return false;
            }
          }
          self->UniformMatrix4fv(arg0, arg1, arg2);
          *vp = JSVAL_VOID;
          return true;
        } while (0);
      }
      return ThrowErrorMessage(cx, MSG_INVALID_ARG, "2", "3");
      break;
    }
    default: {
      return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.uniformMatrix4fv");

      break;
    }
  }
  MOZ_NOT_REACHED("We have an always-returning default case");
  return false;
}


const JSJitInfo uniformMatrix4fv_methodinfo = {
  (JSJitPropertyOp)uniformMatrix4fv,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
useProgram(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.useProgram");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  mozilla::WebGLProgram* arg0;
  if (argv[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::WebGLProgram, mozilla::WebGLProgram>(cx, &argv[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "WebGLProgram");
        return false;
      }
    }
  } else if (argv[0].isNullOrUndefined()) {
    arg0 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->UseProgram(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo useProgram_methodinfo = {
  (JSJitPropertyOp)useProgram,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
validateProgram(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.validateProgram");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  mozilla::WebGLProgram* arg0;
  if (argv[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::WebGLProgram, mozilla::WebGLProgram>(cx, &argv[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "WebGLProgram");
        return false;
      }
    }
  } else if (argv[0].isNullOrUndefined()) {
    arg0 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->ValidateProgram(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo validateProgram_methodinfo = {
  (JSJitPropertyOp)validateProgram,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
vertexAttrib1f(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 2) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.vertexAttrib1f");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  float arg1;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[1], &arg1)) {
    return false;
  }
  self->VertexAttrib1f(arg0, arg1);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo vertexAttrib1f_methodinfo = {
  (JSJitPropertyOp)vertexAttrib1f,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
vertexAttrib1fv(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  unsigned argcount = NS_MIN(argc, 2u);
  switch (argcount) {
    case 2: {
      JS::Value* argv_start = JS_ARGV(cx, vp);
      uint32_t arg0;
      if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv_start[0], &arg0)) {
        return false;
      }
      if (argv_start[1].isObject()) {
        do {
          Maybe<Float32Array> arg1_holder;
          NonNull<Float32Array> arg1;
          arg1_holder.construct(&argv_start[1].toObject());
          if (!arg1_holder.ref().inited()) {
            break;
          }
          arg1 = arg1_holder.addr();
          self->VertexAttrib1fv(arg0, arg1);
          *vp = JSVAL_VOID;
          return true;
        } while (0);
        do {
          const Sequence< float > arg1;
          JSObject* seq = &argv_start[1].toObject();

          if (!IsArrayLike(cx, seq)) {
            break;
          }
          uint32_t length;
          // JS_GetArrayLength actually works on all objects
          if (!JS_GetArrayLength(cx, seq, &length)) {
            return false;
          }
          Sequence< float > &arr = const_cast< Sequence< float >& >(arg1);
          if (!arr.SetCapacity(length)) {
            JS_ReportOutOfMemory(cx);
            return false;
          }
          for (uint32_t i = 0; i < length; ++i) {
            jsval temp;
            if (!JS_GetElement(cx, seq, i, &temp)) {
              return false;
            }
            float& slot = *arr.AppendElement();
            if (!ValueToPrimitive<float, eDefault>(cx, temp, &slot)) {
              return false;
            }
          }
          self->VertexAttrib1fv(arg0, arg1);
          *vp = JSVAL_VOID;
          return true;
        } while (0);
      }
      return ThrowErrorMessage(cx, MSG_INVALID_ARG, "1", "2");
      break;
    }
    default: {
      return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.vertexAttrib1fv");

      break;
    }
  }
  MOZ_NOT_REACHED("We have an always-returning default case");
  return false;
}


const JSJitInfo vertexAttrib1fv_methodinfo = {
  (JSJitPropertyOp)vertexAttrib1fv,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
vertexAttrib2f(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 3) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.vertexAttrib2f");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  float arg1;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[1], &arg1)) {
    return false;
  }
  float arg2;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[2], &arg2)) {
    return false;
  }
  self->VertexAttrib2f(arg0, arg1, arg2);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo vertexAttrib2f_methodinfo = {
  (JSJitPropertyOp)vertexAttrib2f,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
vertexAttrib2fv(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  unsigned argcount = NS_MIN(argc, 2u);
  switch (argcount) {
    case 2: {
      JS::Value* argv_start = JS_ARGV(cx, vp);
      uint32_t arg0;
      if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv_start[0], &arg0)) {
        return false;
      }
      if (argv_start[1].isObject()) {
        do {
          Maybe<Float32Array> arg1_holder;
          NonNull<Float32Array> arg1;
          arg1_holder.construct(&argv_start[1].toObject());
          if (!arg1_holder.ref().inited()) {
            break;
          }
          arg1 = arg1_holder.addr();
          self->VertexAttrib2fv(arg0, arg1);
          *vp = JSVAL_VOID;
          return true;
        } while (0);
        do {
          const Sequence< float > arg1;
          JSObject* seq = &argv_start[1].toObject();

          if (!IsArrayLike(cx, seq)) {
            break;
          }
          uint32_t length;
          // JS_GetArrayLength actually works on all objects
          if (!JS_GetArrayLength(cx, seq, &length)) {
            return false;
          }
          Sequence< float > &arr = const_cast< Sequence< float >& >(arg1);
          if (!arr.SetCapacity(length)) {
            JS_ReportOutOfMemory(cx);
            return false;
          }
          for (uint32_t i = 0; i < length; ++i) {
            jsval temp;
            if (!JS_GetElement(cx, seq, i, &temp)) {
              return false;
            }
            float& slot = *arr.AppendElement();
            if (!ValueToPrimitive<float, eDefault>(cx, temp, &slot)) {
              return false;
            }
          }
          self->VertexAttrib2fv(arg0, arg1);
          *vp = JSVAL_VOID;
          return true;
        } while (0);
      }
      return ThrowErrorMessage(cx, MSG_INVALID_ARG, "1", "2");
      break;
    }
    default: {
      return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.vertexAttrib2fv");

      break;
    }
  }
  MOZ_NOT_REACHED("We have an always-returning default case");
  return false;
}


const JSJitInfo vertexAttrib2fv_methodinfo = {
  (JSJitPropertyOp)vertexAttrib2fv,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
vertexAttrib3f(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 4) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.vertexAttrib3f");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  float arg1;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[1], &arg1)) {
    return false;
  }
  float arg2;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[2], &arg2)) {
    return false;
  }
  float arg3;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[3], &arg3)) {
    return false;
  }
  self->VertexAttrib3f(arg0, arg1, arg2, arg3);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo vertexAttrib3f_methodinfo = {
  (JSJitPropertyOp)vertexAttrib3f,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
vertexAttrib3fv(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  unsigned argcount = NS_MIN(argc, 2u);
  switch (argcount) {
    case 2: {
      JS::Value* argv_start = JS_ARGV(cx, vp);
      uint32_t arg0;
      if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv_start[0], &arg0)) {
        return false;
      }
      if (argv_start[1].isObject()) {
        do {
          Maybe<Float32Array> arg1_holder;
          NonNull<Float32Array> arg1;
          arg1_holder.construct(&argv_start[1].toObject());
          if (!arg1_holder.ref().inited()) {
            break;
          }
          arg1 = arg1_holder.addr();
          self->VertexAttrib3fv(arg0, arg1);
          *vp = JSVAL_VOID;
          return true;
        } while (0);
        do {
          const Sequence< float > arg1;
          JSObject* seq = &argv_start[1].toObject();

          if (!IsArrayLike(cx, seq)) {
            break;
          }
          uint32_t length;
          // JS_GetArrayLength actually works on all objects
          if (!JS_GetArrayLength(cx, seq, &length)) {
            return false;
          }
          Sequence< float > &arr = const_cast< Sequence< float >& >(arg1);
          if (!arr.SetCapacity(length)) {
            JS_ReportOutOfMemory(cx);
            return false;
          }
          for (uint32_t i = 0; i < length; ++i) {
            jsval temp;
            if (!JS_GetElement(cx, seq, i, &temp)) {
              return false;
            }
            float& slot = *arr.AppendElement();
            if (!ValueToPrimitive<float, eDefault>(cx, temp, &slot)) {
              return false;
            }
          }
          self->VertexAttrib3fv(arg0, arg1);
          *vp = JSVAL_VOID;
          return true;
        } while (0);
      }
      return ThrowErrorMessage(cx, MSG_INVALID_ARG, "1", "2");
      break;
    }
    default: {
      return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.vertexAttrib3fv");

      break;
    }
  }
  MOZ_NOT_REACHED("We have an always-returning default case");
  return false;
}


const JSJitInfo vertexAttrib3fv_methodinfo = {
  (JSJitPropertyOp)vertexAttrib3fv,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
vertexAttrib4f(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 5) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.vertexAttrib4f");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  float arg1;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[1], &arg1)) {
    return false;
  }
  float arg2;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[2], &arg2)) {
    return false;
  }
  float arg3;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[3], &arg3)) {
    return false;
  }
  float arg4;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[4], &arg4)) {
    return false;
  }
  self->VertexAttrib4f(arg0, arg1, arg2, arg3, arg4);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo vertexAttrib4f_methodinfo = {
  (JSJitPropertyOp)vertexAttrib4f,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
vertexAttrib4fv(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  unsigned argcount = NS_MIN(argc, 2u);
  switch (argcount) {
    case 2: {
      JS::Value* argv_start = JS_ARGV(cx, vp);
      uint32_t arg0;
      if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv_start[0], &arg0)) {
        return false;
      }
      if (argv_start[1].isObject()) {
        do {
          Maybe<Float32Array> arg1_holder;
          NonNull<Float32Array> arg1;
          arg1_holder.construct(&argv_start[1].toObject());
          if (!arg1_holder.ref().inited()) {
            break;
          }
          arg1 = arg1_holder.addr();
          self->VertexAttrib4fv(arg0, arg1);
          *vp = JSVAL_VOID;
          return true;
        } while (0);
        do {
          const Sequence< float > arg1;
          JSObject* seq = &argv_start[1].toObject();

          if (!IsArrayLike(cx, seq)) {
            break;
          }
          uint32_t length;
          // JS_GetArrayLength actually works on all objects
          if (!JS_GetArrayLength(cx, seq, &length)) {
            return false;
          }
          Sequence< float > &arr = const_cast< Sequence< float >& >(arg1);
          if (!arr.SetCapacity(length)) {
            JS_ReportOutOfMemory(cx);
            return false;
          }
          for (uint32_t i = 0; i < length; ++i) {
            jsval temp;
            if (!JS_GetElement(cx, seq, i, &temp)) {
              return false;
            }
            float& slot = *arr.AppendElement();
            if (!ValueToPrimitive<float, eDefault>(cx, temp, &slot)) {
              return false;
            }
          }
          self->VertexAttrib4fv(arg0, arg1);
          *vp = JSVAL_VOID;
          return true;
        } while (0);
      }
      return ThrowErrorMessage(cx, MSG_INVALID_ARG, "1", "2");
      break;
    }
    default: {
      return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.vertexAttrib4fv");

      break;
    }
  }
  MOZ_NOT_REACHED("We have an always-returning default case");
  return false;
}


const JSJitInfo vertexAttrib4fv_methodinfo = {
  (JSJitPropertyOp)vertexAttrib4fv,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
vertexAttribPointer(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 6) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.vertexAttribPointer");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  int32_t arg1;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[1], &arg1)) {
    return false;
  }
  uint32_t arg2;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[2], &arg2)) {
    return false;
  }
  bool arg3;
  if (!ValueToPrimitive<bool, eDefault>(cx, argv[3], &arg3)) {
    return false;
  }
  int32_t arg4;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[4], &arg4)) {
    return false;
  }
  int64_t arg5;
  if (!ValueToPrimitive<int64_t, eDefault>(cx, argv[5], &arg5)) {
    return false;
  }
  self->VertexAttribPointer(arg0, arg1, arg2, arg3, arg4, arg5);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo vertexAttribPointer_methodinfo = {
  (JSJitPropertyOp)vertexAttribPointer,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
viewport(JSContext* cx, JSHandleObject obj, mozilla::WebGLContext* self, unsigned argc, JS::Value* vp)
{

  if (argc < 4) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "WebGLRenderingContext.viewport");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  int32_t arg0;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  int32_t arg1;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[1], &arg1)) {
    return false;
  }
  int32_t arg2;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[2], &arg2)) {
    return false;
  }
  int32_t arg3;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[3], &arg3)) {
    return false;
  }
  self->Viewport(arg0, arg1, arg2, arg3);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo viewport_methodinfo = {
  (JSJitPropertyOp)viewport,
  prototypes::id::WebGLRenderingContext,
  PrototypeTraits<prototypes::id::WebGLRenderingContext>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static JSBool
genericMethod(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  mozilla::WebGLContext* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::WebGLRenderingContext, mozilla::WebGLContext>(cx, obj, self);
    if (NS_FAILED(rv)) {
      return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "WebGLRenderingContext");
    }
  }
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Method);
  JSJitMethodOp method = (JSJitMethodOp)info->op;
  return method(cx, obj, self, argc, vp);
}

static JSBool
genericGetter(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  mozilla::WebGLContext* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::WebGLRenderingContext, mozilla::WebGLContext>(cx, obj, self);
    if (NS_FAILED(rv)) {
      return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "WebGLRenderingContext");
    }
  }
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Getter);
  JSJitPropertyOp getter = info->op;
  return getter(cx, obj, self, vp);
}

static JSBool
_addProperty(JSContext* cx, JSHandleObject obj, JSHandleId id, JSMutableHandleValue vp)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::WebGLContext>::value), "Must be an nsISupports class");
  mozilla::WebGLContext* self = UnwrapDOMObject<mozilla::WebGLContext>(obj);
  nsContentUtils::PreserveWrapper(reinterpret_cast<nsISupports*>(self), self);
  return true;
}

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::WebGLContext>::value), "Must be an nsISupports class");
  mozilla::WebGLContext* self = UnwrapDOMObject<mozilla::WebGLContext>(obj);
  if (self) {
    ClearWrapper(self, self);
    XPCJSRuntime *rt = nsXPConnect::GetRuntimeInstance();
    if (rt) {
      rt->DeferredRelease(reinterpret_cast<nsISupports*>(self));
    } else {
      NS_RELEASE(self);
    }
  }
}

static JSFunctionSpec sMethods_specs[] = {
  JS_FNINFO("getContextAttributes", genericMethod, &getContextAttributes_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("isContextLost", genericMethod, &isContextLost_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("getSupportedExtensions", genericMethod, &getSupportedExtensions_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("getExtension", genericMethod, &getExtension_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("activeTexture", genericMethod, &activeTexture_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("attachShader", genericMethod, &attachShader_methodinfo, 2, JSPROP_ENUMERATE),
  JS_FNINFO("bindAttribLocation", genericMethod, &bindAttribLocation_methodinfo, 3, JSPROP_ENUMERATE),
  JS_FNINFO("bindBuffer", genericMethod, &bindBuffer_methodinfo, 2, JSPROP_ENUMERATE),
  JS_FNINFO("bindFramebuffer", genericMethod, &bindFramebuffer_methodinfo, 2, JSPROP_ENUMERATE),
  JS_FNINFO("bindRenderbuffer", genericMethod, &bindRenderbuffer_methodinfo, 2, JSPROP_ENUMERATE),
  JS_FNINFO("bindTexture", genericMethod, &bindTexture_methodinfo, 2, JSPROP_ENUMERATE),
  JS_FNINFO("blendColor", genericMethod, &blendColor_methodinfo, 4, JSPROP_ENUMERATE),
  JS_FNINFO("blendEquation", genericMethod, &blendEquation_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("blendEquationSeparate", genericMethod, &blendEquationSeparate_methodinfo, 2, JSPROP_ENUMERATE),
  JS_FNINFO("blendFunc", genericMethod, &blendFunc_methodinfo, 2, JSPROP_ENUMERATE),
  JS_FNINFO("blendFuncSeparate", genericMethod, &blendFuncSeparate_methodinfo, 4, JSPROP_ENUMERATE),
  JS_FNINFO("bufferData", genericMethod, &bufferData_methodinfo, 3, JSPROP_ENUMERATE),
  JS_FNINFO("bufferSubData", genericMethod, &bufferSubData_methodinfo, 3, JSPROP_ENUMERATE),
  JS_FNINFO("checkFramebufferStatus", genericMethod, &checkFramebufferStatus_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("clear", genericMethod, &clear_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("clearColor", genericMethod, &clearColor_methodinfo, 4, JSPROP_ENUMERATE),
  JS_FNINFO("clearDepth", genericMethod, &clearDepth_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("clearStencil", genericMethod, &clearStencil_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("colorMask", genericMethod, &colorMask_methodinfo, 4, JSPROP_ENUMERATE),
  JS_FNINFO("compileShader", genericMethod, &compileShader_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("compressedTexImage2D", genericMethod, &compressedTexImage2D_methodinfo, 7, JSPROP_ENUMERATE),
  JS_FNINFO("compressedTexSubImage2D", genericMethod, &compressedTexSubImage2D_methodinfo, 8, JSPROP_ENUMERATE),
  JS_FNINFO("copyTexImage2D", genericMethod, &copyTexImage2D_methodinfo, 8, JSPROP_ENUMERATE),
  JS_FNINFO("copyTexSubImage2D", genericMethod, &copyTexSubImage2D_methodinfo, 8, JSPROP_ENUMERATE),
  JS_FNINFO("createBuffer", genericMethod, &createBuffer_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("createFramebuffer", genericMethod, &createFramebuffer_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("createProgram", genericMethod, &createProgram_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("createRenderbuffer", genericMethod, &createRenderbuffer_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("createShader", genericMethod, &createShader_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("createTexture", genericMethod, &createTexture_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("cullFace", genericMethod, &cullFace_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("deleteBuffer", genericMethod, &deleteBuffer_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("deleteFramebuffer", genericMethod, &deleteFramebuffer_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("deleteProgram", genericMethod, &deleteProgram_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("deleteRenderbuffer", genericMethod, &deleteRenderbuffer_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("deleteShader", genericMethod, &deleteShader_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("deleteTexture", genericMethod, &deleteTexture_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("depthFunc", genericMethod, &depthFunc_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("depthMask", genericMethod, &depthMask_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("depthRange", genericMethod, &depthRange_methodinfo, 2, JSPROP_ENUMERATE),
  JS_FNINFO("detachShader", genericMethod, &detachShader_methodinfo, 2, JSPROP_ENUMERATE),
  JS_FNINFO("disable", genericMethod, &disable_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("disableVertexAttribArray", genericMethod, &disableVertexAttribArray_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("drawArrays", genericMethod, &drawArrays_methodinfo, 3, JSPROP_ENUMERATE),
  JS_FNINFO("drawElements", genericMethod, &drawElements_methodinfo, 4, JSPROP_ENUMERATE),
  JS_FNINFO("enable", genericMethod, &enable_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("enableVertexAttribArray", genericMethod, &enableVertexAttribArray_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("finish", genericMethod, &finish_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("flush", genericMethod, &flush_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("framebufferRenderbuffer", genericMethod, &framebufferRenderbuffer_methodinfo, 4, JSPROP_ENUMERATE),
  JS_FNINFO("framebufferTexture2D", genericMethod, &framebufferTexture2D_methodinfo, 5, JSPROP_ENUMERATE),
  JS_FNINFO("frontFace", genericMethod, &frontFace_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("generateMipmap", genericMethod, &generateMipmap_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("getActiveAttrib", genericMethod, &getActiveAttrib_methodinfo, 2, JSPROP_ENUMERATE),
  JS_FNINFO("getActiveUniform", genericMethod, &getActiveUniform_methodinfo, 2, JSPROP_ENUMERATE),
  JS_FNINFO("getAttachedShaders", genericMethod, &getAttachedShaders_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("getAttribLocation", genericMethod, &getAttribLocation_methodinfo, 2, JSPROP_ENUMERATE),
  JS_FNINFO("getBufferParameter", genericMethod, &getBufferParameter_methodinfo, 2, JSPROP_ENUMERATE),
  JS_FNINFO("getParameter", genericMethod, &getParameter_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("getError", genericMethod, &getError_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("getFramebufferAttachmentParameter", genericMethod, &getFramebufferAttachmentParameter_methodinfo, 3, JSPROP_ENUMERATE),
  JS_FNINFO("getProgramParameter", genericMethod, &getProgramParameter_methodinfo, 2, JSPROP_ENUMERATE),
  JS_FNINFO("getProgramInfoLog", genericMethod, &getProgramInfoLog_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("getRenderbufferParameter", genericMethod, &getRenderbufferParameter_methodinfo, 2, JSPROP_ENUMERATE),
  JS_FNINFO("getShaderParameter", genericMethod, &getShaderParameter_methodinfo, 2, JSPROP_ENUMERATE),
  JS_FNINFO("getShaderPrecisionFormat", genericMethod, &getShaderPrecisionFormat_methodinfo, 2, JSPROP_ENUMERATE),
  JS_FNINFO("getShaderInfoLog", genericMethod, &getShaderInfoLog_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("getShaderSource", genericMethod, &getShaderSource_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("getTexParameter", genericMethod, &getTexParameter_methodinfo, 2, JSPROP_ENUMERATE),
  JS_FNINFO("getUniform", genericMethod, &getUniform_methodinfo, 2, JSPROP_ENUMERATE),
  JS_FNINFO("getUniformLocation", genericMethod, &getUniformLocation_methodinfo, 2, JSPROP_ENUMERATE),
  JS_FNINFO("getVertexAttrib", genericMethod, &getVertexAttrib_methodinfo, 2, JSPROP_ENUMERATE),
  JS_FNINFO("getVertexAttribOffset", genericMethod, &getVertexAttribOffset_methodinfo, 2, JSPROP_ENUMERATE),
  JS_FNINFO("hint", genericMethod, &hint_methodinfo, 2, JSPROP_ENUMERATE),
  JS_FNINFO("isBuffer", genericMethod, &isBuffer_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("isEnabled", genericMethod, &isEnabled_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("isFramebuffer", genericMethod, &isFramebuffer_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("isProgram", genericMethod, &isProgram_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("isRenderbuffer", genericMethod, &isRenderbuffer_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("isShader", genericMethod, &isShader_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("isTexture", genericMethod, &isTexture_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("lineWidth", genericMethod, &lineWidth_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("linkProgram", genericMethod, &linkProgram_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("pixelStorei", genericMethod, &pixelStorei_methodinfo, 2, JSPROP_ENUMERATE),
  JS_FNINFO("polygonOffset", genericMethod, &polygonOffset_methodinfo, 2, JSPROP_ENUMERATE),
  JS_FNINFO("readPixels", genericMethod, &readPixels_methodinfo, 7, JSPROP_ENUMERATE),
  JS_FNINFO("renderbufferStorage", genericMethod, &renderbufferStorage_methodinfo, 4, JSPROP_ENUMERATE),
  JS_FNINFO("sampleCoverage", genericMethod, &sampleCoverage_methodinfo, 2, JSPROP_ENUMERATE),
  JS_FNINFO("scissor", genericMethod, &scissor_methodinfo, 4, JSPROP_ENUMERATE),
  JS_FNINFO("shaderSource", genericMethod, &shaderSource_methodinfo, 2, JSPROP_ENUMERATE),
  JS_FNINFO("stencilFunc", genericMethod, &stencilFunc_methodinfo, 3, JSPROP_ENUMERATE),
  JS_FNINFO("stencilFuncSeparate", genericMethod, &stencilFuncSeparate_methodinfo, 4, JSPROP_ENUMERATE),
  JS_FNINFO("stencilMask", genericMethod, &stencilMask_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("stencilMaskSeparate", genericMethod, &stencilMaskSeparate_methodinfo, 2, JSPROP_ENUMERATE),
  JS_FNINFO("stencilOp", genericMethod, &stencilOp_methodinfo, 3, JSPROP_ENUMERATE),
  JS_FNINFO("stencilOpSeparate", genericMethod, &stencilOpSeparate_methodinfo, 4, JSPROP_ENUMERATE),
  JS_FNINFO("texImage2D", genericMethod, &texImage2D_methodinfo, 6, JSPROP_ENUMERATE),
  JS_FNINFO("texParameterf", genericMethod, &texParameterf_methodinfo, 3, JSPROP_ENUMERATE),
  JS_FNINFO("texParameteri", genericMethod, &texParameteri_methodinfo, 3, JSPROP_ENUMERATE),
  JS_FNINFO("texSubImage2D", genericMethod, &texSubImage2D_methodinfo, 7, JSPROP_ENUMERATE),
  JS_FNINFO("uniform1f", genericMethod, &uniform1f_methodinfo, 2, JSPROP_ENUMERATE),
  JS_FNINFO("uniform1fv", genericMethod, &uniform1fv_methodinfo, 2, JSPROP_ENUMERATE),
  JS_FNINFO("uniform1i", genericMethod, &uniform1i_methodinfo, 2, JSPROP_ENUMERATE),
  JS_FNINFO("uniform1iv", genericMethod, &uniform1iv_methodinfo, 2, JSPROP_ENUMERATE),
  JS_FNINFO("uniform2f", genericMethod, &uniform2f_methodinfo, 3, JSPROP_ENUMERATE),
  JS_FNINFO("uniform2fv", genericMethod, &uniform2fv_methodinfo, 2, JSPROP_ENUMERATE),
  JS_FNINFO("uniform2i", genericMethod, &uniform2i_methodinfo, 3, JSPROP_ENUMERATE),
  JS_FNINFO("uniform2iv", genericMethod, &uniform2iv_methodinfo, 2, JSPROP_ENUMERATE),
  JS_FNINFO("uniform3f", genericMethod, &uniform3f_methodinfo, 4, JSPROP_ENUMERATE),
  JS_FNINFO("uniform3fv", genericMethod, &uniform3fv_methodinfo, 2, JSPROP_ENUMERATE),
  JS_FNINFO("uniform3i", genericMethod, &uniform3i_methodinfo, 4, JSPROP_ENUMERATE),
  JS_FNINFO("uniform3iv", genericMethod, &uniform3iv_methodinfo, 2, JSPROP_ENUMERATE),
  JS_FNINFO("uniform4f", genericMethod, &uniform4f_methodinfo, 5, JSPROP_ENUMERATE),
  JS_FNINFO("uniform4fv", genericMethod, &uniform4fv_methodinfo, 2, JSPROP_ENUMERATE),
  JS_FNINFO("uniform4i", genericMethod, &uniform4i_methodinfo, 5, JSPROP_ENUMERATE),
  JS_FNINFO("uniform4iv", genericMethod, &uniform4iv_methodinfo, 2, JSPROP_ENUMERATE),
  JS_FNINFO("uniformMatrix2fv", genericMethod, &uniformMatrix2fv_methodinfo, 3, JSPROP_ENUMERATE),
  JS_FNINFO("uniformMatrix3fv", genericMethod, &uniformMatrix3fv_methodinfo, 3, JSPROP_ENUMERATE),
  JS_FNINFO("uniformMatrix4fv", genericMethod, &uniformMatrix4fv_methodinfo, 3, JSPROP_ENUMERATE),
  JS_FNINFO("useProgram", genericMethod, &useProgram_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("validateProgram", genericMethod, &validateProgram_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("vertexAttrib1f", genericMethod, &vertexAttrib1f_methodinfo, 2, JSPROP_ENUMERATE),
  JS_FNINFO("vertexAttrib1fv", genericMethod, &vertexAttrib1fv_methodinfo, 2, JSPROP_ENUMERATE),
  JS_FNINFO("vertexAttrib2f", genericMethod, &vertexAttrib2f_methodinfo, 3, JSPROP_ENUMERATE),
  JS_FNINFO("vertexAttrib2fv", genericMethod, &vertexAttrib2fv_methodinfo, 2, JSPROP_ENUMERATE),
  JS_FNINFO("vertexAttrib3f", genericMethod, &vertexAttrib3f_methodinfo, 4, JSPROP_ENUMERATE),
  JS_FNINFO("vertexAttrib3fv", genericMethod, &vertexAttrib3fv_methodinfo, 2, JSPROP_ENUMERATE),
  JS_FNINFO("vertexAttrib4f", genericMethod, &vertexAttrib4f_methodinfo, 5, JSPROP_ENUMERATE),
  JS_FNINFO("vertexAttrib4fv", genericMethod, &vertexAttrib4fv_methodinfo, 2, JSPROP_ENUMERATE),
  JS_FNINFO("vertexAttribPointer", genericMethod, &vertexAttribPointer_methodinfo, 6, JSPROP_ENUMERATE),
  JS_FNINFO("viewport", genericMethod, &viewport_methodinfo, 4, JSPROP_ENUMERATE),
  JS_FS_END
};

static Prefable<JSFunctionSpec> sMethods[] = {
  { true, &sMethods_specs[0] },
  { false, NULL }
};

static jsid sMethods_ids[137] = { JSID_VOID };

static JSFunctionSpec sChromeMethods_specs[] = {
  JS_FNINFO("QueryInterface", QueryInterface, nullptr, 1, 0),
  JS_FS_END
};

static Prefable<JSFunctionSpec> sChromeMethods[] = {
  { true, &sChromeMethods_specs[0] },
  { false, NULL }
};

static jsid sChromeMethods_ids[2] = { JSID_VOID };

static JSPropertySpec sAttributes_specs[] = {
  { "canvas", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &canvas_getterinfo }, JSOP_NULLWRAPPER},
  { "drawingBufferWidth", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &drawingBufferWidth_getterinfo }, JSOP_NULLWRAPPER},
  { "drawingBufferHeight", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &drawingBufferHeight_getterinfo }, JSOP_NULLWRAPPER},
  { 0, 0, 0, JSOP_NULLWRAPPER, JSOP_NULLWRAPPER }
};

static Prefable<JSPropertySpec> sAttributes[] = {
  { true, &sAttributes_specs[0] },
  { false, NULL }
};

static jsid sAttributes_ids[4] = { JSID_VOID };

static ConstantSpec sConstants_specs[] = {
  { "DEPTH_BUFFER_BIT", UINT_TO_JSVAL(256) },
  { "STENCIL_BUFFER_BIT", UINT_TO_JSVAL(1024) },
  { "COLOR_BUFFER_BIT", UINT_TO_JSVAL(16384) },
  { "POINTS", UINT_TO_JSVAL(0) },
  { "LINES", UINT_TO_JSVAL(1) },
  { "LINE_LOOP", UINT_TO_JSVAL(2) },
  { "LINE_STRIP", UINT_TO_JSVAL(3) },
  { "TRIANGLES", UINT_TO_JSVAL(4) },
  { "TRIANGLE_STRIP", UINT_TO_JSVAL(5) },
  { "TRIANGLE_FAN", UINT_TO_JSVAL(6) },
  { "ZERO", UINT_TO_JSVAL(0) },
  { "ONE", UINT_TO_JSVAL(1) },
  { "SRC_COLOR", UINT_TO_JSVAL(768) },
  { "ONE_MINUS_SRC_COLOR", UINT_TO_JSVAL(769) },
  { "SRC_ALPHA", UINT_TO_JSVAL(770) },
  { "ONE_MINUS_SRC_ALPHA", UINT_TO_JSVAL(771) },
  { "DST_ALPHA", UINT_TO_JSVAL(772) },
  { "ONE_MINUS_DST_ALPHA", UINT_TO_JSVAL(773) },
  { "DST_COLOR", UINT_TO_JSVAL(774) },
  { "ONE_MINUS_DST_COLOR", UINT_TO_JSVAL(775) },
  { "SRC_ALPHA_SATURATE", UINT_TO_JSVAL(776) },
  { "FUNC_ADD", UINT_TO_JSVAL(32774) },
  { "BLEND_EQUATION", UINT_TO_JSVAL(32777) },
  { "BLEND_EQUATION_RGB", UINT_TO_JSVAL(32777) },
  { "BLEND_EQUATION_ALPHA", UINT_TO_JSVAL(34877) },
  { "FUNC_SUBTRACT", UINT_TO_JSVAL(32778) },
  { "FUNC_REVERSE_SUBTRACT", UINT_TO_JSVAL(32779) },
  { "BLEND_DST_RGB", UINT_TO_JSVAL(32968) },
  { "BLEND_SRC_RGB", UINT_TO_JSVAL(32969) },
  { "BLEND_DST_ALPHA", UINT_TO_JSVAL(32970) },
  { "BLEND_SRC_ALPHA", UINT_TO_JSVAL(32971) },
  { "CONSTANT_COLOR", UINT_TO_JSVAL(32769) },
  { "ONE_MINUS_CONSTANT_COLOR", UINT_TO_JSVAL(32770) },
  { "CONSTANT_ALPHA", UINT_TO_JSVAL(32771) },
  { "ONE_MINUS_CONSTANT_ALPHA", UINT_TO_JSVAL(32772) },
  { "BLEND_COLOR", UINT_TO_JSVAL(32773) },
  { "ARRAY_BUFFER", UINT_TO_JSVAL(34962) },
  { "ELEMENT_ARRAY_BUFFER", UINT_TO_JSVAL(34963) },
  { "ARRAY_BUFFER_BINDING", UINT_TO_JSVAL(34964) },
  { "ELEMENT_ARRAY_BUFFER_BINDING", UINT_TO_JSVAL(34965) },
  { "STREAM_DRAW", UINT_TO_JSVAL(35040) },
  { "STATIC_DRAW", UINT_TO_JSVAL(35044) },
  { "DYNAMIC_DRAW", UINT_TO_JSVAL(35048) },
  { "BUFFER_SIZE", UINT_TO_JSVAL(34660) },
  { "BUFFER_USAGE", UINT_TO_JSVAL(34661) },
  { "CURRENT_VERTEX_ATTRIB", UINT_TO_JSVAL(34342) },
  { "FRONT", UINT_TO_JSVAL(1028) },
  { "BACK", UINT_TO_JSVAL(1029) },
  { "FRONT_AND_BACK", UINT_TO_JSVAL(1032) },
  { "CULL_FACE", UINT_TO_JSVAL(2884) },
  { "BLEND", UINT_TO_JSVAL(3042) },
  { "DITHER", UINT_TO_JSVAL(3024) },
  { "STENCIL_TEST", UINT_TO_JSVAL(2960) },
  { "DEPTH_TEST", UINT_TO_JSVAL(2929) },
  { "SCISSOR_TEST", UINT_TO_JSVAL(3089) },
  { "POLYGON_OFFSET_FILL", UINT_TO_JSVAL(32823) },
  { "SAMPLE_ALPHA_TO_COVERAGE", UINT_TO_JSVAL(32926) },
  { "SAMPLE_COVERAGE", UINT_TO_JSVAL(32928) },
  { "NO_ERROR", UINT_TO_JSVAL(0) },
  { "INVALID_ENUM", UINT_TO_JSVAL(1280) },
  { "INVALID_VALUE", UINT_TO_JSVAL(1281) },
  { "INVALID_OPERATION", UINT_TO_JSVAL(1282) },
  { "OUT_OF_MEMORY", UINT_TO_JSVAL(1285) },
  { "CW", UINT_TO_JSVAL(2304) },
  { "CCW", UINT_TO_JSVAL(2305) },
  { "LINE_WIDTH", UINT_TO_JSVAL(2849) },
  { "ALIASED_POINT_SIZE_RANGE", UINT_TO_JSVAL(33901) },
  { "ALIASED_LINE_WIDTH_RANGE", UINT_TO_JSVAL(33902) },
  { "CULL_FACE_MODE", UINT_TO_JSVAL(2885) },
  { "FRONT_FACE", UINT_TO_JSVAL(2886) },
  { "DEPTH_RANGE", UINT_TO_JSVAL(2928) },
  { "DEPTH_WRITEMASK", UINT_TO_JSVAL(2930) },
  { "DEPTH_CLEAR_VALUE", UINT_TO_JSVAL(2931) },
  { "DEPTH_FUNC", UINT_TO_JSVAL(2932) },
  { "STENCIL_CLEAR_VALUE", UINT_TO_JSVAL(2961) },
  { "STENCIL_FUNC", UINT_TO_JSVAL(2962) },
  { "STENCIL_FAIL", UINT_TO_JSVAL(2964) },
  { "STENCIL_PASS_DEPTH_FAIL", UINT_TO_JSVAL(2965) },
  { "STENCIL_PASS_DEPTH_PASS", UINT_TO_JSVAL(2966) },
  { "STENCIL_REF", UINT_TO_JSVAL(2967) },
  { "STENCIL_VALUE_MASK", UINT_TO_JSVAL(2963) },
  { "STENCIL_WRITEMASK", UINT_TO_JSVAL(2968) },
  { "STENCIL_BACK_FUNC", UINT_TO_JSVAL(34816) },
  { "STENCIL_BACK_FAIL", UINT_TO_JSVAL(34817) },
  { "STENCIL_BACK_PASS_DEPTH_FAIL", UINT_TO_JSVAL(34818) },
  { "STENCIL_BACK_PASS_DEPTH_PASS", UINT_TO_JSVAL(34819) },
  { "STENCIL_BACK_REF", UINT_TO_JSVAL(36003) },
  { "STENCIL_BACK_VALUE_MASK", UINT_TO_JSVAL(36004) },
  { "STENCIL_BACK_WRITEMASK", UINT_TO_JSVAL(36005) },
  { "VIEWPORT", UINT_TO_JSVAL(2978) },
  { "SCISSOR_BOX", UINT_TO_JSVAL(3088) },
  { "COLOR_CLEAR_VALUE", UINT_TO_JSVAL(3106) },
  { "COLOR_WRITEMASK", UINT_TO_JSVAL(3107) },
  { "UNPACK_ALIGNMENT", UINT_TO_JSVAL(3317) },
  { "PACK_ALIGNMENT", UINT_TO_JSVAL(3333) },
  { "MAX_TEXTURE_SIZE", UINT_TO_JSVAL(3379) },
  { "MAX_VIEWPORT_DIMS", UINT_TO_JSVAL(3386) },
  { "SUBPIXEL_BITS", UINT_TO_JSVAL(3408) },
  { "RED_BITS", UINT_TO_JSVAL(3410) },
  { "GREEN_BITS", UINT_TO_JSVAL(3411) },
  { "BLUE_BITS", UINT_TO_JSVAL(3412) },
  { "ALPHA_BITS", UINT_TO_JSVAL(3413) },
  { "DEPTH_BITS", UINT_TO_JSVAL(3414) },
  { "STENCIL_BITS", UINT_TO_JSVAL(3415) },
  { "POLYGON_OFFSET_UNITS", UINT_TO_JSVAL(10752) },
  { "POLYGON_OFFSET_FACTOR", UINT_TO_JSVAL(32824) },
  { "TEXTURE_BINDING_2D", UINT_TO_JSVAL(32873) },
  { "SAMPLE_BUFFERS", UINT_TO_JSVAL(32936) },
  { "SAMPLES", UINT_TO_JSVAL(32937) },
  { "SAMPLE_COVERAGE_VALUE", UINT_TO_JSVAL(32938) },
  { "SAMPLE_COVERAGE_INVERT", UINT_TO_JSVAL(32939) },
  { "COMPRESSED_TEXTURE_FORMATS", UINT_TO_JSVAL(34467) },
  { "DONT_CARE", UINT_TO_JSVAL(4352) },
  { "FASTEST", UINT_TO_JSVAL(4353) },
  { "NICEST", UINT_TO_JSVAL(4354) },
  { "GENERATE_MIPMAP_HINT", UINT_TO_JSVAL(33170) },
  { "BYTE", UINT_TO_JSVAL(5120) },
  { "UNSIGNED_BYTE", UINT_TO_JSVAL(5121) },
  { "SHORT", UINT_TO_JSVAL(5122) },
  { "UNSIGNED_SHORT", UINT_TO_JSVAL(5123) },
  { "INT", UINT_TO_JSVAL(5124) },
  { "UNSIGNED_INT", UINT_TO_JSVAL(5125) },
  { "FLOAT", UINT_TO_JSVAL(5126) },
  { "DEPTH_COMPONENT", UINT_TO_JSVAL(6402) },
  { "ALPHA", UINT_TO_JSVAL(6406) },
  { "RGB", UINT_TO_JSVAL(6407) },
  { "RGBA", UINT_TO_JSVAL(6408) },
  { "LUMINANCE", UINT_TO_JSVAL(6409) },
  { "LUMINANCE_ALPHA", UINT_TO_JSVAL(6410) },
  { "UNSIGNED_SHORT_4_4_4_4", UINT_TO_JSVAL(32819) },
  { "UNSIGNED_SHORT_5_5_5_1", UINT_TO_JSVAL(32820) },
  { "UNSIGNED_SHORT_5_6_5", UINT_TO_JSVAL(33635) },
  { "FRAGMENT_SHADER", UINT_TO_JSVAL(35632) },
  { "VERTEX_SHADER", UINT_TO_JSVAL(35633) },
  { "MAX_VERTEX_ATTRIBS", UINT_TO_JSVAL(34921) },
  { "MAX_VERTEX_UNIFORM_VECTORS", UINT_TO_JSVAL(36347) },
  { "MAX_VARYING_VECTORS", UINT_TO_JSVAL(36348) },
  { "MAX_COMBINED_TEXTURE_IMAGE_UNITS", UINT_TO_JSVAL(35661) },
  { "MAX_VERTEX_TEXTURE_IMAGE_UNITS", UINT_TO_JSVAL(35660) },
  { "MAX_TEXTURE_IMAGE_UNITS", UINT_TO_JSVAL(34930) },
  { "MAX_FRAGMENT_UNIFORM_VECTORS", UINT_TO_JSVAL(36349) },
  { "SHADER_TYPE", UINT_TO_JSVAL(35663) },
  { "DELETE_STATUS", UINT_TO_JSVAL(35712) },
  { "LINK_STATUS", UINT_TO_JSVAL(35714) },
  { "VALIDATE_STATUS", UINT_TO_JSVAL(35715) },
  { "ATTACHED_SHADERS", UINT_TO_JSVAL(35717) },
  { "ACTIVE_UNIFORMS", UINT_TO_JSVAL(35718) },
  { "ACTIVE_ATTRIBUTES", UINT_TO_JSVAL(35721) },
  { "SHADING_LANGUAGE_VERSION", UINT_TO_JSVAL(35724) },
  { "CURRENT_PROGRAM", UINT_TO_JSVAL(35725) },
  { "NEVER", UINT_TO_JSVAL(512) },
  { "LESS", UINT_TO_JSVAL(513) },
  { "EQUAL", UINT_TO_JSVAL(514) },
  { "LEQUAL", UINT_TO_JSVAL(515) },
  { "GREATER", UINT_TO_JSVAL(516) },
  { "NOTEQUAL", UINT_TO_JSVAL(517) },
  { "GEQUAL", UINT_TO_JSVAL(518) },
  { "ALWAYS", UINT_TO_JSVAL(519) },
  { "KEEP", UINT_TO_JSVAL(7680) },
  { "REPLACE", UINT_TO_JSVAL(7681) },
  { "INCR", UINT_TO_JSVAL(7682) },
  { "DECR", UINT_TO_JSVAL(7683) },
  { "INVERT", UINT_TO_JSVAL(5386) },
  { "INCR_WRAP", UINT_TO_JSVAL(34055) },
  { "DECR_WRAP", UINT_TO_JSVAL(34056) },
  { "VENDOR", UINT_TO_JSVAL(7936) },
  { "RENDERER", UINT_TO_JSVAL(7937) },
  { "VERSION", UINT_TO_JSVAL(7938) },
  { "NEAREST", UINT_TO_JSVAL(9728) },
  { "LINEAR", UINT_TO_JSVAL(9729) },
  { "NEAREST_MIPMAP_NEAREST", UINT_TO_JSVAL(9984) },
  { "LINEAR_MIPMAP_NEAREST", UINT_TO_JSVAL(9985) },
  { "NEAREST_MIPMAP_LINEAR", UINT_TO_JSVAL(9986) },
  { "LINEAR_MIPMAP_LINEAR", UINT_TO_JSVAL(9987) },
  { "TEXTURE_MAG_FILTER", UINT_TO_JSVAL(10240) },
  { "TEXTURE_MIN_FILTER", UINT_TO_JSVAL(10241) },
  { "TEXTURE_WRAP_S", UINT_TO_JSVAL(10242) },
  { "TEXTURE_WRAP_T", UINT_TO_JSVAL(10243) },
  { "TEXTURE_2D", UINT_TO_JSVAL(3553) },
  { "TEXTURE", UINT_TO_JSVAL(5890) },
  { "TEXTURE_CUBE_MAP", UINT_TO_JSVAL(34067) },
  { "TEXTURE_BINDING_CUBE_MAP", UINT_TO_JSVAL(34068) },
  { "TEXTURE_CUBE_MAP_POSITIVE_X", UINT_TO_JSVAL(34069) },
  { "TEXTURE_CUBE_MAP_NEGATIVE_X", UINT_TO_JSVAL(34070) },
  { "TEXTURE_CUBE_MAP_POSITIVE_Y", UINT_TO_JSVAL(34071) },
  { "TEXTURE_CUBE_MAP_NEGATIVE_Y", UINT_TO_JSVAL(34072) },
  { "TEXTURE_CUBE_MAP_POSITIVE_Z", UINT_TO_JSVAL(34073) },
  { "TEXTURE_CUBE_MAP_NEGATIVE_Z", UINT_TO_JSVAL(34074) },
  { "MAX_CUBE_MAP_TEXTURE_SIZE", UINT_TO_JSVAL(34076) },
  { "TEXTURE0", UINT_TO_JSVAL(33984) },
  { "TEXTURE1", UINT_TO_JSVAL(33985) },
  { "TEXTURE2", UINT_TO_JSVAL(33986) },
  { "TEXTURE3", UINT_TO_JSVAL(33987) },
  { "TEXTURE4", UINT_TO_JSVAL(33988) },
  { "TEXTURE5", UINT_TO_JSVAL(33989) },
  { "TEXTURE6", UINT_TO_JSVAL(33990) },
  { "TEXTURE7", UINT_TO_JSVAL(33991) },
  { "TEXTURE8", UINT_TO_JSVAL(33992) },
  { "TEXTURE9", UINT_TO_JSVAL(33993) },
  { "TEXTURE10", UINT_TO_JSVAL(33994) },
  { "TEXTURE11", UINT_TO_JSVAL(33995) },
  { "TEXTURE12", UINT_TO_JSVAL(33996) },
  { "TEXTURE13", UINT_TO_JSVAL(33997) },
  { "TEXTURE14", UINT_TO_JSVAL(33998) },
  { "TEXTURE15", UINT_TO_JSVAL(33999) },
  { "TEXTURE16", UINT_TO_JSVAL(34000) },
  { "TEXTURE17", UINT_TO_JSVAL(34001) },
  { "TEXTURE18", UINT_TO_JSVAL(34002) },
  { "TEXTURE19", UINT_TO_JSVAL(34003) },
  { "TEXTURE20", UINT_TO_JSVAL(34004) },
  { "TEXTURE21", UINT_TO_JSVAL(34005) },
  { "TEXTURE22", UINT_TO_JSVAL(34006) },
  { "TEXTURE23", UINT_TO_JSVAL(34007) },
  { "TEXTURE24", UINT_TO_JSVAL(34008) },
  { "TEXTURE25", UINT_TO_JSVAL(34009) },
  { "TEXTURE26", UINT_TO_JSVAL(34010) },
  { "TEXTURE27", UINT_TO_JSVAL(34011) },
  { "TEXTURE28", UINT_TO_JSVAL(34012) },
  { "TEXTURE29", UINT_TO_JSVAL(34013) },
  { "TEXTURE30", UINT_TO_JSVAL(34014) },
  { "TEXTURE31", UINT_TO_JSVAL(34015) },
  { "ACTIVE_TEXTURE", UINT_TO_JSVAL(34016) },
  { "REPEAT", UINT_TO_JSVAL(10497) },
  { "CLAMP_TO_EDGE", UINT_TO_JSVAL(33071) },
  { "MIRRORED_REPEAT", UINT_TO_JSVAL(33648) },
  { "FLOAT_VEC2", UINT_TO_JSVAL(35664) },
  { "FLOAT_VEC3", UINT_TO_JSVAL(35665) },
  { "FLOAT_VEC4", UINT_TO_JSVAL(35666) },
  { "INT_VEC2", UINT_TO_JSVAL(35667) },
  { "INT_VEC3", UINT_TO_JSVAL(35668) },
  { "INT_VEC4", UINT_TO_JSVAL(35669) },
  { "BOOL", UINT_TO_JSVAL(35670) },
  { "BOOL_VEC2", UINT_TO_JSVAL(35671) },
  { "BOOL_VEC3", UINT_TO_JSVAL(35672) },
  { "BOOL_VEC4", UINT_TO_JSVAL(35673) },
  { "FLOAT_MAT2", UINT_TO_JSVAL(35674) },
  { "FLOAT_MAT3", UINT_TO_JSVAL(35675) },
  { "FLOAT_MAT4", UINT_TO_JSVAL(35676) },
  { "SAMPLER_2D", UINT_TO_JSVAL(35678) },
  { "SAMPLER_CUBE", UINT_TO_JSVAL(35680) },
  { "VERTEX_ATTRIB_ARRAY_ENABLED", UINT_TO_JSVAL(34338) },
  { "VERTEX_ATTRIB_ARRAY_SIZE", UINT_TO_JSVAL(34339) },
  { "VERTEX_ATTRIB_ARRAY_STRIDE", UINT_TO_JSVAL(34340) },
  { "VERTEX_ATTRIB_ARRAY_TYPE", UINT_TO_JSVAL(34341) },
  { "VERTEX_ATTRIB_ARRAY_NORMALIZED", UINT_TO_JSVAL(34922) },
  { "VERTEX_ATTRIB_ARRAY_POINTER", UINT_TO_JSVAL(34373) },
  { "VERTEX_ATTRIB_ARRAY_BUFFER_BINDING", UINT_TO_JSVAL(34975) },
  { "COMPILE_STATUS", UINT_TO_JSVAL(35713) },
  { "LOW_FLOAT", UINT_TO_JSVAL(36336) },
  { "MEDIUM_FLOAT", UINT_TO_JSVAL(36337) },
  { "HIGH_FLOAT", UINT_TO_JSVAL(36338) },
  { "LOW_INT", UINT_TO_JSVAL(36339) },
  { "MEDIUM_INT", UINT_TO_JSVAL(36340) },
  { "HIGH_INT", UINT_TO_JSVAL(36341) },
  { "FRAMEBUFFER", UINT_TO_JSVAL(36160) },
  { "RENDERBUFFER", UINT_TO_JSVAL(36161) },
  { "RGBA4", UINT_TO_JSVAL(32854) },
  { "RGB5_A1", UINT_TO_JSVAL(32855) },
  { "RGB565", UINT_TO_JSVAL(36194) },
  { "DEPTH_COMPONENT16", UINT_TO_JSVAL(33189) },
  { "STENCIL_INDEX", UINT_TO_JSVAL(6401) },
  { "STENCIL_INDEX8", UINT_TO_JSVAL(36168) },
  { "DEPTH_STENCIL", UINT_TO_JSVAL(34041) },
  { "RENDERBUFFER_WIDTH", UINT_TO_JSVAL(36162) },
  { "RENDERBUFFER_HEIGHT", UINT_TO_JSVAL(36163) },
  { "RENDERBUFFER_INTERNAL_FORMAT", UINT_TO_JSVAL(36164) },
  { "RENDERBUFFER_RED_SIZE", UINT_TO_JSVAL(36176) },
  { "RENDERBUFFER_GREEN_SIZE", UINT_TO_JSVAL(36177) },
  { "RENDERBUFFER_BLUE_SIZE", UINT_TO_JSVAL(36178) },
  { "RENDERBUFFER_ALPHA_SIZE", UINT_TO_JSVAL(36179) },
  { "RENDERBUFFER_DEPTH_SIZE", UINT_TO_JSVAL(36180) },
  { "RENDERBUFFER_STENCIL_SIZE", UINT_TO_JSVAL(36181) },
  { "FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE", UINT_TO_JSVAL(36048) },
  { "FRAMEBUFFER_ATTACHMENT_OBJECT_NAME", UINT_TO_JSVAL(36049) },
  { "FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL", UINT_TO_JSVAL(36050) },
  { "FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE", UINT_TO_JSVAL(36051) },
  { "COLOR_ATTACHMENT0", UINT_TO_JSVAL(36064) },
  { "DEPTH_ATTACHMENT", UINT_TO_JSVAL(36096) },
  { "STENCIL_ATTACHMENT", UINT_TO_JSVAL(36128) },
  { "DEPTH_STENCIL_ATTACHMENT", UINT_TO_JSVAL(33306) },
  { "NONE", UINT_TO_JSVAL(0) },
  { "FRAMEBUFFER_COMPLETE", UINT_TO_JSVAL(36053) },
  { "FRAMEBUFFER_INCOMPLETE_ATTACHMENT", UINT_TO_JSVAL(36054) },
  { "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT", UINT_TO_JSVAL(36055) },
  { "FRAMEBUFFER_INCOMPLETE_DIMENSIONS", UINT_TO_JSVAL(36057) },
  { "FRAMEBUFFER_UNSUPPORTED", UINT_TO_JSVAL(36061) },
  { "FRAMEBUFFER_BINDING", UINT_TO_JSVAL(36006) },
  { "RENDERBUFFER_BINDING", UINT_TO_JSVAL(36007) },
  { "MAX_RENDERBUFFER_SIZE", UINT_TO_JSVAL(34024) },
  { "INVALID_FRAMEBUFFER_OPERATION", UINT_TO_JSVAL(1286) },
  { "UNPACK_FLIP_Y_WEBGL", UINT_TO_JSVAL(37440) },
  { "UNPACK_PREMULTIPLY_ALPHA_WEBGL", UINT_TO_JSVAL(37441) },
  { "CONTEXT_LOST_WEBGL", UINT_TO_JSVAL(37442) },
  { "UNPACK_COLORSPACE_CONVERSION_WEBGL", UINT_TO_JSVAL(37443) },
  { "BROWSER_DEFAULT_WEBGL", UINT_TO_JSVAL(37444) },
  { 0, JSVAL_VOID }
};

static Prefable<ConstantSpec> sConstants[] = {
  { true, &sConstants_specs[0] },
  { false, NULL }
};

static jsid sConstants_ids[296] = { JSID_VOID };


static const NativeProperties sNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sMethods, sMethods_ids, sMethods_specs,
  sAttributes, sAttributes_ids, sAttributes_specs,
  nullptr, nullptr, nullptr,
  sConstants, sConstants_ids, sConstants_specs
};

static const NativeProperties sChromeOnlyNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sChromeMethods, sChromeMethods_ids, sChromeMethods_specs,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr
};
const NativePropertyHooks sNativePropertyHooks = {
  nullptr,
  nullptr,
  { &sNativeProperties, &sChromeOnlyNativeProperties },
  prototypes::id::WebGLRenderingContext,
  constructors::id::WebGLRenderingContext,
  NULL
};

JSNativeHolder _constructor_holder = {
  ThrowingConstructor,
  &sNativePropertyHooks
};

static DOMIfaceAndProtoJSClass PrototypeClass = {
  {
    "WebGLRenderingContextPrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(2),
    JS_PropertyStub,       /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    nullptr,               /* finalize */
    nullptr,               /* checkAccess */
    nullptr,               /* call */
    nullptr,               /* hasInstance */
    nullptr,               /* construct */
    nullptr,               /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  eInterfacePrototype,
  &sNativePropertyHooks
};

void
CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray)
{
  JSObject* parentProto = JS_GetObjectPrototype(aCx, aGlobal);
  if (!parentProto) {
    return;
  }


  if (sChromeMethods_ids[0] == JSID_VOID &&
      (!InitIds(aCx, sChromeMethods, sChromeMethods_ids) ||
       !InitIds(aCx, sMethods, sMethods_ids) ||
       !InitIds(aCx, sAttributes, sAttributes_ids) ||
       !InitIds(aCx, sConstants, sConstants_ids))) {
    sChromeMethods_ids[0] = JSID_VOID;
    return;
  }

  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &PrototypeClass.mBase, &protoAndIfaceArray[prototypes::id::WebGLRenderingContext],
                              nullptr, &_constructor_holder, 0, &protoAndIfaceArray[constructors::id::WebGLRenderingContext],
                              &Class.mClass,
                              &sNativeProperties,
                              xpc::AccessCheck::isChrome(aGlobal) ? &sChromeOnlyNativeProperties : nullptr,
                              "WebGLRenderingContext");
}

JSObject*
DefineDOMInterface(JSContext* aCx, JSObject* aGlobal, bool* aEnabled)
{

  *aEnabled = true;
  return GetConstructorObject(aCx, aGlobal);
}


DOMJSClass Class = {
  { "WebGLRenderingContext",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(3),
    _addProperty, /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    _finalize, /* finalize */
    NULL,                  /* checkAccess */
    NULL,                  /* call */
    NULL,                  /* hasInstance */
    NULL,                  /* construct */
    NULL, /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  {
    { prototypes::id::WebGLRenderingContext, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
    true,
    &sNativePropertyHooks,
    GetParentObject<mozilla::WebGLContext>::Get,
    GetProtoObject,
    nullptr
  }
};

JSObject*
Wrap(JSContext* aCx, JSObject* aScope, mozilla::WebGLContext* aObject, nsWrapperCache* aCache, bool* aTriedToWrap)
{
  MOZ_ASSERT(static_cast<mozilla::WebGLContext*>(aObject) ==
             reinterpret_cast<mozilla::WebGLContext*>(aObject));

  *aTriedToWrap = true;

  JSObject* parent = WrapNativeParent(aCx, aScope, aObject->GetParentObject());
  if (!parent) {
    return NULL;
  }

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.  Scope so we don't
  // collide with the "obj" we declare in CreateBindingJSObject.
  {
    JSObject* obj = aCache->GetWrapper();
    if (obj) {
      return obj;
    }
  }

  JSAutoCompartment ac(aCx, parent);
  JSObject* global = JS_GetGlobalForObject(aCx, parent);

  JSObject* proto = GetProtoObject(aCx, global);
  if (!proto) {
    return NULL;
  }

  JSObject* obj = JS_NewObject(aCx, &Class.mBase, proto, parent);
  if (!obj) {
    return NULL;
  }

  js::SetReservedSlot(obj, DOM_OBJECT_SLOT, PRIVATE_TO_JSVAL(aObject));
  NS_ADDREF(aObject);


  aCache->SetWrapper(obj);

  return obj;
}

} // namespace WebGLRenderingContextBinding



namespace WebGLShaderBinding {

static JSBool
_addProperty(JSContext* cx, JSHandleObject obj, JSHandleId id, JSMutableHandleValue vp)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::WebGLShader>::value), "Must be an nsISupports class");
  mozilla::WebGLShader* self = UnwrapDOMObject<mozilla::WebGLShader>(obj);
  nsContentUtils::PreserveWrapper(reinterpret_cast<nsISupports*>(self), self);
  return true;
}

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::WebGLShader>::value), "Must be an nsISupports class");
  mozilla::WebGLShader* self = UnwrapDOMObject<mozilla::WebGLShader>(obj);
  if (self) {
    ClearWrapper(self, self);
    XPCJSRuntime *rt = nsXPConnect::GetRuntimeInstance();
    if (rt) {
      rt->DeferredRelease(reinterpret_cast<nsISupports*>(self));
    } else {
      NS_RELEASE(self);
    }
  }
}

static JSFunctionSpec sChromeMethods_specs[] = {
  JS_FNINFO("QueryInterface", QueryInterface, nullptr, 1, 0),
  JS_FS_END
};

static Prefable<JSFunctionSpec> sChromeMethods[] = {
  { true, &sChromeMethods_specs[0] },
  { false, NULL }
};

static jsid sChromeMethods_ids[2] = { JSID_VOID };


static const NativeProperties sChromeOnlyNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sChromeMethods, sChromeMethods_ids, sChromeMethods_specs,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr
};
const NativePropertyHooks sNativePropertyHooks = {
  nullptr,
  nullptr,
  { nullptr, &sChromeOnlyNativeProperties },
  prototypes::id::WebGLShader,
  constructors::id::WebGLShader,
  NULL
};

JSNativeHolder _constructor_holder = {
  ThrowingConstructor,
  &sNativePropertyHooks
};

static DOMIfaceAndProtoJSClass PrototypeClass = {
  {
    "WebGLShaderPrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(2),
    JS_PropertyStub,       /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    nullptr,               /* finalize */
    nullptr,               /* checkAccess */
    nullptr,               /* call */
    nullptr,               /* hasInstance */
    nullptr,               /* construct */
    nullptr,               /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  eInterfacePrototype,
  &sNativePropertyHooks
};

void
CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray)
{
  JSObject* parentProto = JS_GetObjectPrototype(aCx, aGlobal);
  if (!parentProto) {
    return;
  }


  if (sChromeMethods_ids[0] == JSID_VOID &&
      !InitIds(aCx, sChromeMethods, sChromeMethods_ids)) {
    sChromeMethods_ids[0] = JSID_VOID;
    return;
  }

  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &PrototypeClass.mBase, &protoAndIfaceArray[prototypes::id::WebGLShader],
                              nullptr, &_constructor_holder, 0, &protoAndIfaceArray[constructors::id::WebGLShader],
                              &Class.mClass,
                              nullptr,
                              xpc::AccessCheck::isChrome(aGlobal) ? &sChromeOnlyNativeProperties : nullptr,
                              "WebGLShader");
}

JSObject*
DefineDOMInterface(JSContext* aCx, JSObject* aGlobal, bool* aEnabled)
{

  *aEnabled = true;
  return GetConstructorObject(aCx, aGlobal);
}


DOMJSClass Class = {
  { "WebGLShader",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(3),
    _addProperty, /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    _finalize, /* finalize */
    NULL,                  /* checkAccess */
    NULL,                  /* call */
    NULL,                  /* hasInstance */
    NULL,                  /* construct */
    NULL, /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  {
    { prototypes::id::WebGLShader, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
    true,
    &sNativePropertyHooks,
    GetParentObject<mozilla::WebGLShader>::Get,
    GetProtoObject,
    nullptr
  }
};

JSObject*
Wrap(JSContext* aCx, JSObject* aScope, mozilla::WebGLShader* aObject, nsWrapperCache* aCache, bool* aTriedToWrap)
{
  MOZ_ASSERT(static_cast<mozilla::WebGLShader*>(aObject) ==
             reinterpret_cast<mozilla::WebGLShader*>(aObject));

  *aTriedToWrap = true;

  JSObject* parent = WrapNativeParent(aCx, aScope, aObject->GetParentObject());
  if (!parent) {
    return NULL;
  }

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.  Scope so we don't
  // collide with the "obj" we declare in CreateBindingJSObject.
  {
    JSObject* obj = aCache->GetWrapper();
    if (obj) {
      return obj;
    }
  }

  JSAutoCompartment ac(aCx, parent);
  JSObject* global = JS_GetGlobalForObject(aCx, parent);

  JSObject* proto = GetProtoObject(aCx, global);
  if (!proto) {
    return NULL;
  }

  JSObject* obj = JS_NewObject(aCx, &Class.mBase, proto, parent);
  if (!obj) {
    return NULL;
  }

  js::SetReservedSlot(obj, DOM_OBJECT_SLOT, PRIVATE_TO_JSVAL(aObject));
  NS_ADDREF(aObject);


  aCache->SetWrapper(obj);

  return obj;
}

} // namespace WebGLShaderBinding



namespace WebGLShaderPrecisionFormatBinding {

static bool
get_rangeMin(JSContext* cx, JSHandleObject obj, mozilla::WebGLShaderPrecisionFormat* self, JS::Value* vp)
{
  int32_t result;
  result = self->RangeMin();
  *vp = INT_TO_JSVAL(int32_t(result));
  return true;
}


const JSJitInfo rangeMin_getterinfo = {
  (JSJitPropertyOp)get_rangeMin,
  prototypes::id::WebGLShaderPrecisionFormat,
  PrototypeTraits<prototypes::id::WebGLShaderPrecisionFormat>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_rangeMax(JSContext* cx, JSHandleObject obj, mozilla::WebGLShaderPrecisionFormat* self, JS::Value* vp)
{
  int32_t result;
  result = self->RangeMax();
  *vp = INT_TO_JSVAL(int32_t(result));
  return true;
}


const JSJitInfo rangeMax_getterinfo = {
  (JSJitPropertyOp)get_rangeMax,
  prototypes::id::WebGLShaderPrecisionFormat,
  PrototypeTraits<prototypes::id::WebGLShaderPrecisionFormat>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_precision(JSContext* cx, JSHandleObject obj, mozilla::WebGLShaderPrecisionFormat* self, JS::Value* vp)
{
  int32_t result;
  result = self->Precision();
  *vp = INT_TO_JSVAL(int32_t(result));
  return true;
}


const JSJitInfo precision_getterinfo = {
  (JSJitPropertyOp)get_precision,
  prototypes::id::WebGLShaderPrecisionFormat,
  PrototypeTraits<prototypes::id::WebGLShaderPrecisionFormat>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

static JSBool
genericGetter(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  mozilla::WebGLShaderPrecisionFormat* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::WebGLShaderPrecisionFormat, mozilla::WebGLShaderPrecisionFormat>(cx, obj, self);
    if (NS_FAILED(rv)) {
      return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "WebGLShaderPrecisionFormat");
    }
  }
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Getter);
  JSJitPropertyOp getter = info->op;
  return getter(cx, obj, self, vp);
}

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::WebGLShaderPrecisionFormat>::value), "Must be an nsISupports class");
  mozilla::WebGLShaderPrecisionFormat* self = UnwrapDOMObject<mozilla::WebGLShaderPrecisionFormat>(obj);
  if (self) {
    XPCJSRuntime *rt = nsXPConnect::GetRuntimeInstance();
    if (rt) {
      rt->DeferredRelease(reinterpret_cast<nsISupports*>(self));
    } else {
      NS_RELEASE(self);
    }
  }
}

static JSFunctionSpec sChromeMethods_specs[] = {
  JS_FNINFO("QueryInterface", QueryInterface, nullptr, 1, 0),
  JS_FS_END
};

static Prefable<JSFunctionSpec> sChromeMethods[] = {
  { true, &sChromeMethods_specs[0] },
  { false, NULL }
};

static jsid sChromeMethods_ids[2] = { JSID_VOID };

static JSPropertySpec sAttributes_specs[] = {
  { "rangeMin", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &rangeMin_getterinfo }, JSOP_NULLWRAPPER},
  { "rangeMax", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &rangeMax_getterinfo }, JSOP_NULLWRAPPER},
  { "precision", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &precision_getterinfo }, JSOP_NULLWRAPPER},
  { 0, 0, 0, JSOP_NULLWRAPPER, JSOP_NULLWRAPPER }
};

static Prefable<JSPropertySpec> sAttributes[] = {
  { true, &sAttributes_specs[0] },
  { false, NULL }
};

static jsid sAttributes_ids[4] = { JSID_VOID };


static const NativeProperties sNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sAttributes, sAttributes_ids, sAttributes_specs,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr
};

static const NativeProperties sChromeOnlyNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sChromeMethods, sChromeMethods_ids, sChromeMethods_specs,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr
};
const NativePropertyHooks sNativePropertyHooks = {
  nullptr,
  nullptr,
  { &sNativeProperties, &sChromeOnlyNativeProperties },
  prototypes::id::WebGLShaderPrecisionFormat,
  constructors::id::WebGLShaderPrecisionFormat,
  NULL
};

JSNativeHolder _constructor_holder = {
  ThrowingConstructor,
  &sNativePropertyHooks
};

static DOMIfaceAndProtoJSClass PrototypeClass = {
  {
    "WebGLShaderPrecisionFormatPrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(2),
    JS_PropertyStub,       /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    nullptr,               /* finalize */
    nullptr,               /* checkAccess */
    nullptr,               /* call */
    nullptr,               /* hasInstance */
    nullptr,               /* construct */
    nullptr,               /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  eInterfacePrototype,
  &sNativePropertyHooks
};

void
CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray)
{
  JSObject* parentProto = JS_GetObjectPrototype(aCx, aGlobal);
  if (!parentProto) {
    return;
  }


  if (sChromeMethods_ids[0] == JSID_VOID &&
      (!InitIds(aCx, sChromeMethods, sChromeMethods_ids) ||
       !InitIds(aCx, sAttributes, sAttributes_ids))) {
    sChromeMethods_ids[0] = JSID_VOID;
    return;
  }

  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &PrototypeClass.mBase, &protoAndIfaceArray[prototypes::id::WebGLShaderPrecisionFormat],
                              nullptr, &_constructor_holder, 0, &protoAndIfaceArray[constructors::id::WebGLShaderPrecisionFormat],
                              &Class.mClass,
                              &sNativeProperties,
                              xpc::AccessCheck::isChrome(aGlobal) ? &sChromeOnlyNativeProperties : nullptr,
                              "WebGLShaderPrecisionFormat");
}

JSObject*
DefineDOMInterface(JSContext* aCx, JSObject* aGlobal, bool* aEnabled)
{

  *aEnabled = true;
  return GetConstructorObject(aCx, aGlobal);
}


DOMJSClass Class = {
  { "WebGLShaderPrecisionFormat",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(3),
    JS_PropertyStub, /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    _finalize, /* finalize */
    NULL,                  /* checkAccess */
    NULL,                  /* call */
    NULL,                  /* hasInstance */
    NULL,                  /* construct */
    NULL, /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  {
    { prototypes::id::WebGLShaderPrecisionFormat, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
    true,
    &sNativePropertyHooks,
    GetParentObject<mozilla::WebGLShaderPrecisionFormat>::Get,
    GetProtoObject,
    nullptr
  }
};

JSObject*
Wrap(JSContext* aCx, JSObject* aScope, mozilla::WebGLShaderPrecisionFormat* aObject)
{
  MOZ_ASSERT(static_cast<mozilla::WebGLShaderPrecisionFormat*>(aObject) ==
             reinterpret_cast<mozilla::WebGLShaderPrecisionFormat*>(aObject));

  JSObject* global = JS_GetGlobalForObject(aCx, aScope);
  JSObject* proto = GetProtoObject(aCx, global);
  if (!proto) {
    return NULL;
  }

  JSObject* obj = JS_NewObject(aCx, &Class.mBase, proto, global);
  if (!obj) {
    return NULL;
  }

  js::SetReservedSlot(obj, DOM_OBJECT_SLOT, PRIVATE_TO_JSVAL(aObject));
  NS_ADDREF(aObject);


  return obj;
}

} // namespace WebGLShaderPrecisionFormatBinding



namespace WebGLTextureBinding {

static JSBool
_addProperty(JSContext* cx, JSHandleObject obj, JSHandleId id, JSMutableHandleValue vp)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::WebGLTexture>::value), "Must be an nsISupports class");
  mozilla::WebGLTexture* self = UnwrapDOMObject<mozilla::WebGLTexture>(obj);
  nsContentUtils::PreserveWrapper(reinterpret_cast<nsISupports*>(self), self);
  return true;
}

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::WebGLTexture>::value), "Must be an nsISupports class");
  mozilla::WebGLTexture* self = UnwrapDOMObject<mozilla::WebGLTexture>(obj);
  if (self) {
    ClearWrapper(self, self);
    XPCJSRuntime *rt = nsXPConnect::GetRuntimeInstance();
    if (rt) {
      rt->DeferredRelease(reinterpret_cast<nsISupports*>(self));
    } else {
      NS_RELEASE(self);
    }
  }
}

static JSFunctionSpec sChromeMethods_specs[] = {
  JS_FNINFO("QueryInterface", QueryInterface, nullptr, 1, 0),
  JS_FS_END
};

static Prefable<JSFunctionSpec> sChromeMethods[] = {
  { true, &sChromeMethods_specs[0] },
  { false, NULL }
};

static jsid sChromeMethods_ids[2] = { JSID_VOID };


static const NativeProperties sChromeOnlyNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sChromeMethods, sChromeMethods_ids, sChromeMethods_specs,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr
};
const NativePropertyHooks sNativePropertyHooks = {
  nullptr,
  nullptr,
  { nullptr, &sChromeOnlyNativeProperties },
  prototypes::id::WebGLTexture,
  constructors::id::WebGLTexture,
  NULL
};

JSNativeHolder _constructor_holder = {
  ThrowingConstructor,
  &sNativePropertyHooks
};

static DOMIfaceAndProtoJSClass PrototypeClass = {
  {
    "WebGLTexturePrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(2),
    JS_PropertyStub,       /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    nullptr,               /* finalize */
    nullptr,               /* checkAccess */
    nullptr,               /* call */
    nullptr,               /* hasInstance */
    nullptr,               /* construct */
    nullptr,               /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  eInterfacePrototype,
  &sNativePropertyHooks
};

void
CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray)
{
  JSObject* parentProto = JS_GetObjectPrototype(aCx, aGlobal);
  if (!parentProto) {
    return;
  }


  if (sChromeMethods_ids[0] == JSID_VOID &&
      !InitIds(aCx, sChromeMethods, sChromeMethods_ids)) {
    sChromeMethods_ids[0] = JSID_VOID;
    return;
  }

  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &PrototypeClass.mBase, &protoAndIfaceArray[prototypes::id::WebGLTexture],
                              nullptr, &_constructor_holder, 0, &protoAndIfaceArray[constructors::id::WebGLTexture],
                              &Class.mClass,
                              nullptr,
                              xpc::AccessCheck::isChrome(aGlobal) ? &sChromeOnlyNativeProperties : nullptr,
                              "WebGLTexture");
}

JSObject*
DefineDOMInterface(JSContext* aCx, JSObject* aGlobal, bool* aEnabled)
{

  *aEnabled = true;
  return GetConstructorObject(aCx, aGlobal);
}


DOMJSClass Class = {
  { "WebGLTexture",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(3),
    _addProperty, /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    _finalize, /* finalize */
    NULL,                  /* checkAccess */
    NULL,                  /* call */
    NULL,                  /* hasInstance */
    NULL,                  /* construct */
    NULL, /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  {
    { prototypes::id::WebGLTexture, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
    true,
    &sNativePropertyHooks,
    GetParentObject<mozilla::WebGLTexture>::Get,
    GetProtoObject,
    nullptr
  }
};

JSObject*
Wrap(JSContext* aCx, JSObject* aScope, mozilla::WebGLTexture* aObject, nsWrapperCache* aCache, bool* aTriedToWrap)
{
  MOZ_ASSERT(static_cast<mozilla::WebGLTexture*>(aObject) ==
             reinterpret_cast<mozilla::WebGLTexture*>(aObject));

  *aTriedToWrap = true;

  JSObject* parent = WrapNativeParent(aCx, aScope, aObject->GetParentObject());
  if (!parent) {
    return NULL;
  }

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.  Scope so we don't
  // collide with the "obj" we declare in CreateBindingJSObject.
  {
    JSObject* obj = aCache->GetWrapper();
    if (obj) {
      return obj;
    }
  }

  JSAutoCompartment ac(aCx, parent);
  JSObject* global = JS_GetGlobalForObject(aCx, parent);

  JSObject* proto = GetProtoObject(aCx, global);
  if (!proto) {
    return NULL;
  }

  JSObject* obj = JS_NewObject(aCx, &Class.mBase, proto, parent);
  if (!obj) {
    return NULL;
  }

  js::SetReservedSlot(obj, DOM_OBJECT_SLOT, PRIVATE_TO_JSVAL(aObject));
  NS_ADDREF(aObject);


  aCache->SetWrapper(obj);

  return obj;
}

} // namespace WebGLTextureBinding



namespace WebGLUniformLocationBinding {

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::WebGLUniformLocation>::value), "Must be an nsISupports class");
  mozilla::WebGLUniformLocation* self = UnwrapDOMObject<mozilla::WebGLUniformLocation>(obj);
  if (self) {
    XPCJSRuntime *rt = nsXPConnect::GetRuntimeInstance();
    if (rt) {
      rt->DeferredRelease(reinterpret_cast<nsISupports*>(self));
    } else {
      NS_RELEASE(self);
    }
  }
}

static JSFunctionSpec sChromeMethods_specs[] = {
  JS_FNINFO("QueryInterface", QueryInterface, nullptr, 1, 0),
  JS_FS_END
};

static Prefable<JSFunctionSpec> sChromeMethods[] = {
  { true, &sChromeMethods_specs[0] },
  { false, NULL }
};

static jsid sChromeMethods_ids[2] = { JSID_VOID };


static const NativeProperties sChromeOnlyNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sChromeMethods, sChromeMethods_ids, sChromeMethods_specs,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr
};
const NativePropertyHooks sNativePropertyHooks = {
  nullptr,
  nullptr,
  { nullptr, &sChromeOnlyNativeProperties },
  prototypes::id::WebGLUniformLocation,
  constructors::id::WebGLUniformLocation,
  NULL
};

JSNativeHolder _constructor_holder = {
  ThrowingConstructor,
  &sNativePropertyHooks
};

static DOMIfaceAndProtoJSClass PrototypeClass = {
  {
    "WebGLUniformLocationPrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(2),
    JS_PropertyStub,       /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    nullptr,               /* finalize */
    nullptr,               /* checkAccess */
    nullptr,               /* call */
    nullptr,               /* hasInstance */
    nullptr,               /* construct */
    nullptr,               /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  eInterfacePrototype,
  &sNativePropertyHooks
};

void
CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray)
{
  JSObject* parentProto = JS_GetObjectPrototype(aCx, aGlobal);
  if (!parentProto) {
    return;
  }


  if (sChromeMethods_ids[0] == JSID_VOID &&
      !InitIds(aCx, sChromeMethods, sChromeMethods_ids)) {
    sChromeMethods_ids[0] = JSID_VOID;
    return;
  }

  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &PrototypeClass.mBase, &protoAndIfaceArray[prototypes::id::WebGLUniformLocation],
                              nullptr, &_constructor_holder, 0, &protoAndIfaceArray[constructors::id::WebGLUniformLocation],
                              &Class.mClass,
                              nullptr,
                              xpc::AccessCheck::isChrome(aGlobal) ? &sChromeOnlyNativeProperties : nullptr,
                              "WebGLUniformLocation");
}

JSObject*
DefineDOMInterface(JSContext* aCx, JSObject* aGlobal, bool* aEnabled)
{

  *aEnabled = true;
  return GetConstructorObject(aCx, aGlobal);
}


DOMJSClass Class = {
  { "WebGLUniformLocation",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(3),
    JS_PropertyStub, /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    _finalize, /* finalize */
    NULL,                  /* checkAccess */
    NULL,                  /* call */
    NULL,                  /* hasInstance */
    NULL,                  /* construct */
    NULL, /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  {
    { prototypes::id::WebGLUniformLocation, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
    true,
    &sNativePropertyHooks,
    GetParentObject<mozilla::WebGLUniformLocation>::Get,
    GetProtoObject,
    nullptr
  }
};

JSObject*
Wrap(JSContext* aCx, JSObject* aScope, mozilla::WebGLUniformLocation* aObject)
{
  MOZ_ASSERT(static_cast<mozilla::WebGLUniformLocation*>(aObject) ==
             reinterpret_cast<mozilla::WebGLUniformLocation*>(aObject));

  JSObject* global = JS_GetGlobalForObject(aCx, aScope);
  JSObject* proto = GetProtoObject(aCx, global);
  if (!proto) {
    return NULL;
  }

  JSObject* obj = JS_NewObject(aCx, &Class.mBase, proto, global);
  if (!obj) {
    return NULL;
  }

  js::SetReservedSlot(obj, DOM_OBJECT_SLOT, PRIVATE_TO_JSVAL(aObject));
  NS_ADDREF(aObject);


  return obj;
}

} // namespace WebGLUniformLocationBinding



} // namespace dom
} // namespace mozilla
