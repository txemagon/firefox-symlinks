/* THIS FILE IS AUTOGENERATED - DO NOT EDIT */

#include "AccessCheck.h"
#include "PrimitiveConversions.h"
#include "TestBindingHeader.h"
#include "TestCodeGenBinding.h"
#include "TestDictionaryBinding.h"
#include "WorkerPrivate.h"
#include "XPCQuickStubs.h"
#include "XPCWrapper.h"
#include "jsfriendapi.h"
#include "mozilla/FloatingPoint.h"
#include "mozilla/Preferences.h"
#include "mozilla/dom/BindingUtils.h"
#include "mozilla/dom/NonRefcountedDOMObject.h"
#include "mozilla/dom/Nullable.h"
#include "mozilla/dom/TypedArray.h"
#include "mozilla/dom/UnionConversions.h"
#include "nsContentUtils.h"
#include "nsDOMQS.h"

using namespace mozilla::dom;
namespace mozilla {
namespace dom {

namespace TestEnumValues {

  const EnumEntry strings[3] = {
    {"a", 1},
    {"b", 1},
    { NULL, 0 }
  };
} // namespace TestEnumValues


bool DictContainingSequence::initedIds = false;
jsid DictContainingSequence::ourSequence_id = JSID_VOID;
jsid DictContainingSequence::ourSequence2_id = JSID_VOID;

bool
DictContainingSequence::InitIds(JSContext* cx)
{
  MOZ_ASSERT(!initedIds);
  if (!InternJSString(cx, ourSequence_id, "ourSequence") ||
      !InternJSString(cx, ourSequence2_id, "ourSequence2")) {
    return false;
  }
  initedIds = true;
  return true;
}

bool
DictContainingSequence::Init(JSContext* cx, JSObject* scopeObj, const JS::Value& val)
{
  // Passing a null JSContext is OK only if we're initing from null,
  // Since in that case we will not have to do any property gets
  MOZ_ASSERT_IF(!cx, val.isNull());
  if (cx && !initedIds && !InitIds(cx)) {
    return false;
  }
  JSBool found;
  JS::Value temp;
  bool isNull = val.isNullOrUndefined();
  if (!IsConvertibleToDictionary(cx, val)) {
    return ThrowErrorMessage(cx, MSG_NOT_DICTIONARY);
  }

  if (isNull) {
    found = false;
  } else if (!JS_HasPropertyById(cx, &val.toObject(), ourSequence_id, &found)) {
    return false;
  }
  if (found) {
    mOurSequence.Construct();
    if (!JS_GetPropertyById(cx, &val.toObject(), ourSequence_id, &temp)) {
      return false;
    }
    if (temp.isObject()) {
      JSObject* seq = &temp.toObject();

      if (!IsArrayLike(cx, seq)) {
        ThrowErrorMessage(cx, MSG_NOT_SEQUENCE);
        return false;
      }
      uint32_t length;
      // JS_GetArrayLength actually works on all objects
      if (!JS_GetArrayLength(cx, seq, &length)) {
        return false;
      }
      Sequence< int32_t > &arr = const_cast< Sequence< int32_t >& >((mOurSequence.Value()));
      if (!arr.SetCapacity(length)) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      for (uint32_t i = 0; i < length; ++i) {
        jsval temp;
        if (!JS_GetElement(cx, seq, i, &temp)) {
          return false;
        }
        int32_t& slot = *arr.AppendElement();
        if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, &slot)) {
          return false;
        }
      }
    } else {
      ThrowErrorMessage(cx, MSG_NOT_OBJECT);
      return false;
    }
  }

  if (isNull) {
    found = false;
  } else if (!JS_HasPropertyById(cx, &val.toObject(), ourSequence2_id, &found)) {
    return false;
  }
  if (found) {
    mOurSequence2.Construct();
    if (!JS_GetPropertyById(cx, &val.toObject(), ourSequence2_id, &temp)) {
      return false;
    }
    if (temp.isObject()) {
      JSObject* seq = &temp.toObject();

      if (!IsArrayLike(cx, seq)) {
        ThrowErrorMessage(cx, MSG_NOT_SEQUENCE);
        return false;
      }
      uint32_t length;
      // JS_GetArrayLength actually works on all objects
      if (!JS_GetArrayLength(cx, seq, &length)) {
        return false;
      }
      Sequence< OwningNonNull<mozilla::dom::TestInterface> > &arr = const_cast< Sequence< OwningNonNull<mozilla::dom::TestInterface> >& >((mOurSequence2.Value()));
      if (!arr.SetCapacity(length)) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      for (uint32_t i = 0; i < length; ++i) {
        jsval temp;
        if (!JS_GetElement(cx, seq, i, &temp)) {
          return false;
        }
        OwningNonNull<mozilla::dom::TestInterface>& slot = *arr.AppendElement();
        if (temp.isObject()) {
          {
            nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(cx, &temp.toObject(), slot);
            if (NS_FAILED(rv)) {
              ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestInterface");
              return false;
            }
          }
        } else {
          ThrowErrorMessage(cx, MSG_NOT_OBJECT);
          return false;
        }
      }
    } else {
      ThrowErrorMessage(cx, MSG_NOT_OBJECT);
      return false;
    }
  }
  return true;
}

bool
DictContainingSequence::ToObject(JSContext* cx, JSObject* parentObject, JS::Value *vp)
{
  if (!initedIds && !InitIds(cx)) {
    return false;
  }
  JSObject* obj = JS_NewObject(cx, nullptr, nullptr, nullptr);
  if (!obj) {
    return false;
  }
  *vp = JS::ObjectValue(*obj);

  if (mOurSequence.WasPassed()) {
    JS::Value temp;
    Sequence< int32_t >& currentValue = mOurSequence.Value();

    uint32_t length = currentValue.Length();
    JSObject *returnArray = JS_NewArrayObject(cx, length, NULL);
    if (!returnArray) {
      return false;
    }
    // Scope for 'tmp'
    {
      jsval tmp;
      for (uint32_t i = 0; i < length; ++i) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          tmp = INT_TO_JSVAL(int32_t(currentValue[i]));
          break;
        } while (0);
        if (!JS_DefineElement(cx, returnArray, i, tmp,
                              nullptr, nullptr, JSPROP_ENUMERATE)) {
          return false;
        }
      }
    }
    temp = JS::ObjectValue(*returnArray);
    if (!JS_DefinePropertyById(cx, obj, ourSequence_id, temp, nullptr, nullptr, JSPROP_ENUMERATE)) {
      return false;
    }
  }

  if (mOurSequence2.WasPassed()) {
    JS::Value temp;
    Sequence< OwningNonNull<mozilla::dom::TestInterface> >& currentValue = mOurSequence2.Value();

    uint32_t length = currentValue.Length();
    JSObject *returnArray = JS_NewArrayObject(cx, length, NULL);
    if (!returnArray) {
      return false;
    }
    // Scope for 'tmp'
    {
      jsval tmp;
      for (uint32_t i = 0; i < length; ++i) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          if (!WrapNewBindingObject(cx, returnArray, currentValue[i], &tmp)) {
            MOZ_ASSERT(JS_IsExceptionPending(cx));
            return false;
          }
          break;
        } while (0);
        if (!JS_DefineElement(cx, returnArray, i, tmp,
                              nullptr, nullptr, JSPROP_ENUMERATE)) {
          return false;
        }
      }
    }
    temp = JS::ObjectValue(*returnArray);
    if (!JS_DefinePropertyById(cx, obj, ourSequence2_id, temp, nullptr, nullptr, JSPROP_ENUMERATE)) {
      return false;
    }
  }

  return true;
}

bool ParentDict::initedIds = false;
jsid ParentDict::c_id = JSID_VOID;
jsid ParentDict::someExternalInterface_id = JSID_VOID;
jsid ParentDict::someInterface_id = JSID_VOID;

bool
ParentDict::InitIds(JSContext* cx)
{
  MOZ_ASSERT(!initedIds);
  if (!InternJSString(cx, c_id, "c") ||
      !InternJSString(cx, someExternalInterface_id, "someExternalInterface") ||
      !InternJSString(cx, someInterface_id, "someInterface")) {
    return false;
  }
  initedIds = true;
  return true;
}

bool
ParentDict::Init(JSContext* cx, JSObject* scopeObj, const JS::Value& val)
{
  // Passing a null JSContext is OK only if we're initing from null,
  // Since in that case we will not have to do any property gets
  MOZ_ASSERT_IF(!cx, val.isNull());
  if (cx && !initedIds && !InitIds(cx)) {
    return false;
  }
  // Per spec, we init the parent's members first
  if (!GrandparentDict::Init(cx, scopeObj, val)) {
    return false;
  }
  JSBool found;
  JS::Value temp;
  bool isNull = val.isNullOrUndefined();
  if (!IsConvertibleToDictionary(cx, val)) {
    return ThrowErrorMessage(cx, MSG_NOT_DICTIONARY);
  }

  if (isNull) {
    found = false;
  } else if (!JS_HasPropertyById(cx, &val.toObject(), c_id, &found)) {
    return false;
  }
  if (found) {
    if (!JS_GetPropertyById(cx, &val.toObject(), c_id, &temp)) {
      return false;
    }
  }
  if (found) {
    if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, &mC)) {
      return false;
    }
  } else {
    mC = 5;
  }

  if (isNull) {
    found = false;
  } else if (!JS_HasPropertyById(cx, &val.toObject(), someExternalInterface_id, &found)) {
    return false;
  }
  if (found) {
    mSomeExternalInterface.Construct();
    if (!JS_GetPropertyById(cx, &val.toObject(), someExternalInterface_id, &temp)) {
      return false;
    }
    if (temp.isObject()) {
      nsRefPtr<mozilla::dom::TestExternalInterface> holder;
      jsval tmpVal = temp;
      mozilla::dom::TestExternalInterface* tmp;
      if (NS_FAILED(xpc_qsUnwrapArg<mozilla::dom::TestExternalInterface>(cx, temp, &tmp, static_cast<mozilla::dom::TestExternalInterface**>(getter_AddRefs(holder)), &tmpVal))) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestExternalInterface");return false;
      }
      MOZ_ASSERT(tmp);
      (mSomeExternalInterface.Value()) = tmp;
    } else {
      ThrowErrorMessage(cx, MSG_NOT_OBJECT);
      return false;
    }
  }

  if (isNull) {
    found = false;
  } else if (!JS_HasPropertyById(cx, &val.toObject(), someInterface_id, &found)) {
    return false;
  }
  if (found) {
    mSomeInterface.Construct();
    if (!JS_GetPropertyById(cx, &val.toObject(), someInterface_id, &temp)) {
      return false;
    }
    if (temp.isObject()) {
      {
        nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(cx, &temp.toObject(), (mSomeInterface.Value()));
        if (NS_FAILED(rv)) {
          ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestInterface");
          return false;
        }
      }
    } else {
      ThrowErrorMessage(cx, MSG_NOT_OBJECT);
      return false;
    }
  }
  return true;
}

bool
ParentDict::ToObject(JSContext* cx, JSObject* parentObject, JS::Value *vp)
{
  if (!initedIds && !InitIds(cx)) {
    return false;
  }
  // Per spec, we define the parent's members first
  if (!GrandparentDict::ToObject(cx, parentObject, vp)) {
    return false;
  }
  JSObject* obj = &vp->toObject();

  {
    // scope for 'temp' and 'currentValue'
    JS::Value temp;
    int32_t& currentValue = mC;
    temp = INT_TO_JSVAL(int32_t(currentValue));
    if (!JS_DefinePropertyById(cx, obj, c_id, temp, nullptr, nullptr, JSPROP_ENUMERATE)) {
      return false;
    }
  }

  if (mSomeExternalInterface.WasPassed()) {
    JS::Value temp;
    nsRefPtr<mozilla::dom::TestExternalInterface>& currentValue = mSomeExternalInterface.Value();
    if (!WrapObject(cx, parentObject, currentValue, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, someExternalInterface_id, temp, nullptr, nullptr, JSPROP_ENUMERATE)) {
      return false;
    }
  }

  if (mSomeInterface.WasPassed()) {
    JS::Value temp;
    OwningNonNull<mozilla::dom::TestInterface>& currentValue = mSomeInterface.Value();
    if (!WrapNewBindingObject(cx, parentObject, currentValue, &temp)) {
      MOZ_ASSERT(JS_IsExceptionPending(cx));
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, someInterface_id, temp, nullptr, nullptr, JSPROP_ENUMERATE)) {
      return false;
    }
  }

  return true;
}

bool Dict::initedIds = false;
jsid Dict::a_id = JSID_VOID;
jsid Dict::anotherObj_id = JSID_VOID;
jsid Dict::b_id = JSID_VOID;
jsid Dict::empty_id = JSID_VOID;
jsid Dict::otherEnum_id = JSID_VOID;
jsid Dict::otherStr_id = JSID_VOID;
jsid Dict::someCallback_id = JSID_VOID;
jsid Dict::someEnum_id = JSID_VOID;
jsid Dict::someObj_id = JSID_VOID;
jsid Dict::str_id = JSID_VOID;
jsid Dict::template_id = JSID_VOID;
jsid Dict::x_id = JSID_VOID;
jsid Dict::yetAnotherStr_id = JSID_VOID;
jsid Dict::z_id = JSID_VOID;

bool
Dict::InitIds(JSContext* cx)
{
  MOZ_ASSERT(!initedIds);
  if (!InternJSString(cx, a_id, "a") ||
      !InternJSString(cx, anotherObj_id, "anotherObj") ||
      !InternJSString(cx, b_id, "b") ||
      !InternJSString(cx, empty_id, "empty") ||
      !InternJSString(cx, otherEnum_id, "otherEnum") ||
      !InternJSString(cx, otherStr_id, "otherStr") ||
      !InternJSString(cx, someCallback_id, "someCallback") ||
      !InternJSString(cx, someEnum_id, "someEnum") ||
      !InternJSString(cx, someObj_id, "someObj") ||
      !InternJSString(cx, str_id, "str") ||
      !InternJSString(cx, template_id, "template") ||
      !InternJSString(cx, x_id, "x") ||
      !InternJSString(cx, yetAnotherStr_id, "yetAnotherStr") ||
      !InternJSString(cx, z_id, "z")) {
    return false;
  }
  initedIds = true;
  return true;
}

bool
Dict::Init(JSContext* cx, JSObject* scopeObj, const JS::Value& val)
{
  // Passing a null JSContext is OK only if we're initing from null,
  // Since in that case we will not have to do any property gets
  MOZ_ASSERT_IF(!cx, val.isNull());
  if (cx && !initedIds && !InitIds(cx)) {
    return false;
  }
  // Per spec, we init the parent's members first
  if (!ParentDict::Init(cx, scopeObj, val)) {
    return false;
  }
  JSBool found;
  JS::Value temp;
  bool isNull = val.isNullOrUndefined();
  if (!IsConvertibleToDictionary(cx, val)) {
    return ThrowErrorMessage(cx, MSG_NOT_DICTIONARY);
  }

  if (isNull) {
    found = false;
  } else if (!JS_HasPropertyById(cx, &val.toObject(), a_id, &found)) {
    return false;
  }
  if (found) {
    mA.Construct();
    if (!JS_GetPropertyById(cx, &val.toObject(), a_id, &temp)) {
      return false;
    }
    if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, &(mA.Value()))) {
      return false;
    }
  }

  if (isNull) {
    found = false;
  } else if (!JS_HasPropertyById(cx, &val.toObject(), anotherObj_id, &found)) {
    return false;
  }
  if (found) {
    if (!JS_GetPropertyById(cx, &val.toObject(), anotherObj_id, &temp)) {
      return false;
    }
  }
  if (found) {
    if (temp.isObject()) {
      if (cx) {
        mAnotherObj.construct(cx, &temp.toObject());
      }
    } else if (temp.isNullOrUndefined()) {
      if (cx) {
        mAnotherObj.construct(cx, (JSObject*) nullptr);
      };
    } else {
      ThrowErrorMessage(cx, MSG_NOT_OBJECT);
      return false;
    }
  } else {
    if (cx) {
      mAnotherObj.construct(cx, (JSObject*) nullptr);
    };
  }

  if (isNull) {
    found = false;
  } else if (!JS_HasPropertyById(cx, &val.toObject(), b_id, &found)) {
    return false;
  }
  if (found) {
    if (!JS_GetPropertyById(cx, &val.toObject(), b_id, &temp)) {
      return false;
    }
  }
  if (found) {
    if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, &mB)) {
      return false;
    }
  } else {
    mB = 8;
  }

  if (isNull) {
    found = false;
  } else if (!JS_HasPropertyById(cx, &val.toObject(), empty_id, &found)) {
    return false;
  }
  if (found) {
    if (!JS_GetPropertyById(cx, &val.toObject(), empty_id, &temp)) {
      return false;
    }
  }
  {
    FakeDependentString str;
    if (found) {
      if (!ConvertJSValueToString(cx, temp, &temp, eStringify, eStringify, str)) {
        return false;
      }
    } else {
      static const PRUnichar data[] = { 0 };
      str.SetData(data, ArrayLength(data) - 1);
    }
    mEmpty = str;
  }


  if (isNull) {
    found = false;
  } else if (!JS_HasPropertyById(cx, &val.toObject(), otherEnum_id, &found)) {
    return false;
  }
  if (found) {
    if (!JS_GetPropertyById(cx, &val.toObject(), otherEnum_id, &temp)) {
      return false;
    }
  }
  if (found) {
    {
      bool ok;
      int index = FindEnumStringIndex<true>(cx, temp, TestEnumValues::strings, "TestEnum", &ok);
      if (!ok) {
        return false;
      }
      MOZ_ASSERT(index >= 0);
      mOtherEnum = static_cast<TestEnum>(index);
    }
  } else {
    mOtherEnum = TestEnumValues::B;
  }

  if (isNull) {
    found = false;
  } else if (!JS_HasPropertyById(cx, &val.toObject(), otherStr_id, &found)) {
    return false;
  }
  if (found) {
    if (!JS_GetPropertyById(cx, &val.toObject(), otherStr_id, &temp)) {
      return false;
    }
  }
  {
    FakeDependentString str;
    if (found) {
      if (!ConvertJSValueToString(cx, temp, &temp, eStringify, eStringify, str)) {
        return false;
      }
    } else {
      static const PRUnichar data[] = { 'd', 'e', 'f', 0 };
      str.SetData(data, ArrayLength(data) - 1);
    }
    mOtherStr = str;
  }


  if (isNull) {
    found = false;
  } else if (!JS_HasPropertyById(cx, &val.toObject(), someCallback_id, &found)) {
    return false;
  }
  if (found) {
    if (!JS_GetPropertyById(cx, &val.toObject(), someCallback_id, &temp)) {
      return false;
    }
  }
  if (found) {
    if (temp.isObject()) {
      if (JS_ObjectIsCallable(cx, &temp.toObject())) {
        bool inited;
        mSomeCallback = new TestCallback(cx, scopeObj, &temp.toObject(), &inited);
        if (!inited) {
          return false;
        }
      } else {
        ThrowErrorMessage(cx, MSG_NOT_CALLABLE);
        return false;
      }
    } else if (temp.isNullOrUndefined()) {
      mSomeCallback = nullptr;
    } else {
      ThrowErrorMessage(cx, MSG_NOT_OBJECT);
      return false;
    }
  } else {
    mSomeCallback = nullptr;
  }

  if (isNull) {
    found = false;
  } else if (!JS_HasPropertyById(cx, &val.toObject(), someEnum_id, &found)) {
    return false;
  }
  if (found) {
    mSomeEnum.Construct();
    if (!JS_GetPropertyById(cx, &val.toObject(), someEnum_id, &temp)) {
      return false;
    }
    {
      bool ok;
      int index = FindEnumStringIndex<true>(cx, temp, TestEnumValues::strings, "TestEnum", &ok);
      if (!ok) {
        return false;
      }
      MOZ_ASSERT(index >= 0);
      (mSomeEnum.Value()) = static_cast<TestEnum>(index);
    }
  }

  if (isNull) {
    found = false;
  } else if (!JS_HasPropertyById(cx, &val.toObject(), someObj_id, &found)) {
    return false;
  }
  if (found) {
    mSomeObj.Construct();
    if (!JS_GetPropertyById(cx, &val.toObject(), someObj_id, &temp)) {
      return false;
    }
    if (temp.isObject()) {
      if (cx) {
        (mSomeObj.Value()).construct(cx, &temp.toObject());
      }
    } else {
      ThrowErrorMessage(cx, MSG_NOT_OBJECT);
      return false;
    }
  }

  if (isNull) {
    found = false;
  } else if (!JS_HasPropertyById(cx, &val.toObject(), str_id, &found)) {
    return false;
  }
  if (found) {
    mStr.Construct();
    if (!JS_GetPropertyById(cx, &val.toObject(), str_id, &temp)) {
      return false;
    }
    {
      FakeDependentString str;
      if (!ConvertJSValueToString(cx, temp, &temp, eStringify, eStringify, str)) {
        return false;
      }
      (mStr.Value()) = str;
    }

  }

  if (isNull) {
    found = false;
  } else if (!JS_HasPropertyById(cx, &val.toObject(), template_id, &found)) {
    return false;
  }
  if (found) {
    mTemplate.Construct();
    if (!JS_GetPropertyById(cx, &val.toObject(), template_id, &temp)) {
      return false;
    }
    {
      FakeDependentString str;
      if (!ConvertJSValueToString(cx, temp, &temp, eStringify, eStringify, str)) {
        return false;
      }
      (mTemplate.Value()) = str;
    }

  }

  if (isNull) {
    found = false;
  } else if (!JS_HasPropertyById(cx, &val.toObject(), x_id, &found)) {
    return false;
  }
  if (found) {
    mX.Construct();
    if (!JS_GetPropertyById(cx, &val.toObject(), x_id, &temp)) {
      return false;
    }
    if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, &(mX.Value()))) {
      return false;
    }
  }

  if (isNull) {
    found = false;
  } else if (!JS_HasPropertyById(cx, &val.toObject(), yetAnotherStr_id, &found)) {
    return false;
  }
  if (found) {
    if (!JS_GetPropertyById(cx, &val.toObject(), yetAnotherStr_id, &temp)) {
      return false;
    }
  }
  {
    FakeDependentString str;
    if (found) {
      if (!ConvertJSValueToString(cx, temp, &temp, eNull, eNull, str)) {
        return false;
      }
    } else {
      str.SetNull();
    }
    mYetAnotherStr = str;
  }


  if (isNull) {
    found = false;
  } else if (!JS_HasPropertyById(cx, &val.toObject(), z_id, &found)) {
    return false;
  }
  if (found) {
    if (!JS_GetPropertyById(cx, &val.toObject(), z_id, &temp)) {
      return false;
    }
  }
  if (found) {
    if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, &mZ)) {
      return false;
    }
  } else {
    mZ = 9;
  }
  return true;
}

bool
Dict::ToObject(JSContext* cx, JSObject* parentObject, JS::Value *vp)
{
  if (!initedIds && !InitIds(cx)) {
    return false;
  }
  // Per spec, we define the parent's members first
  if (!ParentDict::ToObject(cx, parentObject, vp)) {
    return false;
  }
  JSObject* obj = &vp->toObject();

  if (mA.WasPassed()) {
    JS::Value temp;
    int32_t& currentValue = mA.Value();
    temp = INT_TO_JSVAL(int32_t(currentValue));
    if (!JS_DefinePropertyById(cx, obj, a_id, temp, nullptr, nullptr, JSPROP_ENUMERATE)) {
      return false;
    }
  }

  {
    // scope for 'temp' and 'currentValue'
    JS::Value temp;
    LazyRootedObject& currentValue = mAnotherObj;
    temp = JS::ObjectOrNullValue(currentValue);
    if (!MaybeWrapValue(cx, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, anotherObj_id, temp, nullptr, nullptr, JSPROP_ENUMERATE)) {
      return false;
    }
  }

  {
    // scope for 'temp' and 'currentValue'
    JS::Value temp;
    int32_t& currentValue = mB;
    temp = INT_TO_JSVAL(int32_t(currentValue));
    if (!JS_DefinePropertyById(cx, obj, b_id, temp, nullptr, nullptr, JSPROP_ENUMERATE)) {
      return false;
    }
  }

  {
    // scope for 'temp' and 'currentValue'
    JS::Value temp;
    nsString& currentValue = mEmpty;
    if (!xpc::NonVoidStringToJsval(cx, currentValue, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, empty_id, temp, nullptr, nullptr, JSPROP_ENUMERATE)) {
      return false;
    }
  }

  {
    // scope for 'temp' and 'currentValue'
    JS::Value temp;
    TestEnum& currentValue = mOtherEnum;
    MOZ_ASSERT(uint32_t(currentValue) < ArrayLength(TestEnumValues::strings));
    JSString* currentValue_str = JS_NewStringCopyN(cx, TestEnumValues::strings[uint32_t(currentValue)].value, TestEnumValues::strings[uint32_t(currentValue)].length);
    if (!currentValue_str) {
    return false;
    }
    temp = JS::StringValue(currentValue_str);
    if (!JS_DefinePropertyById(cx, obj, otherEnum_id, temp, nullptr, nullptr, JSPROP_ENUMERATE)) {
      return false;
    }
  }

  {
    // scope for 'temp' and 'currentValue'
    JS::Value temp;
    nsString& currentValue = mOtherStr;
    if (!xpc::NonVoidStringToJsval(cx, currentValue, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, otherStr_id, temp, nullptr, nullptr, JSPROP_ENUMERATE)) {
      return false;
    }
  }

  {
    // scope for 'temp' and 'currentValue'
    JS::Value temp;
    nsRefPtr<TestCallback>& currentValue = mSomeCallback;
    if (currentValue) {
      temp = JS::ObjectValue(*currentValue->Callable());
      if (!MaybeWrapValue(cx, &temp)) {
        return false;
      }
      if (!JS_DefinePropertyById(cx, obj, someCallback_id, temp, nullptr, nullptr, JSPROP_ENUMERATE)) {
        return false;
      }
    } else {
      temp = JS::NullValue();
      if (!JS_DefinePropertyById(cx, obj, someCallback_id, temp, nullptr, nullptr, JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }

  if (mSomeEnum.WasPassed()) {
    JS::Value temp;
    TestEnum& currentValue = mSomeEnum.Value();
    MOZ_ASSERT(uint32_t(currentValue) < ArrayLength(TestEnumValues::strings));
    JSString* currentValue_str = JS_NewStringCopyN(cx, TestEnumValues::strings[uint32_t(currentValue)].value, TestEnumValues::strings[uint32_t(currentValue)].length);
    if (!currentValue_str) {
    return false;
    }
    temp = JS::StringValue(currentValue_str);
    if (!JS_DefinePropertyById(cx, obj, someEnum_id, temp, nullptr, nullptr, JSPROP_ENUMERATE)) {
      return false;
    }
  }

  if (mSomeObj.WasPassed()) {
    JS::Value temp;
    NonNullLazyRootedObject& currentValue = mSomeObj.Value();
    temp = JS::ObjectValue(currentValue);
    if (!MaybeWrapValue(cx, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, someObj_id, temp, nullptr, nullptr, JSPROP_ENUMERATE)) {
      return false;
    }
  }

  if (mStr.WasPassed()) {
    JS::Value temp;
    nsString& currentValue = mStr.Value();
    if (!xpc::NonVoidStringToJsval(cx, currentValue, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, str_id, temp, nullptr, nullptr, JSPROP_ENUMERATE)) {
      return false;
    }
  }

  if (mTemplate.WasPassed()) {
    JS::Value temp;
    nsString& currentValue = mTemplate.Value();
    if (!xpc::NonVoidStringToJsval(cx, currentValue, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, template_id, temp, nullptr, nullptr, JSPROP_ENUMERATE)) {
      return false;
    }
  }

  if (mX.WasPassed()) {
    JS::Value temp;
    int32_t& currentValue = mX.Value();
    temp = INT_TO_JSVAL(int32_t(currentValue));
    if (!JS_DefinePropertyById(cx, obj, x_id, temp, nullptr, nullptr, JSPROP_ENUMERATE)) {
      return false;
    }
  }

  {
    // scope for 'temp' and 'currentValue'
    JS::Value temp;
    nsString& currentValue = mYetAnotherStr;
    if (!xpc::StringToJsval(cx, currentValue, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, yetAnotherStr_id, temp, nullptr, nullptr, JSPROP_ENUMERATE)) {
      return false;
    }
  }

  {
    // scope for 'temp' and 'currentValue'
    JS::Value temp;
    int32_t& currentValue = mZ;
    temp = INT_TO_JSVAL(int32_t(currentValue));
    if (!JS_DefinePropertyById(cx, obj, z_id, temp, nullptr, nullptr, JSPROP_ENUMERATE)) {
      return false;
    }
  }

  return true;
}

bool DictContainingDict::initedIds = false;
jsid DictContainingDict::memberDict_id = JSID_VOID;

bool
DictContainingDict::InitIds(JSContext* cx)
{
  MOZ_ASSERT(!initedIds);
  if (!InternJSString(cx, memberDict_id, "memberDict")) {
    return false;
  }
  initedIds = true;
  return true;
}

bool
DictContainingDict::Init(JSContext* cx, JSObject* scopeObj, const JS::Value& val)
{
  // Passing a null JSContext is OK only if we're initing from null,
  // Since in that case we will not have to do any property gets
  MOZ_ASSERT_IF(!cx, val.isNull());
  if (cx && !initedIds && !InitIds(cx)) {
    return false;
  }
  JSBool found;
  JS::Value temp;
  bool isNull = val.isNullOrUndefined();
  if (!IsConvertibleToDictionary(cx, val)) {
    return ThrowErrorMessage(cx, MSG_NOT_DICTIONARY);
  }

  if (isNull) {
    found = false;
  } else if (!JS_HasPropertyById(cx, &val.toObject(), memberDict_id, &found)) {
    return false;
  }
  if (found) {
    if (!JS_GetPropertyById(cx, &val.toObject(), memberDict_id, &temp)) {
      return false;
    }
  }
  if (!mMemberDict.Init(cx, scopeObj, (found) ? temp : JSVAL_NULL)) {
    return false;
  }
  return true;
}

bool
DictContainingDict::ToObject(JSContext* cx, JSObject* parentObject, JS::Value *vp)
{
  if (!initedIds && !InitIds(cx)) {
    return false;
  }
  JSObject* obj = JS_NewObject(cx, nullptr, nullptr, nullptr);
  if (!obj) {
    return false;
  }
  *vp = JS::ObjectValue(*obj);

  {
    // scope for 'temp' and 'currentValue'
    JS::Value temp;
    Dict& currentValue = mMemberDict;
    if (!currentValue.ToObject(cx, parentObject, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, memberDict_id, temp, nullptr, nullptr, JSPROP_ENUMERATE)) {
      return false;
    }
  }

  return true;
}





void
TestCallback::Call(JSContext* cx, JSObject* aThisObj, ErrorResult& aRv)
{
  JS::Value rval = JSVAL_VOID;


  if (!JS_CallFunctionValue(cx, aThisObj, JS::ObjectValue(*mCallable),
                            0, nullptr, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }


}







void
TestTreatAsNullCallback::Call(JSContext* cx, JSObject* aThisObj, ErrorResult& aRv)
{
  JS::Value rval = JSVAL_VOID;


  if (!JS_CallFunctionValue(cx, aThisObj, JS::ObjectValue(*mCallable),
                            0, nullptr, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }


}







int32_t
TestIntegerReturn::Call(JSContext* cx, JSObject* aThisObj, ErrorResult& aRv)
{
  JS::Value rval = JSVAL_VOID;


  if (!JS_CallFunctionValue(cx, aThisObj, JS::ObjectValue(*mCallable),
                            0, nullptr, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return int32_t(0);
  }
  int32_t rvalDecl;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, rval, &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return int32_t(0);
  }
  return rvalDecl;
}







Nullable<int32_t>
TestNullableIntegerReturn::Call(JSContext* cx, JSObject* aThisObj, ErrorResult& aRv)
{
  JS::Value rval = JSVAL_VOID;


  if (!JS_CallFunctionValue(cx, aThisObj, JS::ObjectValue(*mCallable),
                            0, nullptr, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return Nullable<int32_t>();
  }
  const Nullable<int32_t> rvalDecl;
  if (rval.isNullOrUndefined()) {
    const_cast< Nullable<int32_t>& >(rvalDecl).SetNull();
  } else if (!ValueToPrimitive<int32_t, eDefault>(cx, rval, &const_cast< Nullable<int32_t>& >(rvalDecl).SetValue())) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return Nullable<int32_t>();
  }
  return rvalDecl;
}







bool
TestBooleanReturn::Call(JSContext* cx, JSObject* aThisObj, ErrorResult& aRv)
{
  JS::Value rval = JSVAL_VOID;


  if (!JS_CallFunctionValue(cx, aThisObj, JS::ObjectValue(*mCallable),
                            0, nullptr, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return bool(0);
  }
  bool rvalDecl;
  if (!ValueToPrimitive<bool, eDefault>(cx, rval, &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return bool(0);
  }
  return rvalDecl;
}







float
TestFloatReturn::Call(JSContext* cx, JSObject* aThisObj, ErrorResult& aRv)
{
  JS::Value rval = JSVAL_VOID;


  if (!JS_CallFunctionValue(cx, aThisObj, JS::ObjectValue(*mCallable),
                            0, nullptr, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return float(0);
  }
  float rvalDecl;
  if (!ValueToPrimitive<float, eDefault>(cx, rval, &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return float(0);
  } else if (!MOZ_DOUBLE_IS_FINITE(rvalDecl)) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    ThrowErrorMessage(cx, MSG_NOT_FINITE);
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return float(0);
  }
  return rvalDecl;
}







void
TestStringReturn::Call(JSContext* cx, JSObject* aThisObj, int32_t arg, nsString& retval, ErrorResult& aRv)
{
  JS::Value rval = JSVAL_VOID;
  JS::AutoValueVector argv(cx);
  if (!argv.resize(1)) {
    aRv.Throw(NS_ERROR_OUT_OF_MEMORY);
    return;
  }
  unsigned argc = 1;

  do {
    argv[0] = INT_TO_JSVAL(int32_t(arg));
    break;
  } while (0);

  if (!JS_CallFunctionValue(cx, aThisObj, JS::ObjectValue(*mCallable),
                            argc, argv.begin(), &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  FakeDependentString rvalHolder;
  const NonNull<nsAString> rvalDecl;
  if (!ConvertJSValueToString(cx, rval, &rval, eStringify, eStringify, rvalHolder)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  const_cast<NonNull<nsAString>&>(rvalDecl) = &rvalHolder;
  retval = rvalDecl;
}







TestEnum
TestEnumReturn::Call(JSContext* cx, JSObject* aThisObj, ErrorResult& aRv)
{
  JS::Value rval = JSVAL_VOID;


  if (!JS_CallFunctionValue(cx, aThisObj, JS::ObjectValue(*mCallable),
                            0, nullptr, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return TestEnum(0);
  }
  TestEnum rvalDecl;
  {
    bool ok;
    int index = FindEnumStringIndex<true>(cx, rval, TestEnumValues::strings, "TestEnum", &ok);
    if (!ok) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return TestEnum(0);
    }
    MOZ_ASSERT(index >= 0);
    rvalDecl = static_cast<TestEnum>(index);
  }
  return rvalDecl;
}







already_AddRefed<TestInterface>
TestInterfaceReturn::Call(JSContext* cx, JSObject* aThisObj, ErrorResult& aRv)
{
  JS::Value rval = JSVAL_VOID;


  if (!JS_CallFunctionValue(cx, aThisObj, JS::ObjectValue(*mCallable),
                            0, nullptr, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  NonNull<mozilla::dom::TestInterface> rvalDecl;
  if (rval.isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(cx, &rval.toObject(), rvalDecl);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestInterface");
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return nullptr;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  NS_ADDREF(rvalDecl.Ptr());
  return rvalDecl.Ptr();
}







already_AddRefed<TestInterface>
TestNullableInterfaceReturn::Call(JSContext* cx, JSObject* aThisObj, ErrorResult& aRv)
{
  JS::Value rval = JSVAL_VOID;


  if (!JS_CallFunctionValue(cx, aThisObj, JS::ObjectValue(*mCallable),
                            0, nullptr, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  mozilla::dom::TestInterface* rvalDecl;
  if (rval.isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(cx, &rval.toObject(), rvalDecl);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestInterface");
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return nullptr;
      }
    }
  } else if (rval.isNullOrUndefined()) {
    rvalDecl = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  NS_IF_ADDREF(rvalDecl);
  return rvalDecl;
}







already_AddRefed<TestExternalInterface>
TestExternalInterfaceReturn::Call(JSContext* cx, JSObject* aThisObj, ErrorResult& aRv)
{
  JS::Value rval = JSVAL_VOID;


  if (!JS_CallFunctionValue(cx, aThisObj, JS::ObjectValue(*mCallable),
                            0, nullptr, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  nsRefPtr<mozilla::dom::TestExternalInterface> rvalHolder;
  mozilla::dom::TestExternalInterface* rvalDecl;
  if (rval.isObject()) {
    jsval tmpVal = rval;
    mozilla::dom::TestExternalInterface* tmp;
    if (NS_FAILED(xpc_qsUnwrapArg<mozilla::dom::TestExternalInterface>(cx, rval, &tmp, static_cast<mozilla::dom::TestExternalInterface**>(getter_AddRefs(rvalHolder)), &tmpVal))) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestExternalInterface");aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    MOZ_ASSERT(tmp);
    if (tmpVal != rval && !rvalHolder) {
      // We have to have a strong ref, because we got this off
      // some random object that might get GCed
      rvalHolder = tmp;
    }
    rvalDecl = tmp;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  return rvalHolder.forget();
}







already_AddRefed<TestExternalInterface>
TestNullableExternalInterfaceReturn::Call(JSContext* cx, JSObject* aThisObj, ErrorResult& aRv)
{
  JS::Value rval = JSVAL_VOID;


  if (!JS_CallFunctionValue(cx, aThisObj, JS::ObjectValue(*mCallable),
                            0, nullptr, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  nsRefPtr<mozilla::dom::TestExternalInterface> rvalHolder;
  mozilla::dom::TestExternalInterface* rvalDecl;
  if (rval.isObject()) {
    jsval tmpVal = rval;
    mozilla::dom::TestExternalInterface* tmp;
    if (NS_FAILED(xpc_qsUnwrapArg<mozilla::dom::TestExternalInterface>(cx, rval, &tmp, static_cast<mozilla::dom::TestExternalInterface**>(getter_AddRefs(rvalHolder)), &tmpVal))) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestExternalInterface");aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    MOZ_ASSERT(tmp);
    if (tmpVal != rval && !rvalHolder) {
      // We have to have a strong ref, because we got this off
      // some random object that might get GCed
      rvalHolder = tmp;
    }
    rvalDecl = tmp;
  } else if (rval.isNullOrUndefined()) {
    rvalDecl = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  return rvalHolder.forget();
}







already_AddRefed<TestCallbackInterface>
TestCallbackInterfaceReturn::Call(JSContext* cx, JSObject* aThisObj, ErrorResult& aRv)
{
  JS::Value rval = JSVAL_VOID;


  if (!JS_CallFunctionValue(cx, aThisObj, JS::ObjectValue(*mCallable),
                            0, nullptr, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  OwningNonNull<mozilla::dom::TestCallbackInterface> rvalDecl;
  if (rval.isObject()) {
    if (!IsConvertibleToCallbackInterface(cx, &rval.toObject())) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestCallbackInterface");
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return nullptr;
    }

    nsresult rv;
    XPCCallContext ccx(JS_CALLER, cx);
    if (!ccx.IsValid()) {
      rv = NS_ERROR_XPC_BAD_CONVERT_JS;
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestCallbackInterface");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }

    const nsIID& iid = NS_GET_IID(mozilla::dom::TestCallbackInterface);
    nsRefPtr<nsXPCWrappedJS> wrappedJS;
    rv = nsXPCWrappedJS::GetNewOrUsed(ccx, &rval.toObject(), iid,
                                      NULL, getter_AddRefs(wrappedJS));
    if (NS_FAILED(rv) || !wrappedJS) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestCallbackInterface");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }

    // Use a temp nsCOMPtr for the null-check, because rvalDecl might be
    // OwningNonNull, not an nsCOMPtr.
    nsCOMPtr<mozilla::dom::TestCallbackInterface> tmp = do_QueryObject(wrappedJS.get());
    if (!tmp) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestCallbackInterface");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    rvalDecl = tmp.forget();
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  return rvalDecl.forget();
}







already_AddRefed<TestCallbackInterface>
TestNullableCallbackInterfaceReturn::Call(JSContext* cx, JSObject* aThisObj, ErrorResult& aRv)
{
  JS::Value rval = JSVAL_VOID;


  if (!JS_CallFunctionValue(cx, aThisObj, JS::ObjectValue(*mCallable),
                            0, nullptr, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  nsRefPtr<mozilla::dom::TestCallbackInterface> rvalDecl;
  if (rval.isObject()) {
    if (!IsConvertibleToCallbackInterface(cx, &rval.toObject())) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestCallbackInterface");
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return nullptr;
    }

    nsresult rv;
    XPCCallContext ccx(JS_CALLER, cx);
    if (!ccx.IsValid()) {
      rv = NS_ERROR_XPC_BAD_CONVERT_JS;
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestCallbackInterface");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }

    const nsIID& iid = NS_GET_IID(mozilla::dom::TestCallbackInterface);
    nsRefPtr<nsXPCWrappedJS> wrappedJS;
    rv = nsXPCWrappedJS::GetNewOrUsed(ccx, &rval.toObject(), iid,
                                      NULL, getter_AddRefs(wrappedJS));
    if (NS_FAILED(rv) || !wrappedJS) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestCallbackInterface");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }

    // Use a temp nsCOMPtr for the null-check, because rvalDecl might be
    // OwningNonNull, not an nsCOMPtr.
    nsCOMPtr<mozilla::dom::TestCallbackInterface> tmp = do_QueryObject(wrappedJS.get());
    if (!tmp) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestCallbackInterface");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    rvalDecl = tmp.forget();
  } else if (rval.isNullOrUndefined()) {
    rvalDecl = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  return rvalDecl.forget();
}







already_AddRefed<TestCallback>
TestCallbackReturn::Call(JSContext* cx, JSObject* aThisObj, ErrorResult& aRv)
{
  JS::Value rval = JSVAL_VOID;


  if (!JS_CallFunctionValue(cx, aThisObj, JS::ObjectValue(*mCallable),
                            0, nullptr, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  OwningNonNull<TestCallback> rvalDecl;
  if (rval.isObject()) {
    if (JS_ObjectIsCallable(cx, &rval.toObject())) {
      bool inited;
      rvalDecl = new TestCallback(cx, nullptr, &rval.toObject(), &inited);
      if (!inited) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return nullptr;
      }
    } else {
      ThrowErrorMessage(cx, MSG_NOT_CALLABLE);
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  return rvalDecl.forget();
}







already_AddRefed<TestCallback>
TestNullableCallbackReturn::Call(JSContext* cx, JSObject* aThisObj, ErrorResult& aRv)
{
  JS::Value rval = JSVAL_VOID;


  if (!JS_CallFunctionValue(cx, aThisObj, JS::ObjectValue(*mCallable),
                            0, nullptr, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  nsRefPtr<TestCallback> rvalDecl;
  if (rval.isObject()) {
    if (JS_ObjectIsCallable(cx, &rval.toObject())) {
      bool inited;
      rvalDecl = new TestCallback(cx, nullptr, &rval.toObject(), &inited);
      if (!inited) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return nullptr;
      }
    } else {
      ThrowErrorMessage(cx, MSG_NOT_CALLABLE);
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
  } else if (rval.isNullOrUndefined()) {
    rvalDecl = nullptr;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  return rvalDecl.forget();
}







JSObject*
TestObjectReturn::Call(JSContext* cx, JSObject* aThisObj, ErrorResult& aRv)
{
  JS::Value rval = JSVAL_VOID;


  if (!JS_CallFunctionValue(cx, aThisObj, JS::ObjectValue(*mCallable),
                            0, nullptr, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  NonNull<JSObject> rvalDecl;
  if (rval.isObject()) {
    rvalDecl = &rval.toObject();
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  return rvalDecl.Ptr();
}







JSObject*
TestNullableObjectReturn::Call(JSContext* cx, JSObject* aThisObj, ErrorResult& aRv)
{
  JS::Value rval = JSVAL_VOID;


  if (!JS_CallFunctionValue(cx, aThisObj, JS::ObjectValue(*mCallable),
                            0, nullptr, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  JSObject* rvalDecl;
  if (rval.isObject()) {
    rvalDecl = &rval.toObject();
  } else if (rval.isNullOrUndefined()) {
    rvalDecl = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  return rvalDecl;
}







JSObject*
TestTypedArrayReturn::Call(JSContext* cx, JSObject* aThisObj, ErrorResult& aRv)
{
  JS::Value rval = JSVAL_VOID;


  if (!JS_CallFunctionValue(cx, aThisObj, JS::ObjectValue(*mCallable),
                            0, nullptr, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  Maybe<ArrayBuffer> rvalHolder;
  NonNull<ArrayBuffer> rvalDecl;
  if (rval.isObject()) {
    rvalHolder.construct(&rval.toObject());
    if (!rvalHolder.ref().inited()) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "ArrayBuffer");aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    rvalDecl = rvalHolder.addr();
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  return static_cast<ArrayBuffer&>(rvalDecl).Obj();
}







JSObject*
TestNullableTypedArrayReturn::Call(JSContext* cx, JSObject* aThisObj, ErrorResult& aRv)
{
  JS::Value rval = JSVAL_VOID;


  if (!JS_CallFunctionValue(cx, aThisObj, JS::ObjectValue(*mCallable),
                            0, nullptr, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  Maybe<ArrayBuffer> rvalHolder;
  ArrayBuffer* rvalDecl;
  if (rval.isObject()) {
    rvalHolder.construct(&rval.toObject());
    if (!rvalHolder.ref().inited()) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "ArrayBuffer");aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    rvalDecl = rvalHolder.addr();
  } else if (rval.isNullOrUndefined()) {
    rvalDecl = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  return rvalDecl ? rvalDecl->Obj() : nullptr;
}







void
TestSequenceReturn::Call(JSContext* cx, JSObject* aThisObj, nsTArray< bool >& retval, ErrorResult& aRv)
{
  JS::Value rval = JSVAL_VOID;


  if (!JS_CallFunctionValue(cx, aThisObj, JS::ObjectValue(*mCallable),
                            0, nullptr, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  const Sequence< bool > rvalDecl;
  if (rval.isObject()) {
    JSObject* seq = &rval.toObject();

    if (!IsArrayLike(cx, seq)) {
      ThrowErrorMessage(cx, MSG_NOT_SEQUENCE);
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    uint32_t length;
    // JS_GetArrayLength actually works on all objects
    if (!JS_GetArrayLength(cx, seq, &length)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    Sequence< bool > &arr = const_cast< Sequence< bool >& >(rvalDecl);
    if (!arr.SetCapacity(length)) {
      JS_ReportOutOfMemory(cx);
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    for (uint32_t i = 0; i < length; ++i) {
      jsval temp;
      if (!JS_GetElement(cx, seq, i, &temp)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      bool& slot = *arr.AppendElement();
      if (!ValueToPrimitive<bool, eDefault>(cx, temp, &slot)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  retval = rvalDecl;
}







void
TestNullableSequenceReturn::Call(JSContext* cx, JSObject* aThisObj, Nullable< nsTArray< bool > >& retval, ErrorResult& aRv)
{
  JS::Value rval = JSVAL_VOID;


  if (!JS_CallFunctionValue(cx, aThisObj, JS::ObjectValue(*mCallable),
                            0, nullptr, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  const Nullable< Sequence< bool > > rvalDecl;
  if (rval.isObject()) {
    JSObject* seq = &rval.toObject();

    if (!IsArrayLike(cx, seq)) {
      ThrowErrorMessage(cx, MSG_NOT_SEQUENCE);
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    uint32_t length;
    // JS_GetArrayLength actually works on all objects
    if (!JS_GetArrayLength(cx, seq, &length)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    Sequence< bool > &arr = const_cast< Sequence< bool >& >(rvalDecl.Value());
    if (!arr.SetCapacity(length)) {
      JS_ReportOutOfMemory(cx);
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    for (uint32_t i = 0; i < length; ++i) {
      jsval temp;
      if (!JS_GetElement(cx, seq, i, &temp)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      bool& slot = *arr.AppendElement();
      if (!ValueToPrimitive<bool, eDefault>(cx, temp, &slot)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
    }
  } else if (rval.isNullOrUndefined()) {
    const_cast< Nullable< Sequence< bool > > & >(rvalDecl).SetNull();
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  if (rvalDecl.IsNull()) {
    retval.SetNull();
  } else {
    retval.SetValue() = rvalDecl.Value();
  }
}







void
TestIntegerArguments::Call(JSContext* cx, JSObject* aThisObj, int32_t arg1, const Nullable< int32_t >& arg2, const Sequence< int32_t >& arg3, const Nullable< Sequence< Nullable< int32_t > > >& arg4, nsTArray< int32_t >& retval, ErrorResult& aRv)
{
  JS::Value rval = JSVAL_VOID;
  JS::AutoValueVector argv(cx);
  if (!argv.resize(4)) {
    aRv.Throw(NS_ERROR_OUT_OF_MEMORY);
    return;
  }
  unsigned argc = 4;

  do {

    if (arg4.IsNull()) {
      argv[3] = JSVAL_NULL;
      break;
    }

    uint32_t length = arg4.Value().Length();
    JSObject *returnArray = JS_NewArrayObject(cx, length, NULL);
    if (!returnArray) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      jsval tmp;
      for (uint32_t i = 0; i < length; ++i) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          if (arg4.Value()[i].IsNull()) {
            tmp = JSVAL_NULL;
            break;
          }
          tmp = INT_TO_JSVAL(int32_t(arg4.Value()[i].Value()));
          break;
        } while (0);
        if (!JS_DefineElement(cx, returnArray, i, tmp,
                              nullptr, nullptr, JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[3] = JS::ObjectValue(*returnArray);
    break;
  } while (0);

  do {

    uint32_t length = arg3.Length();
    JSObject *returnArray = JS_NewArrayObject(cx, length, NULL);
    if (!returnArray) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      jsval tmp;
      for (uint32_t i = 0; i < length; ++i) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          tmp = INT_TO_JSVAL(int32_t(arg3[i]));
          break;
        } while (0);
        if (!JS_DefineElement(cx, returnArray, i, tmp,
                              nullptr, nullptr, JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[2] = JS::ObjectValue(*returnArray);
    break;
  } while (0);

  do {
    if (arg2.IsNull()) {
      argv[1] = JSVAL_NULL;
      break;
    }
    argv[1] = INT_TO_JSVAL(int32_t(arg2.Value()));
    break;
  } while (0);

  do {
    argv[0] = INT_TO_JSVAL(int32_t(arg1));
    break;
  } while (0);

  if (!JS_CallFunctionValue(cx, aThisObj, JS::ObjectValue(*mCallable),
                            argc, argv.begin(), &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  const Sequence< int32_t > rvalDecl;
  if (rval.isObject()) {
    JSObject* seq = &rval.toObject();

    if (!IsArrayLike(cx, seq)) {
      ThrowErrorMessage(cx, MSG_NOT_SEQUENCE);
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    uint32_t length;
    // JS_GetArrayLength actually works on all objects
    if (!JS_GetArrayLength(cx, seq, &length)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    Sequence< int32_t > &arr = const_cast< Sequence< int32_t >& >(rvalDecl);
    if (!arr.SetCapacity(length)) {
      JS_ReportOutOfMemory(cx);
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    for (uint32_t i = 0; i < length; ++i) {
      jsval temp;
      if (!JS_GetElement(cx, seq, i, &temp)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      int32_t& slot = *arr.AppendElement();
      if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, &slot)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  retval = rvalDecl;
}







void
TestInterfaceArguments::Call(JSContext* cx, JSObject* aThisObj, mozilla::dom::TestInterface& arg1, mozilla::dom::TestInterface* arg2, mozilla::dom::TestExternalInterface* arg3, mozilla::dom::TestExternalInterface* arg4, mozilla::dom::TestCallbackInterface& arg5, mozilla::dom::TestCallbackInterface* arg6, const Sequence< OwningNonNull<mozilla::dom::TestInterface> >& arg7, const Nullable< Sequence< nsRefPtr<mozilla::dom::TestInterface> > >& arg8, const Sequence< nsRefPtr<mozilla::dom::TestExternalInterface> >& arg9, const Nullable< Sequence< nsRefPtr<mozilla::dom::TestExternalInterface> > >& arg10, const Sequence< OwningNonNull<mozilla::dom::TestCallbackInterface> >& arg11, const Nullable< Sequence< nsRefPtr<mozilla::dom::TestCallbackInterface> > >& arg12, ErrorResult& aRv)
{
  JS::Value rval = JSVAL_VOID;
  JS::AutoValueVector argv(cx);
  if (!argv.resize(12)) {
    aRv.Throw(NS_ERROR_OUT_OF_MEMORY);
    return;
  }
  unsigned argc = 12;

  do {

    if (arg12.IsNull()) {
      argv[11] = JSVAL_NULL;
      break;
    }

    uint32_t length = arg12.Value().Length();
    JSObject *returnArray = JS_NewArrayObject(cx, length, NULL);
    if (!returnArray) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      jsval tmp;
      for (uint32_t i = 0; i < length; ++i) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          if (!arg12.Value()[i]) {
            tmp = JSVAL_NULL;
            break;
          }
          if (!WrapCallbackInterface(cx, returnArray, arg12.Value()[i], &tmp)) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
          break;
        } while (0);
        if (!JS_DefineElement(cx, returnArray, i, tmp,
                              nullptr, nullptr, JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[11] = JS::ObjectValue(*returnArray);
    break;
  } while (0);

  do {

    uint32_t length = arg11.Length();
    JSObject *returnArray = JS_NewArrayObject(cx, length, NULL);
    if (!returnArray) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      jsval tmp;
      for (uint32_t i = 0; i < length; ++i) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          if (!WrapCallbackInterface(cx, returnArray, arg11[i], &tmp)) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
          break;
        } while (0);
        if (!JS_DefineElement(cx, returnArray, i, tmp,
                              nullptr, nullptr, JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[10] = JS::ObjectValue(*returnArray);
    break;
  } while (0);

  do {

    if (arg10.IsNull()) {
      argv[9] = JSVAL_NULL;
      break;
    }

    uint32_t length = arg10.Value().Length();
    JSObject *returnArray = JS_NewArrayObject(cx, length, NULL);
    if (!returnArray) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      jsval tmp;
      for (uint32_t i = 0; i < length; ++i) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          if (!arg10.Value()[i]) {
            tmp = JSVAL_NULL;
            break;
          }
          if (!WrapObject(cx, returnArray, arg10.Value()[i], &tmp)) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
          break;
        } while (0);
        if (!JS_DefineElement(cx, returnArray, i, tmp,
                              nullptr, nullptr, JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[9] = JS::ObjectValue(*returnArray);
    break;
  } while (0);

  do {

    uint32_t length = arg9.Length();
    JSObject *returnArray = JS_NewArrayObject(cx, length, NULL);
    if (!returnArray) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      jsval tmp;
      for (uint32_t i = 0; i < length; ++i) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          if (!WrapObject(cx, returnArray, arg9[i], &tmp)) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
          break;
        } while (0);
        if (!JS_DefineElement(cx, returnArray, i, tmp,
                              nullptr, nullptr, JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[8] = JS::ObjectValue(*returnArray);
    break;
  } while (0);

  do {

    if (arg8.IsNull()) {
      argv[7] = JSVAL_NULL;
      break;
    }

    uint32_t length = arg8.Value().Length();
    JSObject *returnArray = JS_NewArrayObject(cx, length, NULL);
    if (!returnArray) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      jsval tmp;
      for (uint32_t i = 0; i < length; ++i) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          if (!arg8.Value()[i]) {
            tmp = JSVAL_NULL;
            break;
          }
          if (!WrapNewBindingObject(cx, returnArray, arg8.Value()[i], &tmp)) {
            MOZ_ASSERT(JS_IsExceptionPending(cx));
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
          break;
        } while (0);
        if (!JS_DefineElement(cx, returnArray, i, tmp,
                              nullptr, nullptr, JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[7] = JS::ObjectValue(*returnArray);
    break;
  } while (0);

  do {

    uint32_t length = arg7.Length();
    JSObject *returnArray = JS_NewArrayObject(cx, length, NULL);
    if (!returnArray) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      jsval tmp;
      for (uint32_t i = 0; i < length; ++i) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          if (!WrapNewBindingObject(cx, returnArray, arg7[i], &tmp)) {
            MOZ_ASSERT(JS_IsExceptionPending(cx));
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
          break;
        } while (0);
        if (!JS_DefineElement(cx, returnArray, i, tmp,
                              nullptr, nullptr, JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[6] = JS::ObjectValue(*returnArray);
    break;
  } while (0);

  do {
    if (!arg6) {
      argv[5] = JSVAL_NULL;
      break;
    }
    if (!WrapCallbackInterface(cx, mCallable, arg6, &argv[5])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (0);

  do {
    if (!WrapCallbackInterface(cx, mCallable, arg5, &argv[4])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (0);

  do {
    if (!arg4) {
      argv[3] = JSVAL_NULL;
      break;
    }
    if (!WrapObject(cx, mCallable, arg4, &argv[3])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (0);

  do {
    if (!WrapObject(cx, mCallable, arg3, &argv[2])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (0);

  do {
    if (!arg2) {
      argv[1] = JSVAL_NULL;
      break;
    }
    if (!WrapNewBindingObject(cx, mCallable, arg2, &argv[1])) {
      MOZ_ASSERT(JS_IsExceptionPending(cx));
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (0);

  do {
    if (!WrapNewBindingObject(cx, mCallable, arg1, &argv[0])) {
      MOZ_ASSERT(JS_IsExceptionPending(cx));
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (0);

  if (!JS_CallFunctionValue(cx, aThisObj, JS::ObjectValue(*mCallable),
                            argc, argv.begin(), &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }


}







void
TestStringEnumArguments::Call(JSContext* cx, JSObject* aThisObj, const nsAString& myString, const nsAString& nullString, TestEnum myEnum, ErrorResult& aRv)
{
  JS::Value rval = JSVAL_VOID;
  JS::AutoValueVector argv(cx);
  if (!argv.resize(3)) {
    aRv.Throw(NS_ERROR_OUT_OF_MEMORY);
    return;
  }
  unsigned argc = 3;

  do {
    MOZ_ASSERT(uint32_t(myEnum) < ArrayLength(TestEnumValues::strings));
    JSString* myEnum_str = JS_NewStringCopyN(cx, TestEnumValues::strings[uint32_t(myEnum)].value, TestEnumValues::strings[uint32_t(myEnum)].length);
    if (!myEnum_str) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
    }
    argv[2] = JS::StringValue(myEnum_str);
    break;
  } while (0);

  do {
    nsString mutableStr(nullString);
    if (!xpc::StringToJsval(cx, mutableStr, &argv[1])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (0);

  do {
    nsString mutableStr(myString);
    if (!xpc::NonVoidStringToJsval(cx, mutableStr, &argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (0);

  if (!JS_CallFunctionValue(cx, aThisObj, JS::ObjectValue(*mCallable),
                            argc, argv.begin(), &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }


}







void
TestObjectArguments::Call(JSContext* cx, JSObject* aThisObj, JSObject* anObj, JSObject* anotherObj, JSObject* buf, JSObject* buf2, ErrorResult& aRv)
{
  JS::Value rval = JSVAL_VOID;
  JS::AutoValueVector argv(cx);
  if (!argv.resize(4)) {
    aRv.Throw(NS_ERROR_OUT_OF_MEMORY);
    return;
  }
  unsigned argc = 4;

  do {
    argv[3] = JS::ObjectOrNullValue(buf2);
    if (!MaybeWrapValue(cx, &argv[3])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (0);

  do {
    argv[2] = JS::ObjectValue(*buf);
    if (!MaybeWrapValue(cx, &argv[2])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (0);

  do {
    argv[1] = JS::ObjectOrNullValue(anotherObj);
    if (!MaybeWrapValue(cx, &argv[1])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (0);

  do {
    argv[0] = JS::ObjectValue(*anObj);
    if (!MaybeWrapValue(cx, &argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (0);

  if (!JS_CallFunctionValue(cx, aThisObj, JS::ObjectValue(*mCallable),
                            argc, argv.begin(), &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }


}







void
TestOptionalArguments::Call(JSContext* cx, JSObject* aThisObj, const Optional< nsAString >& aString, const Optional< JSObject* >& something, const Optional< Sequence< OwningNonNull<mozilla::dom::TestInterface> > >& aSeq, const Optional< mozilla::dom::TestInterface* >& anInterface, const Optional< NonNull<mozilla::dom::TestInterface> >& anotherInterface, const Optional< int32_t >& aLong, ErrorResult& aRv)
{
  JS::Value rval = JSVAL_VOID;
  JS::AutoValueVector argv(cx);
  if (!argv.resize(6)) {
    aRv.Throw(NS_ERROR_OUT_OF_MEMORY);
    return;
  }
  unsigned argc = 6;

  do {
    if (aLong.WasPassed()) {
      argv[5] = INT_TO_JSVAL(int32_t(aLong.Value()));
      break;
    } else if (argc == 6) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[5] = JS::UndefinedValue();
    }
  } while (0);

  do {
    if (anotherInterface.WasPassed()) {
      if (!WrapNewBindingObject(cx, mCallable, anotherInterface.Value(), &argv[4])) {
        MOZ_ASSERT(JS_IsExceptionPending(cx));
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      break;
    } else if (argc == 5) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[4] = JS::UndefinedValue();
    }
  } while (0);

  do {
    if (anInterface.WasPassed()) {
      if (!anInterface.Value()) {
        argv[3] = JSVAL_NULL;
        break;
      }
      if (!WrapNewBindingObject(cx, mCallable, anInterface.Value(), &argv[3])) {
        MOZ_ASSERT(JS_IsExceptionPending(cx));
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      break;
    } else if (argc == 4) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[3] = JS::UndefinedValue();
    }
  } while (0);

  do {
    if (aSeq.WasPassed()) {

      uint32_t length = aSeq.Value().Length();
      JSObject *returnArray = JS_NewArrayObject(cx, length, NULL);
      if (!returnArray) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      // Scope for 'tmp'
      {
        jsval tmp;
        for (uint32_t i = 0; i < length; ++i) {
          // Control block to let us common up the JS_DefineElement calls when there
          // are different ways to succeed at wrapping the object.
          do {
            if (!WrapNewBindingObject(cx, returnArray, aSeq.Value()[i], &tmp)) {
              MOZ_ASSERT(JS_IsExceptionPending(cx));
              aRv.Throw(NS_ERROR_UNEXPECTED);
              return;
            }
            break;
          } while (0);
          if (!JS_DefineElement(cx, returnArray, i, tmp,
                                nullptr, nullptr, JSPROP_ENUMERATE)) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
        }
      }
      argv[2] = JS::ObjectValue(*returnArray);
      break;
    } else if (argc == 3) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[2] = JS::UndefinedValue();
    }
  } while (0);

  do {
    if (something.WasPassed()) {
      argv[1] = JS::ObjectValue(*something.Value());
      if (!MaybeWrapValue(cx, &argv[1])) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      break;
    } else if (argc == 2) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[1] = JS::UndefinedValue();
    }
  } while (0);

  do {
    if (aString.WasPassed()) {
      nsString mutableStr(aString.Value());
      if (!xpc::NonVoidStringToJsval(cx, mutableStr, &argv[0])) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      break;
    } else if (argc == 1) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[0] = JS::UndefinedValue();
    }
  } while (0);

  if (!JS_CallFunctionValue(cx, aThisObj, JS::ObjectValue(*mCallable),
                            argc, argv.begin(), &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }


}



namespace OnlyForUseInConstructorBinding {

static JSBool
_addProperty(JSContext* cx, JSHandleObject obj, JSHandleId id, JSMutableHandleValue vp)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::dom::OnlyForUseInConstructor>::value), "Must be an nsISupports class");
  mozilla::dom::OnlyForUseInConstructor* self = UnwrapDOMObject<mozilla::dom::OnlyForUseInConstructor>(obj);
  nsContentUtils::PreserveWrapper(reinterpret_cast<nsISupports*>(self), self);
  return true;
}

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::dom::OnlyForUseInConstructor>::value), "Must be an nsISupports class");
  mozilla::dom::OnlyForUseInConstructor* self = UnwrapDOMObject<mozilla::dom::OnlyForUseInConstructor>(obj);
  if (self) {
    ClearWrapper(self, self);
    XPCJSRuntime *rt = nsXPConnect::GetRuntimeInstance();
    if (rt) {
      rt->DeferredRelease(reinterpret_cast<nsISupports*>(self));
    } else {
      NS_RELEASE(self);
    }
  }
}

static JSFunctionSpec sChromeMethods_specs[] = {
  JS_FNINFO("QueryInterface", QueryInterface, nullptr, 1, 0),
  JS_FS_END
};

static Prefable<JSFunctionSpec> sChromeMethods[] = {
  { true, &sChromeMethods_specs[0] },
  { false, NULL }
};

static jsid sChromeMethods_ids[2] = { JSID_VOID };


static const NativeProperties sChromeOnlyNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sChromeMethods, sChromeMethods_ids, sChromeMethods_specs,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr
};
const NativePropertyHooks sNativePropertyHooks = {
  nullptr,
  nullptr,
  { nullptr, &sChromeOnlyNativeProperties },
  prototypes::id::OnlyForUseInConstructor,
  constructors::id::OnlyForUseInConstructor,
  NULL
};

JSNativeHolder _constructor_holder = {
  ThrowingConstructor,
  &sNativePropertyHooks
};

static DOMIfaceAndProtoJSClass PrototypeClass = {
  {
    "OnlyForUseInConstructorPrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(2),
    JS_PropertyStub,       /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    nullptr,               /* finalize */
    nullptr,               /* checkAccess */
    nullptr,               /* call */
    nullptr,               /* hasInstance */
    nullptr,               /* construct */
    nullptr,               /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  eInterfacePrototype,
  &sNativePropertyHooks
};

void
CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray)
{
  JSObject* parentProto = JS_GetObjectPrototype(aCx, aGlobal);
  if (!parentProto) {
    return;
  }


  if (sChromeMethods_ids[0] == JSID_VOID &&
      !InitIds(aCx, sChromeMethods, sChromeMethods_ids)) {
    sChromeMethods_ids[0] = JSID_VOID;
    return;
  }

  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &PrototypeClass.mBase, &protoAndIfaceArray[prototypes::id::OnlyForUseInConstructor],
                              nullptr, &_constructor_holder, 0, &protoAndIfaceArray[constructors::id::OnlyForUseInConstructor],
                              &Class.mClass,
                              nullptr,
                              xpc::AccessCheck::isChrome(aGlobal) ? &sChromeOnlyNativeProperties : nullptr,
                              "OnlyForUseInConstructor");
}

JSObject*
DefineDOMInterface(JSContext* aCx, JSObject* aGlobal, bool* aEnabled)
{

  *aEnabled = true;
  return GetConstructorObject(aCx, aGlobal);
}


DOMJSClass Class = {
  { "OnlyForUseInConstructor",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(3),
    _addProperty, /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    _finalize, /* finalize */
    NULL,                  /* checkAccess */
    NULL,                  /* call */
    NULL,                  /* hasInstance */
    NULL,                  /* construct */
    NULL, /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  {
    { prototypes::id::OnlyForUseInConstructor, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
    true,
    &sNativePropertyHooks,
    GetParentObject<mozilla::dom::OnlyForUseInConstructor>::Get,
    GetProtoObject,
    nullptr
  }
};

JSObject*
Wrap(JSContext* aCx, JSObject* aScope, mozilla::dom::OnlyForUseInConstructor* aObject, nsWrapperCache* aCache, bool* aTriedToWrap)
{
  MOZ_ASSERT(static_cast<mozilla::dom::OnlyForUseInConstructor*>(aObject) ==
             reinterpret_cast<mozilla::dom::OnlyForUseInConstructor*>(aObject));

  *aTriedToWrap = true;

  JSObject* parent = WrapNativeParent(aCx, aScope, aObject->GetParentObject());
  if (!parent) {
    return NULL;
  }

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.  Scope so we don't
  // collide with the "obj" we declare in CreateBindingJSObject.
  {
    JSObject* obj = aCache->GetWrapper();
    if (obj) {
      return obj;
    }
  }

  JSAutoCompartment ac(aCx, parent);
  JSObject* global = JS_GetGlobalForObject(aCx, parent);

  JSObject* proto = GetProtoObject(aCx, global);
  if (!proto) {
    return NULL;
  }

  JSObject* obj = JS_NewObject(aCx, &Class.mBase, proto, parent);
  if (!obj) {
    return NULL;
  }

  js::SetReservedSlot(obj, DOM_OBJECT_SLOT, PRIVATE_TO_JSVAL(aObject));
  NS_ADDREF(aObject);


  aCache->SetWrapper(obj);

  return obj;
}

} // namespace OnlyForUseInConstructorBinding



namespace TestChildInterfaceBinding {

static bool
get_unforgeableAttr(JSContext* cx, JSHandleObject obj, mozilla::dom::TestChildInterface* self, JS::Value* vp)
{
  int32_t result;
  result = self->UnforgeableAttr();
  *vp = INT_TO_JSVAL(int32_t(result));
  return true;
}


const JSJitInfo unforgeableAttr_getterinfo = {
  (JSJitPropertyOp)get_unforgeableAttr,
  prototypes::id::TestChildInterface,
  PrototypeTraits<prototypes::id::TestChildInterface>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_unforgeableAttr2(JSContext* cx, JSHandleObject obj, mozilla::dom::TestChildInterface* self, JS::Value* vp)
{
  int32_t result;
  result = self->UnforgeableAttr2();
  *vp = INT_TO_JSVAL(int32_t(result));
  return true;
}


const JSJitInfo unforgeableAttr2_getterinfo = {
  (JSJitPropertyOp)get_unforgeableAttr2,
  prototypes::id::TestChildInterface,
  PrototypeTraits<prototypes::id::TestChildInterface>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

static JSBool
genericGetter(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  mozilla::dom::TestChildInterface* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::TestChildInterface, mozilla::dom::TestChildInterface>(cx, obj, self);
    if (NS_FAILED(rv)) {
      return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestChildInterface");
    }
  }
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Getter);
  JSJitPropertyOp getter = info->op;
  return getter(cx, obj, self, vp);
}

static JSBool
_addProperty(JSContext* cx, JSHandleObject obj, JSHandleId id, JSMutableHandleValue vp)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::dom::TestChildInterface>::value), "Must be an nsISupports class");
  mozilla::dom::TestChildInterface* self = UnwrapDOMObject<mozilla::dom::TestChildInterface>(obj);
  nsContentUtils::PreserveWrapper(reinterpret_cast<nsISupports*>(self), self);
  return true;
}

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::dom::TestChildInterface>::value), "Must be an nsISupports class");
  mozilla::dom::TestChildInterface* self = UnwrapDOMObject<mozilla::dom::TestChildInterface>(obj);
  if (self) {
    ClearWrapper(self, self);
    XPCJSRuntime *rt = nsXPConnect::GetRuntimeInstance();
    if (rt) {
      rt->DeferredRelease(reinterpret_cast<nsISupports*>(self));
    } else {
      NS_RELEASE(self);
    }
  }
}

static JSPropertySpec sUnforgeableAttributes_specs[] = {
  { "unforgeableAttr", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS | JSPROP_PERMANENT, { (JSPropertyOp)genericGetter, &unforgeableAttr_getterinfo }, JSOP_NULLWRAPPER},
  { 0, 0, 0, JSOP_NULLWRAPPER, JSOP_NULLWRAPPER }
};

static Prefable<JSPropertySpec> sUnforgeableAttributes[] = {
  { true, &sUnforgeableAttributes_specs[0] },
  { false, NULL }
};

static jsid sUnforgeableAttributes_ids[2] = { JSID_VOID };

static JSPropertySpec sChromeUnforgeableAttributes_specs[] = {
  { "unforgeableAttr2", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS | JSPROP_PERMANENT, { (JSPropertyOp)genericGetter, &unforgeableAttr2_getterinfo }, JSOP_NULLWRAPPER},
  { 0, 0, 0, JSOP_NULLWRAPPER, JSOP_NULLWRAPPER }
};

static Prefable<JSPropertySpec> sChromeUnforgeableAttributes[] = {
  { true, &sChromeUnforgeableAttributes_specs[0] },
  { false, NULL }
};

static jsid sChromeUnforgeableAttributes_ids[2] = { JSID_VOID };


static const NativeProperties sNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sUnforgeableAttributes, sUnforgeableAttributes_ids, sUnforgeableAttributes_specs,
  nullptr, nullptr, nullptr
};

static const NativeProperties sChromeOnlyNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sChromeUnforgeableAttributes, sChromeUnforgeableAttributes_ids, sChromeUnforgeableAttributes_specs,
  nullptr, nullptr, nullptr
};
const NativePropertyHooks sNativePropertyHooks = {
  nullptr,
  nullptr,
  { &sNativeProperties, &sChromeOnlyNativeProperties },
  prototypes::id::TestChildInterface,
  constructors::id::TestChildInterface,
  &TestInterfaceBinding::sNativePropertyHooks
};

JSNativeHolder _constructor_holder = {
  ThrowingConstructor,
  &sNativePropertyHooks
};

static DOMIfaceAndProtoJSClass PrototypeClass = {
  {
    "TestChildInterfacePrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(2),
    JS_PropertyStub,       /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    nullptr,               /* finalize */
    nullptr,               /* checkAccess */
    nullptr,               /* call */
    nullptr,               /* hasInstance */
    nullptr,               /* construct */
    nullptr,               /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  eInterfacePrototype,
  &sNativePropertyHooks
};

void
CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray)
{
  JSObject* parentProto = TestInterfaceBinding::GetProtoObject(aCx, aGlobal);
  if (!parentProto) {
    return;
  }


  if (sChromeUnforgeableAttributes_ids[0] == JSID_VOID &&
      (!InitIds(aCx, sChromeUnforgeableAttributes, sChromeUnforgeableAttributes_ids) ||
       !InitIds(aCx, sUnforgeableAttributes, sUnforgeableAttributes_ids))) {
    sChromeUnforgeableAttributes_ids[0] = JSID_VOID;
    return;
  }

  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &PrototypeClass.mBase, &protoAndIfaceArray[prototypes::id::TestChildInterface],
                              nullptr, &_constructor_holder, 0, &protoAndIfaceArray[constructors::id::TestChildInterface],
                              &Class.mClass,
                              &sNativeProperties,
                              xpc::AccessCheck::isChrome(aGlobal) ? &sChromeOnlyNativeProperties : nullptr,
                              "TestChildInterface");
}

JSObject*
DefineDOMInterface(JSContext* aCx, JSObject* aGlobal, bool* aEnabled)
{

  *aEnabled = true;
  return GetConstructorObject(aCx, aGlobal);
}


DOMJSClass Class = {
  { "TestChildInterface",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(3),
    _addProperty, /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    _finalize, /* finalize */
    NULL,                  /* checkAccess */
    NULL,                  /* call */
    NULL,                  /* hasInstance */
    NULL,                  /* construct */
    NULL, /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  {
    { prototypes::id::TestInterface, prototypes::id::TestChildInterface, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
    true,
    &sNativePropertyHooks,
    GetParentObject<mozilla::dom::TestChildInterface>::Get,
    GetProtoObject,
    nullptr
  }
};

JSObject*
Wrap(JSContext* aCx, JSObject* aScope, mozilla::dom::TestChildInterface* aObject, nsWrapperCache* aCache, bool* aTriedToWrap)
{
  MOZ_ASSERT(static_cast<mozilla::dom::TestChildInterface*>(aObject) ==
             reinterpret_cast<mozilla::dom::TestChildInterface*>(aObject));
  MOZ_ASSERT(static_cast<mozilla::dom::TestInterface*>(aObject) ==
             reinterpret_cast<mozilla::dom::TestInterface*>(aObject));

  *aTriedToWrap = true;

  JSObject* parent = WrapNativeParent(aCx, aScope, aObject->GetParentObject());
  if (!parent) {
    return NULL;
  }

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.  Scope so we don't
  // collide with the "obj" we declare in CreateBindingJSObject.
  {
    JSObject* obj = aCache->GetWrapper();
    if (obj) {
      return obj;
    }
  }

  JSAutoCompartment ac(aCx, parent);
  JSObject* global = JS_GetGlobalForObject(aCx, parent);

  JSObject* proto = GetProtoObject(aCx, global);
  if (!proto) {
    return NULL;
  }

  JSObject* obj = JS_NewObject(aCx, &Class.mBase, proto, parent);
  if (!obj) {
    return NULL;
  }

  js::SetReservedSlot(obj, DOM_OBJECT_SLOT, PRIVATE_TO_JSVAL(aObject));
  NS_ADDREF(aObject);


  // Important: do unforgeable property setup after we have handed
  // over ownership of the C++ object to obj as needed, so that if
  // we fail and it ends up GCed it won't have problems in the
  // finalizer trying to drop its ownership of the C++ object.
  if (!DefineUnforgeableAttributes(aCx, obj, sUnforgeableAttributes)) {
    return nullptr;
  }
  if (xpc::AccessCheck::isChrome(global)) {
    if (!DefineUnforgeableAttributes(aCx, obj, sChromeUnforgeableAttributes)) {
      return nullptr;
    }
  }

  aCache->SetWrapper(obj);

  return obj;
}

} // namespace TestChildInterfaceBinding



namespace TestCppKeywordNamedMethodsInterfaceBinding {

static bool
_continue(JSContext* cx, JSHandleObject obj, mozilla::dom::TestCppKeywordNamedMethodsInterface* self, unsigned argc, JS::Value* vp)
{
  bool result;
  result = self->Continue();
  *vp = BOOLEAN_TO_JSVAL(result);
  return true;
}


const JSJitInfo continue_methodinfo = {
  (JSJitPropertyOp)_continue,
  prototypes::id::TestCppKeywordNamedMethodsInterface,
  PrototypeTraits<prototypes::id::TestCppKeywordNamedMethodsInterface>::Depth,
  JSJitInfo::Method,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

static bool
_delete(JSContext* cx, JSHandleObject obj, mozilla::dom::TestCppKeywordNamedMethodsInterface* self, unsigned argc, JS::Value* vp)
{
  bool result;
  result = self->Delete();
  *vp = BOOLEAN_TO_JSVAL(result);
  return true;
}


const JSJitInfo delete_methodinfo = {
  (JSJitPropertyOp)_delete,
  prototypes::id::TestCppKeywordNamedMethodsInterface,
  PrototypeTraits<prototypes::id::TestCppKeywordNamedMethodsInterface>::Depth,
  JSJitInfo::Method,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

static bool
_volatile(JSContext* cx, JSHandleObject obj, mozilla::dom::TestCppKeywordNamedMethodsInterface* self, unsigned argc, JS::Value* vp)
{
  int32_t result;
  result = self->Volatile();
  *vp = INT_TO_JSVAL(int32_t(result));
  return true;
}


const JSJitInfo volatile_methodinfo = {
  (JSJitPropertyOp)_volatile,
  prototypes::id::TestCppKeywordNamedMethodsInterface,
  PrototypeTraits<prototypes::id::TestCppKeywordNamedMethodsInterface>::Depth,
  JSJitInfo::Method,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

static JSBool
genericMethod(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  mozilla::dom::TestCppKeywordNamedMethodsInterface* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::TestCppKeywordNamedMethodsInterface, mozilla::dom::TestCppKeywordNamedMethodsInterface>(cx, obj, self);
    if (NS_FAILED(rv)) {
      return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestCppKeywordNamedMethodsInterface");
    }
  }
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Method);
  JSJitMethodOp method = (JSJitMethodOp)info->op;
  return method(cx, obj, self, argc, vp);
}

static JSBool
_addProperty(JSContext* cx, JSHandleObject obj, JSHandleId id, JSMutableHandleValue vp)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::dom::TestCppKeywordNamedMethodsInterface>::value), "Must be an nsISupports class");
  mozilla::dom::TestCppKeywordNamedMethodsInterface* self = UnwrapDOMObject<mozilla::dom::TestCppKeywordNamedMethodsInterface>(obj);
  nsContentUtils::PreserveWrapper(reinterpret_cast<nsISupports*>(self), self);
  return true;
}

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::dom::TestCppKeywordNamedMethodsInterface>::value), "Must be an nsISupports class");
  mozilla::dom::TestCppKeywordNamedMethodsInterface* self = UnwrapDOMObject<mozilla::dom::TestCppKeywordNamedMethodsInterface>(obj);
  if (self) {
    ClearWrapper(self, self);
    XPCJSRuntime *rt = nsXPConnect::GetRuntimeInstance();
    if (rt) {
      rt->DeferredRelease(reinterpret_cast<nsISupports*>(self));
    } else {
      NS_RELEASE(self);
    }
  }
}

static JSFunctionSpec sMethods_specs[] = {
  JS_FNINFO("continue", genericMethod, &continue_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("delete", genericMethod, &delete_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("volatile", genericMethod, &volatile_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FS_END
};

static Prefable<JSFunctionSpec> sMethods[] = {
  { true, &sMethods_specs[0] },
  { false, NULL }
};

static jsid sMethods_ids[4] = { JSID_VOID };

static JSFunctionSpec sChromeMethods_specs[] = {
  JS_FNINFO("QueryInterface", QueryInterface, nullptr, 1, 0),
  JS_FS_END
};

static Prefable<JSFunctionSpec> sChromeMethods[] = {
  { true, &sChromeMethods_specs[0] },
  { false, NULL }
};

static jsid sChromeMethods_ids[2] = { JSID_VOID };


static const NativeProperties sNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sMethods, sMethods_ids, sMethods_specs,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr
};

static const NativeProperties sChromeOnlyNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sChromeMethods, sChromeMethods_ids, sChromeMethods_specs,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr
};
const NativePropertyHooks sNativePropertyHooks = {
  nullptr,
  nullptr,
  { &sNativeProperties, &sChromeOnlyNativeProperties },
  prototypes::id::TestCppKeywordNamedMethodsInterface,
  constructors::id::TestCppKeywordNamedMethodsInterface,
  NULL
};

JSNativeHolder _constructor_holder = {
  ThrowingConstructor,
  &sNativePropertyHooks
};

static DOMIfaceAndProtoJSClass PrototypeClass = {
  {
    "TestCppKeywordNamedMethodsInterfacePrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(2),
    JS_PropertyStub,       /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    nullptr,               /* finalize */
    nullptr,               /* checkAccess */
    nullptr,               /* call */
    nullptr,               /* hasInstance */
    nullptr,               /* construct */
    nullptr,               /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  eInterfacePrototype,
  &sNativePropertyHooks
};

void
CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray)
{
  JSObject* parentProto = JS_GetObjectPrototype(aCx, aGlobal);
  if (!parentProto) {
    return;
  }


  if (sChromeMethods_ids[0] == JSID_VOID &&
      (!InitIds(aCx, sChromeMethods, sChromeMethods_ids) ||
       !InitIds(aCx, sMethods, sMethods_ids))) {
    sChromeMethods_ids[0] = JSID_VOID;
    return;
  }

  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &PrototypeClass.mBase, &protoAndIfaceArray[prototypes::id::TestCppKeywordNamedMethodsInterface],
                              nullptr, &_constructor_holder, 0, &protoAndIfaceArray[constructors::id::TestCppKeywordNamedMethodsInterface],
                              &Class.mClass,
                              &sNativeProperties,
                              xpc::AccessCheck::isChrome(aGlobal) ? &sChromeOnlyNativeProperties : nullptr,
                              "TestCppKeywordNamedMethodsInterface");
}

JSObject*
DefineDOMInterface(JSContext* aCx, JSObject* aGlobal, bool* aEnabled)
{

  *aEnabled = true;
  return GetConstructorObject(aCx, aGlobal);
}


DOMJSClass Class = {
  { "TestCppKeywordNamedMethodsInterface",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(3),
    _addProperty, /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    _finalize, /* finalize */
    NULL,                  /* checkAccess */
    NULL,                  /* call */
    NULL,                  /* hasInstance */
    NULL,                  /* construct */
    NULL, /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  {
    { prototypes::id::TestCppKeywordNamedMethodsInterface, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
    true,
    &sNativePropertyHooks,
    GetParentObject<mozilla::dom::TestCppKeywordNamedMethodsInterface>::Get,
    GetProtoObject,
    nullptr
  }
};

JSObject*
Wrap(JSContext* aCx, JSObject* aScope, mozilla::dom::TestCppKeywordNamedMethodsInterface* aObject, nsWrapperCache* aCache, bool* aTriedToWrap)
{
  MOZ_ASSERT(static_cast<mozilla::dom::TestCppKeywordNamedMethodsInterface*>(aObject) ==
             reinterpret_cast<mozilla::dom::TestCppKeywordNamedMethodsInterface*>(aObject));

  *aTriedToWrap = true;

  JSObject* parent = WrapNativeParent(aCx, aScope, aObject->GetParentObject());
  if (!parent) {
    return NULL;
  }

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.  Scope so we don't
  // collide with the "obj" we declare in CreateBindingJSObject.
  {
    JSObject* obj = aCache->GetWrapper();
    if (obj) {
      return obj;
    }
  }

  JSAutoCompartment ac(aCx, parent);
  JSObject* global = JS_GetGlobalForObject(aCx, parent);

  JSObject* proto = GetProtoObject(aCx, global);
  if (!proto) {
    return NULL;
  }

  JSObject* obj = JS_NewObject(aCx, &Class.mBase, proto, parent);
  if (!obj) {
    return NULL;
  }

  js::SetReservedSlot(obj, DOM_OBJECT_SLOT, PRIVATE_TO_JSVAL(aObject));
  NS_ADDREF(aObject);


  aCache->SetWrapper(obj);

  return obj;
}

} // namespace TestCppKeywordNamedMethodsInterfaceBinding



namespace TestIndexedAndNamedDeleterInterfaceBinding {

static bool
delNamedItem(JSContext* cx, JSHandleObject obj, mozilla::dom::TestIndexedAndNamedDeleterInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestIndexedAndNamedDeleterInterface.delNamedItem");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eStringify, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  self->DelNamedItem(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo delNamedItem_methodinfo = {
  (JSJitPropertyOp)delNamedItem,
  prototypes::id::TestIndexedAndNamedDeleterInterface,
  PrototypeTraits<prototypes::id::TestIndexedAndNamedDeleterInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static JSBool
genericMethod(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  mozilla::dom::TestIndexedAndNamedDeleterInterface* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::TestIndexedAndNamedDeleterInterface, mozilla::dom::TestIndexedAndNamedDeleterInterface>(cx, obj, self);
    if (NS_FAILED(rv)) {
      return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestIndexedAndNamedDeleterInterface");
    }
  }
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Method);
  JSJitMethodOp method = (JSJitMethodOp)info->op;
  return method(cx, obj, self, argc, vp);
}

static JSFunctionSpec sMethods_specs[] = {
  JS_FNINFO("delNamedItem", genericMethod, &delNamedItem_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FS_END
};

static Prefable<JSFunctionSpec> sMethods[] = {
  { true, &sMethods_specs[0] },
  { false, NULL }
};

static jsid sMethods_ids[2] = { JSID_VOID };

static JSFunctionSpec sChromeMethods_specs[] = {
  JS_FNINFO("QueryInterface", QueryInterface, nullptr, 1, 0),
  JS_FS_END
};

static Prefable<JSFunctionSpec> sChromeMethods[] = {
  { true, &sChromeMethods_specs[0] },
  { false, NULL }
};

static jsid sChromeMethods_ids[2] = { JSID_VOID };


static const NativeProperties sNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sMethods, sMethods_ids, sMethods_specs,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr
};

static const NativeProperties sChromeOnlyNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sChromeMethods, sChromeMethods_ids, sChromeMethods_specs,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr
};
const NativePropertyHooks sNativePropertyHooks = {
  ResolveOwnProperty,
  EnumerateOwnProperties,
  { &sNativeProperties, &sChromeOnlyNativeProperties },
  prototypes::id::TestIndexedAndNamedDeleterInterface,
  constructors::id::TestIndexedAndNamedDeleterInterface,
  NULL
};

JSNativeHolder _constructor_holder = {
  ThrowingConstructor,
  &sNativePropertyHooks
};

static DOMIfaceAndProtoJSClass PrototypeClass = {
  {
    "TestIndexedAndNamedDeleterInterfacePrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(2),
    JS_PropertyStub,       /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    nullptr,               /* finalize */
    nullptr,               /* checkAccess */
    nullptr,               /* call */
    nullptr,               /* hasInstance */
    nullptr,               /* construct */
    nullptr,               /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  eInterfacePrototype,
  &sNativePropertyHooks
};

void
CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray)
{
  JSObject* parentProto = JS_GetObjectPrototype(aCx, aGlobal);
  if (!parentProto) {
    return;
  }


  if (sChromeMethods_ids[0] == JSID_VOID &&
      (!InitIds(aCx, sChromeMethods, sChromeMethods_ids) ||
       !InitIds(aCx, sMethods, sMethods_ids))) {
    sChromeMethods_ids[0] = JSID_VOID;
    return;
  }

  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &PrototypeClass.mBase, &protoAndIfaceArray[prototypes::id::TestIndexedAndNamedDeleterInterface],
                              nullptr, &_constructor_holder, 0, &protoAndIfaceArray[constructors::id::TestIndexedAndNamedDeleterInterface],
                              &Class,
                              &sNativeProperties,
                              xpc::AccessCheck::isChrome(aGlobal) ? &sChromeOnlyNativeProperties : nullptr,
                              "TestIndexedAndNamedDeleterInterface");
}

bool
ResolveOwnProperty(JSContext* cx, JSObject* wrapper, JSObject* obj, jsid id, JSPropertyDescriptor* desc, unsigned flags)
{
  // We rely on getOwnPropertyDescriptor not shadowing prototype properties by named
  // properties. If that changes we'll need to filter here.
  return js::GetProxyHandler(obj)->getOwnPropertyDescriptor(cx, wrapper, id, desc, flags);

}

bool
EnumerateOwnProperties(JSContext* cx, JSObject* wrapper, JSObject* obj, JS::AutoIdVector& props)
{
  // We rely on getOwnPropertyNames not shadowing prototype properties by named
  // properties. If that changes we'll need to filter here.
  return js::GetProxyHandler(obj)->getOwnPropertyNames(cx, wrapper, props);

}

JSObject*
DefineDOMInterface(JSContext* aCx, JSObject* aGlobal, bool* aEnabled)
{

  *aEnabled = true;
  return GetConstructorObject(aCx, aGlobal);
}

MOZ_ALWAYS_INLINE bool
IsProxy(JSObject* obj)
{
  return js::IsProxy(obj) && js::GetProxyHandler(obj) == DOMProxyHandler::getInstance();
}

MOZ_ALWAYS_INLINE mozilla::dom::TestIndexedAndNamedDeleterInterface*
UnwrapProxy(JSObject* obj)
{
  if (xpc::WrapperFactory::IsXrayWrapper(obj)) {
    obj = js::UnwrapObject(obj);
  }
  MOZ_ASSERT(IsProxy(obj));
  return static_cast<mozilla::dom::TestIndexedAndNamedDeleterInterface*>(js::GetProxyPrivate(obj).toPrivate());
}


const DOMClass Class = {
  { prototypes::id::TestIndexedAndNamedDeleterInterface, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
  true,
  &sNativePropertyHooks,
  GetParentObject<mozilla::dom::TestIndexedAndNamedDeleterInterface>::Get,
  GetProtoObject,
  nullptr
};



DOMProxyHandler::DOMProxyHandler()
  : mozilla::dom::DOMProxyHandler(Class)
{

}


bool
DOMProxyHandler::getOwnPropertyDescriptor(JSContext* cx, JSObject* proxy, jsid id, JSPropertyDescriptor* desc, unsigned flags)
{
  int32_t index = GetArrayIndexFromId(cx, id);
  if (!(flags & JSRESOLVE_ASSIGNING)) {
    if (IsArrayIndex(index)) {
      mozilla::dom::TestIndexedAndNamedDeleterInterface* self = UnwrapProxy(proxy);
      bool found;
      int32_t result;
      result = self->IndexedGetter(index, found);

      if (found) {
        desc->value = INT_TO_JSVAL(int32_t(result));
        FillPropertyDescriptor(desc, proxy, true);
        return true;
      }
    }
  }

  JSObject* expando;
  if (!xpc::WrapperFactory::IsXrayWrapper(proxy) && (expando = GetExpandoObject(proxy))) {
    if (!JS_GetPropertyDescriptorById(cx, expando, id, flags, desc)) {
      return false;
    }
    if (desc->obj) {
      // Pretend the property lives on the wrapper.
      desc->obj = proxy;
      return true;
    }
  }

  if (!IsArrayIndex(index) && !(flags & JSRESOLVE_ASSIGNING) && !HasPropertyOnPrototype(cx, proxy, this, id)) {
    JS::Value nameVal = js::IdToValue(id);
    FakeDependentString name;
    if (!ConvertJSValueToString(cx, nameVal, &nameVal,
                                eStringify, eStringify, name)) {
      return false;
    }

    mozilla::dom::TestIndexedAndNamedDeleterInterface* self = UnwrapProxy(proxy);
    bool found;
    int32_t result;
    result = self->NamedGetter(name, found);

    if (found) {
      desc->value = INT_TO_JSVAL(int32_t(result));
      FillPropertyDescriptor(desc, proxy, true);
      return true;
    }
  }

  desc->obj = NULL;
  return true;
}


bool
DOMProxyHandler::getOwnPropertyNames(JSContext* cx, JSObject* proxy, JS::AutoIdVector& props)
{
  uint32_t length = UnwrapProxy(proxy)->Length();
  MOZ_ASSERT(int32_t(length) >= 0);
  for (int32_t i = 0; i < int32_t(length); ++i) {
    if (!props.append(INT_TO_JSID(i))) {
      return false;
    }
  }

  nsTArray<nsString> names;
  UnwrapProxy(proxy)->GetSupportedNames(names);
  if (!AppendNamedPropertyIds(cx, proxy, names, props)) {
    return false;
  }

  JSObject* expando;
  if (!xpc::WrapperFactory::IsXrayWrapper(proxy) && (expando = DOMProxyHandler::GetExpandoObject(proxy)) &&
      !js::GetPropertyNames(cx, expando, JSITER_OWNONLY | JSITER_HIDDEN, &props)) {
    return false;
  }

  return true;
}


bool
DOMProxyHandler::hasOwn(JSContext* cx, JSObject* proxy, jsid id, bool* bp)
{
  int32_t index = GetArrayIndexFromId(cx, id);
  if (IsArrayIndex(index)) {
    mozilla::dom::TestIndexedAndNamedDeleterInterface* self = UnwrapProxy(proxy);
    bool found;
    int32_t result;
    result = self->IndexedGetter(index, found);
    (void)result;

    *bp = found;
    return true;
  }

  JSObject* expando = GetExpandoObject(proxy);
  if (expando) {
    JSBool b = true;
    JSBool ok = JS_HasPropertyById(cx, expando, id, &b);
    *bp = !!b;
    if (!ok || *bp) {
      return ok;
    }
  }

  if (!HasPropertyOnPrototype(cx, proxy, this, id)) {
    JS::Value nameVal = js::IdToValue(id);
    FakeDependentString name;
    if (!ConvertJSValueToString(cx, nameVal, &nameVal,
                                eStringify, eStringify, name)) {
      return false;
    }

    mozilla::dom::TestIndexedAndNamedDeleterInterface* self = UnwrapProxy(proxy);
    bool found;
    int32_t result;
    result = self->NamedGetter(name, found);
    (void)result;

    *bp = found;
    return true;
  }

  *bp = false;
  return true;
}


bool
DOMProxyHandler::get(JSContext* cx, JSObject* proxy, JSObject* receiver, jsid id, JS::Value* vp)
{
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
              "Should not have a XrayWrapper here");

  int32_t index = GetArrayIndexFromId(cx, id);
  if (IsArrayIndex(index)) {
    mozilla::dom::TestIndexedAndNamedDeleterInterface* self = UnwrapProxy(proxy);
    bool found;
    int32_t result;
    result = self->IndexedGetter(index, found);

    if (found) {
      *vp = INT_TO_JSVAL(int32_t(result));
      return true;
    }
    // Even if we don't have this index, we don't forward the
    // get on to our expando object.
  } else {
    JSObject* expando = DOMProxyHandler::GetExpandoObject(proxy);
    if (expando) {
      JSBool hasProp;
      if (!JS_HasPropertyById(cx, expando, id, &hasProp)) {
        return false;
      }

      if (hasProp) {
        return JS_GetPropertyById(cx, expando, id, vp);
      }
    }
  }

  {  // Scope for this "found" so it doesn't leak to things below
    bool found;
    if (!GetPropertyOnPrototype(cx, proxy, id, &found, vp)) {
      return false;
    }

    if (found) {
      return true;
    }
  }
  if (!IsArrayIndex(index)) {
    JS::Value nameVal = js::IdToValue(id);
    FakeDependentString name;
    if (!ConvertJSValueToString(cx, nameVal, &nameVal,
                                eStringify, eStringify, name)) {
      return false;
    }

    mozilla::dom::TestIndexedAndNamedDeleterInterface* self = UnwrapProxy(proxy);
    bool found;
    int32_t result;
    result = self->NamedGetter(name, found);

    if (found) {
      *vp = INT_TO_JSVAL(int32_t(result));
      return true;
    }
  }

  vp->setUndefined();
  return true;
}


JSString*
DOMProxyHandler::obj_toString(JSContext* cx, JSObject* proxy)
{
  return mozilla::dom::DOMProxyHandler::obj_toString(cx, "TestIndexedAndNamedDeleterInterface");
}


void
DOMProxyHandler::finalize(JSFreeOp* fop, JSObject* proxy)
{
  mozilla::dom::TestIndexedAndNamedDeleterInterface* self = UnwrapProxy(proxy);

  if (self) {
    ClearWrapper(self, self);
    XPCJSRuntime *rt = nsXPConnect::GetRuntimeInstance();
    if (rt) {
      rt->DeferredRelease(reinterpret_cast<nsISupports*>(self));
    } else {
      NS_RELEASE(self);
    }
  }
}


bool
DOMProxyHandler::getElementIfPresent(JSContext* cx, JSObject* proxy, JSObject* receiver, uint32_t index, JS::Value* vp, bool* present)
{
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
               "Should not have a XrayWrapper here");

  mozilla::dom::TestIndexedAndNamedDeleterInterface* self = UnwrapProxy(proxy);
  bool found;
  int32_t result;
  result = self->IndexedGetter(index, found);

  if (found) {
    *vp = INT_TO_JSVAL(int32_t(result));
    *present = found;
    return true;
  }
  // We skip the expando object and any named getters if
  // there is an indexed getter.


  JSObject *proto;
  if (!js::GetObjectProto(cx, proxy, &proto)) {
    return false;
  }
  if (proto) {
    JSBool isPresent;
    if (!JS_GetElementIfPresent(cx, proto, index, proxy, vp, &isPresent)) {
      return false;
    }
    *present = isPresent;
    return true;
  }

  *present = false;
  // Can't Debug_SetValueRangeToCrashOnTouch because it's not public
  return true;
}


DOMProxyHandler*
DOMProxyHandler::getInstance()
{
  static DOMProxyHandler instance;
  return &instance;
}


bool
DOMProxyHandler::delete_(JSContext* cx, JSObject* proxy, jsid id, bool* bp)
{
  int32_t index = GetArrayIndexFromId(cx, id);
  if (IsArrayIndex(index)) {
    mozilla::dom::TestIndexedAndNamedDeleterInterface* self = UnwrapProxy(proxy);
    bool found;
    self->IndexedDeleter(index, found);
    *bp = true;
    // We always return here, even if the property was not found
    return true;
  }
  if (!HasPropertyOnPrototype(cx, proxy, this, id)) {
    JS::Value nameVal = js::IdToValue(id);
    FakeDependentString name;
    if (!ConvertJSValueToString(cx, nameVal, &nameVal,
                                eStringify, eStringify, name)) {
      return false;
    }

    mozilla::dom::TestIndexedAndNamedDeleterInterface* self = UnwrapProxy(proxy);
    bool found;
    self->NamedDeleter(name, found);
    *bp = true;
    if (found) {
      return true;
    }
  }
  return dom::DOMProxyHandler::delete_(cx, proxy, id, bp);
}


bool
Is(JSObject* obj)
{
  return IsProxy(obj);
}

JSObject*
Wrap(JSContext* aCx, JSObject* aScope, mozilla::dom::TestIndexedAndNamedDeleterInterface* aObject, nsWrapperCache* aCache, bool* aTriedToWrap)
{
  MOZ_ASSERT(static_cast<mozilla::dom::TestIndexedAndNamedDeleterInterface*>(aObject) ==
             reinterpret_cast<mozilla::dom::TestIndexedAndNamedDeleterInterface*>(aObject));

  *aTriedToWrap = true;

  JSObject* parent = WrapNativeParent(aCx, aScope, aObject->GetParentObject());
  if (!parent) {
    return NULL;
  }

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.  Scope so we don't
  // collide with the "obj" we declare in CreateBindingJSObject.
  {
    JSObject* obj = aCache->GetWrapper();
    if (obj) {
      return obj;
    }
  }

  JSAutoCompartment ac(aCx, parent);
  JSObject* global = JS_GetGlobalForObject(aCx, parent);

  JSObject* proto = GetProtoObject(aCx, global);
  if (!proto) {
    return NULL;
  }

  JSObject *obj = NewProxyObject(aCx, DOMProxyHandler::getInstance(),
                                 JS::PrivateValue(aObject), proto, parent);
  if (!obj) {
    return NULL;
  }

  NS_ADDREF(aObject);


  aCache->SetWrapper(obj);

  return obj;
}

} // namespace TestIndexedAndNamedDeleterInterfaceBinding



namespace TestIndexedAndNamedGetterAndSetterInterfaceBinding {

static bool
item(JSContext* cx, JSHandleObject obj, mozilla::dom::TestIndexedAndNamedGetterAndSetterInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestIndexedAndNamedGetterAndSetterInterface.item");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  int32_t result;
  result = self->Item(arg0);
  *vp = INT_TO_JSVAL(int32_t(result));
  return true;
}


const JSJitInfo item_methodinfo = {
  (JSJitPropertyOp)item,
  prototypes::id::TestIndexedAndNamedGetterAndSetterInterface,
  PrototypeTraits<prototypes::id::TestIndexedAndNamedGetterAndSetterInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

static bool
namedItem(JSContext* cx, JSHandleObject obj, mozilla::dom::TestIndexedAndNamedGetterAndSetterInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestIndexedAndNamedGetterAndSetterInterface.namedItem");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eStringify, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  nsString result;
  self->NamedItem(arg0, result);
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}


const JSJitInfo namedItem_methodinfo = {
  (JSJitPropertyOp)namedItem,
  prototypes::id::TestIndexedAndNamedGetterAndSetterInterface,
  PrototypeTraits<prototypes::id::TestIndexedAndNamedGetterAndSetterInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

static bool
__stringifier(JSContext* cx, JSHandleObject obj, mozilla::dom::TestIndexedAndNamedGetterAndSetterInterface* self, unsigned argc, JS::Value* vp)
{
  nsString result;
  self->Stringify(result);
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}


const JSJitInfo __stringifier_methodinfo = {
  (JSJitPropertyOp)__stringifier,
  prototypes::id::TestIndexedAndNamedGetterAndSetterInterface,
  PrototypeTraits<prototypes::id::TestIndexedAndNamedGetterAndSetterInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_length(JSContext* cx, JSHandleObject obj, mozilla::dom::TestIndexedAndNamedGetterAndSetterInterface* self, JS::Value* vp)
{
  uint32_t result;
  result = self->Length();
  *vp = UINT_TO_JSVAL(result);
  return true;
}


const JSJitInfo length_getterinfo = {
  (JSJitPropertyOp)get_length,
  prototypes::id::TestIndexedAndNamedGetterAndSetterInterface,
  PrototypeTraits<prototypes::id::TestIndexedAndNamedGetterAndSetterInterface>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

static JSBool
genericMethod(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  mozilla::dom::TestIndexedAndNamedGetterAndSetterInterface* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::TestIndexedAndNamedGetterAndSetterInterface, mozilla::dom::TestIndexedAndNamedGetterAndSetterInterface>(cx, obj, self);
    if (NS_FAILED(rv)) {
      return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestIndexedAndNamedGetterAndSetterInterface");
    }
  }
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Method);
  JSJitMethodOp method = (JSJitMethodOp)info->op;
  return method(cx, obj, self, argc, vp);
}

static JSBool
genericGetter(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  mozilla::dom::TestIndexedAndNamedGetterAndSetterInterface* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::TestIndexedAndNamedGetterAndSetterInterface, mozilla::dom::TestIndexedAndNamedGetterAndSetterInterface>(cx, obj, self);
    if (NS_FAILED(rv)) {
      return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestIndexedAndNamedGetterAndSetterInterface");
    }
  }
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Getter);
  JSJitPropertyOp getter = info->op;
  return getter(cx, obj, self, vp);
}

static JSFunctionSpec sMethods_specs[] = {
  JS_FNINFO("item", genericMethod, &item_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("namedItem", genericMethod, &namedItem_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("iterator", JS_ArrayIterator, nullptr, 0, JSPROP_ENUMERATE),
  JS_FNINFO("toString", genericMethod, &__stringifier_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FS_END
};

static Prefable<JSFunctionSpec> sMethods[] = {
  { true, &sMethods_specs[0] },
  { false, NULL }
};

static jsid sMethods_ids[5] = { JSID_VOID };

static JSPropertySpec sAttributes_specs[] = {
  { "length", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &length_getterinfo }, JSOP_NULLWRAPPER},
  { 0, 0, 0, JSOP_NULLWRAPPER, JSOP_NULLWRAPPER }
};

static Prefable<JSPropertySpec> sAttributes[] = {
  { true, &sAttributes_specs[0] },
  { false, NULL }
};

static jsid sAttributes_ids[2] = { JSID_VOID };


static const NativeProperties sNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sMethods, sMethods_ids, sMethods_specs,
  sAttributes, sAttributes_ids, sAttributes_specs,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr
};
const NativePropertyHooks sNativePropertyHooks = {
  ResolveOwnProperty,
  EnumerateOwnProperties,
  { &sNativeProperties, nullptr },
  prototypes::id::TestIndexedAndNamedGetterAndSetterInterface,
  constructors::id::TestIndexedAndNamedGetterAndSetterInterface,
  &TestIndexedSetterInterfaceBinding::sNativePropertyHooks
};

JSNativeHolder _constructor_holder = {
  ThrowingConstructor,
  &sNativePropertyHooks
};

static DOMIfaceAndProtoJSClass PrototypeClass = {
  {
    "TestIndexedAndNamedGetterAndSetterInterfacePrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(2),
    JS_PropertyStub,       /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    nullptr,               /* finalize */
    nullptr,               /* checkAccess */
    nullptr,               /* call */
    nullptr,               /* hasInstance */
    nullptr,               /* construct */
    nullptr,               /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  eInterfacePrototype,
  &sNativePropertyHooks
};

void
CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray)
{
  JSObject* parentProto = TestIndexedSetterInterfaceBinding::GetProtoObject(aCx, aGlobal);
  if (!parentProto) {
    return;
  }


  if (sMethods_ids[0] == JSID_VOID &&
      (!InitIds(aCx, sMethods, sMethods_ids) ||
       !InitIds(aCx, sAttributes, sAttributes_ids))) {
    sMethods_ids[0] = JSID_VOID;
    return;
  }

  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &PrototypeClass.mBase, &protoAndIfaceArray[prototypes::id::TestIndexedAndNamedGetterAndSetterInterface],
                              nullptr, &_constructor_holder, 0, &protoAndIfaceArray[constructors::id::TestIndexedAndNamedGetterAndSetterInterface],
                              &Class,
                              &sNativeProperties,
                              nullptr,
                              "TestIndexedAndNamedGetterAndSetterInterface");
}

bool
ResolveOwnProperty(JSContext* cx, JSObject* wrapper, JSObject* obj, jsid id, JSPropertyDescriptor* desc, unsigned flags)
{
  // We rely on getOwnPropertyDescriptor not shadowing prototype properties by named
  // properties. If that changes we'll need to filter here.
  return js::GetProxyHandler(obj)->getOwnPropertyDescriptor(cx, wrapper, id, desc, flags);

}

bool
EnumerateOwnProperties(JSContext* cx, JSObject* wrapper, JSObject* obj, JS::AutoIdVector& props)
{
  // We rely on getOwnPropertyNames not shadowing prototype properties by named
  // properties. If that changes we'll need to filter here.
  return js::GetProxyHandler(obj)->getOwnPropertyNames(cx, wrapper, props);

}

JSObject*
DefineDOMInterface(JSContext* aCx, JSObject* aGlobal, bool* aEnabled)
{

  *aEnabled = true;
  return GetConstructorObject(aCx, aGlobal);
}

MOZ_ALWAYS_INLINE bool
IsProxy(JSObject* obj)
{
  return js::IsProxy(obj) && js::GetProxyHandler(obj) == DOMProxyHandler::getInstance();
}

MOZ_ALWAYS_INLINE mozilla::dom::TestIndexedAndNamedGetterAndSetterInterface*
UnwrapProxy(JSObject* obj)
{
  if (xpc::WrapperFactory::IsXrayWrapper(obj)) {
    obj = js::UnwrapObject(obj);
  }
  MOZ_ASSERT(IsProxy(obj));
  return static_cast<mozilla::dom::TestIndexedAndNamedGetterAndSetterInterface*>(js::GetProxyPrivate(obj).toPrivate());
}


const DOMClass Class = {
  { prototypes::id::TestIndexedSetterInterface, prototypes::id::TestIndexedAndNamedGetterAndSetterInterface, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
  true,
  &sNativePropertyHooks,
  GetParentObject<mozilla::dom::TestIndexedAndNamedGetterAndSetterInterface>::Get,
  GetProtoObject,
  nullptr
};



DOMProxyHandler::DOMProxyHandler()
  : mozilla::dom::DOMProxyHandler(Class)
{

}


bool
DOMProxyHandler::getOwnPropertyDescriptor(JSContext* cx, JSObject* proxy, jsid id, JSPropertyDescriptor* desc, unsigned flags)
{
  int32_t index = GetArrayIndexFromId(cx, id);
  if (flags & JSRESOLVE_ASSIGNING) {
    if (IsArrayIndex(index)) {
      FillPropertyDescriptor(desc, proxy, JSVAL_VOID, false);
      return true;
    }
    FillPropertyDescriptor(desc, proxy, JSVAL_VOID, false);
    return true;
  } else {
    if (IsArrayIndex(index)) {
      mozilla::dom::TestIndexedAndNamedGetterAndSetterInterface* self = UnwrapProxy(proxy);
      bool found;
      int32_t result;
      result = self->IndexedGetter(index, found);

      if (found) {
        desc->value = INT_TO_JSVAL(int32_t(result));
        FillPropertyDescriptor(desc, proxy, false);
        return true;
      }
    }
  }

  JSObject* expando;
  if (!xpc::WrapperFactory::IsXrayWrapper(proxy) && (expando = GetExpandoObject(proxy))) {
    if (!JS_GetPropertyDescriptorById(cx, expando, id, flags, desc)) {
      return false;
    }
    if (desc->obj) {
      // Pretend the property lives on the wrapper.
      desc->obj = proxy;
      return true;
    }
  }

  if (!IsArrayIndex(index) && !(flags & JSRESOLVE_ASSIGNING) && !HasPropertyOnPrototype(cx, proxy, this, id)) {
    JS::Value nameVal = js::IdToValue(id);
    FakeDependentString name;
    if (!ConvertJSValueToString(cx, nameVal, &nameVal,
                                eStringify, eStringify, name)) {
      return false;
    }

    mozilla::dom::TestIndexedAndNamedGetterAndSetterInterface* self = UnwrapProxy(proxy);
    bool found;
    nsString result;
    self->NamedGetter(name, found, result);

    if (found) {
      if (!xpc::NonVoidStringToJsval(cx, result, &desc->value)) {
        return false;
      }
      FillPropertyDescriptor(desc, proxy, false);
      return true;
    }
  }

  desc->obj = NULL;
  return true;
}


bool
DOMProxyHandler::defineProperty(JSContext* cx, JSObject* proxy, jsid id, JSPropertyDescriptor* desc)
{
  int32_t index = GetArrayIndexFromId(cx, id);
  if (IsArrayIndex(index)) {
    mozilla::dom::TestIndexedAndNamedGetterAndSetterInterface* self = UnwrapProxy(proxy);
    int32_t item;
    if (!ValueToPrimitive<int32_t, eDefault>(cx, desc->value, &item)) {
      return false;
    }
    self->IndexedSetter(index, item);
    return true;
  }
  JS::Value nameVal = js::IdToValue(id);
  FakeDependentString name;
  if (!ConvertJSValueToString(cx, nameVal, &nameVal,
                              eStringify, eStringify, name)) {
    return false;
  }

  mozilla::dom::TestIndexedAndNamedGetterAndSetterInterface* self = UnwrapProxy(proxy);
  FakeDependentString item_holder;
  const NonNull<nsAString> item;
  if (!ConvertJSValueToString(cx, desc->value, &desc->value, eStringify, eStringify, item_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(item) = &item_holder;
  self->NamedSetter(name, item);

  return true;

}


bool
DOMProxyHandler::getOwnPropertyNames(JSContext* cx, JSObject* proxy, JS::AutoIdVector& props)
{
  uint32_t length = UnwrapProxy(proxy)->Length();
  MOZ_ASSERT(int32_t(length) >= 0);
  for (int32_t i = 0; i < int32_t(length); ++i) {
    if (!props.append(INT_TO_JSID(i))) {
      return false;
    }
  }

  nsTArray<nsString> names;
  UnwrapProxy(proxy)->GetSupportedNames(names);
  if (!AppendNamedPropertyIds(cx, proxy, names, props)) {
    return false;
  }

  JSObject* expando;
  if (!xpc::WrapperFactory::IsXrayWrapper(proxy) && (expando = DOMProxyHandler::GetExpandoObject(proxy)) &&
      !js::GetPropertyNames(cx, expando, JSITER_OWNONLY | JSITER_HIDDEN, &props)) {
    return false;
  }

  return true;
}


bool
DOMProxyHandler::hasOwn(JSContext* cx, JSObject* proxy, jsid id, bool* bp)
{
  int32_t index = GetArrayIndexFromId(cx, id);
  if (IsArrayIndex(index)) {
    mozilla::dom::TestIndexedAndNamedGetterAndSetterInterface* self = UnwrapProxy(proxy);
    bool found;
    int32_t result;
    result = self->IndexedGetter(index, found);
    (void)result;

    *bp = found;
    return true;
  }

  JSObject* expando = GetExpandoObject(proxy);
  if (expando) {
    JSBool b = true;
    JSBool ok = JS_HasPropertyById(cx, expando, id, &b);
    *bp = !!b;
    if (!ok || *bp) {
      return ok;
    }
  }

  if (!HasPropertyOnPrototype(cx, proxy, this, id)) {
    JS::Value nameVal = js::IdToValue(id);
    FakeDependentString name;
    if (!ConvertJSValueToString(cx, nameVal, &nameVal,
                                eStringify, eStringify, name)) {
      return false;
    }

    mozilla::dom::TestIndexedAndNamedGetterAndSetterInterface* self = UnwrapProxy(proxy);
    bool found;
    nsString result;
    self->NamedGetter(name, found, result);
    (void)result;

    *bp = found;
    return true;
  }

  *bp = false;
  return true;
}


bool
DOMProxyHandler::get(JSContext* cx, JSObject* proxy, JSObject* receiver, jsid id, JS::Value* vp)
{
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
              "Should not have a XrayWrapper here");

  int32_t index = GetArrayIndexFromId(cx, id);
  if (IsArrayIndex(index)) {
    mozilla::dom::TestIndexedAndNamedGetterAndSetterInterface* self = UnwrapProxy(proxy);
    bool found;
    int32_t result;
    result = self->IndexedGetter(index, found);

    if (found) {
      *vp = INT_TO_JSVAL(int32_t(result));
      return true;
    }
    // Even if we don't have this index, we don't forward the
    // get on to our expando object.
  } else {
    JSObject* expando = DOMProxyHandler::GetExpandoObject(proxy);
    if (expando) {
      JSBool hasProp;
      if (!JS_HasPropertyById(cx, expando, id, &hasProp)) {
        return false;
      }

      if (hasProp) {
        return JS_GetPropertyById(cx, expando, id, vp);
      }
    }
  }

  {  // Scope for this "found" so it doesn't leak to things below
    bool found;
    if (!GetPropertyOnPrototype(cx, proxy, id, &found, vp)) {
      return false;
    }

    if (found) {
      return true;
    }
  }
  if (!IsArrayIndex(index)) {
    JS::Value nameVal = js::IdToValue(id);
    FakeDependentString name;
    if (!ConvertJSValueToString(cx, nameVal, &nameVal,
                                eStringify, eStringify, name)) {
      return false;
    }

    mozilla::dom::TestIndexedAndNamedGetterAndSetterInterface* self = UnwrapProxy(proxy);
    bool found;
    nsString result;
    self->NamedGetter(name, found, result);

    if (found) {
      if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
        return false;
      }
      return true;
    }
  }

  vp->setUndefined();
  return true;
}


JSString*
DOMProxyHandler::obj_toString(JSContext* cx, JSObject* proxy)
{
  return mozilla::dom::DOMProxyHandler::obj_toString(cx, "TestIndexedAndNamedGetterAndSetterInterface");
}


void
DOMProxyHandler::finalize(JSFreeOp* fop, JSObject* proxy)
{
  mozilla::dom::TestIndexedAndNamedGetterAndSetterInterface* self = UnwrapProxy(proxy);

  if (self) {
    ClearWrapper(self, self);
    XPCJSRuntime *rt = nsXPConnect::GetRuntimeInstance();
    if (rt) {
      rt->DeferredRelease(reinterpret_cast<nsISupports*>(self));
    } else {
      NS_RELEASE(self);
    }
  }
}


bool
DOMProxyHandler::getElementIfPresent(JSContext* cx, JSObject* proxy, JSObject* receiver, uint32_t index, JS::Value* vp, bool* present)
{
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
               "Should not have a XrayWrapper here");

  mozilla::dom::TestIndexedAndNamedGetterAndSetterInterface* self = UnwrapProxy(proxy);
  bool found;
  int32_t result;
  result = self->IndexedGetter(index, found);

  if (found) {
    *vp = INT_TO_JSVAL(int32_t(result));
    *present = found;
    return true;
  }
  // We skip the expando object and any named getters if
  // there is an indexed getter.


  JSObject *proto;
  if (!js::GetObjectProto(cx, proxy, &proto)) {
    return false;
  }
  if (proto) {
    JSBool isPresent;
    if (!JS_GetElementIfPresent(cx, proto, index, proxy, vp, &isPresent)) {
      return false;
    }
    *present = isPresent;
    return true;
  }

  *present = false;
  // Can't Debug_SetValueRangeToCrashOnTouch because it's not public
  return true;
}


DOMProxyHandler*
DOMProxyHandler::getInstance()
{
  static DOMProxyHandler instance;
  return &instance;
}


bool
DOMProxyHandler::delete_(JSContext* cx, JSObject* proxy, jsid id, bool* bp)
{
  int32_t index = GetArrayIndexFromId(cx, id);
  if (IsArrayIndex(index)) {
    mozilla::dom::TestIndexedAndNamedGetterAndSetterInterface* self = UnwrapProxy(proxy);
    bool found;
    int32_t result;
    result = self->IndexedGetter(index, found);
    (void)result;
    if (found) {
      // XXXbz we should throw if Throw is true!
      *bp = false;
    } else {
      *bp = true;
    }
    // We always return here, even if the property was not found
    return true;
  }
  if (!HasPropertyOnPrototype(cx, proxy, this, id)) {
    JS::Value nameVal = js::IdToValue(id);
    FakeDependentString name;
    if (!ConvertJSValueToString(cx, nameVal, &nameVal,
                                eStringify, eStringify, name)) {
      return false;
    }

    mozilla::dom::TestIndexedAndNamedGetterAndSetterInterface* self = UnwrapProxy(proxy);
    bool found;
    nsString result;
    self->NamedGetter(name, found, result);
    (void)result;
    if (found) {
      // XXXbz we should throw if Throw is true!
      *bp = false;
    } else {
      *bp = true;
    }
    if (found) {
      return true;
    }
  }
  return dom::DOMProxyHandler::delete_(cx, proxy, id, bp);
}


bool
Is(JSObject* obj)
{
  return IsProxy(obj);
}

JSObject*
Wrap(JSContext* aCx, JSObject* aScope, mozilla::dom::TestIndexedAndNamedGetterAndSetterInterface* aObject, nsWrapperCache* aCache, bool* aTriedToWrap)
{
  MOZ_ASSERT(static_cast<mozilla::dom::TestIndexedAndNamedGetterAndSetterInterface*>(aObject) ==
             reinterpret_cast<mozilla::dom::TestIndexedAndNamedGetterAndSetterInterface*>(aObject));
  MOZ_ASSERT(static_cast<mozilla::dom::TestIndexedSetterInterface*>(aObject) ==
             reinterpret_cast<mozilla::dom::TestIndexedSetterInterface*>(aObject));

  *aTriedToWrap = true;

  JSObject* parent = WrapNativeParent(aCx, aScope, aObject->GetParentObject());
  if (!parent) {
    return NULL;
  }

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.  Scope so we don't
  // collide with the "obj" we declare in CreateBindingJSObject.
  {
    JSObject* obj = aCache->GetWrapper();
    if (obj) {
      return obj;
    }
  }

  JSAutoCompartment ac(aCx, parent);
  JSObject* global = JS_GetGlobalForObject(aCx, parent);

  JSObject* proto = GetProtoObject(aCx, global);
  if (!proto) {
    return NULL;
  }

  JSObject *obj = NewProxyObject(aCx, DOMProxyHandler::getInstance(),
                                 JS::PrivateValue(aObject), proto, parent);
  if (!obj) {
    return NULL;
  }

  NS_ADDREF(aObject);


  aCache->SetWrapper(obj);

  return obj;
}

} // namespace TestIndexedAndNamedGetterAndSetterInterfaceBinding



namespace TestIndexedAndNamedGetterInterfaceBinding {

static bool
namedItem(JSContext* cx, JSHandleObject obj, mozilla::dom::TestIndexedAndNamedGetterInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestIndexedAndNamedGetterInterface.namedItem");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eStringify, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  nsString result;
  self->NamedItem(arg0, result);
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}


const JSJitInfo namedItem_methodinfo = {
  (JSJitPropertyOp)namedItem,
  prototypes::id::TestIndexedAndNamedGetterInterface,
  PrototypeTraits<prototypes::id::TestIndexedAndNamedGetterInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_length(JSContext* cx, JSHandleObject obj, mozilla::dom::TestIndexedAndNamedGetterInterface* self, JS::Value* vp)
{
  uint32_t result;
  result = self->Length();
  *vp = UINT_TO_JSVAL(result);
  return true;
}


const JSJitInfo length_getterinfo = {
  (JSJitPropertyOp)get_length,
  prototypes::id::TestIndexedAndNamedGetterInterface,
  PrototypeTraits<prototypes::id::TestIndexedAndNamedGetterInterface>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

static JSBool
genericMethod(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  mozilla::dom::TestIndexedAndNamedGetterInterface* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::TestIndexedAndNamedGetterInterface, mozilla::dom::TestIndexedAndNamedGetterInterface>(cx, obj, self);
    if (NS_FAILED(rv)) {
      return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestIndexedAndNamedGetterInterface");
    }
  }
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Method);
  JSJitMethodOp method = (JSJitMethodOp)info->op;
  return method(cx, obj, self, argc, vp);
}

static JSBool
genericGetter(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  mozilla::dom::TestIndexedAndNamedGetterInterface* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::TestIndexedAndNamedGetterInterface, mozilla::dom::TestIndexedAndNamedGetterInterface>(cx, obj, self);
    if (NS_FAILED(rv)) {
      return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestIndexedAndNamedGetterInterface");
    }
  }
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Getter);
  JSJitPropertyOp getter = info->op;
  return getter(cx, obj, self, vp);
}

static JSFunctionSpec sMethods_specs[] = {
  JS_FNINFO("namedItem", genericMethod, &namedItem_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FS_END
};

static Prefable<JSFunctionSpec> sMethods[] = {
  { true, &sMethods_specs[0] },
  { false, NULL }
};

static jsid sMethods_ids[2] = { JSID_VOID };

static JSFunctionSpec sChromeMethods_specs[] = {
  JS_FNINFO("QueryInterface", QueryInterface, nullptr, 1, 0),
  JS_FS_END
};

static Prefable<JSFunctionSpec> sChromeMethods[] = {
  { true, &sChromeMethods_specs[0] },
  { false, NULL }
};

static jsid sChromeMethods_ids[2] = { JSID_VOID };

static JSPropertySpec sAttributes_specs[] = {
  { "length", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &length_getterinfo }, JSOP_NULLWRAPPER},
  { 0, 0, 0, JSOP_NULLWRAPPER, JSOP_NULLWRAPPER }
};

static Prefable<JSPropertySpec> sAttributes[] = {
  { true, &sAttributes_specs[0] },
  { false, NULL }
};

static jsid sAttributes_ids[2] = { JSID_VOID };


static const NativeProperties sNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sMethods, sMethods_ids, sMethods_specs,
  sAttributes, sAttributes_ids, sAttributes_specs,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr
};

static const NativeProperties sChromeOnlyNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sChromeMethods, sChromeMethods_ids, sChromeMethods_specs,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr
};
const NativePropertyHooks sNativePropertyHooks = {
  ResolveOwnProperty,
  EnumerateOwnProperties,
  { &sNativeProperties, &sChromeOnlyNativeProperties },
  prototypes::id::TestIndexedAndNamedGetterInterface,
  constructors::id::TestIndexedAndNamedGetterInterface,
  NULL
};

JSNativeHolder _constructor_holder = {
  ThrowingConstructor,
  &sNativePropertyHooks
};

static DOMIfaceAndProtoJSClass PrototypeClass = {
  {
    "TestIndexedAndNamedGetterInterfacePrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(2),
    JS_PropertyStub,       /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    nullptr,               /* finalize */
    nullptr,               /* checkAccess */
    nullptr,               /* call */
    nullptr,               /* hasInstance */
    nullptr,               /* construct */
    nullptr,               /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  eInterfacePrototype,
  &sNativePropertyHooks
};

void
CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray)
{
  JSObject* parentProto = JS_GetObjectPrototype(aCx, aGlobal);
  if (!parentProto) {
    return;
  }


  if (sChromeMethods_ids[0] == JSID_VOID &&
      (!InitIds(aCx, sChromeMethods, sChromeMethods_ids) ||
       !InitIds(aCx, sMethods, sMethods_ids) ||
       !InitIds(aCx, sAttributes, sAttributes_ids))) {
    sChromeMethods_ids[0] = JSID_VOID;
    return;
  }

  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &PrototypeClass.mBase, &protoAndIfaceArray[prototypes::id::TestIndexedAndNamedGetterInterface],
                              nullptr, &_constructor_holder, 0, &protoAndIfaceArray[constructors::id::TestIndexedAndNamedGetterInterface],
                              &Class,
                              &sNativeProperties,
                              xpc::AccessCheck::isChrome(aGlobal) ? &sChromeOnlyNativeProperties : nullptr,
                              "TestIndexedAndNamedGetterInterface");
}

bool
ResolveOwnProperty(JSContext* cx, JSObject* wrapper, JSObject* obj, jsid id, JSPropertyDescriptor* desc, unsigned flags)
{
  // We rely on getOwnPropertyDescriptor not shadowing prototype properties by named
  // properties. If that changes we'll need to filter here.
  return js::GetProxyHandler(obj)->getOwnPropertyDescriptor(cx, wrapper, id, desc, flags);

}

bool
EnumerateOwnProperties(JSContext* cx, JSObject* wrapper, JSObject* obj, JS::AutoIdVector& props)
{
  // We rely on getOwnPropertyNames not shadowing prototype properties by named
  // properties. If that changes we'll need to filter here.
  return js::GetProxyHandler(obj)->getOwnPropertyNames(cx, wrapper, props);

}

JSObject*
DefineDOMInterface(JSContext* aCx, JSObject* aGlobal, bool* aEnabled)
{

  *aEnabled = true;
  return GetConstructorObject(aCx, aGlobal);
}

MOZ_ALWAYS_INLINE bool
IsProxy(JSObject* obj)
{
  return js::IsProxy(obj) && js::GetProxyHandler(obj) == DOMProxyHandler::getInstance();
}

MOZ_ALWAYS_INLINE mozilla::dom::TestIndexedAndNamedGetterInterface*
UnwrapProxy(JSObject* obj)
{
  if (xpc::WrapperFactory::IsXrayWrapper(obj)) {
    obj = js::UnwrapObject(obj);
  }
  MOZ_ASSERT(IsProxy(obj));
  return static_cast<mozilla::dom::TestIndexedAndNamedGetterInterface*>(js::GetProxyPrivate(obj).toPrivate());
}


const DOMClass Class = {
  { prototypes::id::TestIndexedAndNamedGetterInterface, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
  true,
  &sNativePropertyHooks,
  GetParentObject<mozilla::dom::TestIndexedAndNamedGetterInterface>::Get,
  GetProtoObject,
  nullptr
};



DOMProxyHandler::DOMProxyHandler()
  : mozilla::dom::DOMProxyHandler(Class)
{

}


bool
DOMProxyHandler::getOwnPropertyDescriptor(JSContext* cx, JSObject* proxy, jsid id, JSPropertyDescriptor* desc, unsigned flags)
{
  int32_t index = GetArrayIndexFromId(cx, id);
  if (!(flags & JSRESOLVE_ASSIGNING)) {
    if (IsArrayIndex(index)) {
      mozilla::dom::TestIndexedAndNamedGetterInterface* self = UnwrapProxy(proxy);
      bool found;
      int32_t result;
      result = self->IndexedGetter(index, found);

      if (found) {
        desc->value = INT_TO_JSVAL(int32_t(result));
        FillPropertyDescriptor(desc, proxy, true);
        return true;
      }
    }
  }

  JSObject* expando;
  if (!xpc::WrapperFactory::IsXrayWrapper(proxy) && (expando = GetExpandoObject(proxy))) {
    if (!JS_GetPropertyDescriptorById(cx, expando, id, flags, desc)) {
      return false;
    }
    if (desc->obj) {
      // Pretend the property lives on the wrapper.
      desc->obj = proxy;
      return true;
    }
  }

  if (!IsArrayIndex(index) && !(flags & JSRESOLVE_ASSIGNING) && !HasPropertyOnPrototype(cx, proxy, this, id)) {
    JS::Value nameVal = js::IdToValue(id);
    FakeDependentString name;
    if (!ConvertJSValueToString(cx, nameVal, &nameVal,
                                eStringify, eStringify, name)) {
      return false;
    }

    mozilla::dom::TestIndexedAndNamedGetterInterface* self = UnwrapProxy(proxy);
    bool found;
    nsString result;
    self->NamedGetter(name, found, result);

    if (found) {
      if (!xpc::NonVoidStringToJsval(cx, result, &desc->value)) {
        return false;
      }
      FillPropertyDescriptor(desc, proxy, true);
      return true;
    }
  }

  desc->obj = NULL;
  return true;
}


bool
DOMProxyHandler::getOwnPropertyNames(JSContext* cx, JSObject* proxy, JS::AutoIdVector& props)
{
  uint32_t length = UnwrapProxy(proxy)->Length();
  MOZ_ASSERT(int32_t(length) >= 0);
  for (int32_t i = 0; i < int32_t(length); ++i) {
    if (!props.append(INT_TO_JSID(i))) {
      return false;
    }
  }

  nsTArray<nsString> names;
  UnwrapProxy(proxy)->GetSupportedNames(names);
  if (!AppendNamedPropertyIds(cx, proxy, names, props)) {
    return false;
  }

  JSObject* expando;
  if (!xpc::WrapperFactory::IsXrayWrapper(proxy) && (expando = DOMProxyHandler::GetExpandoObject(proxy)) &&
      !js::GetPropertyNames(cx, expando, JSITER_OWNONLY | JSITER_HIDDEN, &props)) {
    return false;
  }

  return true;
}


bool
DOMProxyHandler::hasOwn(JSContext* cx, JSObject* proxy, jsid id, bool* bp)
{
  int32_t index = GetArrayIndexFromId(cx, id);
  if (IsArrayIndex(index)) {
    mozilla::dom::TestIndexedAndNamedGetterInterface* self = UnwrapProxy(proxy);
    bool found;
    int32_t result;
    result = self->IndexedGetter(index, found);
    (void)result;

    *bp = found;
    return true;
  }

  JSObject* expando = GetExpandoObject(proxy);
  if (expando) {
    JSBool b = true;
    JSBool ok = JS_HasPropertyById(cx, expando, id, &b);
    *bp = !!b;
    if (!ok || *bp) {
      return ok;
    }
  }

  if (!HasPropertyOnPrototype(cx, proxy, this, id)) {
    JS::Value nameVal = js::IdToValue(id);
    FakeDependentString name;
    if (!ConvertJSValueToString(cx, nameVal, &nameVal,
                                eStringify, eStringify, name)) {
      return false;
    }

    mozilla::dom::TestIndexedAndNamedGetterInterface* self = UnwrapProxy(proxy);
    bool found;
    nsString result;
    self->NamedGetter(name, found, result);
    (void)result;

    *bp = found;
    return true;
  }

  *bp = false;
  return true;
}


bool
DOMProxyHandler::get(JSContext* cx, JSObject* proxy, JSObject* receiver, jsid id, JS::Value* vp)
{
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
              "Should not have a XrayWrapper here");

  int32_t index = GetArrayIndexFromId(cx, id);
  if (IsArrayIndex(index)) {
    mozilla::dom::TestIndexedAndNamedGetterInterface* self = UnwrapProxy(proxy);
    bool found;
    int32_t result;
    result = self->IndexedGetter(index, found);

    if (found) {
      *vp = INT_TO_JSVAL(int32_t(result));
      return true;
    }
    // Even if we don't have this index, we don't forward the
    // get on to our expando object.
  } else {
    JSObject* expando = DOMProxyHandler::GetExpandoObject(proxy);
    if (expando) {
      JSBool hasProp;
      if (!JS_HasPropertyById(cx, expando, id, &hasProp)) {
        return false;
      }

      if (hasProp) {
        return JS_GetPropertyById(cx, expando, id, vp);
      }
    }
  }

  {  // Scope for this "found" so it doesn't leak to things below
    bool found;
    if (!GetPropertyOnPrototype(cx, proxy, id, &found, vp)) {
      return false;
    }

    if (found) {
      return true;
    }
  }
  if (!IsArrayIndex(index)) {
    JS::Value nameVal = js::IdToValue(id);
    FakeDependentString name;
    if (!ConvertJSValueToString(cx, nameVal, &nameVal,
                                eStringify, eStringify, name)) {
      return false;
    }

    mozilla::dom::TestIndexedAndNamedGetterInterface* self = UnwrapProxy(proxy);
    bool found;
    nsString result;
    self->NamedGetter(name, found, result);

    if (found) {
      if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
        return false;
      }
      return true;
    }
  }

  vp->setUndefined();
  return true;
}


JSString*
DOMProxyHandler::obj_toString(JSContext* cx, JSObject* proxy)
{
  return mozilla::dom::DOMProxyHandler::obj_toString(cx, "TestIndexedAndNamedGetterInterface");
}


void
DOMProxyHandler::finalize(JSFreeOp* fop, JSObject* proxy)
{
  mozilla::dom::TestIndexedAndNamedGetterInterface* self = UnwrapProxy(proxy);

  if (self) {
    ClearWrapper(self, self);
    XPCJSRuntime *rt = nsXPConnect::GetRuntimeInstance();
    if (rt) {
      rt->DeferredRelease(reinterpret_cast<nsISupports*>(self));
    } else {
      NS_RELEASE(self);
    }
  }
}


bool
DOMProxyHandler::getElementIfPresent(JSContext* cx, JSObject* proxy, JSObject* receiver, uint32_t index, JS::Value* vp, bool* present)
{
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
               "Should not have a XrayWrapper here");

  mozilla::dom::TestIndexedAndNamedGetterInterface* self = UnwrapProxy(proxy);
  bool found;
  int32_t result;
  result = self->IndexedGetter(index, found);

  if (found) {
    *vp = INT_TO_JSVAL(int32_t(result));
    *present = found;
    return true;
  }
  // We skip the expando object and any named getters if
  // there is an indexed getter.


  JSObject *proto;
  if (!js::GetObjectProto(cx, proxy, &proto)) {
    return false;
  }
  if (proto) {
    JSBool isPresent;
    if (!JS_GetElementIfPresent(cx, proto, index, proxy, vp, &isPresent)) {
      return false;
    }
    *present = isPresent;
    return true;
  }

  *present = false;
  // Can't Debug_SetValueRangeToCrashOnTouch because it's not public
  return true;
}


DOMProxyHandler*
DOMProxyHandler::getInstance()
{
  static DOMProxyHandler instance;
  return &instance;
}


bool
DOMProxyHandler::delete_(JSContext* cx, JSObject* proxy, jsid id, bool* bp)
{
  int32_t index = GetArrayIndexFromId(cx, id);
  if (IsArrayIndex(index)) {
    mozilla::dom::TestIndexedAndNamedGetterInterface* self = UnwrapProxy(proxy);
    bool found;
    int32_t result;
    result = self->IndexedGetter(index, found);
    (void)result;
    if (found) {
      // XXXbz we should throw if Throw is true!
      *bp = false;
    } else {
      *bp = true;
    }
    // We always return here, even if the property was not found
    return true;
  }
  if (!HasPropertyOnPrototype(cx, proxy, this, id)) {
    JS::Value nameVal = js::IdToValue(id);
    FakeDependentString name;
    if (!ConvertJSValueToString(cx, nameVal, &nameVal,
                                eStringify, eStringify, name)) {
      return false;
    }

    mozilla::dom::TestIndexedAndNamedGetterInterface* self = UnwrapProxy(proxy);
    bool found;
    nsString result;
    self->NamedGetter(name, found, result);
    (void)result;
    if (found) {
      // XXXbz we should throw if Throw is true!
      *bp = false;
    } else {
      *bp = true;
    }
    if (found) {
      return true;
    }
  }
  return dom::DOMProxyHandler::delete_(cx, proxy, id, bp);
}


bool
Is(JSObject* obj)
{
  return IsProxy(obj);
}

JSObject*
Wrap(JSContext* aCx, JSObject* aScope, mozilla::dom::TestIndexedAndNamedGetterInterface* aObject, nsWrapperCache* aCache, bool* aTriedToWrap)
{
  MOZ_ASSERT(static_cast<mozilla::dom::TestIndexedAndNamedGetterInterface*>(aObject) ==
             reinterpret_cast<mozilla::dom::TestIndexedAndNamedGetterInterface*>(aObject));

  *aTriedToWrap = true;

  JSObject* parent = WrapNativeParent(aCx, aScope, aObject->GetParentObject());
  if (!parent) {
    return NULL;
  }

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.  Scope so we don't
  // collide with the "obj" we declare in CreateBindingJSObject.
  {
    JSObject* obj = aCache->GetWrapper();
    if (obj) {
      return obj;
    }
  }

  JSAutoCompartment ac(aCx, parent);
  JSObject* global = JS_GetGlobalForObject(aCx, parent);

  JSObject* proto = GetProtoObject(aCx, global);
  if (!proto) {
    return NULL;
  }

  JSObject *obj = NewProxyObject(aCx, DOMProxyHandler::getInstance(),
                                 JS::PrivateValue(aObject), proto, parent);
  if (!obj) {
    return NULL;
  }

  NS_ADDREF(aObject);


  aCache->SetWrapper(obj);

  return obj;
}

} // namespace TestIndexedAndNamedGetterInterfaceBinding



namespace TestIndexedAndNamedSetterInterfaceBinding {

static bool
setNamedItem(JSContext* cx, JSHandleObject obj, mozilla::dom::TestIndexedAndNamedSetterInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 2) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestIndexedAndNamedSetterInterface.setNamedItem");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eStringify, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  NonNull<mozilla::dom::TestIndexedSetterInterface> arg1;
  if (argv[1].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::TestIndexedSetterInterface, mozilla::dom::TestIndexedSetterInterface>(cx, &argv[1].toObject(), arg1);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestIndexedSetterInterface");
        return false;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->SetNamedItem(arg0, arg1);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo setNamedItem_methodinfo = {
  (JSJitPropertyOp)setNamedItem,
  prototypes::id::TestIndexedAndNamedSetterInterface,
  PrototypeTraits<prototypes::id::TestIndexedAndNamedSetterInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static JSBool
genericMethod(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  mozilla::dom::TestIndexedAndNamedSetterInterface* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::TestIndexedAndNamedSetterInterface, mozilla::dom::TestIndexedAndNamedSetterInterface>(cx, obj, self);
    if (NS_FAILED(rv)) {
      return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestIndexedAndNamedSetterInterface");
    }
  }
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Method);
  JSJitMethodOp method = (JSJitMethodOp)info->op;
  return method(cx, obj, self, argc, vp);
}

static JSFunctionSpec sMethods_specs[] = {
  JS_FNINFO("setNamedItem", genericMethod, &setNamedItem_methodinfo, 2, JSPROP_ENUMERATE),
  JS_FS_END
};

static Prefable<JSFunctionSpec> sMethods[] = {
  { true, &sMethods_specs[0] },
  { false, NULL }
};

static jsid sMethods_ids[2] = { JSID_VOID };

static JSFunctionSpec sChromeMethods_specs[] = {
  JS_FNINFO("QueryInterface", QueryInterface, nullptr, 1, 0),
  JS_FS_END
};

static Prefable<JSFunctionSpec> sChromeMethods[] = {
  { true, &sChromeMethods_specs[0] },
  { false, NULL }
};

static jsid sChromeMethods_ids[2] = { JSID_VOID };


static const NativeProperties sNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sMethods, sMethods_ids, sMethods_specs,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr
};

static const NativeProperties sChromeOnlyNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sChromeMethods, sChromeMethods_ids, sChromeMethods_specs,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr
};
const NativePropertyHooks sNativePropertyHooks = {
  ResolveOwnProperty,
  EnumerateOwnProperties,
  { &sNativeProperties, &sChromeOnlyNativeProperties },
  prototypes::id::TestIndexedAndNamedSetterInterface,
  constructors::id::TestIndexedAndNamedSetterInterface,
  NULL
};

JSNativeHolder _constructor_holder = {
  ThrowingConstructor,
  &sNativePropertyHooks
};

static DOMIfaceAndProtoJSClass PrototypeClass = {
  {
    "TestIndexedAndNamedSetterInterfacePrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(2),
    JS_PropertyStub,       /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    nullptr,               /* finalize */
    nullptr,               /* checkAccess */
    nullptr,               /* call */
    nullptr,               /* hasInstance */
    nullptr,               /* construct */
    nullptr,               /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  eInterfacePrototype,
  &sNativePropertyHooks
};

void
CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray)
{
  JSObject* parentProto = JS_GetObjectPrototype(aCx, aGlobal);
  if (!parentProto) {
    return;
  }


  if (sChromeMethods_ids[0] == JSID_VOID &&
      (!InitIds(aCx, sChromeMethods, sChromeMethods_ids) ||
       !InitIds(aCx, sMethods, sMethods_ids))) {
    sChromeMethods_ids[0] = JSID_VOID;
    return;
  }

  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &PrototypeClass.mBase, &protoAndIfaceArray[prototypes::id::TestIndexedAndNamedSetterInterface],
                              nullptr, &_constructor_holder, 0, &protoAndIfaceArray[constructors::id::TestIndexedAndNamedSetterInterface],
                              &Class,
                              &sNativeProperties,
                              xpc::AccessCheck::isChrome(aGlobal) ? &sChromeOnlyNativeProperties : nullptr,
                              "TestIndexedAndNamedSetterInterface");
}

bool
ResolveOwnProperty(JSContext* cx, JSObject* wrapper, JSObject* obj, jsid id, JSPropertyDescriptor* desc, unsigned flags)
{
  // We rely on getOwnPropertyDescriptor not shadowing prototype properties by named
  // properties. If that changes we'll need to filter here.
  return js::GetProxyHandler(obj)->getOwnPropertyDescriptor(cx, wrapper, id, desc, flags);

}

bool
EnumerateOwnProperties(JSContext* cx, JSObject* wrapper, JSObject* obj, JS::AutoIdVector& props)
{
  // We rely on getOwnPropertyNames not shadowing prototype properties by named
  // properties. If that changes we'll need to filter here.
  return js::GetProxyHandler(obj)->getOwnPropertyNames(cx, wrapper, props);

}

JSObject*
DefineDOMInterface(JSContext* aCx, JSObject* aGlobal, bool* aEnabled)
{

  *aEnabled = true;
  return GetConstructorObject(aCx, aGlobal);
}

MOZ_ALWAYS_INLINE bool
IsProxy(JSObject* obj)
{
  return js::IsProxy(obj) && js::GetProxyHandler(obj) == DOMProxyHandler::getInstance();
}

MOZ_ALWAYS_INLINE mozilla::dom::TestIndexedAndNamedSetterInterface*
UnwrapProxy(JSObject* obj)
{
  if (xpc::WrapperFactory::IsXrayWrapper(obj)) {
    obj = js::UnwrapObject(obj);
  }
  MOZ_ASSERT(IsProxy(obj));
  return static_cast<mozilla::dom::TestIndexedAndNamedSetterInterface*>(js::GetProxyPrivate(obj).toPrivate());
}


const DOMClass Class = {
  { prototypes::id::TestIndexedAndNamedSetterInterface, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
  true,
  &sNativePropertyHooks,
  GetParentObject<mozilla::dom::TestIndexedAndNamedSetterInterface>::Get,
  GetProtoObject,
  nullptr
};



DOMProxyHandler::DOMProxyHandler()
  : mozilla::dom::DOMProxyHandler(Class)
{

}


bool
DOMProxyHandler::getOwnPropertyDescriptor(JSContext* cx, JSObject* proxy, jsid id, JSPropertyDescriptor* desc, unsigned flags)
{
  int32_t index = GetArrayIndexFromId(cx, id);
  if (flags & JSRESOLVE_ASSIGNING) {
    if (IsArrayIndex(index)) {
      FillPropertyDescriptor(desc, proxy, JSVAL_VOID, false);
      return true;
    }
    FillPropertyDescriptor(desc, proxy, JSVAL_VOID, false);
    return true;
  } else {
    if (IsArrayIndex(index)) {
      mozilla::dom::TestIndexedAndNamedSetterInterface* self = UnwrapProxy(proxy);
      bool found;
      nsRefPtr<mozilla::dom::TestIndexedSetterInterface> result;
      result = self->IndexedGetter(index, found);

      if (found) {
        if (!WrapNewBindingObject(cx, proxy, result, &desc->value)) {
          MOZ_ASSERT(JS_IsExceptionPending(cx));
          return false;
        }
        FillPropertyDescriptor(desc, proxy, false);
        return true;
      }
    }
  }

  JSObject* expando;
  if (!xpc::WrapperFactory::IsXrayWrapper(proxy) && (expando = GetExpandoObject(proxy))) {
    if (!JS_GetPropertyDescriptorById(cx, expando, id, flags, desc)) {
      return false;
    }
    if (desc->obj) {
      // Pretend the property lives on the wrapper.
      desc->obj = proxy;
      return true;
    }
  }

  if (!IsArrayIndex(index) && !(flags & JSRESOLVE_ASSIGNING) && !HasPropertyOnPrototype(cx, proxy, this, id)) {
    JS::Value nameVal = js::IdToValue(id);
    FakeDependentString name;
    if (!ConvertJSValueToString(cx, nameVal, &nameVal,
                                eStringify, eStringify, name)) {
      return false;
    }

    mozilla::dom::TestIndexedAndNamedSetterInterface* self = UnwrapProxy(proxy);
    bool found;
    nsRefPtr<mozilla::dom::TestIndexedSetterInterface> result;
    result = self->NamedGetter(name, found);

    if (found) {
      if (!WrapNewBindingObject(cx, proxy, result, &desc->value)) {
        MOZ_ASSERT(JS_IsExceptionPending(cx));
        return false;
      }
      FillPropertyDescriptor(desc, proxy, false);
      return true;
    }
  }

  desc->obj = NULL;
  return true;
}


bool
DOMProxyHandler::defineProperty(JSContext* cx, JSObject* proxy, jsid id, JSPropertyDescriptor* desc)
{
  int32_t index = GetArrayIndexFromId(cx, id);
  if (IsArrayIndex(index)) {
    mozilla::dom::TestIndexedAndNamedSetterInterface* self = UnwrapProxy(proxy);
    NonNull<mozilla::dom::TestIndexedSetterInterface> item;
    if (desc->value.isObject()) {
      {
        nsresult rv = UnwrapObject<prototypes::id::TestIndexedSetterInterface, mozilla::dom::TestIndexedSetterInterface>(cx, &desc->value.toObject(), item);
        if (NS_FAILED(rv)) {
          ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestIndexedSetterInterface");
          return false;
        }
      }
    } else {
      ThrowErrorMessage(cx, MSG_NOT_OBJECT);
      return false;
    }
    self->IndexedSetter(index, item);
    return true;
  }
  JS::Value nameVal = js::IdToValue(id);
  FakeDependentString name;
  if (!ConvertJSValueToString(cx, nameVal, &nameVal,
                              eStringify, eStringify, name)) {
    return false;
  }

  mozilla::dom::TestIndexedAndNamedSetterInterface* self = UnwrapProxy(proxy);
  NonNull<mozilla::dom::TestIndexedSetterInterface> item;
  if (desc->value.isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::TestIndexedSetterInterface, mozilla::dom::TestIndexedSetterInterface>(cx, &desc->value.toObject(), item);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestIndexedSetterInterface");
        return false;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->NamedSetter(name, item);

  return true;

}


bool
DOMProxyHandler::getOwnPropertyNames(JSContext* cx, JSObject* proxy, JS::AutoIdVector& props)
{
  uint32_t length = UnwrapProxy(proxy)->Length();
  MOZ_ASSERT(int32_t(length) >= 0);
  for (int32_t i = 0; i < int32_t(length); ++i) {
    if (!props.append(INT_TO_JSID(i))) {
      return false;
    }
  }

  nsTArray<nsString> names;
  UnwrapProxy(proxy)->GetSupportedNames(names);
  if (!AppendNamedPropertyIds(cx, proxy, names, props)) {
    return false;
  }

  JSObject* expando;
  if (!xpc::WrapperFactory::IsXrayWrapper(proxy) && (expando = DOMProxyHandler::GetExpandoObject(proxy)) &&
      !js::GetPropertyNames(cx, expando, JSITER_OWNONLY | JSITER_HIDDEN, &props)) {
    return false;
  }

  return true;
}


bool
DOMProxyHandler::hasOwn(JSContext* cx, JSObject* proxy, jsid id, bool* bp)
{
  int32_t index = GetArrayIndexFromId(cx, id);
  if (IsArrayIndex(index)) {
    mozilla::dom::TestIndexedAndNamedSetterInterface* self = UnwrapProxy(proxy);
    bool found;
    nsRefPtr<mozilla::dom::TestIndexedSetterInterface> result;
    result = self->IndexedGetter(index, found);
    (void)result;

    *bp = found;
    return true;
  }

  JSObject* expando = GetExpandoObject(proxy);
  if (expando) {
    JSBool b = true;
    JSBool ok = JS_HasPropertyById(cx, expando, id, &b);
    *bp = !!b;
    if (!ok || *bp) {
      return ok;
    }
  }

  if (!HasPropertyOnPrototype(cx, proxy, this, id)) {
    JS::Value nameVal = js::IdToValue(id);
    FakeDependentString name;
    if (!ConvertJSValueToString(cx, nameVal, &nameVal,
                                eStringify, eStringify, name)) {
      return false;
    }

    mozilla::dom::TestIndexedAndNamedSetterInterface* self = UnwrapProxy(proxy);
    bool found;
    nsRefPtr<mozilla::dom::TestIndexedSetterInterface> result;
    result = self->NamedGetter(name, found);
    (void)result;

    *bp = found;
    return true;
  }

  *bp = false;
  return true;
}


bool
DOMProxyHandler::get(JSContext* cx, JSObject* proxy, JSObject* receiver, jsid id, JS::Value* vp)
{
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
              "Should not have a XrayWrapper here");

  int32_t index = GetArrayIndexFromId(cx, id);
  if (IsArrayIndex(index)) {
    mozilla::dom::TestIndexedAndNamedSetterInterface* self = UnwrapProxy(proxy);
    bool found;
    nsRefPtr<mozilla::dom::TestIndexedSetterInterface> result;
    result = self->IndexedGetter(index, found);

    if (found) {
      if (!WrapNewBindingObject(cx, proxy, result, vp)) {
        MOZ_ASSERT(JS_IsExceptionPending(cx));
        return false;
      }
      return true;
    }
    // Even if we don't have this index, we don't forward the
    // get on to our expando object.
  } else {
    JSObject* expando = DOMProxyHandler::GetExpandoObject(proxy);
    if (expando) {
      JSBool hasProp;
      if (!JS_HasPropertyById(cx, expando, id, &hasProp)) {
        return false;
      }

      if (hasProp) {
        return JS_GetPropertyById(cx, expando, id, vp);
      }
    }
  }

  {  // Scope for this "found" so it doesn't leak to things below
    bool found;
    if (!GetPropertyOnPrototype(cx, proxy, id, &found, vp)) {
      return false;
    }

    if (found) {
      return true;
    }
  }
  if (!IsArrayIndex(index)) {
    JS::Value nameVal = js::IdToValue(id);
    FakeDependentString name;
    if (!ConvertJSValueToString(cx, nameVal, &nameVal,
                                eStringify, eStringify, name)) {
      return false;
    }

    mozilla::dom::TestIndexedAndNamedSetterInterface* self = UnwrapProxy(proxy);
    bool found;
    nsRefPtr<mozilla::dom::TestIndexedSetterInterface> result;
    result = self->NamedGetter(name, found);

    if (found) {
      if (!WrapNewBindingObject(cx, proxy, result, vp)) {
        MOZ_ASSERT(JS_IsExceptionPending(cx));
        return false;
      }
      return true;
    }
  }

  vp->setUndefined();
  return true;
}


JSString*
DOMProxyHandler::obj_toString(JSContext* cx, JSObject* proxy)
{
  return mozilla::dom::DOMProxyHandler::obj_toString(cx, "TestIndexedAndNamedSetterInterface");
}


void
DOMProxyHandler::finalize(JSFreeOp* fop, JSObject* proxy)
{
  mozilla::dom::TestIndexedAndNamedSetterInterface* self = UnwrapProxy(proxy);

  if (self) {
    ClearWrapper(self, self);
    XPCJSRuntime *rt = nsXPConnect::GetRuntimeInstance();
    if (rt) {
      rt->DeferredRelease(reinterpret_cast<nsISupports*>(self));
    } else {
      NS_RELEASE(self);
    }
  }
}


bool
DOMProxyHandler::getElementIfPresent(JSContext* cx, JSObject* proxy, JSObject* receiver, uint32_t index, JS::Value* vp, bool* present)
{
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
               "Should not have a XrayWrapper here");

  mozilla::dom::TestIndexedAndNamedSetterInterface* self = UnwrapProxy(proxy);
  bool found;
  nsRefPtr<mozilla::dom::TestIndexedSetterInterface> result;
  result = self->IndexedGetter(index, found);

  if (found) {
    if (!WrapNewBindingObject(cx, proxy, result, vp)) {
      MOZ_ASSERT(JS_IsExceptionPending(cx));
      return false;
    }
    *present = found;
    return true;
  }
  // We skip the expando object and any named getters if
  // there is an indexed getter.


  JSObject *proto;
  if (!js::GetObjectProto(cx, proxy, &proto)) {
    return false;
  }
  if (proto) {
    JSBool isPresent;
    if (!JS_GetElementIfPresent(cx, proto, index, proxy, vp, &isPresent)) {
      return false;
    }
    *present = isPresent;
    return true;
  }

  *present = false;
  // Can't Debug_SetValueRangeToCrashOnTouch because it's not public
  return true;
}


DOMProxyHandler*
DOMProxyHandler::getInstance()
{
  static DOMProxyHandler instance;
  return &instance;
}


bool
DOMProxyHandler::delete_(JSContext* cx, JSObject* proxy, jsid id, bool* bp)
{
  int32_t index = GetArrayIndexFromId(cx, id);
  if (IsArrayIndex(index)) {
    mozilla::dom::TestIndexedAndNamedSetterInterface* self = UnwrapProxy(proxy);
    bool found;
    nsRefPtr<mozilla::dom::TestIndexedSetterInterface> result;
    result = self->IndexedGetter(index, found);
    (void)result;
    if (found) {
      // XXXbz we should throw if Throw is true!
      *bp = false;
    } else {
      *bp = true;
    }
    // We always return here, even if the property was not found
    return true;
  }
  if (!HasPropertyOnPrototype(cx, proxy, this, id)) {
    JS::Value nameVal = js::IdToValue(id);
    FakeDependentString name;
    if (!ConvertJSValueToString(cx, nameVal, &nameVal,
                                eStringify, eStringify, name)) {
      return false;
    }

    mozilla::dom::TestIndexedAndNamedSetterInterface* self = UnwrapProxy(proxy);
    bool found;
    nsRefPtr<mozilla::dom::TestIndexedSetterInterface> result;
    result = self->NamedGetter(name, found);
    (void)result;
    if (found) {
      // XXXbz we should throw if Throw is true!
      *bp = false;
    } else {
      *bp = true;
    }
    if (found) {
      return true;
    }
  }
  return dom::DOMProxyHandler::delete_(cx, proxy, id, bp);
}


bool
Is(JSObject* obj)
{
  return IsProxy(obj);
}

JSObject*
Wrap(JSContext* aCx, JSObject* aScope, mozilla::dom::TestIndexedAndNamedSetterInterface* aObject, nsWrapperCache* aCache, bool* aTriedToWrap)
{
  MOZ_ASSERT(static_cast<mozilla::dom::TestIndexedAndNamedSetterInterface*>(aObject) ==
             reinterpret_cast<mozilla::dom::TestIndexedAndNamedSetterInterface*>(aObject));

  *aTriedToWrap = true;

  JSObject* parent = WrapNativeParent(aCx, aScope, aObject->GetParentObject());
  if (!parent) {
    return NULL;
  }

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.  Scope so we don't
  // collide with the "obj" we declare in CreateBindingJSObject.
  {
    JSObject* obj = aCache->GetWrapper();
    if (obj) {
      return obj;
    }
  }

  JSAutoCompartment ac(aCx, parent);
  JSObject* global = JS_GetGlobalForObject(aCx, parent);

  JSObject* proto = GetProtoObject(aCx, global);
  if (!proto) {
    return NULL;
  }

  JSObject *obj = NewProxyObject(aCx, DOMProxyHandler::getInstance(),
                                 JS::PrivateValue(aObject), proto, parent);
  if (!obj) {
    return NULL;
  }

  NS_ADDREF(aObject);


  aCache->SetWrapper(obj);

  return obj;
}

} // namespace TestIndexedAndNamedSetterInterfaceBinding



namespace TestIndexedDeleterInterfaceBinding {

static bool
delItem(JSContext* cx, JSHandleObject obj, mozilla::dom::TestIndexedDeleterInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestIndexedDeleterInterface.delItem");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  self->DelItem(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo delItem_methodinfo = {
  (JSJitPropertyOp)delItem,
  prototypes::id::TestIndexedDeleterInterface,
  PrototypeTraits<prototypes::id::TestIndexedDeleterInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static JSBool
genericMethod(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  mozilla::dom::TestIndexedDeleterInterface* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::TestIndexedDeleterInterface, mozilla::dom::TestIndexedDeleterInterface>(cx, obj, self);
    if (NS_FAILED(rv)) {
      return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestIndexedDeleterInterface");
    }
  }
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Method);
  JSJitMethodOp method = (JSJitMethodOp)info->op;
  return method(cx, obj, self, argc, vp);
}

static JSFunctionSpec sMethods_specs[] = {
  JS_FNINFO("delItem", genericMethod, &delItem_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FS_END
};

static Prefable<JSFunctionSpec> sMethods[] = {
  { true, &sMethods_specs[0] },
  { false, NULL }
};

static jsid sMethods_ids[2] = { JSID_VOID };

static JSFunctionSpec sChromeMethods_specs[] = {
  JS_FNINFO("QueryInterface", QueryInterface, nullptr, 1, 0),
  JS_FS_END
};

static Prefable<JSFunctionSpec> sChromeMethods[] = {
  { true, &sChromeMethods_specs[0] },
  { false, NULL }
};

static jsid sChromeMethods_ids[2] = { JSID_VOID };


static const NativeProperties sNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sMethods, sMethods_ids, sMethods_specs,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr
};

static const NativeProperties sChromeOnlyNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sChromeMethods, sChromeMethods_ids, sChromeMethods_specs,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr
};
const NativePropertyHooks sNativePropertyHooks = {
  ResolveOwnProperty,
  EnumerateOwnProperties,
  { &sNativeProperties, &sChromeOnlyNativeProperties },
  prototypes::id::TestIndexedDeleterInterface,
  constructors::id::TestIndexedDeleterInterface,
  NULL
};

JSNativeHolder _constructor_holder = {
  ThrowingConstructor,
  &sNativePropertyHooks
};

static DOMIfaceAndProtoJSClass PrototypeClass = {
  {
    "TestIndexedDeleterInterfacePrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(2),
    JS_PropertyStub,       /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    nullptr,               /* finalize */
    nullptr,               /* checkAccess */
    nullptr,               /* call */
    nullptr,               /* hasInstance */
    nullptr,               /* construct */
    nullptr,               /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  eInterfacePrototype,
  &sNativePropertyHooks
};

void
CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray)
{
  JSObject* parentProto = JS_GetObjectPrototype(aCx, aGlobal);
  if (!parentProto) {
    return;
  }


  if (sChromeMethods_ids[0] == JSID_VOID &&
      (!InitIds(aCx, sChromeMethods, sChromeMethods_ids) ||
       !InitIds(aCx, sMethods, sMethods_ids))) {
    sChromeMethods_ids[0] = JSID_VOID;
    return;
  }

  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &PrototypeClass.mBase, &protoAndIfaceArray[prototypes::id::TestIndexedDeleterInterface],
                              nullptr, &_constructor_holder, 0, &protoAndIfaceArray[constructors::id::TestIndexedDeleterInterface],
                              &Class,
                              &sNativeProperties,
                              xpc::AccessCheck::isChrome(aGlobal) ? &sChromeOnlyNativeProperties : nullptr,
                              "TestIndexedDeleterInterface");
}

bool
ResolveOwnProperty(JSContext* cx, JSObject* wrapper, JSObject* obj, jsid id, JSPropertyDescriptor* desc, unsigned flags)
{
  // We rely on getOwnPropertyDescriptor not shadowing prototype properties by named
  // properties. If that changes we'll need to filter here.
  return js::GetProxyHandler(obj)->getOwnPropertyDescriptor(cx, wrapper, id, desc, flags);

}

bool
EnumerateOwnProperties(JSContext* cx, JSObject* wrapper, JSObject* obj, JS::AutoIdVector& props)
{
  // We rely on getOwnPropertyNames not shadowing prototype properties by named
  // properties. If that changes we'll need to filter here.
  return js::GetProxyHandler(obj)->getOwnPropertyNames(cx, wrapper, props);

}

JSObject*
DefineDOMInterface(JSContext* aCx, JSObject* aGlobal, bool* aEnabled)
{

  *aEnabled = true;
  return GetConstructorObject(aCx, aGlobal);
}

MOZ_ALWAYS_INLINE bool
IsProxy(JSObject* obj)
{
  return js::IsProxy(obj) && js::GetProxyHandler(obj) == DOMProxyHandler::getInstance();
}

MOZ_ALWAYS_INLINE mozilla::dom::TestIndexedDeleterInterface*
UnwrapProxy(JSObject* obj)
{
  if (xpc::WrapperFactory::IsXrayWrapper(obj)) {
    obj = js::UnwrapObject(obj);
  }
  MOZ_ASSERT(IsProxy(obj));
  return static_cast<mozilla::dom::TestIndexedDeleterInterface*>(js::GetProxyPrivate(obj).toPrivate());
}


const DOMClass Class = {
  { prototypes::id::TestIndexedDeleterInterface, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
  true,
  &sNativePropertyHooks,
  GetParentObject<mozilla::dom::TestIndexedDeleterInterface>::Get,
  GetProtoObject,
  nullptr
};



DOMProxyHandler::DOMProxyHandler()
  : mozilla::dom::DOMProxyHandler(Class)
{

}


bool
DOMProxyHandler::getOwnPropertyDescriptor(JSContext* cx, JSObject* proxy, jsid id, JSPropertyDescriptor* desc, unsigned flags)
{
  int32_t index = GetArrayIndexFromId(cx, id);
  if (!(flags & JSRESOLVE_ASSIGNING)) {
    if (IsArrayIndex(index)) {
      mozilla::dom::TestIndexedDeleterInterface* self = UnwrapProxy(proxy);
      bool found;
      int32_t result;
      result = self->IndexedGetter(index, found);

      if (found) {
        desc->value = INT_TO_JSVAL(int32_t(result));
        FillPropertyDescriptor(desc, proxy, true);
        return true;
      }
    }
  }

  JSObject* expando;
  if (!xpc::WrapperFactory::IsXrayWrapper(proxy) && (expando = GetExpandoObject(proxy))) {
    if (!JS_GetPropertyDescriptorById(cx, expando, id, flags, desc)) {
      return false;
    }
    if (desc->obj) {
      // Pretend the property lives on the wrapper.
      desc->obj = proxy;
      return true;
    }
  }

  desc->obj = NULL;
  return true;
}


bool
DOMProxyHandler::getOwnPropertyNames(JSContext* cx, JSObject* proxy, JS::AutoIdVector& props)
{
  uint32_t length = UnwrapProxy(proxy)->Length();
  MOZ_ASSERT(int32_t(length) >= 0);
  for (int32_t i = 0; i < int32_t(length); ++i) {
    if (!props.append(INT_TO_JSID(i))) {
      return false;
    }
  }

  JSObject* expando;
  if (!xpc::WrapperFactory::IsXrayWrapper(proxy) && (expando = DOMProxyHandler::GetExpandoObject(proxy)) &&
      !js::GetPropertyNames(cx, expando, JSITER_OWNONLY | JSITER_HIDDEN, &props)) {
    return false;
  }

  return true;
}


bool
DOMProxyHandler::hasOwn(JSContext* cx, JSObject* proxy, jsid id, bool* bp)
{
  int32_t index = GetArrayIndexFromId(cx, id);
  if (IsArrayIndex(index)) {
    mozilla::dom::TestIndexedDeleterInterface* self = UnwrapProxy(proxy);
    bool found;
    int32_t result;
    result = self->IndexedGetter(index, found);
    (void)result;

    *bp = found;
    return true;
  }

  JSObject* expando = GetExpandoObject(proxy);
  if (expando) {
    JSBool b = true;
    JSBool ok = JS_HasPropertyById(cx, expando, id, &b);
    *bp = !!b;
    if (!ok || *bp) {
      return ok;
    }
  }

  *bp = false;
  return true;
}


bool
DOMProxyHandler::get(JSContext* cx, JSObject* proxy, JSObject* receiver, jsid id, JS::Value* vp)
{
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
              "Should not have a XrayWrapper here");

  int32_t index = GetArrayIndexFromId(cx, id);
  if (IsArrayIndex(index)) {
    mozilla::dom::TestIndexedDeleterInterface* self = UnwrapProxy(proxy);
    bool found;
    int32_t result;
    result = self->IndexedGetter(index, found);

    if (found) {
      *vp = INT_TO_JSVAL(int32_t(result));
      return true;
    }
    // Even if we don't have this index, we don't forward the
    // get on to our expando object.
  } else {
    JSObject* expando = DOMProxyHandler::GetExpandoObject(proxy);
    if (expando) {
      JSBool hasProp;
      if (!JS_HasPropertyById(cx, expando, id, &hasProp)) {
        return false;
      }

      if (hasProp) {
        return JS_GetPropertyById(cx, expando, id, vp);
      }
    }
  }

  {  // Scope for this "found" so it doesn't leak to things below
    bool found;
    if (!GetPropertyOnPrototype(cx, proxy, id, &found, vp)) {
      return false;
    }

    if (found) {
      return true;
    }
  }

  vp->setUndefined();
  return true;
}


JSString*
DOMProxyHandler::obj_toString(JSContext* cx, JSObject* proxy)
{
  return mozilla::dom::DOMProxyHandler::obj_toString(cx, "TestIndexedDeleterInterface");
}


void
DOMProxyHandler::finalize(JSFreeOp* fop, JSObject* proxy)
{
  mozilla::dom::TestIndexedDeleterInterface* self = UnwrapProxy(proxy);

  if (self) {
    ClearWrapper(self, self);
    XPCJSRuntime *rt = nsXPConnect::GetRuntimeInstance();
    if (rt) {
      rt->DeferredRelease(reinterpret_cast<nsISupports*>(self));
    } else {
      NS_RELEASE(self);
    }
  }
}


bool
DOMProxyHandler::getElementIfPresent(JSContext* cx, JSObject* proxy, JSObject* receiver, uint32_t index, JS::Value* vp, bool* present)
{
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
               "Should not have a XrayWrapper here");

  mozilla::dom::TestIndexedDeleterInterface* self = UnwrapProxy(proxy);
  bool found;
  int32_t result;
  result = self->IndexedGetter(index, found);

  if (found) {
    *vp = INT_TO_JSVAL(int32_t(result));
    *present = found;
    return true;
  }
  // We skip the expando object and any named getters if
  // there is an indexed getter.


  JSObject *proto;
  if (!js::GetObjectProto(cx, proxy, &proto)) {
    return false;
  }
  if (proto) {
    JSBool isPresent;
    if (!JS_GetElementIfPresent(cx, proto, index, proxy, vp, &isPresent)) {
      return false;
    }
    *present = isPresent;
    return true;
  }

  *present = false;
  // Can't Debug_SetValueRangeToCrashOnTouch because it's not public
  return true;
}


DOMProxyHandler*
DOMProxyHandler::getInstance()
{
  static DOMProxyHandler instance;
  return &instance;
}


bool
DOMProxyHandler::delete_(JSContext* cx, JSObject* proxy, jsid id, bool* bp)
{
  int32_t index = GetArrayIndexFromId(cx, id);
  if (IsArrayIndex(index)) {
    uint32_t idx = index;
    mozilla::dom::TestIndexedDeleterInterface* self = UnwrapProxy(proxy);
    bool found;
    self->IndexedDeleter(idx, found);
    *bp = true;
    // We always return here, even if the property was not found
    return true;
  }
  return dom::DOMProxyHandler::delete_(cx, proxy, id, bp);
}


bool
Is(JSObject* obj)
{
  return IsProxy(obj);
}

JSObject*
Wrap(JSContext* aCx, JSObject* aScope, mozilla::dom::TestIndexedDeleterInterface* aObject, nsWrapperCache* aCache, bool* aTriedToWrap)
{
  MOZ_ASSERT(static_cast<mozilla::dom::TestIndexedDeleterInterface*>(aObject) ==
             reinterpret_cast<mozilla::dom::TestIndexedDeleterInterface*>(aObject));

  *aTriedToWrap = true;

  JSObject* parent = WrapNativeParent(aCx, aScope, aObject->GetParentObject());
  if (!parent) {
    return NULL;
  }

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.  Scope so we don't
  // collide with the "obj" we declare in CreateBindingJSObject.
  {
    JSObject* obj = aCache->GetWrapper();
    if (obj) {
      return obj;
    }
  }

  JSAutoCompartment ac(aCx, parent);
  JSObject* global = JS_GetGlobalForObject(aCx, parent);

  JSObject* proto = GetProtoObject(aCx, global);
  if (!proto) {
    return NULL;
  }

  JSObject *obj = NewProxyObject(aCx, DOMProxyHandler::getInstance(),
                                 JS::PrivateValue(aObject), proto, parent);
  if (!obj) {
    return NULL;
  }

  NS_ADDREF(aObject);


  aCache->SetWrapper(obj);

  return obj;
}

} // namespace TestIndexedDeleterInterfaceBinding



namespace TestIndexedDeleterWithRetvalInterfaceBinding {

static bool
delItem(JSContext* cx, JSHandleObject obj, mozilla::dom::TestIndexedDeleterWithRetvalInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestIndexedDeleterWithRetvalInterface.delItem");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  bool result;
  result = self->DelItem(arg0);
  *vp = BOOLEAN_TO_JSVAL(result);
  return true;
}


const JSJitInfo delItem_methodinfo = {
  (JSJitPropertyOp)delItem,
  prototypes::id::TestIndexedDeleterWithRetvalInterface,
  PrototypeTraits<prototypes::id::TestIndexedDeleterWithRetvalInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

static JSBool
genericMethod(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  mozilla::dom::TestIndexedDeleterWithRetvalInterface* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::TestIndexedDeleterWithRetvalInterface, mozilla::dom::TestIndexedDeleterWithRetvalInterface>(cx, obj, self);
    if (NS_FAILED(rv)) {
      return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestIndexedDeleterWithRetvalInterface");
    }
  }
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Method);
  JSJitMethodOp method = (JSJitMethodOp)info->op;
  return method(cx, obj, self, argc, vp);
}

static JSFunctionSpec sMethods_specs[] = {
  JS_FNINFO("delItem", genericMethod, &delItem_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FS_END
};

static Prefable<JSFunctionSpec> sMethods[] = {
  { true, &sMethods_specs[0] },
  { false, NULL }
};

static jsid sMethods_ids[2] = { JSID_VOID };

static JSFunctionSpec sChromeMethods_specs[] = {
  JS_FNINFO("QueryInterface", QueryInterface, nullptr, 1, 0),
  JS_FS_END
};

static Prefable<JSFunctionSpec> sChromeMethods[] = {
  { true, &sChromeMethods_specs[0] },
  { false, NULL }
};

static jsid sChromeMethods_ids[2] = { JSID_VOID };


static const NativeProperties sNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sMethods, sMethods_ids, sMethods_specs,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr
};

static const NativeProperties sChromeOnlyNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sChromeMethods, sChromeMethods_ids, sChromeMethods_specs,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr
};
const NativePropertyHooks sNativePropertyHooks = {
  ResolveOwnProperty,
  EnumerateOwnProperties,
  { &sNativeProperties, &sChromeOnlyNativeProperties },
  prototypes::id::TestIndexedDeleterWithRetvalInterface,
  constructors::id::TestIndexedDeleterWithRetvalInterface,
  NULL
};

JSNativeHolder _constructor_holder = {
  ThrowingConstructor,
  &sNativePropertyHooks
};

static DOMIfaceAndProtoJSClass PrototypeClass = {
  {
    "TestIndexedDeleterWithRetvalInterfacePrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(2),
    JS_PropertyStub,       /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    nullptr,               /* finalize */
    nullptr,               /* checkAccess */
    nullptr,               /* call */
    nullptr,               /* hasInstance */
    nullptr,               /* construct */
    nullptr,               /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  eInterfacePrototype,
  &sNativePropertyHooks
};

void
CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray)
{
  JSObject* parentProto = JS_GetObjectPrototype(aCx, aGlobal);
  if (!parentProto) {
    return;
  }


  if (sChromeMethods_ids[0] == JSID_VOID &&
      (!InitIds(aCx, sChromeMethods, sChromeMethods_ids) ||
       !InitIds(aCx, sMethods, sMethods_ids))) {
    sChromeMethods_ids[0] = JSID_VOID;
    return;
  }

  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &PrototypeClass.mBase, &protoAndIfaceArray[prototypes::id::TestIndexedDeleterWithRetvalInterface],
                              nullptr, &_constructor_holder, 0, &protoAndIfaceArray[constructors::id::TestIndexedDeleterWithRetvalInterface],
                              &Class,
                              &sNativeProperties,
                              xpc::AccessCheck::isChrome(aGlobal) ? &sChromeOnlyNativeProperties : nullptr,
                              "TestIndexedDeleterWithRetvalInterface");
}

bool
ResolveOwnProperty(JSContext* cx, JSObject* wrapper, JSObject* obj, jsid id, JSPropertyDescriptor* desc, unsigned flags)
{
  // We rely on getOwnPropertyDescriptor not shadowing prototype properties by named
  // properties. If that changes we'll need to filter here.
  return js::GetProxyHandler(obj)->getOwnPropertyDescriptor(cx, wrapper, id, desc, flags);

}

bool
EnumerateOwnProperties(JSContext* cx, JSObject* wrapper, JSObject* obj, JS::AutoIdVector& props)
{
  // We rely on getOwnPropertyNames not shadowing prototype properties by named
  // properties. If that changes we'll need to filter here.
  return js::GetProxyHandler(obj)->getOwnPropertyNames(cx, wrapper, props);

}

JSObject*
DefineDOMInterface(JSContext* aCx, JSObject* aGlobal, bool* aEnabled)
{

  *aEnabled = true;
  return GetConstructorObject(aCx, aGlobal);
}

MOZ_ALWAYS_INLINE bool
IsProxy(JSObject* obj)
{
  return js::IsProxy(obj) && js::GetProxyHandler(obj) == DOMProxyHandler::getInstance();
}

MOZ_ALWAYS_INLINE mozilla::dom::TestIndexedDeleterWithRetvalInterface*
UnwrapProxy(JSObject* obj)
{
  if (xpc::WrapperFactory::IsXrayWrapper(obj)) {
    obj = js::UnwrapObject(obj);
  }
  MOZ_ASSERT(IsProxy(obj));
  return static_cast<mozilla::dom::TestIndexedDeleterWithRetvalInterface*>(js::GetProxyPrivate(obj).toPrivate());
}


const DOMClass Class = {
  { prototypes::id::TestIndexedDeleterWithRetvalInterface, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
  true,
  &sNativePropertyHooks,
  GetParentObject<mozilla::dom::TestIndexedDeleterWithRetvalInterface>::Get,
  GetProtoObject,
  nullptr
};



DOMProxyHandler::DOMProxyHandler()
  : mozilla::dom::DOMProxyHandler(Class)
{

}


bool
DOMProxyHandler::getOwnPropertyDescriptor(JSContext* cx, JSObject* proxy, jsid id, JSPropertyDescriptor* desc, unsigned flags)
{
  int32_t index = GetArrayIndexFromId(cx, id);
  if (!(flags & JSRESOLVE_ASSIGNING)) {
    if (IsArrayIndex(index)) {
      mozilla::dom::TestIndexedDeleterWithRetvalInterface* self = UnwrapProxy(proxy);
      bool found;
      int32_t result;
      result = self->IndexedGetter(index, found);

      if (found) {
        desc->value = INT_TO_JSVAL(int32_t(result));
        FillPropertyDescriptor(desc, proxy, true);
        return true;
      }
    }
  }

  JSObject* expando;
  if (!xpc::WrapperFactory::IsXrayWrapper(proxy) && (expando = GetExpandoObject(proxy))) {
    if (!JS_GetPropertyDescriptorById(cx, expando, id, flags, desc)) {
      return false;
    }
    if (desc->obj) {
      // Pretend the property lives on the wrapper.
      desc->obj = proxy;
      return true;
    }
  }

  desc->obj = NULL;
  return true;
}


bool
DOMProxyHandler::getOwnPropertyNames(JSContext* cx, JSObject* proxy, JS::AutoIdVector& props)
{
  uint32_t length = UnwrapProxy(proxy)->Length();
  MOZ_ASSERT(int32_t(length) >= 0);
  for (int32_t i = 0; i < int32_t(length); ++i) {
    if (!props.append(INT_TO_JSID(i))) {
      return false;
    }
  }

  JSObject* expando;
  if (!xpc::WrapperFactory::IsXrayWrapper(proxy) && (expando = DOMProxyHandler::GetExpandoObject(proxy)) &&
      !js::GetPropertyNames(cx, expando, JSITER_OWNONLY | JSITER_HIDDEN, &props)) {
    return false;
  }

  return true;
}


bool
DOMProxyHandler::hasOwn(JSContext* cx, JSObject* proxy, jsid id, bool* bp)
{
  int32_t index = GetArrayIndexFromId(cx, id);
  if (IsArrayIndex(index)) {
    mozilla::dom::TestIndexedDeleterWithRetvalInterface* self = UnwrapProxy(proxy);
    bool found;
    int32_t result;
    result = self->IndexedGetter(index, found);
    (void)result;

    *bp = found;
    return true;
  }

  JSObject* expando = GetExpandoObject(proxy);
  if (expando) {
    JSBool b = true;
    JSBool ok = JS_HasPropertyById(cx, expando, id, &b);
    *bp = !!b;
    if (!ok || *bp) {
      return ok;
    }
  }

  *bp = false;
  return true;
}


bool
DOMProxyHandler::get(JSContext* cx, JSObject* proxy, JSObject* receiver, jsid id, JS::Value* vp)
{
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
              "Should not have a XrayWrapper here");

  int32_t index = GetArrayIndexFromId(cx, id);
  if (IsArrayIndex(index)) {
    mozilla::dom::TestIndexedDeleterWithRetvalInterface* self = UnwrapProxy(proxy);
    bool found;
    int32_t result;
    result = self->IndexedGetter(index, found);

    if (found) {
      *vp = INT_TO_JSVAL(int32_t(result));
      return true;
    }
    // Even if we don't have this index, we don't forward the
    // get on to our expando object.
  } else {
    JSObject* expando = DOMProxyHandler::GetExpandoObject(proxy);
    if (expando) {
      JSBool hasProp;
      if (!JS_HasPropertyById(cx, expando, id, &hasProp)) {
        return false;
      }

      if (hasProp) {
        return JS_GetPropertyById(cx, expando, id, vp);
      }
    }
  }

  {  // Scope for this "found" so it doesn't leak to things below
    bool found;
    if (!GetPropertyOnPrototype(cx, proxy, id, &found, vp)) {
      return false;
    }

    if (found) {
      return true;
    }
  }

  vp->setUndefined();
  return true;
}


JSString*
DOMProxyHandler::obj_toString(JSContext* cx, JSObject* proxy)
{
  return mozilla::dom::DOMProxyHandler::obj_toString(cx, "TestIndexedDeleterWithRetvalInterface");
}


void
DOMProxyHandler::finalize(JSFreeOp* fop, JSObject* proxy)
{
  mozilla::dom::TestIndexedDeleterWithRetvalInterface* self = UnwrapProxy(proxy);

  if (self) {
    ClearWrapper(self, self);
    XPCJSRuntime *rt = nsXPConnect::GetRuntimeInstance();
    if (rt) {
      rt->DeferredRelease(reinterpret_cast<nsISupports*>(self));
    } else {
      NS_RELEASE(self);
    }
  }
}


bool
DOMProxyHandler::getElementIfPresent(JSContext* cx, JSObject* proxy, JSObject* receiver, uint32_t index, JS::Value* vp, bool* present)
{
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
               "Should not have a XrayWrapper here");

  mozilla::dom::TestIndexedDeleterWithRetvalInterface* self = UnwrapProxy(proxy);
  bool found;
  int32_t result;
  result = self->IndexedGetter(index, found);

  if (found) {
    *vp = INT_TO_JSVAL(int32_t(result));
    *present = found;
    return true;
  }
  // We skip the expando object and any named getters if
  // there is an indexed getter.


  JSObject *proto;
  if (!js::GetObjectProto(cx, proxy, &proto)) {
    return false;
  }
  if (proto) {
    JSBool isPresent;
    if (!JS_GetElementIfPresent(cx, proto, index, proxy, vp, &isPresent)) {
      return false;
    }
    *present = isPresent;
    return true;
  }

  *present = false;
  // Can't Debug_SetValueRangeToCrashOnTouch because it's not public
  return true;
}


DOMProxyHandler*
DOMProxyHandler::getInstance()
{
  static DOMProxyHandler instance;
  return &instance;
}


bool
DOMProxyHandler::delete_(JSContext* cx, JSObject* proxy, jsid id, bool* bp)
{
  int32_t index = GetArrayIndexFromId(cx, id);
  if (IsArrayIndex(index)) {
    mozilla::dom::TestIndexedDeleterWithRetvalInterface* self = UnwrapProxy(proxy);
    bool found;
    bool result;
    result = self->IndexedDeleter(index, found);
    if (found) {
      // XXXbz we should throw as needed if Throw is true
      *bp = result;
    } else {
      *bp = true;
    }
    // We always return here, even if the property was not found
    return true;
  }
  return dom::DOMProxyHandler::delete_(cx, proxy, id, bp);
}


bool
Is(JSObject* obj)
{
  return IsProxy(obj);
}

JSObject*
Wrap(JSContext* aCx, JSObject* aScope, mozilla::dom::TestIndexedDeleterWithRetvalInterface* aObject, nsWrapperCache* aCache, bool* aTriedToWrap)
{
  MOZ_ASSERT(static_cast<mozilla::dom::TestIndexedDeleterWithRetvalInterface*>(aObject) ==
             reinterpret_cast<mozilla::dom::TestIndexedDeleterWithRetvalInterface*>(aObject));

  *aTriedToWrap = true;

  JSObject* parent = WrapNativeParent(aCx, aScope, aObject->GetParentObject());
  if (!parent) {
    return NULL;
  }

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.  Scope so we don't
  // collide with the "obj" we declare in CreateBindingJSObject.
  {
    JSObject* obj = aCache->GetWrapper();
    if (obj) {
      return obj;
    }
  }

  JSAutoCompartment ac(aCx, parent);
  JSObject* global = JS_GetGlobalForObject(aCx, parent);

  JSObject* proto = GetProtoObject(aCx, global);
  if (!proto) {
    return NULL;
  }

  JSObject *obj = NewProxyObject(aCx, DOMProxyHandler::getInstance(),
                                 JS::PrivateValue(aObject), proto, parent);
  if (!obj) {
    return NULL;
  }

  NS_ADDREF(aObject);


  aCache->SetWrapper(obj);

  return obj;
}

} // namespace TestIndexedDeleterWithRetvalInterfaceBinding



namespace TestIndexedGetterAndSetterAndNamedGetterInterfaceBinding {

static JSFunctionSpec sChromeMethods_specs[] = {
  JS_FNINFO("QueryInterface", QueryInterface, nullptr, 1, 0),
  JS_FS_END
};

static Prefable<JSFunctionSpec> sChromeMethods[] = {
  { true, &sChromeMethods_specs[0] },
  { false, NULL }
};

static jsid sChromeMethods_ids[2] = { JSID_VOID };


static const NativeProperties sChromeOnlyNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sChromeMethods, sChromeMethods_ids, sChromeMethods_specs,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr
};
const NativePropertyHooks sNativePropertyHooks = {
  ResolveOwnProperty,
  EnumerateOwnProperties,
  { nullptr, &sChromeOnlyNativeProperties },
  prototypes::id::TestIndexedGetterAndSetterAndNamedGetterInterface,
  constructors::id::TestIndexedGetterAndSetterAndNamedGetterInterface,
  NULL
};

JSNativeHolder _constructor_holder = {
  ThrowingConstructor,
  &sNativePropertyHooks
};

static DOMIfaceAndProtoJSClass PrototypeClass = {
  {
    "TestIndexedGetterAndSetterAndNamedGetterInterfacePrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(2),
    JS_PropertyStub,       /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    nullptr,               /* finalize */
    nullptr,               /* checkAccess */
    nullptr,               /* call */
    nullptr,               /* hasInstance */
    nullptr,               /* construct */
    nullptr,               /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  eInterfacePrototype,
  &sNativePropertyHooks
};

void
CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray)
{
  JSObject* parentProto = JS_GetObjectPrototype(aCx, aGlobal);
  if (!parentProto) {
    return;
  }


  if (sChromeMethods_ids[0] == JSID_VOID &&
      !InitIds(aCx, sChromeMethods, sChromeMethods_ids)) {
    sChromeMethods_ids[0] = JSID_VOID;
    return;
  }

  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &PrototypeClass.mBase, &protoAndIfaceArray[prototypes::id::TestIndexedGetterAndSetterAndNamedGetterInterface],
                              nullptr, &_constructor_holder, 0, &protoAndIfaceArray[constructors::id::TestIndexedGetterAndSetterAndNamedGetterInterface],
                              &Class,
                              nullptr,
                              xpc::AccessCheck::isChrome(aGlobal) ? &sChromeOnlyNativeProperties : nullptr,
                              "TestIndexedGetterAndSetterAndNamedGetterInterface");
}

bool
ResolveOwnProperty(JSContext* cx, JSObject* wrapper, JSObject* obj, jsid id, JSPropertyDescriptor* desc, unsigned flags)
{
  // We rely on getOwnPropertyDescriptor not shadowing prototype properties by named
  // properties. If that changes we'll need to filter here.
  return js::GetProxyHandler(obj)->getOwnPropertyDescriptor(cx, wrapper, id, desc, flags);

}

bool
EnumerateOwnProperties(JSContext* cx, JSObject* wrapper, JSObject* obj, JS::AutoIdVector& props)
{
  // We rely on getOwnPropertyNames not shadowing prototype properties by named
  // properties. If that changes we'll need to filter here.
  return js::GetProxyHandler(obj)->getOwnPropertyNames(cx, wrapper, props);

}

JSObject*
DefineDOMInterface(JSContext* aCx, JSObject* aGlobal, bool* aEnabled)
{

  *aEnabled = true;
  return GetConstructorObject(aCx, aGlobal);
}

MOZ_ALWAYS_INLINE bool
IsProxy(JSObject* obj)
{
  return js::IsProxy(obj) && js::GetProxyHandler(obj) == DOMProxyHandler::getInstance();
}

MOZ_ALWAYS_INLINE mozilla::dom::TestIndexedGetterAndSetterAndNamedGetterInterface*
UnwrapProxy(JSObject* obj)
{
  if (xpc::WrapperFactory::IsXrayWrapper(obj)) {
    obj = js::UnwrapObject(obj);
  }
  MOZ_ASSERT(IsProxy(obj));
  return static_cast<mozilla::dom::TestIndexedGetterAndSetterAndNamedGetterInterface*>(js::GetProxyPrivate(obj).toPrivate());
}


const DOMClass Class = {
  { prototypes::id::TestIndexedGetterAndSetterAndNamedGetterInterface, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
  true,
  &sNativePropertyHooks,
  GetParentObject<mozilla::dom::TestIndexedGetterAndSetterAndNamedGetterInterface>::Get,
  GetProtoObject,
  nullptr
};



DOMProxyHandler::DOMProxyHandler()
  : mozilla::dom::DOMProxyHandler(Class)
{

}


bool
DOMProxyHandler::getOwnPropertyDescriptor(JSContext* cx, JSObject* proxy, jsid id, JSPropertyDescriptor* desc, unsigned flags)
{
  int32_t index = GetArrayIndexFromId(cx, id);
  if (flags & JSRESOLVE_ASSIGNING) {
    if (IsArrayIndex(index)) {
      FillPropertyDescriptor(desc, proxy, JSVAL_VOID, false);
      return true;
    }
  } else {
    if (IsArrayIndex(index)) {
      mozilla::dom::TestIndexedGetterAndSetterAndNamedGetterInterface* self = UnwrapProxy(proxy);
      bool found;
      int32_t result;
      result = self->IndexedGetter(index, found);

      if (found) {
        desc->value = INT_TO_JSVAL(int32_t(result));
        FillPropertyDescriptor(desc, proxy, false);
        return true;
      }
    }
  }

  JSObject* expando;
  if (!xpc::WrapperFactory::IsXrayWrapper(proxy) && (expando = GetExpandoObject(proxy))) {
    if (!JS_GetPropertyDescriptorById(cx, expando, id, flags, desc)) {
      return false;
    }
    if (desc->obj) {
      // Pretend the property lives on the wrapper.
      desc->obj = proxy;
      return true;
    }
  }

  if (!IsArrayIndex(index) && !(flags & JSRESOLVE_ASSIGNING) && !HasPropertyOnPrototype(cx, proxy, this, id)) {
    JS::Value nameVal = js::IdToValue(id);
    FakeDependentString myName;
    if (!ConvertJSValueToString(cx, nameVal, &nameVal,
                                eStringify, eStringify, myName)) {
      return false;
    }

    mozilla::dom::TestIndexedGetterAndSetterAndNamedGetterInterface* self = UnwrapProxy(proxy);
    bool found;
    nsString result;
    self->NamedGetter(myName, found, result);

    if (found) {
      if (!xpc::NonVoidStringToJsval(cx, result, &desc->value)) {
        return false;
      }
      FillPropertyDescriptor(desc, proxy, true);
      return true;
    }
  }

  desc->obj = NULL;
  return true;
}


bool
DOMProxyHandler::defineProperty(JSContext* cx, JSObject* proxy, jsid id, JSPropertyDescriptor* desc)
{
  int32_t index = GetArrayIndexFromId(cx, id);
  if (IsArrayIndex(index)) {
    mozilla::dom::TestIndexedGetterAndSetterAndNamedGetterInterface* self = UnwrapProxy(proxy);
    int32_t arg;
    if (!ValueToPrimitive<int32_t, eDefault>(cx, desc->value, &arg)) {
      return false;
    }
    self->IndexedSetter(index, arg);
    return true;
  }
  JS::Value nameVal = js::IdToValue(id);
  FakeDependentString myName;
  if (!ConvertJSValueToString(cx, nameVal, &nameVal,
                              eStringify, eStringify, myName)) {
    return false;
  }

  mozilla::dom::TestIndexedGetterAndSetterAndNamedGetterInterface* self = UnwrapProxy(proxy);
  bool found;
  nsString result;
  self->NamedGetter(myName, found, result);
  (void)result;

  if (found) {
    return ThrowErrorMessage(cx, MSG_NO_PROPERTY_SETTER, "TestIndexedGetterAndSetterAndNamedGetterInterface");
  }return mozilla::dom::DOMProxyHandler::defineProperty(cx, proxy, id, desc);
}


bool
DOMProxyHandler::getOwnPropertyNames(JSContext* cx, JSObject* proxy, JS::AutoIdVector& props)
{
  uint32_t length = UnwrapProxy(proxy)->Length();
  MOZ_ASSERT(int32_t(length) >= 0);
  for (int32_t i = 0; i < int32_t(length); ++i) {
    if (!props.append(INT_TO_JSID(i))) {
      return false;
    }
  }

  nsTArray<nsString> names;
  UnwrapProxy(proxy)->GetSupportedNames(names);
  if (!AppendNamedPropertyIds(cx, proxy, names, props)) {
    return false;
  }

  JSObject* expando;
  if (!xpc::WrapperFactory::IsXrayWrapper(proxy) && (expando = DOMProxyHandler::GetExpandoObject(proxy)) &&
      !js::GetPropertyNames(cx, expando, JSITER_OWNONLY | JSITER_HIDDEN, &props)) {
    return false;
  }

  return true;
}


bool
DOMProxyHandler::hasOwn(JSContext* cx, JSObject* proxy, jsid id, bool* bp)
{
  int32_t index = GetArrayIndexFromId(cx, id);
  if (IsArrayIndex(index)) {
    mozilla::dom::TestIndexedGetterAndSetterAndNamedGetterInterface* self = UnwrapProxy(proxy);
    bool found;
    int32_t result;
    result = self->IndexedGetter(index, found);
    (void)result;

    *bp = found;
    return true;
  }

  JSObject* expando = GetExpandoObject(proxy);
  if (expando) {
    JSBool b = true;
    JSBool ok = JS_HasPropertyById(cx, expando, id, &b);
    *bp = !!b;
    if (!ok || *bp) {
      return ok;
    }
  }

  if (!HasPropertyOnPrototype(cx, proxy, this, id)) {
    JS::Value nameVal = js::IdToValue(id);
    FakeDependentString myName;
    if (!ConvertJSValueToString(cx, nameVal, &nameVal,
                                eStringify, eStringify, myName)) {
      return false;
    }

    mozilla::dom::TestIndexedGetterAndSetterAndNamedGetterInterface* self = UnwrapProxy(proxy);
    bool found;
    nsString result;
    self->NamedGetter(myName, found, result);
    (void)result;

    *bp = found;
    return true;
  }

  *bp = false;
  return true;
}


bool
DOMProxyHandler::get(JSContext* cx, JSObject* proxy, JSObject* receiver, jsid id, JS::Value* vp)
{
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
              "Should not have a XrayWrapper here");

  int32_t index = GetArrayIndexFromId(cx, id);
  if (IsArrayIndex(index)) {
    mozilla::dom::TestIndexedGetterAndSetterAndNamedGetterInterface* self = UnwrapProxy(proxy);
    bool found;
    int32_t result;
    result = self->IndexedGetter(index, found);

    if (found) {
      *vp = INT_TO_JSVAL(int32_t(result));
      return true;
    }
    // Even if we don't have this index, we don't forward the
    // get on to our expando object.
  } else {
    JSObject* expando = DOMProxyHandler::GetExpandoObject(proxy);
    if (expando) {
      JSBool hasProp;
      if (!JS_HasPropertyById(cx, expando, id, &hasProp)) {
        return false;
      }

      if (hasProp) {
        return JS_GetPropertyById(cx, expando, id, vp);
      }
    }
  }

  {  // Scope for this "found" so it doesn't leak to things below
    bool found;
    if (!GetPropertyOnPrototype(cx, proxy, id, &found, vp)) {
      return false;
    }

    if (found) {
      return true;
    }
  }
  if (!IsArrayIndex(index)) {
    JS::Value nameVal = js::IdToValue(id);
    FakeDependentString myName;
    if (!ConvertJSValueToString(cx, nameVal, &nameVal,
                                eStringify, eStringify, myName)) {
      return false;
    }

    mozilla::dom::TestIndexedGetterAndSetterAndNamedGetterInterface* self = UnwrapProxy(proxy);
    bool found;
    nsString result;
    self->NamedGetter(myName, found, result);

    if (found) {
      if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
        return false;
      }
      return true;
    }
  }

  vp->setUndefined();
  return true;
}


JSString*
DOMProxyHandler::obj_toString(JSContext* cx, JSObject* proxy)
{
  return mozilla::dom::DOMProxyHandler::obj_toString(cx, "TestIndexedGetterAndSetterAndNamedGetterInterface");
}


void
DOMProxyHandler::finalize(JSFreeOp* fop, JSObject* proxy)
{
  mozilla::dom::TestIndexedGetterAndSetterAndNamedGetterInterface* self = UnwrapProxy(proxy);

  if (self) {
    ClearWrapper(self, self);
    XPCJSRuntime *rt = nsXPConnect::GetRuntimeInstance();
    if (rt) {
      rt->DeferredRelease(reinterpret_cast<nsISupports*>(self));
    } else {
      NS_RELEASE(self);
    }
  }
}


bool
DOMProxyHandler::getElementIfPresent(JSContext* cx, JSObject* proxy, JSObject* receiver, uint32_t index, JS::Value* vp, bool* present)
{
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
               "Should not have a XrayWrapper here");

  mozilla::dom::TestIndexedGetterAndSetterAndNamedGetterInterface* self = UnwrapProxy(proxy);
  bool found;
  int32_t result;
  result = self->IndexedGetter(index, found);

  if (found) {
    *vp = INT_TO_JSVAL(int32_t(result));
    *present = found;
    return true;
  }
  // We skip the expando object and any named getters if
  // there is an indexed getter.


  JSObject *proto;
  if (!js::GetObjectProto(cx, proxy, &proto)) {
    return false;
  }
  if (proto) {
    JSBool isPresent;
    if (!JS_GetElementIfPresent(cx, proto, index, proxy, vp, &isPresent)) {
      return false;
    }
    *present = isPresent;
    return true;
  }

  *present = false;
  // Can't Debug_SetValueRangeToCrashOnTouch because it's not public
  return true;
}


DOMProxyHandler*
DOMProxyHandler::getInstance()
{
  static DOMProxyHandler instance;
  return &instance;
}


bool
DOMProxyHandler::delete_(JSContext* cx, JSObject* proxy, jsid id, bool* bp)
{
  int32_t index = GetArrayIndexFromId(cx, id);
  if (IsArrayIndex(index)) {
    mozilla::dom::TestIndexedGetterAndSetterAndNamedGetterInterface* self = UnwrapProxy(proxy);
    bool found;
    int32_t result;
    result = self->IndexedGetter(index, found);
    (void)result;
    if (found) {
      // XXXbz we should throw if Throw is true!
      *bp = false;
    } else {
      *bp = true;
    }
    // We always return here, even if the property was not found
    return true;
  }
  if (!HasPropertyOnPrototype(cx, proxy, this, id)) {
    JS::Value nameVal = js::IdToValue(id);
    FakeDependentString myName;
    if (!ConvertJSValueToString(cx, nameVal, &nameVal,
                                eStringify, eStringify, myName)) {
      return false;
    }

    mozilla::dom::TestIndexedGetterAndSetterAndNamedGetterInterface* self = UnwrapProxy(proxy);
    bool found;
    nsString result;
    self->NamedGetter(myName, found, result);
    (void)result;
    if (found) {
      // XXXbz we should throw if Throw is true!
      *bp = false;
    } else {
      *bp = true;
    }
    if (found) {
      return true;
    }
  }
  return dom::DOMProxyHandler::delete_(cx, proxy, id, bp);
}


bool
Is(JSObject* obj)
{
  return IsProxy(obj);
}

JSObject*
Wrap(JSContext* aCx, JSObject* aScope, mozilla::dom::TestIndexedGetterAndSetterAndNamedGetterInterface* aObject, nsWrapperCache* aCache, bool* aTriedToWrap)
{
  MOZ_ASSERT(static_cast<mozilla::dom::TestIndexedGetterAndSetterAndNamedGetterInterface*>(aObject) ==
             reinterpret_cast<mozilla::dom::TestIndexedGetterAndSetterAndNamedGetterInterface*>(aObject));

  *aTriedToWrap = true;

  JSObject* parent = WrapNativeParent(aCx, aScope, aObject->GetParentObject());
  if (!parent) {
    return NULL;
  }

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.  Scope so we don't
  // collide with the "obj" we declare in CreateBindingJSObject.
  {
    JSObject* obj = aCache->GetWrapper();
    if (obj) {
      return obj;
    }
  }

  JSAutoCompartment ac(aCx, parent);
  JSObject* global = JS_GetGlobalForObject(aCx, parent);

  JSObject* proto = GetProtoObject(aCx, global);
  if (!proto) {
    return NULL;
  }

  JSObject *obj = NewProxyObject(aCx, DOMProxyHandler::getInstance(),
                                 JS::PrivateValue(aObject), proto, parent);
  if (!obj) {
    return NULL;
  }

  NS_ADDREF(aObject);


  aCache->SetWrapper(obj);

  return obj;
}

} // namespace TestIndexedGetterAndSetterAndNamedGetterInterfaceBinding



namespace TestIndexedGetterInterfaceBinding {

static bool
item(JSContext* cx, JSHandleObject obj, mozilla::dom::TestIndexedGetterInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestIndexedGetterInterface.item");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  int32_t result;
  result = self->Item(arg0);
  *vp = INT_TO_JSVAL(int32_t(result));
  return true;
}


const JSJitInfo item_methodinfo = {
  (JSJitPropertyOp)item,
  prototypes::id::TestIndexedGetterInterface,
  PrototypeTraits<prototypes::id::TestIndexedGetterInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_length(JSContext* cx, JSHandleObject obj, mozilla::dom::TestIndexedGetterInterface* self, JS::Value* vp)
{
  uint32_t result;
  result = self->Length();
  *vp = UINT_TO_JSVAL(result);
  return true;
}


const JSJitInfo length_getterinfo = {
  (JSJitPropertyOp)get_length,
  prototypes::id::TestIndexedGetterInterface,
  PrototypeTraits<prototypes::id::TestIndexedGetterInterface>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

static JSBool
genericMethod(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  mozilla::dom::TestIndexedGetterInterface* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::TestIndexedGetterInterface, mozilla::dom::TestIndexedGetterInterface>(cx, obj, self);
    if (NS_FAILED(rv)) {
      return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestIndexedGetterInterface");
    }
  }
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Method);
  JSJitMethodOp method = (JSJitMethodOp)info->op;
  return method(cx, obj, self, argc, vp);
}

static JSBool
genericGetter(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  mozilla::dom::TestIndexedGetterInterface* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::TestIndexedGetterInterface, mozilla::dom::TestIndexedGetterInterface>(cx, obj, self);
    if (NS_FAILED(rv)) {
      return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestIndexedGetterInterface");
    }
  }
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Getter);
  JSJitPropertyOp getter = info->op;
  return getter(cx, obj, self, vp);
}

static JSFunctionSpec sMethods_specs[] = {
  JS_FNINFO("item", genericMethod, &item_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("iterator", JS_ArrayIterator, nullptr, 0, JSPROP_ENUMERATE),
  JS_FS_END
};

static Prefable<JSFunctionSpec> sMethods[] = {
  { true, &sMethods_specs[0] },
  { false, NULL }
};

static jsid sMethods_ids[3] = { JSID_VOID };

static JSFunctionSpec sChromeMethods_specs[] = {
  JS_FNINFO("QueryInterface", QueryInterface, nullptr, 1, 0),
  JS_FS_END
};

static Prefable<JSFunctionSpec> sChromeMethods[] = {
  { true, &sChromeMethods_specs[0] },
  { false, NULL }
};

static jsid sChromeMethods_ids[2] = { JSID_VOID };

static JSPropertySpec sAttributes_specs[] = {
  { "length", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &length_getterinfo }, JSOP_NULLWRAPPER},
  { 0, 0, 0, JSOP_NULLWRAPPER, JSOP_NULLWRAPPER }
};

static Prefable<JSPropertySpec> sAttributes[] = {
  { true, &sAttributes_specs[0] },
  { false, NULL }
};

static jsid sAttributes_ids[2] = { JSID_VOID };


static const NativeProperties sNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sMethods, sMethods_ids, sMethods_specs,
  sAttributes, sAttributes_ids, sAttributes_specs,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr
};

static const NativeProperties sChromeOnlyNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sChromeMethods, sChromeMethods_ids, sChromeMethods_specs,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr
};
const NativePropertyHooks sNativePropertyHooks = {
  ResolveOwnProperty,
  EnumerateOwnProperties,
  { &sNativeProperties, &sChromeOnlyNativeProperties },
  prototypes::id::TestIndexedGetterInterface,
  constructors::id::TestIndexedGetterInterface,
  NULL
};

JSNativeHolder _constructor_holder = {
  ThrowingConstructor,
  &sNativePropertyHooks
};

static DOMIfaceAndProtoJSClass PrototypeClass = {
  {
    "TestIndexedGetterInterfacePrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(2),
    JS_PropertyStub,       /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    nullptr,               /* finalize */
    nullptr,               /* checkAccess */
    nullptr,               /* call */
    nullptr,               /* hasInstance */
    nullptr,               /* construct */
    nullptr,               /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  eInterfacePrototype,
  &sNativePropertyHooks
};

void
CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray)
{
  JSObject* parentProto = JS_GetObjectPrototype(aCx, aGlobal);
  if (!parentProto) {
    return;
  }


  if (sChromeMethods_ids[0] == JSID_VOID &&
      (!InitIds(aCx, sChromeMethods, sChromeMethods_ids) ||
       !InitIds(aCx, sMethods, sMethods_ids) ||
       !InitIds(aCx, sAttributes, sAttributes_ids))) {
    sChromeMethods_ids[0] = JSID_VOID;
    return;
  }

  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &PrototypeClass.mBase, &protoAndIfaceArray[prototypes::id::TestIndexedGetterInterface],
                              nullptr, &_constructor_holder, 0, &protoAndIfaceArray[constructors::id::TestIndexedGetterInterface],
                              &Class,
                              &sNativeProperties,
                              xpc::AccessCheck::isChrome(aGlobal) ? &sChromeOnlyNativeProperties : nullptr,
                              "TestIndexedGetterInterface");
}

bool
ResolveOwnProperty(JSContext* cx, JSObject* wrapper, JSObject* obj, jsid id, JSPropertyDescriptor* desc, unsigned flags)
{
  // We rely on getOwnPropertyDescriptor not shadowing prototype properties by named
  // properties. If that changes we'll need to filter here.
  return js::GetProxyHandler(obj)->getOwnPropertyDescriptor(cx, wrapper, id, desc, flags);

}

bool
EnumerateOwnProperties(JSContext* cx, JSObject* wrapper, JSObject* obj, JS::AutoIdVector& props)
{
  // We rely on getOwnPropertyNames not shadowing prototype properties by named
  // properties. If that changes we'll need to filter here.
  return js::GetProxyHandler(obj)->getOwnPropertyNames(cx, wrapper, props);

}

JSObject*
DefineDOMInterface(JSContext* aCx, JSObject* aGlobal, bool* aEnabled)
{

  *aEnabled = true;
  return GetConstructorObject(aCx, aGlobal);
}

MOZ_ALWAYS_INLINE bool
IsProxy(JSObject* obj)
{
  return js::IsProxy(obj) && js::GetProxyHandler(obj) == DOMProxyHandler::getInstance();
}

MOZ_ALWAYS_INLINE mozilla::dom::TestIndexedGetterInterface*
UnwrapProxy(JSObject* obj)
{
  if (xpc::WrapperFactory::IsXrayWrapper(obj)) {
    obj = js::UnwrapObject(obj);
  }
  MOZ_ASSERT(IsProxy(obj));
  return static_cast<mozilla::dom::TestIndexedGetterInterface*>(js::GetProxyPrivate(obj).toPrivate());
}


const DOMClass Class = {
  { prototypes::id::TestIndexedGetterInterface, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
  true,
  &sNativePropertyHooks,
  GetParentObject<mozilla::dom::TestIndexedGetterInterface>::Get,
  GetProtoObject,
  nullptr
};



DOMProxyHandler::DOMProxyHandler()
  : mozilla::dom::DOMProxyHandler(Class)
{

}


bool
DOMProxyHandler::getOwnPropertyDescriptor(JSContext* cx, JSObject* proxy, jsid id, JSPropertyDescriptor* desc, unsigned flags)
{
  int32_t index = GetArrayIndexFromId(cx, id);
  if (!(flags & JSRESOLVE_ASSIGNING)) {
    if (IsArrayIndex(index)) {
      uint32_t idx = index;
      mozilla::dom::TestIndexedGetterInterface* self = UnwrapProxy(proxy);
      bool found;
      int32_t result;
      result = self->IndexedGetter(idx, found);

      if (found) {
        desc->value = INT_TO_JSVAL(int32_t(result));
        FillPropertyDescriptor(desc, proxy, true);
        return true;
      }
    }
  }

  JSObject* expando;
  if (!xpc::WrapperFactory::IsXrayWrapper(proxy) && (expando = GetExpandoObject(proxy))) {
    if (!JS_GetPropertyDescriptorById(cx, expando, id, flags, desc)) {
      return false;
    }
    if (desc->obj) {
      // Pretend the property lives on the wrapper.
      desc->obj = proxy;
      return true;
    }
  }

  desc->obj = NULL;
  return true;
}


bool
DOMProxyHandler::getOwnPropertyNames(JSContext* cx, JSObject* proxy, JS::AutoIdVector& props)
{
  uint32_t length = UnwrapProxy(proxy)->Length();
  MOZ_ASSERT(int32_t(length) >= 0);
  for (int32_t i = 0; i < int32_t(length); ++i) {
    if (!props.append(INT_TO_JSID(i))) {
      return false;
    }
  }

  JSObject* expando;
  if (!xpc::WrapperFactory::IsXrayWrapper(proxy) && (expando = DOMProxyHandler::GetExpandoObject(proxy)) &&
      !js::GetPropertyNames(cx, expando, JSITER_OWNONLY | JSITER_HIDDEN, &props)) {
    return false;
  }

  return true;
}


bool
DOMProxyHandler::hasOwn(JSContext* cx, JSObject* proxy, jsid id, bool* bp)
{
  int32_t index = GetArrayIndexFromId(cx, id);
  if (IsArrayIndex(index)) {
    uint32_t idx = index;
    mozilla::dom::TestIndexedGetterInterface* self = UnwrapProxy(proxy);
    bool found;
    int32_t result;
    result = self->IndexedGetter(idx, found);
    (void)result;

    *bp = found;
    return true;
  }

  JSObject* expando = GetExpandoObject(proxy);
  if (expando) {
    JSBool b = true;
    JSBool ok = JS_HasPropertyById(cx, expando, id, &b);
    *bp = !!b;
    if (!ok || *bp) {
      return ok;
    }
  }

  *bp = false;
  return true;
}


bool
DOMProxyHandler::get(JSContext* cx, JSObject* proxy, JSObject* receiver, jsid id, JS::Value* vp)
{
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
              "Should not have a XrayWrapper here");

  int32_t index = GetArrayIndexFromId(cx, id);
  if (IsArrayIndex(index)) {
    uint32_t idx = index;
    mozilla::dom::TestIndexedGetterInterface* self = UnwrapProxy(proxy);
    bool found;
    int32_t result;
    result = self->IndexedGetter(idx, found);

    if (found) {
      *vp = INT_TO_JSVAL(int32_t(result));
      return true;
    }
    // Even if we don't have this index, we don't forward the
    // get on to our expando object.
  } else {
    JSObject* expando = DOMProxyHandler::GetExpandoObject(proxy);
    if (expando) {
      JSBool hasProp;
      if (!JS_HasPropertyById(cx, expando, id, &hasProp)) {
        return false;
      }

      if (hasProp) {
        return JS_GetPropertyById(cx, expando, id, vp);
      }
    }
  }

  {  // Scope for this "found" so it doesn't leak to things below
    bool found;
    if (!GetPropertyOnPrototype(cx, proxy, id, &found, vp)) {
      return false;
    }

    if (found) {
      return true;
    }
  }

  vp->setUndefined();
  return true;
}


JSString*
DOMProxyHandler::obj_toString(JSContext* cx, JSObject* proxy)
{
  return mozilla::dom::DOMProxyHandler::obj_toString(cx, "TestIndexedGetterInterface");
}


void
DOMProxyHandler::finalize(JSFreeOp* fop, JSObject* proxy)
{
  mozilla::dom::TestIndexedGetterInterface* self = UnwrapProxy(proxy);

  if (self) {
    ClearWrapper(self, self);
    XPCJSRuntime *rt = nsXPConnect::GetRuntimeInstance();
    if (rt) {
      rt->DeferredRelease(reinterpret_cast<nsISupports*>(self));
    } else {
      NS_RELEASE(self);
    }
  }
}


bool
DOMProxyHandler::getElementIfPresent(JSContext* cx, JSObject* proxy, JSObject* receiver, uint32_t index, JS::Value* vp, bool* present)
{
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
               "Should not have a XrayWrapper here");

  uint32_t idx = index;
  mozilla::dom::TestIndexedGetterInterface* self = UnwrapProxy(proxy);
  bool found;
  int32_t result;
  result = self->IndexedGetter(idx, found);

  if (found) {
    *vp = INT_TO_JSVAL(int32_t(result));
    *present = found;
    return true;
  }
  // We skip the expando object and any named getters if
  // there is an indexed getter.


  JSObject *proto;
  if (!js::GetObjectProto(cx, proxy, &proto)) {
    return false;
  }
  if (proto) {
    JSBool isPresent;
    if (!JS_GetElementIfPresent(cx, proto, index, proxy, vp, &isPresent)) {
      return false;
    }
    *present = isPresent;
    return true;
  }

  *present = false;
  // Can't Debug_SetValueRangeToCrashOnTouch because it's not public
  return true;
}


DOMProxyHandler*
DOMProxyHandler::getInstance()
{
  static DOMProxyHandler instance;
  return &instance;
}


bool
DOMProxyHandler::delete_(JSContext* cx, JSObject* proxy, jsid id, bool* bp)
{
  int32_t index = GetArrayIndexFromId(cx, id);
  if (IsArrayIndex(index)) {
    uint32_t idx = index;
    mozilla::dom::TestIndexedGetterInterface* self = UnwrapProxy(proxy);
    bool found;
    int32_t result;
    result = self->IndexedGetter(idx, found);
    (void)result;
    if (found) {
      // XXXbz we should throw if Throw is true!
      *bp = false;
    } else {
      *bp = true;
    }
    // We always return here, even if the property was not found
    return true;
  }
  return dom::DOMProxyHandler::delete_(cx, proxy, id, bp);
}


bool
Is(JSObject* obj)
{
  return IsProxy(obj);
}

JSObject*
Wrap(JSContext* aCx, JSObject* aScope, mozilla::dom::TestIndexedGetterInterface* aObject, nsWrapperCache* aCache, bool* aTriedToWrap)
{
  MOZ_ASSERT(static_cast<mozilla::dom::TestIndexedGetterInterface*>(aObject) ==
             reinterpret_cast<mozilla::dom::TestIndexedGetterInterface*>(aObject));

  *aTriedToWrap = true;

  JSObject* parent = WrapNativeParent(aCx, aScope, aObject->GetParentObject());
  if (!parent) {
    return NULL;
  }

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.  Scope so we don't
  // collide with the "obj" we declare in CreateBindingJSObject.
  {
    JSObject* obj = aCache->GetWrapper();
    if (obj) {
      return obj;
    }
  }

  JSAutoCompartment ac(aCx, parent);
  JSObject* global = JS_GetGlobalForObject(aCx, parent);

  JSObject* proto = GetProtoObject(aCx, global);
  if (!proto) {
    return NULL;
  }

  JSObject *obj = NewProxyObject(aCx, DOMProxyHandler::getInstance(),
                                 JS::PrivateValue(aObject), proto, parent);
  if (!obj) {
    return NULL;
  }

  NS_ADDREF(aObject);


  aCache->SetWrapper(obj);

  return obj;
}

} // namespace TestIndexedGetterInterfaceBinding



namespace TestIndexedSetterInterfaceBinding {

static bool
setItem(JSContext* cx, JSHandleObject obj, mozilla::dom::TestIndexedSetterInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 2) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestIndexedSetterInterface.setItem");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  FakeDependentString arg1_holder;
  const NonNull<nsAString> arg1;
  if (!ConvertJSValueToString(cx, argv[1], &argv[1], eStringify, eStringify, arg1_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg1) = &arg1_holder;
  self->SetItem(arg0, arg1);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo setItem_methodinfo = {
  (JSJitPropertyOp)setItem,
  prototypes::id::TestIndexedSetterInterface,
  PrototypeTraits<prototypes::id::TestIndexedSetterInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static JSBool
genericMethod(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  mozilla::dom::TestIndexedSetterInterface* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::TestIndexedSetterInterface, mozilla::dom::TestIndexedSetterInterface>(cx, obj, self);
    if (NS_FAILED(rv)) {
      return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestIndexedSetterInterface");
    }
  }
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Method);
  JSJitMethodOp method = (JSJitMethodOp)info->op;
  return method(cx, obj, self, argc, vp);
}

static JSFunctionSpec sMethods_specs[] = {
  JS_FNINFO("setItem", genericMethod, &setItem_methodinfo, 2, JSPROP_ENUMERATE),
  JS_FS_END
};

static Prefable<JSFunctionSpec> sMethods[] = {
  { true, &sMethods_specs[0] },
  { false, NULL }
};

static jsid sMethods_ids[2] = { JSID_VOID };

static JSFunctionSpec sChromeMethods_specs[] = {
  JS_FNINFO("QueryInterface", QueryInterface, nullptr, 1, 0),
  JS_FS_END
};

static Prefable<JSFunctionSpec> sChromeMethods[] = {
  { true, &sChromeMethods_specs[0] },
  { false, NULL }
};

static jsid sChromeMethods_ids[2] = { JSID_VOID };


static const NativeProperties sNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sMethods, sMethods_ids, sMethods_specs,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr
};

static const NativeProperties sChromeOnlyNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sChromeMethods, sChromeMethods_ids, sChromeMethods_specs,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr
};
const NativePropertyHooks sNativePropertyHooks = {
  ResolveOwnProperty,
  EnumerateOwnProperties,
  { &sNativeProperties, &sChromeOnlyNativeProperties },
  prototypes::id::TestIndexedSetterInterface,
  constructors::id::TestIndexedSetterInterface,
  NULL
};

JSNativeHolder _constructor_holder = {
  ThrowingConstructor,
  &sNativePropertyHooks
};

static DOMIfaceAndProtoJSClass PrototypeClass = {
  {
    "TestIndexedSetterInterfacePrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(2),
    JS_PropertyStub,       /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    nullptr,               /* finalize */
    nullptr,               /* checkAccess */
    nullptr,               /* call */
    nullptr,               /* hasInstance */
    nullptr,               /* construct */
    nullptr,               /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  eInterfacePrototype,
  &sNativePropertyHooks
};

void
CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray)
{
  JSObject* parentProto = JS_GetObjectPrototype(aCx, aGlobal);
  if (!parentProto) {
    return;
  }


  if (sChromeMethods_ids[0] == JSID_VOID &&
      (!InitIds(aCx, sChromeMethods, sChromeMethods_ids) ||
       !InitIds(aCx, sMethods, sMethods_ids))) {
    sChromeMethods_ids[0] = JSID_VOID;
    return;
  }

  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &PrototypeClass.mBase, &protoAndIfaceArray[prototypes::id::TestIndexedSetterInterface],
                              nullptr, &_constructor_holder, 0, &protoAndIfaceArray[constructors::id::TestIndexedSetterInterface],
                              &Class,
                              &sNativeProperties,
                              xpc::AccessCheck::isChrome(aGlobal) ? &sChromeOnlyNativeProperties : nullptr,
                              "TestIndexedSetterInterface");
}

bool
ResolveOwnProperty(JSContext* cx, JSObject* wrapper, JSObject* obj, jsid id, JSPropertyDescriptor* desc, unsigned flags)
{
  // We rely on getOwnPropertyDescriptor not shadowing prototype properties by named
  // properties. If that changes we'll need to filter here.
  return js::GetProxyHandler(obj)->getOwnPropertyDescriptor(cx, wrapper, id, desc, flags);

}

bool
EnumerateOwnProperties(JSContext* cx, JSObject* wrapper, JSObject* obj, JS::AutoIdVector& props)
{
  // We rely on getOwnPropertyNames not shadowing prototype properties by named
  // properties. If that changes we'll need to filter here.
  return js::GetProxyHandler(obj)->getOwnPropertyNames(cx, wrapper, props);

}

JSObject*
DefineDOMInterface(JSContext* aCx, JSObject* aGlobal, bool* aEnabled)
{

  *aEnabled = true;
  return GetConstructorObject(aCx, aGlobal);
}

MOZ_ALWAYS_INLINE bool
IsProxy(JSObject* obj)
{
  return js::IsProxy(obj) && js::GetProxyHandler(obj) == DOMProxyHandler::getInstance();
}

MOZ_ALWAYS_INLINE mozilla::dom::TestIndexedSetterInterface*
UnwrapProxy(JSObject* obj)
{
  if (xpc::WrapperFactory::IsXrayWrapper(obj)) {
    obj = js::UnwrapObject(obj);
  }
  MOZ_ASSERT(IsProxy(obj));
  return static_cast<mozilla::dom::TestIndexedSetterInterface*>(js::GetProxyPrivate(obj).toPrivate());
}


const DOMClass Class = {
  { prototypes::id::TestIndexedSetterInterface, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
  true,
  &sNativePropertyHooks,
  GetParentObject<mozilla::dom::TestIndexedSetterInterface>::Get,
  GetProtoObject,
  nullptr
};



DOMProxyHandler::DOMProxyHandler()
  : mozilla::dom::DOMProxyHandler(Class)
{

}


bool
DOMProxyHandler::getOwnPropertyDescriptor(JSContext* cx, JSObject* proxy, jsid id, JSPropertyDescriptor* desc, unsigned flags)
{
  int32_t index = GetArrayIndexFromId(cx, id);
  if (flags & JSRESOLVE_ASSIGNING) {
    if (IsArrayIndex(index)) {
      FillPropertyDescriptor(desc, proxy, JSVAL_VOID, false);
      return true;
    }
  } else {
    if (IsArrayIndex(index)) {
      uint32_t idx = index;
      mozilla::dom::TestIndexedSetterInterface* self = UnwrapProxy(proxy);
      bool found;
      nsString result;
      self->IndexedGetter(idx, found, result);

      if (found) {
        if (!xpc::NonVoidStringToJsval(cx, result, &desc->value)) {
          return false;
        }
        FillPropertyDescriptor(desc, proxy, false);
        return true;
      }
    }
  }

  JSObject* expando;
  if (!xpc::WrapperFactory::IsXrayWrapper(proxy) && (expando = GetExpandoObject(proxy))) {
    if (!JS_GetPropertyDescriptorById(cx, expando, id, flags, desc)) {
      return false;
    }
    if (desc->obj) {
      // Pretend the property lives on the wrapper.
      desc->obj = proxy;
      return true;
    }
  }

  desc->obj = NULL;
  return true;
}


bool
DOMProxyHandler::defineProperty(JSContext* cx, JSObject* proxy, jsid id, JSPropertyDescriptor* desc)
{
  int32_t index = GetArrayIndexFromId(cx, id);
  if (IsArrayIndex(index)) {
    uint32_t idx = index;
    mozilla::dom::TestIndexedSetterInterface* self = UnwrapProxy(proxy);
    FakeDependentString item_holder;
    const NonNull<nsAString> item;
    if (!ConvertJSValueToString(cx, desc->value, &desc->value, eStringify, eStringify, item_holder)) {
      return false;
    }
    const_cast<NonNull<nsAString>&>(item) = &item_holder;
    self->IndexedSetter(idx, item);
    return true;
  }
  return mozilla::dom::DOMProxyHandler::defineProperty(cx, proxy, id, desc);
}


bool
DOMProxyHandler::getOwnPropertyNames(JSContext* cx, JSObject* proxy, JS::AutoIdVector& props)
{
  uint32_t length = UnwrapProxy(proxy)->Length();
  MOZ_ASSERT(int32_t(length) >= 0);
  for (int32_t i = 0; i < int32_t(length); ++i) {
    if (!props.append(INT_TO_JSID(i))) {
      return false;
    }
  }

  JSObject* expando;
  if (!xpc::WrapperFactory::IsXrayWrapper(proxy) && (expando = DOMProxyHandler::GetExpandoObject(proxy)) &&
      !js::GetPropertyNames(cx, expando, JSITER_OWNONLY | JSITER_HIDDEN, &props)) {
    return false;
  }

  return true;
}


bool
DOMProxyHandler::hasOwn(JSContext* cx, JSObject* proxy, jsid id, bool* bp)
{
  int32_t index = GetArrayIndexFromId(cx, id);
  if (IsArrayIndex(index)) {
    uint32_t idx = index;
    mozilla::dom::TestIndexedSetterInterface* self = UnwrapProxy(proxy);
    bool found;
    nsString result;
    self->IndexedGetter(idx, found, result);
    (void)result;

    *bp = found;
    return true;
  }

  JSObject* expando = GetExpandoObject(proxy);
  if (expando) {
    JSBool b = true;
    JSBool ok = JS_HasPropertyById(cx, expando, id, &b);
    *bp = !!b;
    if (!ok || *bp) {
      return ok;
    }
  }

  *bp = false;
  return true;
}


bool
DOMProxyHandler::get(JSContext* cx, JSObject* proxy, JSObject* receiver, jsid id, JS::Value* vp)
{
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
              "Should not have a XrayWrapper here");

  int32_t index = GetArrayIndexFromId(cx, id);
  if (IsArrayIndex(index)) {
    uint32_t idx = index;
    mozilla::dom::TestIndexedSetterInterface* self = UnwrapProxy(proxy);
    bool found;
    nsString result;
    self->IndexedGetter(idx, found, result);

    if (found) {
      if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
        return false;
      }
      return true;
    }
    // Even if we don't have this index, we don't forward the
    // get on to our expando object.
  } else {
    JSObject* expando = DOMProxyHandler::GetExpandoObject(proxy);
    if (expando) {
      JSBool hasProp;
      if (!JS_HasPropertyById(cx, expando, id, &hasProp)) {
        return false;
      }

      if (hasProp) {
        return JS_GetPropertyById(cx, expando, id, vp);
      }
    }
  }

  {  // Scope for this "found" so it doesn't leak to things below
    bool found;
    if (!GetPropertyOnPrototype(cx, proxy, id, &found, vp)) {
      return false;
    }

    if (found) {
      return true;
    }
  }

  vp->setUndefined();
  return true;
}


JSString*
DOMProxyHandler::obj_toString(JSContext* cx, JSObject* proxy)
{
  return mozilla::dom::DOMProxyHandler::obj_toString(cx, "TestIndexedSetterInterface");
}


void
DOMProxyHandler::finalize(JSFreeOp* fop, JSObject* proxy)
{
  mozilla::dom::TestIndexedSetterInterface* self = UnwrapProxy(proxy);

  if (self) {
    ClearWrapper(self, self);
    XPCJSRuntime *rt = nsXPConnect::GetRuntimeInstance();
    if (rt) {
      rt->DeferredRelease(reinterpret_cast<nsISupports*>(self));
    } else {
      NS_RELEASE(self);
    }
  }
}


bool
DOMProxyHandler::getElementIfPresent(JSContext* cx, JSObject* proxy, JSObject* receiver, uint32_t index, JS::Value* vp, bool* present)
{
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
               "Should not have a XrayWrapper here");

  uint32_t idx = index;
  mozilla::dom::TestIndexedSetterInterface* self = UnwrapProxy(proxy);
  bool found;
  nsString result;
  self->IndexedGetter(idx, found, result);

  if (found) {
    if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
      return false;
    }
    *present = found;
    return true;
  }
  // We skip the expando object and any named getters if
  // there is an indexed getter.


  JSObject *proto;
  if (!js::GetObjectProto(cx, proxy, &proto)) {
    return false;
  }
  if (proto) {
    JSBool isPresent;
    if (!JS_GetElementIfPresent(cx, proto, index, proxy, vp, &isPresent)) {
      return false;
    }
    *present = isPresent;
    return true;
  }

  *present = false;
  // Can't Debug_SetValueRangeToCrashOnTouch because it's not public
  return true;
}


DOMProxyHandler*
DOMProxyHandler::getInstance()
{
  static DOMProxyHandler instance;
  return &instance;
}


bool
DOMProxyHandler::delete_(JSContext* cx, JSObject* proxy, jsid id, bool* bp)
{
  int32_t index = GetArrayIndexFromId(cx, id);
  if (IsArrayIndex(index)) {
    uint32_t idx = index;
    mozilla::dom::TestIndexedSetterInterface* self = UnwrapProxy(proxy);
    bool found;
    nsString result;
    self->IndexedGetter(idx, found, result);
    (void)result;
    if (found) {
      // XXXbz we should throw if Throw is true!
      *bp = false;
    } else {
      *bp = true;
    }
    // We always return here, even if the property was not found
    return true;
  }
  return dom::DOMProxyHandler::delete_(cx, proxy, id, bp);
}


bool
Is(JSObject* obj)
{
  return IsProxy(obj);
}

JSObject*
Wrap(JSContext* aCx, JSObject* aScope, mozilla::dom::TestIndexedSetterInterface* aObject, nsWrapperCache* aCache, bool* aTriedToWrap)
{
  MOZ_ASSERT(static_cast<mozilla::dom::TestIndexedSetterInterface*>(aObject) ==
             reinterpret_cast<mozilla::dom::TestIndexedSetterInterface*>(aObject));

  *aTriedToWrap = true;

  JSObject* parent = WrapNativeParent(aCx, aScope, aObject->GetParentObject());
  if (!parent) {
    return NULL;
  }

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.  Scope so we don't
  // collide with the "obj" we declare in CreateBindingJSObject.
  {
    JSObject* obj = aCache->GetWrapper();
    if (obj) {
      return obj;
    }
  }

  JSAutoCompartment ac(aCx, parent);
  JSObject* global = JS_GetGlobalForObject(aCx, parent);

  JSObject* proto = GetProtoObject(aCx, global);
  if (!proto) {
    return NULL;
  }

  JSObject *obj = NewProxyObject(aCx, DOMProxyHandler::getInstance(),
                                 JS::PrivateValue(aObject), proto, parent);
  if (!obj) {
    return NULL;
  }

  NS_ADDREF(aObject);


  aCache->SetWrapper(obj);

  return obj;
}

} // namespace TestIndexedSetterInterfaceBinding



namespace TestInterfaceBinding {

static bool
get_readonlyByte(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* vp)
{
  int8_t result;
  result = self->ReadonlyByte();
  *vp = INT_TO_JSVAL(int32_t(result));
  return true;
}


const JSJitInfo readonlyByte_getterinfo = {
  (JSJitPropertyOp)get_readonlyByte,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_writableByte(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* vp)
{
  int8_t result;
  result = self->WritableByte();
  *vp = INT_TO_JSVAL(int32_t(result));
  return true;
}

static bool
set_writableByte(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* argv)
{
  int8_t arg0;
  if (!ValueToPrimitive<int8_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  self->SetWritableByte(arg0);

  return true;
}


const JSJitInfo writableByte_getterinfo = {
  (JSJitPropertyOp)get_writableByte,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo writableByte_setterinfo = {
  (JSJitPropertyOp)set_writableByte,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passByte(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.passByte");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  int8_t arg0;
  if (!ValueToPrimitive<int8_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  self->PassByte(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passByte_methodinfo = {
  (JSJitPropertyOp)passByte,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveByte(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{
  int8_t result;
  result = self->ReceiveByte();
  *vp = INT_TO_JSVAL(int32_t(result));
  return true;
}


const JSJitInfo receiveByte_methodinfo = {
  (JSJitPropertyOp)receiveByte,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalByte(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  const Optional< int8_t > arg0;
  if (0 < argc) {
    const_cast< Optional< int8_t > &>(arg0).Construct();
    if (!ValueToPrimitive<int8_t, eDefault>(cx, argv[0], &const_cast< int8_t & >(arg0.Value()))) {
      return false;
    }
  }
  self->PassOptionalByte(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalByte_methodinfo = {
  (JSJitPropertyOp)passOptionalByte,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalByteWithDefault(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  int8_t arg0;
  if (0 < argc) {
    if (!ValueToPrimitive<int8_t, eDefault>(cx, argv[0], &arg0)) {
      return false;
    }
  } else {
    arg0 = 0;
  }
  self->PassOptionalByteWithDefault(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalByteWithDefault_methodinfo = {
  (JSJitPropertyOp)passOptionalByteWithDefault,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passNullableByte(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.passNullableByte");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  const Nullable<int8_t> arg0;
  if (argv[0].isNullOrUndefined()) {
    const_cast< Nullable<int8_t>& >(arg0).SetNull();
  } else if (!ValueToPrimitive<int8_t, eDefault>(cx, argv[0], &const_cast< Nullable<int8_t>& >(arg0).SetValue())) {
    return false;
  }
  self->PassNullableByte(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passNullableByte_methodinfo = {
  (JSJitPropertyOp)passNullableByte,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalNullableByte(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  const Optional< Nullable<int8_t> > arg0;
  if (0 < argc) {
    const_cast< Optional< Nullable<int8_t> > &>(arg0).Construct();
    if (argv[0].isNullOrUndefined()) {
      const_cast< Nullable<int8_t>& >(const_cast< Nullable<int8_t> & >(arg0.Value())).SetNull();
    } else if (!ValueToPrimitive<int8_t, eDefault>(cx, argv[0], &const_cast< Nullable<int8_t>& >(const_cast< Nullable<int8_t> & >(arg0.Value())).SetValue())) {
      return false;
    }
  }
  self->PassOptionalNullableByte(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalNullableByte_methodinfo = {
  (JSJitPropertyOp)passOptionalNullableByte,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passVariadicByte(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  const Sequence< int8_t > arg0;
  if (argc > 0) {
    Sequence< int8_t >& arr = const_cast< Sequence< int8_t >& >(arg0);
    if (!arr.SetCapacity(argc - 0)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t variadicArg = 0; variadicArg < argc; ++variadicArg) {
      int8_t& slot = *arr.AppendElement();
      if (!ValueToPrimitive<int8_t, eDefault>(cx, argv[variadicArg], &slot)) {
        return false;
      }
    }
  }
  self->PassVariadicByte(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passVariadicByte_methodinfo = {
  (JSJitPropertyOp)passVariadicByte,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_readonlyShort(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* vp)
{
  int16_t result;
  result = self->ReadonlyShort();
  *vp = INT_TO_JSVAL(int32_t(result));
  return true;
}


const JSJitInfo readonlyShort_getterinfo = {
  (JSJitPropertyOp)get_readonlyShort,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_writableShort(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* vp)
{
  int16_t result;
  result = self->WritableShort();
  *vp = INT_TO_JSVAL(int32_t(result));
  return true;
}

static bool
set_writableShort(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* argv)
{
  int16_t arg0;
  if (!ValueToPrimitive<int16_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  self->SetWritableShort(arg0);

  return true;
}


const JSJitInfo writableShort_getterinfo = {
  (JSJitPropertyOp)get_writableShort,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo writableShort_setterinfo = {
  (JSJitPropertyOp)set_writableShort,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passShort(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.passShort");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  int16_t arg0;
  if (!ValueToPrimitive<int16_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  self->PassShort(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passShort_methodinfo = {
  (JSJitPropertyOp)passShort,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveShort(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{
  int16_t result;
  result = self->ReceiveShort();
  *vp = INT_TO_JSVAL(int32_t(result));
  return true;
}


const JSJitInfo receiveShort_methodinfo = {
  (JSJitPropertyOp)receiveShort,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalShort(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  const Optional< int16_t > arg0;
  if (0 < argc) {
    const_cast< Optional< int16_t > &>(arg0).Construct();
    if (!ValueToPrimitive<int16_t, eDefault>(cx, argv[0], &const_cast< int16_t & >(arg0.Value()))) {
      return false;
    }
  }
  self->PassOptionalShort(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalShort_methodinfo = {
  (JSJitPropertyOp)passOptionalShort,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalShortWithDefault(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  int16_t arg0;
  if (0 < argc) {
    if (!ValueToPrimitive<int16_t, eDefault>(cx, argv[0], &arg0)) {
      return false;
    }
  } else {
    arg0 = 5;
  }
  self->PassOptionalShortWithDefault(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalShortWithDefault_methodinfo = {
  (JSJitPropertyOp)passOptionalShortWithDefault,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_readonlyLong(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* vp)
{
  int32_t result;
  result = self->ReadonlyLong();
  *vp = INT_TO_JSVAL(int32_t(result));
  return true;
}


const JSJitInfo readonlyLong_getterinfo = {
  (JSJitPropertyOp)get_readonlyLong,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_writableLong(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* vp)
{
  int32_t result;
  result = self->WritableLong();
  *vp = INT_TO_JSVAL(int32_t(result));
  return true;
}

static bool
set_writableLong(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* argv)
{
  int32_t arg0;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  self->SetWritableLong(arg0);

  return true;
}


const JSJitInfo writableLong_getterinfo = {
  (JSJitPropertyOp)get_writableLong,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo writableLong_setterinfo = {
  (JSJitPropertyOp)set_writableLong,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passLong(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.passLong");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  int32_t arg0;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  self->PassLong(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passLong_methodinfo = {
  (JSJitPropertyOp)passLong,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveLong(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{
  int32_t result;
  result = self->ReceiveLong();
  *vp = INT_TO_JSVAL(int32_t(result));
  return true;
}


const JSJitInfo receiveLong_methodinfo = {
  (JSJitPropertyOp)receiveLong,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalLong(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  const Optional< int32_t > arg0;
  if (0 < argc) {
    const_cast< Optional< int32_t > &>(arg0).Construct();
    if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[0], &const_cast< int32_t & >(arg0.Value()))) {
      return false;
    }
  }
  self->PassOptionalLong(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalLong_methodinfo = {
  (JSJitPropertyOp)passOptionalLong,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalLongWithDefault(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  int32_t arg0;
  if (0 < argc) {
    if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[0], &arg0)) {
      return false;
    }
  } else {
    arg0 = 7;
  }
  self->PassOptionalLongWithDefault(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalLongWithDefault_methodinfo = {
  (JSJitPropertyOp)passOptionalLongWithDefault,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_readonlyLongLong(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* vp)
{
  int64_t result;
  result = self->ReadonlyLongLong();
  *vp = JS_NumberValue(double(result));
  return true;
}


const JSJitInfo readonlyLongLong_getterinfo = {
  (JSJitPropertyOp)get_readonlyLongLong,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_writableLongLong(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* vp)
{
  int64_t result;
  result = self->WritableLongLong();
  *vp = JS_NumberValue(double(result));
  return true;
}

static bool
set_writableLongLong(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* argv)
{
  int64_t arg0;
  if (!ValueToPrimitive<int64_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  self->SetWritableLongLong(arg0);

  return true;
}


const JSJitInfo writableLongLong_getterinfo = {
  (JSJitPropertyOp)get_writableLongLong,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo writableLongLong_setterinfo = {
  (JSJitPropertyOp)set_writableLongLong,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passLongLong(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.passLongLong");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  int64_t arg0;
  if (!ValueToPrimitive<int64_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  self->PassLongLong(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passLongLong_methodinfo = {
  (JSJitPropertyOp)passLongLong,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveLongLong(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{
  int64_t result;
  result = self->ReceiveLongLong();
  *vp = JS_NumberValue(double(result));
  return true;
}


const JSJitInfo receiveLongLong_methodinfo = {
  (JSJitPropertyOp)receiveLongLong,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalLongLong(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  const Optional< int64_t > arg0;
  if (0 < argc) {
    const_cast< Optional< int64_t > &>(arg0).Construct();
    if (!ValueToPrimitive<int64_t, eDefault>(cx, argv[0], &const_cast< int64_t & >(arg0.Value()))) {
      return false;
    }
  }
  self->PassOptionalLongLong(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalLongLong_methodinfo = {
  (JSJitPropertyOp)passOptionalLongLong,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalLongLongWithDefault(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  int64_t arg0;
  if (0 < argc) {
    if (!ValueToPrimitive<int64_t, eDefault>(cx, argv[0], &arg0)) {
      return false;
    }
  } else {
    arg0 = -12;
  }
  self->PassOptionalLongLongWithDefault(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalLongLongWithDefault_methodinfo = {
  (JSJitPropertyOp)passOptionalLongLongWithDefault,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_readonlyOctet(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* vp)
{
  uint8_t result;
  result = self->ReadonlyOctet();
  *vp = INT_TO_JSVAL(int32_t(result));
  return true;
}


const JSJitInfo readonlyOctet_getterinfo = {
  (JSJitPropertyOp)get_readonlyOctet,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_writableOctet(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* vp)
{
  uint8_t result;
  result = self->WritableOctet();
  *vp = INT_TO_JSVAL(int32_t(result));
  return true;
}

static bool
set_writableOctet(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* argv)
{
  uint8_t arg0;
  if (!ValueToPrimitive<uint8_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  self->SetWritableOctet(arg0);

  return true;
}


const JSJitInfo writableOctet_getterinfo = {
  (JSJitPropertyOp)get_writableOctet,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo writableOctet_setterinfo = {
  (JSJitPropertyOp)set_writableOctet,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOctet(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.passOctet");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  uint8_t arg0;
  if (!ValueToPrimitive<uint8_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  self->PassOctet(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOctet_methodinfo = {
  (JSJitPropertyOp)passOctet,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveOctet(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{
  uint8_t result;
  result = self->ReceiveOctet();
  *vp = INT_TO_JSVAL(int32_t(result));
  return true;
}


const JSJitInfo receiveOctet_methodinfo = {
  (JSJitPropertyOp)receiveOctet,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalOctet(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  const Optional< uint8_t > arg0;
  if (0 < argc) {
    const_cast< Optional< uint8_t > &>(arg0).Construct();
    if (!ValueToPrimitive<uint8_t, eDefault>(cx, argv[0], &const_cast< uint8_t & >(arg0.Value()))) {
      return false;
    }
  }
  self->PassOptionalOctet(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalOctet_methodinfo = {
  (JSJitPropertyOp)passOptionalOctet,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalOctetWithDefault(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  uint8_t arg0;
  if (0 < argc) {
    if (!ValueToPrimitive<uint8_t, eDefault>(cx, argv[0], &arg0)) {
      return false;
    }
  } else {
    arg0 = 19;
  }
  self->PassOptionalOctetWithDefault(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalOctetWithDefault_methodinfo = {
  (JSJitPropertyOp)passOptionalOctetWithDefault,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_readonlyUnsignedShort(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* vp)
{
  uint16_t result;
  result = self->ReadonlyUnsignedShort();
  *vp = INT_TO_JSVAL(int32_t(result));
  return true;
}


const JSJitInfo readonlyUnsignedShort_getterinfo = {
  (JSJitPropertyOp)get_readonlyUnsignedShort,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_writableUnsignedShort(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* vp)
{
  uint16_t result;
  result = self->WritableUnsignedShort();
  *vp = INT_TO_JSVAL(int32_t(result));
  return true;
}

static bool
set_writableUnsignedShort(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* argv)
{
  uint16_t arg0;
  if (!ValueToPrimitive<uint16_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  self->SetWritableUnsignedShort(arg0);

  return true;
}


const JSJitInfo writableUnsignedShort_getterinfo = {
  (JSJitPropertyOp)get_writableUnsignedShort,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo writableUnsignedShort_setterinfo = {
  (JSJitPropertyOp)set_writableUnsignedShort,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passUnsignedShort(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.passUnsignedShort");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  uint16_t arg0;
  if (!ValueToPrimitive<uint16_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  self->PassUnsignedShort(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passUnsignedShort_methodinfo = {
  (JSJitPropertyOp)passUnsignedShort,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveUnsignedShort(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{
  uint16_t result;
  result = self->ReceiveUnsignedShort();
  *vp = INT_TO_JSVAL(int32_t(result));
  return true;
}


const JSJitInfo receiveUnsignedShort_methodinfo = {
  (JSJitPropertyOp)receiveUnsignedShort,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalUnsignedShort(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  const Optional< uint16_t > arg0;
  if (0 < argc) {
    const_cast< Optional< uint16_t > &>(arg0).Construct();
    if (!ValueToPrimitive<uint16_t, eDefault>(cx, argv[0], &const_cast< uint16_t & >(arg0.Value()))) {
      return false;
    }
  }
  self->PassOptionalUnsignedShort(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalUnsignedShort_methodinfo = {
  (JSJitPropertyOp)passOptionalUnsignedShort,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalUnsignedShortWithDefault(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  uint16_t arg0;
  if (0 < argc) {
    if (!ValueToPrimitive<uint16_t, eDefault>(cx, argv[0], &arg0)) {
      return false;
    }
  } else {
    arg0 = 2;
  }
  self->PassOptionalUnsignedShortWithDefault(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalUnsignedShortWithDefault_methodinfo = {
  (JSJitPropertyOp)passOptionalUnsignedShortWithDefault,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_readonlyUnsignedLong(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* vp)
{
  uint32_t result;
  result = self->ReadonlyUnsignedLong();
  *vp = UINT_TO_JSVAL(result);
  return true;
}


const JSJitInfo readonlyUnsignedLong_getterinfo = {
  (JSJitPropertyOp)get_readonlyUnsignedLong,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_writableUnsignedLong(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* vp)
{
  uint32_t result;
  result = self->WritableUnsignedLong();
  *vp = UINT_TO_JSVAL(result);
  return true;
}

static bool
set_writableUnsignedLong(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* argv)
{
  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  self->SetWritableUnsignedLong(arg0);

  return true;
}


const JSJitInfo writableUnsignedLong_getterinfo = {
  (JSJitPropertyOp)get_writableUnsignedLong,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo writableUnsignedLong_setterinfo = {
  (JSJitPropertyOp)set_writableUnsignedLong,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passUnsignedLong(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.passUnsignedLong");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  self->PassUnsignedLong(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passUnsignedLong_methodinfo = {
  (JSJitPropertyOp)passUnsignedLong,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveUnsignedLong(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{
  uint32_t result;
  result = self->ReceiveUnsignedLong();
  *vp = UINT_TO_JSVAL(result);
  return true;
}


const JSJitInfo receiveUnsignedLong_methodinfo = {
  (JSJitPropertyOp)receiveUnsignedLong,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalUnsignedLong(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  const Optional< uint32_t > arg0;
  if (0 < argc) {
    const_cast< Optional< uint32_t > &>(arg0).Construct();
    if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[0], &const_cast< uint32_t & >(arg0.Value()))) {
      return false;
    }
  }
  self->PassOptionalUnsignedLong(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalUnsignedLong_methodinfo = {
  (JSJitPropertyOp)passOptionalUnsignedLong,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalUnsignedLongWithDefault(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  uint32_t arg0;
  if (0 < argc) {
    if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[0], &arg0)) {
      return false;
    }
  } else {
    arg0 = 6;
  }
  self->PassOptionalUnsignedLongWithDefault(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalUnsignedLongWithDefault_methodinfo = {
  (JSJitPropertyOp)passOptionalUnsignedLongWithDefault,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_readonlyUnsignedLongLong(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* vp)
{
  uint64_t result;
  result = self->ReadonlyUnsignedLongLong();
  *vp = JS_NumberValue(double(result));
  return true;
}


const JSJitInfo readonlyUnsignedLongLong_getterinfo = {
  (JSJitPropertyOp)get_readonlyUnsignedLongLong,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_writableUnsignedLongLong(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* vp)
{
  uint64_t result;
  result = self->WritableUnsignedLongLong();
  *vp = JS_NumberValue(double(result));
  return true;
}

static bool
set_writableUnsignedLongLong(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* argv)
{
  uint64_t arg0;
  if (!ValueToPrimitive<uint64_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  self->SetWritableUnsignedLongLong(arg0);

  return true;
}


const JSJitInfo writableUnsignedLongLong_getterinfo = {
  (JSJitPropertyOp)get_writableUnsignedLongLong,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo writableUnsignedLongLong_setterinfo = {
  (JSJitPropertyOp)set_writableUnsignedLongLong,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passUnsignedLongLong(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.passUnsignedLongLong");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  uint64_t arg0;
  if (!ValueToPrimitive<uint64_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  self->PassUnsignedLongLong(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passUnsignedLongLong_methodinfo = {
  (JSJitPropertyOp)passUnsignedLongLong,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveUnsignedLongLong(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{
  uint64_t result;
  result = self->ReceiveUnsignedLongLong();
  *vp = JS_NumberValue(double(result));
  return true;
}


const JSJitInfo receiveUnsignedLongLong_methodinfo = {
  (JSJitPropertyOp)receiveUnsignedLongLong,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalUnsignedLongLong(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  const Optional< uint64_t > arg0;
  if (0 < argc) {
    const_cast< Optional< uint64_t > &>(arg0).Construct();
    if (!ValueToPrimitive<uint64_t, eDefault>(cx, argv[0], &const_cast< uint64_t & >(arg0.Value()))) {
      return false;
    }
  }
  self->PassOptionalUnsignedLongLong(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalUnsignedLongLong_methodinfo = {
  (JSJitPropertyOp)passOptionalUnsignedLongLong,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalUnsignedLongLongWithDefault(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  uint64_t arg0;
  if (0 < argc) {
    if (!ValueToPrimitive<uint64_t, eDefault>(cx, argv[0], &arg0)) {
      return false;
    }
  } else {
    arg0 = 17;
  }
  self->PassOptionalUnsignedLongLongWithDefault(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalUnsignedLongLongWithDefault_methodinfo = {
  (JSJitPropertyOp)passOptionalUnsignedLongLongWithDefault,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_writableFloat(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* vp)
{
  float result;
  result = self->WritableFloat();
  *vp = JS_NumberValue(double(result));
  return true;
}

static bool
set_writableFloat(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* argv)
{
  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[0], &arg0)) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg0)) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    ThrowErrorMessage(cx, MSG_NOT_FINITE);
    return false;
  }
  self->SetWritableFloat(arg0);

  return true;
}


const JSJitInfo writableFloat_getterinfo = {
  (JSJitPropertyOp)get_writableFloat,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo writableFloat_setterinfo = {
  (JSJitPropertyOp)set_writableFloat,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_writableUnrestrictedFloat(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* vp)
{
  float result;
  result = self->WritableUnrestrictedFloat();
  *vp = JS_NumberValue(double(result));
  return true;
}

static bool
set_writableUnrestrictedFloat(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* argv)
{
  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  self->SetWritableUnrestrictedFloat(arg0);

  return true;
}


const JSJitInfo writableUnrestrictedFloat_getterinfo = {
  (JSJitPropertyOp)get_writableUnrestrictedFloat,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo writableUnrestrictedFloat_setterinfo = {
  (JSJitPropertyOp)set_writableUnrestrictedFloat,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_writableNullableFloat(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* vp)
{
  Nullable<float> result;
  result = self->GetWritableNullableFloat();
  if (result.IsNull()) {
    *vp = JSVAL_NULL;
    return true;
  }
  *vp = JS_NumberValue(double(result.Value()));
  return true;
}

static bool
set_writableNullableFloat(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* argv)
{
  const Nullable<float> arg0;
  if (argv[0].isNullOrUndefined()) {
    const_cast< Nullable<float>& >(arg0).SetNull();
  } else if (!ValueToPrimitive<float, eDefault>(cx, argv[0], &const_cast< Nullable<float>& >(arg0).SetValue())) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg0.Value())) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    ThrowErrorMessage(cx, MSG_NOT_FINITE);
    return false;
  }
  self->SetWritableNullableFloat(arg0);

  return true;
}


const JSJitInfo writableNullableFloat_getterinfo = {
  (JSJitPropertyOp)get_writableNullableFloat,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo writableNullableFloat_setterinfo = {
  (JSJitPropertyOp)set_writableNullableFloat,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_writableNullableUnrestrictedFloat(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* vp)
{
  Nullable<float> result;
  result = self->GetWritableNullableUnrestrictedFloat();
  if (result.IsNull()) {
    *vp = JSVAL_NULL;
    return true;
  }
  *vp = JS_NumberValue(double(result.Value()));
  return true;
}

static bool
set_writableNullableUnrestrictedFloat(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* argv)
{
  const Nullable<float> arg0;
  if (argv[0].isNullOrUndefined()) {
    const_cast< Nullable<float>& >(arg0).SetNull();
  } else if (!ValueToPrimitive<float, eDefault>(cx, argv[0], &const_cast< Nullable<float>& >(arg0).SetValue())) {
    return false;
  }
  self->SetWritableNullableUnrestrictedFloat(arg0);

  return true;
}


const JSJitInfo writableNullableUnrestrictedFloat_getterinfo = {
  (JSJitPropertyOp)get_writableNullableUnrestrictedFloat,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo writableNullableUnrestrictedFloat_setterinfo = {
  (JSJitPropertyOp)set_writableNullableUnrestrictedFloat,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_writableDouble(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* vp)
{
  double result;
  result = self->WritableDouble();
  *vp = JS_NumberValue(double(result));
  return true;
}

static bool
set_writableDouble(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* argv)
{
  double arg0;
  if (!ValueToPrimitive<double, eDefault>(cx, argv[0], &arg0)) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg0)) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    ThrowErrorMessage(cx, MSG_NOT_FINITE);
    return false;
  }
  self->SetWritableDouble(arg0);

  return true;
}


const JSJitInfo writableDouble_getterinfo = {
  (JSJitPropertyOp)get_writableDouble,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo writableDouble_setterinfo = {
  (JSJitPropertyOp)set_writableDouble,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_writableUnrestrictedDouble(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* vp)
{
  double result;
  result = self->WritableUnrestrictedDouble();
  *vp = JS_NumberValue(double(result));
  return true;
}

static bool
set_writableUnrestrictedDouble(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* argv)
{
  double arg0;
  if (!ValueToPrimitive<double, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  self->SetWritableUnrestrictedDouble(arg0);

  return true;
}


const JSJitInfo writableUnrestrictedDouble_getterinfo = {
  (JSJitPropertyOp)get_writableUnrestrictedDouble,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo writableUnrestrictedDouble_setterinfo = {
  (JSJitPropertyOp)set_writableUnrestrictedDouble,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_writableNullableDouble(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* vp)
{
  Nullable<double> result;
  result = self->GetWritableNullableDouble();
  if (result.IsNull()) {
    *vp = JSVAL_NULL;
    return true;
  }
  *vp = JS_NumberValue(double(result.Value()));
  return true;
}

static bool
set_writableNullableDouble(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* argv)
{
  const Nullable<double> arg0;
  if (argv[0].isNullOrUndefined()) {
    const_cast< Nullable<double>& >(arg0).SetNull();
  } else if (!ValueToPrimitive<double, eDefault>(cx, argv[0], &const_cast< Nullable<double>& >(arg0).SetValue())) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg0.Value())) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    ThrowErrorMessage(cx, MSG_NOT_FINITE);
    return false;
  }
  self->SetWritableNullableDouble(arg0);

  return true;
}


const JSJitInfo writableNullableDouble_getterinfo = {
  (JSJitPropertyOp)get_writableNullableDouble,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo writableNullableDouble_setterinfo = {
  (JSJitPropertyOp)set_writableNullableDouble,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_writableNullableUnrestrictedDouble(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* vp)
{
  Nullable<double> result;
  result = self->GetWritableNullableUnrestrictedDouble();
  if (result.IsNull()) {
    *vp = JSVAL_NULL;
    return true;
  }
  *vp = JS_NumberValue(double(result.Value()));
  return true;
}

static bool
set_writableNullableUnrestrictedDouble(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* argv)
{
  const Nullable<double> arg0;
  if (argv[0].isNullOrUndefined()) {
    const_cast< Nullable<double>& >(arg0).SetNull();
  } else if (!ValueToPrimitive<double, eDefault>(cx, argv[0], &const_cast< Nullable<double>& >(arg0).SetValue())) {
    return false;
  }
  self->SetWritableNullableUnrestrictedDouble(arg0);

  return true;
}


const JSJitInfo writableNullableUnrestrictedDouble_getterinfo = {
  (JSJitPropertyOp)get_writableNullableUnrestrictedDouble,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo writableNullableUnrestrictedDouble_setterinfo = {
  (JSJitPropertyOp)set_writableNullableUnrestrictedDouble,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passFloat(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 16) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.passFloat");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[0], &arg0)) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg0)) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    ThrowErrorMessage(cx, MSG_NOT_FINITE);
    return false;
  }
  float arg1;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[1], &arg1)) {
    return false;
  }
  const Nullable<float> arg2;
  if (argv[2].isNullOrUndefined()) {
    const_cast< Nullable<float>& >(arg2).SetNull();
  } else if (!ValueToPrimitive<float, eDefault>(cx, argv[2], &const_cast< Nullable<float>& >(arg2).SetValue())) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg2.Value())) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    ThrowErrorMessage(cx, MSG_NOT_FINITE);
    return false;
  }
  const Nullable<float> arg3;
  if (argv[3].isNullOrUndefined()) {
    const_cast< Nullable<float>& >(arg3).SetNull();
  } else if (!ValueToPrimitive<float, eDefault>(cx, argv[3], &const_cast< Nullable<float>& >(arg3).SetValue())) {
    return false;
  }
  double arg4;
  if (!ValueToPrimitive<double, eDefault>(cx, argv[4], &arg4)) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg4)) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    ThrowErrorMessage(cx, MSG_NOT_FINITE);
    return false;
  }
  double arg5;
  if (!ValueToPrimitive<double, eDefault>(cx, argv[5], &arg5)) {
    return false;
  }
  const Nullable<double> arg6;
  if (argv[6].isNullOrUndefined()) {
    const_cast< Nullable<double>& >(arg6).SetNull();
  } else if (!ValueToPrimitive<double, eDefault>(cx, argv[6], &const_cast< Nullable<double>& >(arg6).SetValue())) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg6.Value())) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    ThrowErrorMessage(cx, MSG_NOT_FINITE);
    return false;
  }
  const Nullable<double> arg7;
  if (argv[7].isNullOrUndefined()) {
    const_cast< Nullable<double>& >(arg7).SetNull();
  } else if (!ValueToPrimitive<double, eDefault>(cx, argv[7], &const_cast< Nullable<double>& >(arg7).SetValue())) {
    return false;
  }
  const Sequence< float > arg8;
  if (argv[8].isObject()) {
    JSObject* seq = &argv[8].toObject();

    if (!IsArrayLike(cx, seq)) {
      ThrowErrorMessage(cx, MSG_NOT_SEQUENCE);
      return false;
    }
    uint32_t length;
    // JS_GetArrayLength actually works on all objects
    if (!JS_GetArrayLength(cx, seq, &length)) {
      return false;
    }
    Sequence< float > &arr = const_cast< Sequence< float >& >(arg8);
    if (!arr.SetCapacity(length)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t i = 0; i < length; ++i) {
      jsval temp;
      if (!JS_GetElement(cx, seq, i, &temp)) {
        return false;
      }
      float& slot = *arr.AppendElement();
      if (!ValueToPrimitive<float, eDefault>(cx, temp, &slot)) {
        return false;
      } else if (!MOZ_DOUBLE_IS_FINITE(slot)) {
        // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
        //       when passed a non-finite float too.
        ThrowErrorMessage(cx, MSG_NOT_FINITE);
        return false;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  const Sequence< float > arg9;
  if (argv[9].isObject()) {
    JSObject* seq = &argv[9].toObject();

    if (!IsArrayLike(cx, seq)) {
      ThrowErrorMessage(cx, MSG_NOT_SEQUENCE);
      return false;
    }
    uint32_t length;
    // JS_GetArrayLength actually works on all objects
    if (!JS_GetArrayLength(cx, seq, &length)) {
      return false;
    }
    Sequence< float > &arr = const_cast< Sequence< float >& >(arg9);
    if (!arr.SetCapacity(length)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t i = 0; i < length; ++i) {
      jsval temp;
      if (!JS_GetElement(cx, seq, i, &temp)) {
        return false;
      }
      float& slot = *arr.AppendElement();
      if (!ValueToPrimitive<float, eDefault>(cx, temp, &slot)) {
        return false;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  const Sequence< Nullable<float> > arg10;
  if (argv[10].isObject()) {
    JSObject* seq = &argv[10].toObject();

    if (!IsArrayLike(cx, seq)) {
      ThrowErrorMessage(cx, MSG_NOT_SEQUENCE);
      return false;
    }
    uint32_t length;
    // JS_GetArrayLength actually works on all objects
    if (!JS_GetArrayLength(cx, seq, &length)) {
      return false;
    }
    Sequence< Nullable<float> > &arr = const_cast< Sequence< Nullable<float> >& >(arg10);
    if (!arr.SetCapacity(length)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t i = 0; i < length; ++i) {
      jsval temp;
      if (!JS_GetElement(cx, seq, i, &temp)) {
        return false;
      }
      Nullable<float>& slot = *arr.AppendElement();
      if (temp.isNullOrUndefined()) {
        const_cast< Nullable<float>& >(slot).SetNull();
      } else if (!ValueToPrimitive<float, eDefault>(cx, temp, &const_cast< Nullable<float>& >(slot).SetValue())) {
        return false;
      } else if (!MOZ_DOUBLE_IS_FINITE(slot.Value())) {
        // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
        //       when passed a non-finite float too.
        ThrowErrorMessage(cx, MSG_NOT_FINITE);
        return false;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  const Sequence< Nullable<float> > arg11;
  if (argv[11].isObject()) {
    JSObject* seq = &argv[11].toObject();

    if (!IsArrayLike(cx, seq)) {
      ThrowErrorMessage(cx, MSG_NOT_SEQUENCE);
      return false;
    }
    uint32_t length;
    // JS_GetArrayLength actually works on all objects
    if (!JS_GetArrayLength(cx, seq, &length)) {
      return false;
    }
    Sequence< Nullable<float> > &arr = const_cast< Sequence< Nullable<float> >& >(arg11);
    if (!arr.SetCapacity(length)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t i = 0; i < length; ++i) {
      jsval temp;
      if (!JS_GetElement(cx, seq, i, &temp)) {
        return false;
      }
      Nullable<float>& slot = *arr.AppendElement();
      if (temp.isNullOrUndefined()) {
        const_cast< Nullable<float>& >(slot).SetNull();
      } else if (!ValueToPrimitive<float, eDefault>(cx, temp, &const_cast< Nullable<float>& >(slot).SetValue())) {
        return false;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  const Sequence< double > arg12;
  if (argv[12].isObject()) {
    JSObject* seq = &argv[12].toObject();

    if (!IsArrayLike(cx, seq)) {
      ThrowErrorMessage(cx, MSG_NOT_SEQUENCE);
      return false;
    }
    uint32_t length;
    // JS_GetArrayLength actually works on all objects
    if (!JS_GetArrayLength(cx, seq, &length)) {
      return false;
    }
    Sequence< double > &arr = const_cast< Sequence< double >& >(arg12);
    if (!arr.SetCapacity(length)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t i = 0; i < length; ++i) {
      jsval temp;
      if (!JS_GetElement(cx, seq, i, &temp)) {
        return false;
      }
      double& slot = *arr.AppendElement();
      if (!ValueToPrimitive<double, eDefault>(cx, temp, &slot)) {
        return false;
      } else if (!MOZ_DOUBLE_IS_FINITE(slot)) {
        // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
        //       when passed a non-finite float too.
        ThrowErrorMessage(cx, MSG_NOT_FINITE);
        return false;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  const Sequence< double > arg13;
  if (argv[13].isObject()) {
    JSObject* seq = &argv[13].toObject();

    if (!IsArrayLike(cx, seq)) {
      ThrowErrorMessage(cx, MSG_NOT_SEQUENCE);
      return false;
    }
    uint32_t length;
    // JS_GetArrayLength actually works on all objects
    if (!JS_GetArrayLength(cx, seq, &length)) {
      return false;
    }
    Sequence< double > &arr = const_cast< Sequence< double >& >(arg13);
    if (!arr.SetCapacity(length)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t i = 0; i < length; ++i) {
      jsval temp;
      if (!JS_GetElement(cx, seq, i, &temp)) {
        return false;
      }
      double& slot = *arr.AppendElement();
      if (!ValueToPrimitive<double, eDefault>(cx, temp, &slot)) {
        return false;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  const Sequence< Nullable<double> > arg14;
  if (argv[14].isObject()) {
    JSObject* seq = &argv[14].toObject();

    if (!IsArrayLike(cx, seq)) {
      ThrowErrorMessage(cx, MSG_NOT_SEQUENCE);
      return false;
    }
    uint32_t length;
    // JS_GetArrayLength actually works on all objects
    if (!JS_GetArrayLength(cx, seq, &length)) {
      return false;
    }
    Sequence< Nullable<double> > &arr = const_cast< Sequence< Nullable<double> >& >(arg14);
    if (!arr.SetCapacity(length)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t i = 0; i < length; ++i) {
      jsval temp;
      if (!JS_GetElement(cx, seq, i, &temp)) {
        return false;
      }
      Nullable<double>& slot = *arr.AppendElement();
      if (temp.isNullOrUndefined()) {
        const_cast< Nullable<double>& >(slot).SetNull();
      } else if (!ValueToPrimitive<double, eDefault>(cx, temp, &const_cast< Nullable<double>& >(slot).SetValue())) {
        return false;
      } else if (!MOZ_DOUBLE_IS_FINITE(slot.Value())) {
        // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
        //       when passed a non-finite float too.
        ThrowErrorMessage(cx, MSG_NOT_FINITE);
        return false;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  const Sequence< Nullable<double> > arg15;
  if (argv[15].isObject()) {
    JSObject* seq = &argv[15].toObject();

    if (!IsArrayLike(cx, seq)) {
      ThrowErrorMessage(cx, MSG_NOT_SEQUENCE);
      return false;
    }
    uint32_t length;
    // JS_GetArrayLength actually works on all objects
    if (!JS_GetArrayLength(cx, seq, &length)) {
      return false;
    }
    Sequence< Nullable<double> > &arr = const_cast< Sequence< Nullable<double> >& >(arg15);
    if (!arr.SetCapacity(length)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t i = 0; i < length; ++i) {
      jsval temp;
      if (!JS_GetElement(cx, seq, i, &temp)) {
        return false;
      }
      Nullable<double>& slot = *arr.AppendElement();
      if (temp.isNullOrUndefined()) {
        const_cast< Nullable<double>& >(slot).SetNull();
      } else if (!ValueToPrimitive<double, eDefault>(cx, temp, &const_cast< Nullable<double>& >(slot).SetValue())) {
        return false;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassFloat(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passFloat_methodinfo = {
  (JSJitPropertyOp)passFloat,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passLenientFloat(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 16) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.passLenientFloat");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[0], &arg0)) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg0)) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    *vp = JSVAL_VOID;
    return true;
  }
  float arg1;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[1], &arg1)) {
    return false;
  }
  const Nullable<float> arg2;
  if (argv[2].isNullOrUndefined()) {
    const_cast< Nullable<float>& >(arg2).SetNull();
  } else if (!ValueToPrimitive<float, eDefault>(cx, argv[2], &const_cast< Nullable<float>& >(arg2).SetValue())) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg2.Value())) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    *vp = JSVAL_VOID;
    return true;
  }
  const Nullable<float> arg3;
  if (argv[3].isNullOrUndefined()) {
    const_cast< Nullable<float>& >(arg3).SetNull();
  } else if (!ValueToPrimitive<float, eDefault>(cx, argv[3], &const_cast< Nullable<float>& >(arg3).SetValue())) {
    return false;
  }
  double arg4;
  if (!ValueToPrimitive<double, eDefault>(cx, argv[4], &arg4)) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg4)) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    *vp = JSVAL_VOID;
    return true;
  }
  double arg5;
  if (!ValueToPrimitive<double, eDefault>(cx, argv[5], &arg5)) {
    return false;
  }
  const Nullable<double> arg6;
  if (argv[6].isNullOrUndefined()) {
    const_cast< Nullable<double>& >(arg6).SetNull();
  } else if (!ValueToPrimitive<double, eDefault>(cx, argv[6], &const_cast< Nullable<double>& >(arg6).SetValue())) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg6.Value())) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    *vp = JSVAL_VOID;
    return true;
  }
  const Nullable<double> arg7;
  if (argv[7].isNullOrUndefined()) {
    const_cast< Nullable<double>& >(arg7).SetNull();
  } else if (!ValueToPrimitive<double, eDefault>(cx, argv[7], &const_cast< Nullable<double>& >(arg7).SetValue())) {
    return false;
  }
  const Sequence< float > arg8;
  if (argv[8].isObject()) {
    JSObject* seq = &argv[8].toObject();

    if (!IsArrayLike(cx, seq)) {
      ThrowErrorMessage(cx, MSG_NOT_SEQUENCE);
      return false;
    }
    uint32_t length;
    // JS_GetArrayLength actually works on all objects
    if (!JS_GetArrayLength(cx, seq, &length)) {
      return false;
    }
    Sequence< float > &arr = const_cast< Sequence< float >& >(arg8);
    if (!arr.SetCapacity(length)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t i = 0; i < length; ++i) {
      jsval temp;
      if (!JS_GetElement(cx, seq, i, &temp)) {
        return false;
      }
      float& slot = *arr.AppendElement();
      if (!ValueToPrimitive<float, eDefault>(cx, temp, &slot)) {
        return false;
      } else if (!MOZ_DOUBLE_IS_FINITE(slot)) {
        // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
        //       when passed a non-finite float too.
        *vp = JSVAL_VOID;
        return true;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  const Sequence< float > arg9;
  if (argv[9].isObject()) {
    JSObject* seq = &argv[9].toObject();

    if (!IsArrayLike(cx, seq)) {
      ThrowErrorMessage(cx, MSG_NOT_SEQUENCE);
      return false;
    }
    uint32_t length;
    // JS_GetArrayLength actually works on all objects
    if (!JS_GetArrayLength(cx, seq, &length)) {
      return false;
    }
    Sequence< float > &arr = const_cast< Sequence< float >& >(arg9);
    if (!arr.SetCapacity(length)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t i = 0; i < length; ++i) {
      jsval temp;
      if (!JS_GetElement(cx, seq, i, &temp)) {
        return false;
      }
      float& slot = *arr.AppendElement();
      if (!ValueToPrimitive<float, eDefault>(cx, temp, &slot)) {
        return false;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  const Sequence< Nullable<float> > arg10;
  if (argv[10].isObject()) {
    JSObject* seq = &argv[10].toObject();

    if (!IsArrayLike(cx, seq)) {
      ThrowErrorMessage(cx, MSG_NOT_SEQUENCE);
      return false;
    }
    uint32_t length;
    // JS_GetArrayLength actually works on all objects
    if (!JS_GetArrayLength(cx, seq, &length)) {
      return false;
    }
    Sequence< Nullable<float> > &arr = const_cast< Sequence< Nullable<float> >& >(arg10);
    if (!arr.SetCapacity(length)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t i = 0; i < length; ++i) {
      jsval temp;
      if (!JS_GetElement(cx, seq, i, &temp)) {
        return false;
      }
      Nullable<float>& slot = *arr.AppendElement();
      if (temp.isNullOrUndefined()) {
        const_cast< Nullable<float>& >(slot).SetNull();
      } else if (!ValueToPrimitive<float, eDefault>(cx, temp, &const_cast< Nullable<float>& >(slot).SetValue())) {
        return false;
      } else if (!MOZ_DOUBLE_IS_FINITE(slot.Value())) {
        // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
        //       when passed a non-finite float too.
        *vp = JSVAL_VOID;
        return true;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  const Sequence< Nullable<float> > arg11;
  if (argv[11].isObject()) {
    JSObject* seq = &argv[11].toObject();

    if (!IsArrayLike(cx, seq)) {
      ThrowErrorMessage(cx, MSG_NOT_SEQUENCE);
      return false;
    }
    uint32_t length;
    // JS_GetArrayLength actually works on all objects
    if (!JS_GetArrayLength(cx, seq, &length)) {
      return false;
    }
    Sequence< Nullable<float> > &arr = const_cast< Sequence< Nullable<float> >& >(arg11);
    if (!arr.SetCapacity(length)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t i = 0; i < length; ++i) {
      jsval temp;
      if (!JS_GetElement(cx, seq, i, &temp)) {
        return false;
      }
      Nullable<float>& slot = *arr.AppendElement();
      if (temp.isNullOrUndefined()) {
        const_cast< Nullable<float>& >(slot).SetNull();
      } else if (!ValueToPrimitive<float, eDefault>(cx, temp, &const_cast< Nullable<float>& >(slot).SetValue())) {
        return false;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  const Sequence< double > arg12;
  if (argv[12].isObject()) {
    JSObject* seq = &argv[12].toObject();

    if (!IsArrayLike(cx, seq)) {
      ThrowErrorMessage(cx, MSG_NOT_SEQUENCE);
      return false;
    }
    uint32_t length;
    // JS_GetArrayLength actually works on all objects
    if (!JS_GetArrayLength(cx, seq, &length)) {
      return false;
    }
    Sequence< double > &arr = const_cast< Sequence< double >& >(arg12);
    if (!arr.SetCapacity(length)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t i = 0; i < length; ++i) {
      jsval temp;
      if (!JS_GetElement(cx, seq, i, &temp)) {
        return false;
      }
      double& slot = *arr.AppendElement();
      if (!ValueToPrimitive<double, eDefault>(cx, temp, &slot)) {
        return false;
      } else if (!MOZ_DOUBLE_IS_FINITE(slot)) {
        // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
        //       when passed a non-finite float too.
        *vp = JSVAL_VOID;
        return true;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  const Sequence< double > arg13;
  if (argv[13].isObject()) {
    JSObject* seq = &argv[13].toObject();

    if (!IsArrayLike(cx, seq)) {
      ThrowErrorMessage(cx, MSG_NOT_SEQUENCE);
      return false;
    }
    uint32_t length;
    // JS_GetArrayLength actually works on all objects
    if (!JS_GetArrayLength(cx, seq, &length)) {
      return false;
    }
    Sequence< double > &arr = const_cast< Sequence< double >& >(arg13);
    if (!arr.SetCapacity(length)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t i = 0; i < length; ++i) {
      jsval temp;
      if (!JS_GetElement(cx, seq, i, &temp)) {
        return false;
      }
      double& slot = *arr.AppendElement();
      if (!ValueToPrimitive<double, eDefault>(cx, temp, &slot)) {
        return false;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  const Sequence< Nullable<double> > arg14;
  if (argv[14].isObject()) {
    JSObject* seq = &argv[14].toObject();

    if (!IsArrayLike(cx, seq)) {
      ThrowErrorMessage(cx, MSG_NOT_SEQUENCE);
      return false;
    }
    uint32_t length;
    // JS_GetArrayLength actually works on all objects
    if (!JS_GetArrayLength(cx, seq, &length)) {
      return false;
    }
    Sequence< Nullable<double> > &arr = const_cast< Sequence< Nullable<double> >& >(arg14);
    if (!arr.SetCapacity(length)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t i = 0; i < length; ++i) {
      jsval temp;
      if (!JS_GetElement(cx, seq, i, &temp)) {
        return false;
      }
      Nullable<double>& slot = *arr.AppendElement();
      if (temp.isNullOrUndefined()) {
        const_cast< Nullable<double>& >(slot).SetNull();
      } else if (!ValueToPrimitive<double, eDefault>(cx, temp, &const_cast< Nullable<double>& >(slot).SetValue())) {
        return false;
      } else if (!MOZ_DOUBLE_IS_FINITE(slot.Value())) {
        // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
        //       when passed a non-finite float too.
        *vp = JSVAL_VOID;
        return true;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  const Sequence< Nullable<double> > arg15;
  if (argv[15].isObject()) {
    JSObject* seq = &argv[15].toObject();

    if (!IsArrayLike(cx, seq)) {
      ThrowErrorMessage(cx, MSG_NOT_SEQUENCE);
      return false;
    }
    uint32_t length;
    // JS_GetArrayLength actually works on all objects
    if (!JS_GetArrayLength(cx, seq, &length)) {
      return false;
    }
    Sequence< Nullable<double> > &arr = const_cast< Sequence< Nullable<double> >& >(arg15);
    if (!arr.SetCapacity(length)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t i = 0; i < length; ++i) {
      jsval temp;
      if (!JS_GetElement(cx, seq, i, &temp)) {
        return false;
      }
      Nullable<double>& slot = *arr.AppendElement();
      if (temp.isNullOrUndefined()) {
        const_cast< Nullable<double>& >(slot).SetNull();
      } else if (!ValueToPrimitive<double, eDefault>(cx, temp, &const_cast< Nullable<double>& >(slot).SetValue())) {
        return false;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassLenientFloat(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passLenientFloat_methodinfo = {
  (JSJitPropertyOp)passLenientFloat,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_lenientFloatAttr(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* vp)
{
  float result;
  result = self->LenientFloatAttr();
  *vp = JS_NumberValue(double(result));
  return true;
}

static bool
set_lenientFloatAttr(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* argv)
{
  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[0], &arg0)) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg0)) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    return true;
  }
  self->SetLenientFloatAttr(arg0);

  return true;
}


const JSJitInfo lenientFloatAttr_getterinfo = {
  (JSJitPropertyOp)get_lenientFloatAttr,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo lenientFloatAttr_setterinfo = {
  (JSJitPropertyOp)set_lenientFloatAttr,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_lenientDoubleAttr(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* vp)
{
  double result;
  result = self->LenientDoubleAttr();
  *vp = JS_NumberValue(double(result));
  return true;
}

static bool
set_lenientDoubleAttr(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* argv)
{
  double arg0;
  if (!ValueToPrimitive<double, eDefault>(cx, argv[0], &arg0)) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg0)) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    return true;
  }
  self->SetLenientDoubleAttr(arg0);

  return true;
}


const JSJitInfo lenientDoubleAttr_getterinfo = {
  (JSJitPropertyOp)get_lenientDoubleAttr,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo lenientDoubleAttr_setterinfo = {
  (JSJitPropertyOp)set_lenientDoubleAttr,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveSelf(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{
  nsRefPtr<mozilla::dom::TestInterface> result;
  result = self->ReceiveSelf();
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}


const JSJitInfo receiveSelf_methodinfo = {
  (JSJitPropertyOp)receiveSelf,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveNullableSelf(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{
  nsRefPtr<mozilla::dom::TestInterface> result;
  result = self->ReceiveNullableSelf();
  if (!result) {
    *vp = JSVAL_NULL;
    return true;
  }
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}


const JSJitInfo receiveNullableSelf_methodinfo = {
  (JSJitPropertyOp)receiveNullableSelf,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveWeakSelf(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{
  mozilla::dom::TestInterface* result;
  result = self->ReceiveWeakSelf();
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}


const JSJitInfo receiveWeakSelf_methodinfo = {
  (JSJitPropertyOp)receiveWeakSelf,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveWeakNullableSelf(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{
  mozilla::dom::TestInterface* result;
  result = self->ReceiveWeakNullableSelf();
  if (!result) {
    *vp = JSVAL_NULL;
    return true;
  }
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}


const JSJitInfo receiveWeakNullableSelf_methodinfo = {
  (JSJitPropertyOp)receiveWeakNullableSelf,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
passSelf(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.passSelf");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  NonNull<mozilla::dom::TestInterface> arg0;
  if (argv[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(cx, &argv[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestInterface");
        return false;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassSelf(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passSelf_methodinfo = {
  (JSJitPropertyOp)passSelf,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passSelf2(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.passSelf2");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  NonNull<mozilla::dom::TestInterface> arg0;
  if (argv[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(cx, &argv[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestInterface");
        return false;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassSelf2(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passSelf2_methodinfo = {
  (JSJitPropertyOp)passSelf2,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passNullableSelf(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.passNullableSelf");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  mozilla::dom::TestInterface* arg0;
  if (argv[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(cx, &argv[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestInterface");
        return false;
      }
    }
  } else if (argv[0].isNullOrUndefined()) {
    arg0 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassNullableSelf(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passNullableSelf_methodinfo = {
  (JSJitPropertyOp)passNullableSelf,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_nonNullSelf(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* vp)
{
  nsRefPtr<mozilla::dom::TestInterface> result;
  result = self->NonNullSelf();
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static bool
set_nonNullSelf(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* argv)
{
  NonNull<mozilla::dom::TestInterface> arg0;
  if (argv[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(cx, &argv[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestInterface");
        return false;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->SetNonNullSelf(arg0);

  return true;
}


const JSJitInfo nonNullSelf_getterinfo = {
  (JSJitPropertyOp)get_nonNullSelf,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo nonNullSelf_setterinfo = {
  (JSJitPropertyOp)set_nonNullSelf,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_nullableSelf(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* vp)
{
  nsRefPtr<mozilla::dom::TestInterface> result;
  result = self->GetNullableSelf();
  if (!result) {
    *vp = JSVAL_NULL;
    return true;
  }
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static bool
set_nullableSelf(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* argv)
{
  mozilla::dom::TestInterface* arg0;
  if (argv[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(cx, &argv[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestInterface");
        return false;
      }
    }
  } else if (argv[0].isNullOrUndefined()) {
    arg0 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->SetNullableSelf(arg0);

  return true;
}


const JSJitInfo nullableSelf_getterinfo = {
  (JSJitPropertyOp)get_nullableSelf,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo nullableSelf_setterinfo = {
  (JSJitPropertyOp)set_nullableSelf,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalSelf(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  const Optional< mozilla::dom::TestInterface* > arg0;
  if (0 < argc) {
    const_cast< Optional< mozilla::dom::TestInterface* > &>(arg0).Construct();
    if (argv[0].isObject()) {
      {
        nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(cx, &argv[0].toObject(), const_cast< mozilla::dom::TestInterface* & >(arg0.Value()));
        if (NS_FAILED(rv)) {
          ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestInterface");
          return false;
        }
      }
    } else if (argv[0].isNullOrUndefined()) {
      const_cast< mozilla::dom::TestInterface* & >(arg0.Value()) = NULL;
    } else {
      ThrowErrorMessage(cx, MSG_NOT_OBJECT);
      return false;
    }
  }
  self->PassOptionalSelf(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalSelf_methodinfo = {
  (JSJitPropertyOp)passOptionalSelf,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalNonNullSelf(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  const Optional< NonNull<mozilla::dom::TestInterface> > arg0;
  if (0 < argc) {
    const_cast< Optional< NonNull<mozilla::dom::TestInterface> > &>(arg0).Construct();
    if (argv[0].isObject()) {
      {
        nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(cx, &argv[0].toObject(), const_cast< NonNull<mozilla::dom::TestInterface> & >(arg0.Value()));
        if (NS_FAILED(rv)) {
          ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestInterface");
          return false;
        }
      }
    } else {
      ThrowErrorMessage(cx, MSG_NOT_OBJECT);
      return false;
    }
  }
  self->PassOptionalNonNullSelf(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalNonNullSelf_methodinfo = {
  (JSJitPropertyOp)passOptionalNonNullSelf,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalSelfWithDefault(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  mozilla::dom::TestInterface* arg0;
  if (0 < argc) {
    if (argv[0].isObject()) {
      {
        nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(cx, &argv[0].toObject(), arg0);
        if (NS_FAILED(rv)) {
          ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestInterface");
          return false;
        }
      }
    } else if (argv[0].isNullOrUndefined()) {
      arg0 = NULL;
    } else {
      ThrowErrorMessage(cx, MSG_NOT_OBJECT);
      return false;
    }
  } else {
    arg0 = NULL;
  }
  self->PassOptionalSelfWithDefault(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalSelfWithDefault_methodinfo = {
  (JSJitPropertyOp)passOptionalSelfWithDefault,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveNonWrapperCacheInterface(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{
  nsRefPtr<mozilla::dom::TestNonWrapperCacheInterface> result;
  result = self->ReceiveNonWrapperCacheInterface();
  if (!WrapNewBindingNonWrapperCachedObject(cx, obj, result, vp)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}


const JSJitInfo receiveNonWrapperCacheInterface_methodinfo = {
  (JSJitPropertyOp)receiveNonWrapperCacheInterface,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveNullableNonWrapperCacheInterface(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{
  nsRefPtr<mozilla::dom::TestNonWrapperCacheInterface> result;
  result = self->ReceiveNullableNonWrapperCacheInterface();
  if (!result) {
    *vp = JSVAL_NULL;
    return true;
  }
  if (!WrapNewBindingNonWrapperCachedObject(cx, obj, result, vp)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}


const JSJitInfo receiveNullableNonWrapperCacheInterface_methodinfo = {
  (JSJitPropertyOp)receiveNullableNonWrapperCacheInterface,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveNonWrapperCacheInterfaceSequence(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{
  nsTArray< nsRefPtr<mozilla::dom::TestNonWrapperCacheInterface> > result;
  self->ReceiveNonWrapperCacheInterfaceSequence(result);

  uint32_t length = result.Length();
  JSObject *returnArray = JS_NewArrayObject(cx, length, NULL);
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    jsval tmp;
    for (uint32_t i = 0; i < length; ++i) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!WrapNewBindingNonWrapperCachedObject(cx, returnArray, result[i], &tmp)) {
          MOZ_ASSERT(JS_IsExceptionPending(cx));
          return false;
        }
        break;
      } while (0);
      if (!JS_DefineElement(cx, returnArray, i, tmp,
                            nullptr, nullptr, JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  *vp = JS::ObjectValue(*returnArray);
  return true;
}


const JSJitInfo receiveNonWrapperCacheInterfaceSequence_methodinfo = {
  (JSJitPropertyOp)receiveNonWrapperCacheInterfaceSequence,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveNullableNonWrapperCacheInterfaceSequence(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{
  nsTArray< nsRefPtr<mozilla::dom::TestNonWrapperCacheInterface> > result;
  self->ReceiveNullableNonWrapperCacheInterfaceSequence(result);

  uint32_t length = result.Length();
  JSObject *returnArray = JS_NewArrayObject(cx, length, NULL);
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    jsval tmp;
    for (uint32_t i = 0; i < length; ++i) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!result[i]) {
          tmp = JSVAL_NULL;
          break;
        }
        if (!WrapNewBindingNonWrapperCachedObject(cx, returnArray, result[i], &tmp)) {
          MOZ_ASSERT(JS_IsExceptionPending(cx));
          return false;
        }
        break;
      } while (0);
      if (!JS_DefineElement(cx, returnArray, i, tmp,
                            nullptr, nullptr, JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  *vp = JS::ObjectValue(*returnArray);
  return true;
}


const JSJitInfo receiveNullableNonWrapperCacheInterfaceSequence_methodinfo = {
  (JSJitPropertyOp)receiveNullableNonWrapperCacheInterfaceSequence,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveNonWrapperCacheInterfaceNullableSequence(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{
  Nullable< nsTArray< nsRefPtr<mozilla::dom::TestNonWrapperCacheInterface> > > result;
  self->ReceiveNonWrapperCacheInterfaceNullableSequence(result);

  if (result.IsNull()) {
    *vp = JSVAL_NULL;
    return true;
  }

  uint32_t length = result.Value().Length();
  JSObject *returnArray = JS_NewArrayObject(cx, length, NULL);
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    jsval tmp;
    for (uint32_t i = 0; i < length; ++i) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!WrapNewBindingNonWrapperCachedObject(cx, returnArray, result.Value()[i], &tmp)) {
          MOZ_ASSERT(JS_IsExceptionPending(cx));
          return false;
        }
        break;
      } while (0);
      if (!JS_DefineElement(cx, returnArray, i, tmp,
                            nullptr, nullptr, JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  *vp = JS::ObjectValue(*returnArray);
  return true;
}


const JSJitInfo receiveNonWrapperCacheInterfaceNullableSequence_methodinfo = {
  (JSJitPropertyOp)receiveNonWrapperCacheInterfaceNullableSequence,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveNullableNonWrapperCacheInterfaceNullableSequence(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{
  Nullable< nsTArray< nsRefPtr<mozilla::dom::TestNonWrapperCacheInterface> > > result;
  self->ReceiveNullableNonWrapperCacheInterfaceNullableSequence(result);

  if (result.IsNull()) {
    *vp = JSVAL_NULL;
    return true;
  }

  uint32_t length = result.Value().Length();
  JSObject *returnArray = JS_NewArrayObject(cx, length, NULL);
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    jsval tmp;
    for (uint32_t i = 0; i < length; ++i) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!result.Value()[i]) {
          tmp = JSVAL_NULL;
          break;
        }
        if (!WrapNewBindingNonWrapperCachedObject(cx, returnArray, result.Value()[i], &tmp)) {
          MOZ_ASSERT(JS_IsExceptionPending(cx));
          return false;
        }
        break;
      } while (0);
      if (!JS_DefineElement(cx, returnArray, i, tmp,
                            nullptr, nullptr, JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  *vp = JS::ObjectValue(*returnArray);
  return true;
}


const JSJitInfo receiveNullableNonWrapperCacheInterfaceNullableSequence_methodinfo = {
  (JSJitPropertyOp)receiveNullableNonWrapperCacheInterfaceNullableSequence,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveOther(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{
  nsRefPtr<mozilla::dom::TestNonCastableInterface> result;
  result = self->ReceiveOther();
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}


const JSJitInfo receiveOther_methodinfo = {
  (JSJitPropertyOp)receiveOther,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveNullableOther(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{
  nsRefPtr<mozilla::dom::TestNonCastableInterface> result;
  result = self->ReceiveNullableOther();
  if (!result) {
    *vp = JSVAL_NULL;
    return true;
  }
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}


const JSJitInfo receiveNullableOther_methodinfo = {
  (JSJitPropertyOp)receiveNullableOther,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveWeakOther(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{
  mozilla::dom::TestNonCastableInterface* result;
  result = self->ReceiveWeakOther();
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}


const JSJitInfo receiveWeakOther_methodinfo = {
  (JSJitPropertyOp)receiveWeakOther,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveWeakNullableOther(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{
  mozilla::dom::TestNonCastableInterface* result;
  result = self->ReceiveWeakNullableOther();
  if (!result) {
    *vp = JSVAL_NULL;
    return true;
  }
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}


const JSJitInfo receiveWeakNullableOther_methodinfo = {
  (JSJitPropertyOp)receiveWeakNullableOther,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOther(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.passOther");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  nsRefPtr<mozilla::dom::TestNonCastableInterface> arg0_holder;
  NonNull<mozilla::dom::TestNonCastableInterface> arg0;
  if (argv[0].isObject()) {
    jsval tmpVal = argv[0];
    mozilla::dom::TestNonCastableInterface* tmp;
    if (NS_FAILED(xpc_qsUnwrapArg<mozilla::dom::TestNonCastableInterface>(cx, argv[0], &tmp, static_cast<mozilla::dom::TestNonCastableInterface**>(getter_AddRefs(arg0_holder)), &tmpVal))) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestNonCastableInterface");return false;
    }
    MOZ_ASSERT(tmp);
    if (tmpVal != argv[0] && !arg0_holder) {
      // We have to have a strong ref, because we got this off
      // some random object that might get GCed
      arg0_holder = tmp;
    }
    arg0 = tmp;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassOther(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOther_methodinfo = {
  (JSJitPropertyOp)passOther,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOther2(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.passOther2");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  nsRefPtr<mozilla::dom::TestNonCastableInterface> arg0_holder;
  NonNull<mozilla::dom::TestNonCastableInterface> arg0;
  if (argv[0].isObject()) {
    jsval tmpVal = argv[0];
    mozilla::dom::TestNonCastableInterface* tmp;
    if (NS_FAILED(xpc_qsUnwrapArg<mozilla::dom::TestNonCastableInterface>(cx, argv[0], &tmp, static_cast<mozilla::dom::TestNonCastableInterface**>(getter_AddRefs(arg0_holder)), &tmpVal))) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestNonCastableInterface");return false;
    }
    MOZ_ASSERT(tmp);
    if (tmpVal != argv[0] && !arg0_holder) {
      // We have to have a strong ref, because we got this off
      // some random object that might get GCed
      arg0_holder = tmp;
    }
    arg0 = tmp;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassOther2(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOther2_methodinfo = {
  (JSJitPropertyOp)passOther2,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passNullableOther(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.passNullableOther");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  nsRefPtr<mozilla::dom::TestNonCastableInterface> arg0_holder;
  mozilla::dom::TestNonCastableInterface* arg0;
  if (argv[0].isObject()) {
    jsval tmpVal = argv[0];
    mozilla::dom::TestNonCastableInterface* tmp;
    if (NS_FAILED(xpc_qsUnwrapArg<mozilla::dom::TestNonCastableInterface>(cx, argv[0], &tmp, static_cast<mozilla::dom::TestNonCastableInterface**>(getter_AddRefs(arg0_holder)), &tmpVal))) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestNonCastableInterface");return false;
    }
    MOZ_ASSERT(tmp);
    if (tmpVal != argv[0] && !arg0_holder) {
      // We have to have a strong ref, because we got this off
      // some random object that might get GCed
      arg0_holder = tmp;
    }
    arg0 = tmp;
  } else if (argv[0].isNullOrUndefined()) {
    arg0 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassNullableOther(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passNullableOther_methodinfo = {
  (JSJitPropertyOp)passNullableOther,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_nonNullOther(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* vp)
{
  nsRefPtr<mozilla::dom::TestNonCastableInterface> result;
  result = self->NonNullOther();
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static bool
set_nonNullOther(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* argv)
{
  nsRefPtr<mozilla::dom::TestNonCastableInterface> arg0_holder;
  NonNull<mozilla::dom::TestNonCastableInterface> arg0;
  if (argv[0].isObject()) {
    jsval tmpVal = argv[0];
    mozilla::dom::TestNonCastableInterface* tmp;
    if (NS_FAILED(xpc_qsUnwrapArg<mozilla::dom::TestNonCastableInterface>(cx, argv[0], &tmp, static_cast<mozilla::dom::TestNonCastableInterface**>(getter_AddRefs(arg0_holder)), &tmpVal))) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestNonCastableInterface");return false;
    }
    MOZ_ASSERT(tmp);
    if (tmpVal != argv[0] && !arg0_holder) {
      // We have to have a strong ref, because we got this off
      // some random object that might get GCed
      arg0_holder = tmp;
    }
    arg0 = tmp;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->SetNonNullOther(arg0);

  return true;
}


const JSJitInfo nonNullOther_getterinfo = {
  (JSJitPropertyOp)get_nonNullOther,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo nonNullOther_setterinfo = {
  (JSJitPropertyOp)set_nonNullOther,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_nullableOther(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* vp)
{
  nsRefPtr<mozilla::dom::TestNonCastableInterface> result;
  result = self->GetNullableOther();
  if (!result) {
    *vp = JSVAL_NULL;
    return true;
  }
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static bool
set_nullableOther(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* argv)
{
  nsRefPtr<mozilla::dom::TestNonCastableInterface> arg0_holder;
  mozilla::dom::TestNonCastableInterface* arg0;
  if (argv[0].isObject()) {
    jsval tmpVal = argv[0];
    mozilla::dom::TestNonCastableInterface* tmp;
    if (NS_FAILED(xpc_qsUnwrapArg<mozilla::dom::TestNonCastableInterface>(cx, argv[0], &tmp, static_cast<mozilla::dom::TestNonCastableInterface**>(getter_AddRefs(arg0_holder)), &tmpVal))) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestNonCastableInterface");return false;
    }
    MOZ_ASSERT(tmp);
    if (tmpVal != argv[0] && !arg0_holder) {
      // We have to have a strong ref, because we got this off
      // some random object that might get GCed
      arg0_holder = tmp;
    }
    arg0 = tmp;
  } else if (argv[0].isNullOrUndefined()) {
    arg0 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->SetNullableOther(arg0);

  return true;
}


const JSJitInfo nullableOther_getterinfo = {
  (JSJitPropertyOp)get_nullableOther,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo nullableOther_setterinfo = {
  (JSJitPropertyOp)set_nullableOther,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalOther(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  const Optional< nsRefPtr<mozilla::dom::TestNonCastableInterface> > arg0_holder;
  const Optional< mozilla::dom::TestNonCastableInterface* > arg0;
  if (0 < argc) {
    const_cast< Optional< mozilla::dom::TestNonCastableInterface* > &>(arg0).Construct();
    const_cast< Optional< nsRefPtr<mozilla::dom::TestNonCastableInterface> > &>(arg0_holder).Construct();
    if (argv[0].isObject()) {
      jsval tmpVal = argv[0];
      mozilla::dom::TestNonCastableInterface* tmp;
      if (NS_FAILED(xpc_qsUnwrapArg<mozilla::dom::TestNonCastableInterface>(cx, argv[0], &tmp, static_cast<mozilla::dom::TestNonCastableInterface**>(getter_AddRefs(const_cast< nsRefPtr<mozilla::dom::TestNonCastableInterface> & >(arg0_holder.Value()))), &tmpVal))) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestNonCastableInterface");return false;
      }
      MOZ_ASSERT(tmp);
      if (tmpVal != argv[0] && !const_cast< nsRefPtr<mozilla::dom::TestNonCastableInterface> & >(arg0_holder.Value())) {
        // We have to have a strong ref, because we got this off
        // some random object that might get GCed
        const_cast< nsRefPtr<mozilla::dom::TestNonCastableInterface> & >(arg0_holder.Value()) = tmp;
      }
      const_cast< mozilla::dom::TestNonCastableInterface* & >(arg0.Value()) = tmp;
    } else if (argv[0].isNullOrUndefined()) {
      const_cast< mozilla::dom::TestNonCastableInterface* & >(arg0.Value()) = NULL;
    } else {
      ThrowErrorMessage(cx, MSG_NOT_OBJECT);
      return false;
    }
  }
  self->PassOptionalOther(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalOther_methodinfo = {
  (JSJitPropertyOp)passOptionalOther,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalNonNullOther(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  const Optional< nsRefPtr<mozilla::dom::TestNonCastableInterface> > arg0_holder;
  const Optional< NonNull<mozilla::dom::TestNonCastableInterface> > arg0;
  if (0 < argc) {
    const_cast< Optional< NonNull<mozilla::dom::TestNonCastableInterface> > &>(arg0).Construct();
    const_cast< Optional< nsRefPtr<mozilla::dom::TestNonCastableInterface> > &>(arg0_holder).Construct();
    if (argv[0].isObject()) {
      jsval tmpVal = argv[0];
      mozilla::dom::TestNonCastableInterface* tmp;
      if (NS_FAILED(xpc_qsUnwrapArg<mozilla::dom::TestNonCastableInterface>(cx, argv[0], &tmp, static_cast<mozilla::dom::TestNonCastableInterface**>(getter_AddRefs(const_cast< nsRefPtr<mozilla::dom::TestNonCastableInterface> & >(arg0_holder.Value()))), &tmpVal))) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestNonCastableInterface");return false;
      }
      MOZ_ASSERT(tmp);
      if (tmpVal != argv[0] && !const_cast< nsRefPtr<mozilla::dom::TestNonCastableInterface> & >(arg0_holder.Value())) {
        // We have to have a strong ref, because we got this off
        // some random object that might get GCed
        const_cast< nsRefPtr<mozilla::dom::TestNonCastableInterface> & >(arg0_holder.Value()) = tmp;
      }
      const_cast< NonNull<mozilla::dom::TestNonCastableInterface> & >(arg0.Value()) = tmp;
    } else {
      ThrowErrorMessage(cx, MSG_NOT_OBJECT);
      return false;
    }
  }
  self->PassOptionalNonNullOther(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalNonNullOther_methodinfo = {
  (JSJitPropertyOp)passOptionalNonNullOther,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalOtherWithDefault(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  nsRefPtr<mozilla::dom::TestNonCastableInterface> arg0_holder;
  mozilla::dom::TestNonCastableInterface* arg0;
  if (0 < argc) {
    if (argv[0].isObject()) {
      jsval tmpVal = argv[0];
      mozilla::dom::TestNonCastableInterface* tmp;
      if (NS_FAILED(xpc_qsUnwrapArg<mozilla::dom::TestNonCastableInterface>(cx, argv[0], &tmp, static_cast<mozilla::dom::TestNonCastableInterface**>(getter_AddRefs(arg0_holder)), &tmpVal))) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestNonCastableInterface");return false;
      }
      MOZ_ASSERT(tmp);
      if (tmpVal != argv[0] && !arg0_holder) {
        // We have to have a strong ref, because we got this off
        // some random object that might get GCed
        arg0_holder = tmp;
      }
      arg0 = tmp;
    } else if (argv[0].isNullOrUndefined()) {
      arg0 = NULL;
    } else {
      ThrowErrorMessage(cx, MSG_NOT_OBJECT);
      return false;
    }
  } else {
    arg0 = NULL;
  }
  self->PassOptionalOtherWithDefault(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalOtherWithDefault_methodinfo = {
  (JSJitPropertyOp)passOptionalOtherWithDefault,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveExternal(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{
  nsRefPtr<mozilla::dom::TestExternalInterface> result;
  result = self->ReceiveExternal();
  if (!WrapObject(cx, obj, result, vp)) {
    return false;
  }
  return true;
}


const JSJitInfo receiveExternal_methodinfo = {
  (JSJitPropertyOp)receiveExternal,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveNullableExternal(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{
  nsRefPtr<mozilla::dom::TestExternalInterface> result;
  result = self->ReceiveNullableExternal();
  if (!result) {
    *vp = JSVAL_NULL;
    return true;
  }
  if (!WrapObject(cx, obj, result, vp)) {
    return false;
  }
  return true;
}


const JSJitInfo receiveNullableExternal_methodinfo = {
  (JSJitPropertyOp)receiveNullableExternal,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveWeakExternal(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{
  mozilla::dom::TestExternalInterface* result;
  result = self->ReceiveWeakExternal();
  if (!WrapObject(cx, obj, result, vp)) {
    return false;
  }
  return true;
}


const JSJitInfo receiveWeakExternal_methodinfo = {
  (JSJitPropertyOp)receiveWeakExternal,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveWeakNullableExternal(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{
  mozilla::dom::TestExternalInterface* result;
  result = self->ReceiveWeakNullableExternal();
  if (!result) {
    *vp = JSVAL_NULL;
    return true;
  }
  if (!WrapObject(cx, obj, result, vp)) {
    return false;
  }
  return true;
}


const JSJitInfo receiveWeakNullableExternal_methodinfo = {
  (JSJitPropertyOp)receiveWeakNullableExternal,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
passExternal(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.passExternal");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  nsRefPtr<mozilla::dom::TestExternalInterface> arg0_holder;
  mozilla::dom::TestExternalInterface* arg0;
  if (argv[0].isObject()) {
    jsval tmpVal = argv[0];
    mozilla::dom::TestExternalInterface* tmp;
    if (NS_FAILED(xpc_qsUnwrapArg<mozilla::dom::TestExternalInterface>(cx, argv[0], &tmp, static_cast<mozilla::dom::TestExternalInterface**>(getter_AddRefs(arg0_holder)), &tmpVal))) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestExternalInterface");return false;
    }
    MOZ_ASSERT(tmp);
    if (tmpVal != argv[0] && !arg0_holder) {
      // We have to have a strong ref, because we got this off
      // some random object that might get GCed
      arg0_holder = tmp;
    }
    arg0 = tmp;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassExternal(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passExternal_methodinfo = {
  (JSJitPropertyOp)passExternal,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passExternal2(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.passExternal2");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  nsRefPtr<mozilla::dom::TestExternalInterface> arg0_holder;
  mozilla::dom::TestExternalInterface* arg0;
  if (argv[0].isObject()) {
    jsval tmpVal = argv[0];
    mozilla::dom::TestExternalInterface* tmp;
    if (NS_FAILED(xpc_qsUnwrapArg<mozilla::dom::TestExternalInterface>(cx, argv[0], &tmp, static_cast<mozilla::dom::TestExternalInterface**>(getter_AddRefs(arg0_holder)), &tmpVal))) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestExternalInterface");return false;
    }
    MOZ_ASSERT(tmp);
    if (tmpVal != argv[0] && !arg0_holder) {
      // We have to have a strong ref, because we got this off
      // some random object that might get GCed
      arg0_holder = tmp;
    }
    arg0 = tmp;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassExternal2(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passExternal2_methodinfo = {
  (JSJitPropertyOp)passExternal2,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passNullableExternal(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.passNullableExternal");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  nsRefPtr<mozilla::dom::TestExternalInterface> arg0_holder;
  mozilla::dom::TestExternalInterface* arg0;
  if (argv[0].isObject()) {
    jsval tmpVal = argv[0];
    mozilla::dom::TestExternalInterface* tmp;
    if (NS_FAILED(xpc_qsUnwrapArg<mozilla::dom::TestExternalInterface>(cx, argv[0], &tmp, static_cast<mozilla::dom::TestExternalInterface**>(getter_AddRefs(arg0_holder)), &tmpVal))) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestExternalInterface");return false;
    }
    MOZ_ASSERT(tmp);
    if (tmpVal != argv[0] && !arg0_holder) {
      // We have to have a strong ref, because we got this off
      // some random object that might get GCed
      arg0_holder = tmp;
    }
    arg0 = tmp;
  } else if (argv[0].isNullOrUndefined()) {
    arg0 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassNullableExternal(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passNullableExternal_methodinfo = {
  (JSJitPropertyOp)passNullableExternal,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_nonNullExternal(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* vp)
{
  nsRefPtr<mozilla::dom::TestExternalInterface> result;
  result = self->NonNullExternal();
  if (!WrapObject(cx, obj, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_nonNullExternal(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* argv)
{
  nsRefPtr<mozilla::dom::TestExternalInterface> arg0_holder;
  mozilla::dom::TestExternalInterface* arg0;
  if (argv[0].isObject()) {
    jsval tmpVal = argv[0];
    mozilla::dom::TestExternalInterface* tmp;
    if (NS_FAILED(xpc_qsUnwrapArg<mozilla::dom::TestExternalInterface>(cx, argv[0], &tmp, static_cast<mozilla::dom::TestExternalInterface**>(getter_AddRefs(arg0_holder)), &tmpVal))) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestExternalInterface");return false;
    }
    MOZ_ASSERT(tmp);
    if (tmpVal != argv[0] && !arg0_holder) {
      // We have to have a strong ref, because we got this off
      // some random object that might get GCed
      arg0_holder = tmp;
    }
    arg0 = tmp;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->SetNonNullExternal(arg0);

  return true;
}


const JSJitInfo nonNullExternal_getterinfo = {
  (JSJitPropertyOp)get_nonNullExternal,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo nonNullExternal_setterinfo = {
  (JSJitPropertyOp)set_nonNullExternal,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_nullableExternal(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* vp)
{
  nsRefPtr<mozilla::dom::TestExternalInterface> result;
  result = self->GetNullableExternal();
  if (!result) {
    *vp = JSVAL_NULL;
    return true;
  }
  if (!WrapObject(cx, obj, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_nullableExternal(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* argv)
{
  nsRefPtr<mozilla::dom::TestExternalInterface> arg0_holder;
  mozilla::dom::TestExternalInterface* arg0;
  if (argv[0].isObject()) {
    jsval tmpVal = argv[0];
    mozilla::dom::TestExternalInterface* tmp;
    if (NS_FAILED(xpc_qsUnwrapArg<mozilla::dom::TestExternalInterface>(cx, argv[0], &tmp, static_cast<mozilla::dom::TestExternalInterface**>(getter_AddRefs(arg0_holder)), &tmpVal))) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestExternalInterface");return false;
    }
    MOZ_ASSERT(tmp);
    if (tmpVal != argv[0] && !arg0_holder) {
      // We have to have a strong ref, because we got this off
      // some random object that might get GCed
      arg0_holder = tmp;
    }
    arg0 = tmp;
  } else if (argv[0].isNullOrUndefined()) {
    arg0 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->SetNullableExternal(arg0);

  return true;
}


const JSJitInfo nullableExternal_getterinfo = {
  (JSJitPropertyOp)get_nullableExternal,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo nullableExternal_setterinfo = {
  (JSJitPropertyOp)set_nullableExternal,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalExternal(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  const Optional< nsRefPtr<mozilla::dom::TestExternalInterface> > arg0_holder;
  const Optional< mozilla::dom::TestExternalInterface* > arg0;
  if (0 < argc) {
    const_cast< Optional< mozilla::dom::TestExternalInterface* > &>(arg0).Construct();
    const_cast< Optional< nsRefPtr<mozilla::dom::TestExternalInterface> > &>(arg0_holder).Construct();
    if (argv[0].isObject()) {
      jsval tmpVal = argv[0];
      mozilla::dom::TestExternalInterface* tmp;
      if (NS_FAILED(xpc_qsUnwrapArg<mozilla::dom::TestExternalInterface>(cx, argv[0], &tmp, static_cast<mozilla::dom::TestExternalInterface**>(getter_AddRefs(const_cast< nsRefPtr<mozilla::dom::TestExternalInterface> & >(arg0_holder.Value()))), &tmpVal))) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestExternalInterface");return false;
      }
      MOZ_ASSERT(tmp);
      if (tmpVal != argv[0] && !const_cast< nsRefPtr<mozilla::dom::TestExternalInterface> & >(arg0_holder.Value())) {
        // We have to have a strong ref, because we got this off
        // some random object that might get GCed
        const_cast< nsRefPtr<mozilla::dom::TestExternalInterface> & >(arg0_holder.Value()) = tmp;
      }
      const_cast< mozilla::dom::TestExternalInterface* & >(arg0.Value()) = tmp;
    } else if (argv[0].isNullOrUndefined()) {
      const_cast< mozilla::dom::TestExternalInterface* & >(arg0.Value()) = NULL;
    } else {
      ThrowErrorMessage(cx, MSG_NOT_OBJECT);
      return false;
    }
  }
  self->PassOptionalExternal(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalExternal_methodinfo = {
  (JSJitPropertyOp)passOptionalExternal,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalNonNullExternal(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  const Optional< nsRefPtr<mozilla::dom::TestExternalInterface> > arg0_holder;
  const Optional< mozilla::dom::TestExternalInterface* > arg0;
  if (0 < argc) {
    const_cast< Optional< mozilla::dom::TestExternalInterface* > &>(arg0).Construct();
    const_cast< Optional< nsRefPtr<mozilla::dom::TestExternalInterface> > &>(arg0_holder).Construct();
    if (argv[0].isObject()) {
      jsval tmpVal = argv[0];
      mozilla::dom::TestExternalInterface* tmp;
      if (NS_FAILED(xpc_qsUnwrapArg<mozilla::dom::TestExternalInterface>(cx, argv[0], &tmp, static_cast<mozilla::dom::TestExternalInterface**>(getter_AddRefs(const_cast< nsRefPtr<mozilla::dom::TestExternalInterface> & >(arg0_holder.Value()))), &tmpVal))) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestExternalInterface");return false;
      }
      MOZ_ASSERT(tmp);
      if (tmpVal != argv[0] && !const_cast< nsRefPtr<mozilla::dom::TestExternalInterface> & >(arg0_holder.Value())) {
        // We have to have a strong ref, because we got this off
        // some random object that might get GCed
        const_cast< nsRefPtr<mozilla::dom::TestExternalInterface> & >(arg0_holder.Value()) = tmp;
      }
      const_cast< mozilla::dom::TestExternalInterface* & >(arg0.Value()) = tmp;
    } else {
      ThrowErrorMessage(cx, MSG_NOT_OBJECT);
      return false;
    }
  }
  self->PassOptionalNonNullExternal(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalNonNullExternal_methodinfo = {
  (JSJitPropertyOp)passOptionalNonNullExternal,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalExternalWithDefault(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  nsRefPtr<mozilla::dom::TestExternalInterface> arg0_holder;
  mozilla::dom::TestExternalInterface* arg0;
  if (0 < argc) {
    if (argv[0].isObject()) {
      jsval tmpVal = argv[0];
      mozilla::dom::TestExternalInterface* tmp;
      if (NS_FAILED(xpc_qsUnwrapArg<mozilla::dom::TestExternalInterface>(cx, argv[0], &tmp, static_cast<mozilla::dom::TestExternalInterface**>(getter_AddRefs(arg0_holder)), &tmpVal))) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestExternalInterface");return false;
      }
      MOZ_ASSERT(tmp);
      if (tmpVal != argv[0] && !arg0_holder) {
        // We have to have a strong ref, because we got this off
        // some random object that might get GCed
        arg0_holder = tmp;
      }
      arg0 = tmp;
    } else if (argv[0].isNullOrUndefined()) {
      arg0 = NULL;
    } else {
      ThrowErrorMessage(cx, MSG_NOT_OBJECT);
      return false;
    }
  } else {
    arg0 = NULL;
  }
  self->PassOptionalExternalWithDefault(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalExternalWithDefault_methodinfo = {
  (JSJitPropertyOp)passOptionalExternalWithDefault,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveCallbackInterface(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{
  nsRefPtr<mozilla::dom::TestCallbackInterface> result;
  result = self->ReceiveCallbackInterface();
  if (!WrapCallbackInterface(cx, obj, result, vp)) {
    return false;
  }
  return true;
}


const JSJitInfo receiveCallbackInterface_methodinfo = {
  (JSJitPropertyOp)receiveCallbackInterface,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveNullableCallbackInterface(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{
  nsRefPtr<mozilla::dom::TestCallbackInterface> result;
  result = self->ReceiveNullableCallbackInterface();
  if (!result) {
    *vp = JSVAL_NULL;
    return true;
  }
  if (!WrapCallbackInterface(cx, obj, result, vp)) {
    return false;
  }
  return true;
}


const JSJitInfo receiveNullableCallbackInterface_methodinfo = {
  (JSJitPropertyOp)receiveNullableCallbackInterface,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveWeakCallbackInterface(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{
  nsRefPtr<mozilla::dom::TestCallbackInterface> result;
  result = self->ReceiveWeakCallbackInterface();
  if (!WrapCallbackInterface(cx, obj, result, vp)) {
    return false;
  }
  return true;
}


const JSJitInfo receiveWeakCallbackInterface_methodinfo = {
  (JSJitPropertyOp)receiveWeakCallbackInterface,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveWeakNullableCallbackInterface(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{
  nsRefPtr<mozilla::dom::TestCallbackInterface> result;
  result = self->ReceiveWeakNullableCallbackInterface();
  if (!result) {
    *vp = JSVAL_NULL;
    return true;
  }
  if (!WrapCallbackInterface(cx, obj, result, vp)) {
    return false;
  }
  return true;
}


const JSJitInfo receiveWeakNullableCallbackInterface_methodinfo = {
  (JSJitPropertyOp)receiveWeakNullableCallbackInterface,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
passCallbackInterface(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.passCallbackInterface");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  OwningNonNull<mozilla::dom::TestCallbackInterface> arg0;
  if (argv[0].isObject()) {
    if (!IsConvertibleToCallbackInterface(cx, &argv[0].toObject())) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestCallbackInterface");
        return false;
    }

    nsresult rv;
    XPCCallContext ccx(JS_CALLER, cx);
    if (!ccx.IsValid()) {
      rv = NS_ERROR_XPC_BAD_CONVERT_JS;
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestCallbackInterface");
      return false;
    }

    const nsIID& iid = NS_GET_IID(mozilla::dom::TestCallbackInterface);
    nsRefPtr<nsXPCWrappedJS> wrappedJS;
    rv = nsXPCWrappedJS::GetNewOrUsed(ccx, &argv[0].toObject(), iid,
                                      NULL, getter_AddRefs(wrappedJS));
    if (NS_FAILED(rv) || !wrappedJS) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestCallbackInterface");
      return false;
    }

    // Use a temp nsCOMPtr for the null-check, because arg0 might be
    // OwningNonNull, not an nsCOMPtr.
    nsCOMPtr<mozilla::dom::TestCallbackInterface> tmp = do_QueryObject(wrappedJS.get());
    if (!tmp) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestCallbackInterface");
      return false;
    }
    arg0 = tmp.forget();
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassCallbackInterface(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passCallbackInterface_methodinfo = {
  (JSJitPropertyOp)passCallbackInterface,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passCallbackInterface2(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.passCallbackInterface2");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  OwningNonNull<mozilla::dom::TestCallbackInterface> arg0;
  if (argv[0].isObject()) {
    if (!IsConvertibleToCallbackInterface(cx, &argv[0].toObject())) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestCallbackInterface");
        return false;
    }

    nsresult rv;
    XPCCallContext ccx(JS_CALLER, cx);
    if (!ccx.IsValid()) {
      rv = NS_ERROR_XPC_BAD_CONVERT_JS;
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestCallbackInterface");
      return false;
    }

    const nsIID& iid = NS_GET_IID(mozilla::dom::TestCallbackInterface);
    nsRefPtr<nsXPCWrappedJS> wrappedJS;
    rv = nsXPCWrappedJS::GetNewOrUsed(ccx, &argv[0].toObject(), iid,
                                      NULL, getter_AddRefs(wrappedJS));
    if (NS_FAILED(rv) || !wrappedJS) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestCallbackInterface");
      return false;
    }

    // Use a temp nsCOMPtr for the null-check, because arg0 might be
    // OwningNonNull, not an nsCOMPtr.
    nsCOMPtr<mozilla::dom::TestCallbackInterface> tmp = do_QueryObject(wrappedJS.get());
    if (!tmp) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestCallbackInterface");
      return false;
    }
    arg0 = tmp.forget();
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassCallbackInterface2(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passCallbackInterface2_methodinfo = {
  (JSJitPropertyOp)passCallbackInterface2,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passNullableCallbackInterface(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.passNullableCallbackInterface");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  nsRefPtr<mozilla::dom::TestCallbackInterface> arg0;
  if (argv[0].isObject()) {
    if (!IsConvertibleToCallbackInterface(cx, &argv[0].toObject())) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestCallbackInterface");
        return false;
    }

    nsresult rv;
    XPCCallContext ccx(JS_CALLER, cx);
    if (!ccx.IsValid()) {
      rv = NS_ERROR_XPC_BAD_CONVERT_JS;
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestCallbackInterface");
      return false;
    }

    const nsIID& iid = NS_GET_IID(mozilla::dom::TestCallbackInterface);
    nsRefPtr<nsXPCWrappedJS> wrappedJS;
    rv = nsXPCWrappedJS::GetNewOrUsed(ccx, &argv[0].toObject(), iid,
                                      NULL, getter_AddRefs(wrappedJS));
    if (NS_FAILED(rv) || !wrappedJS) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestCallbackInterface");
      return false;
    }

    // Use a temp nsCOMPtr for the null-check, because arg0 might be
    // OwningNonNull, not an nsCOMPtr.
    nsCOMPtr<mozilla::dom::TestCallbackInterface> tmp = do_QueryObject(wrappedJS.get());
    if (!tmp) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestCallbackInterface");
      return false;
    }
    arg0 = tmp.forget();
  } else if (argv[0].isNullOrUndefined()) {
    arg0 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassNullableCallbackInterface(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passNullableCallbackInterface_methodinfo = {
  (JSJitPropertyOp)passNullableCallbackInterface,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_nonNullCallbackInterface(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* vp)
{
  nsRefPtr<mozilla::dom::TestCallbackInterface> result;
  result = self->NonNullCallbackInterface();
  if (!WrapCallbackInterface(cx, obj, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_nonNullCallbackInterface(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* argv)
{
  OwningNonNull<mozilla::dom::TestCallbackInterface> arg0;
  if (argv[0].isObject()) {
    if (!IsConvertibleToCallbackInterface(cx, &argv[0].toObject())) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestCallbackInterface");
        return false;
    }

    nsresult rv;
    XPCCallContext ccx(JS_CALLER, cx);
    if (!ccx.IsValid()) {
      rv = NS_ERROR_XPC_BAD_CONVERT_JS;
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestCallbackInterface");
      return false;
    }

    const nsIID& iid = NS_GET_IID(mozilla::dom::TestCallbackInterface);
    nsRefPtr<nsXPCWrappedJS> wrappedJS;
    rv = nsXPCWrappedJS::GetNewOrUsed(ccx, &argv[0].toObject(), iid,
                                      NULL, getter_AddRefs(wrappedJS));
    if (NS_FAILED(rv) || !wrappedJS) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestCallbackInterface");
      return false;
    }

    // Use a temp nsCOMPtr for the null-check, because arg0 might be
    // OwningNonNull, not an nsCOMPtr.
    nsCOMPtr<mozilla::dom::TestCallbackInterface> tmp = do_QueryObject(wrappedJS.get());
    if (!tmp) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestCallbackInterface");
      return false;
    }
    arg0 = tmp.forget();
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->SetNonNullCallbackInterface(arg0);

  return true;
}


const JSJitInfo nonNullCallbackInterface_getterinfo = {
  (JSJitPropertyOp)get_nonNullCallbackInterface,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo nonNullCallbackInterface_setterinfo = {
  (JSJitPropertyOp)set_nonNullCallbackInterface,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_nullableCallbackInterface(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* vp)
{
  nsRefPtr<mozilla::dom::TestCallbackInterface> result;
  result = self->GetNullableCallbackInterface();
  if (!result) {
    *vp = JSVAL_NULL;
    return true;
  }
  if (!WrapCallbackInterface(cx, obj, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_nullableCallbackInterface(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* argv)
{
  nsRefPtr<mozilla::dom::TestCallbackInterface> arg0;
  if (argv[0].isObject()) {
    if (!IsConvertibleToCallbackInterface(cx, &argv[0].toObject())) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestCallbackInterface");
        return false;
    }

    nsresult rv;
    XPCCallContext ccx(JS_CALLER, cx);
    if (!ccx.IsValid()) {
      rv = NS_ERROR_XPC_BAD_CONVERT_JS;
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestCallbackInterface");
      return false;
    }

    const nsIID& iid = NS_GET_IID(mozilla::dom::TestCallbackInterface);
    nsRefPtr<nsXPCWrappedJS> wrappedJS;
    rv = nsXPCWrappedJS::GetNewOrUsed(ccx, &argv[0].toObject(), iid,
                                      NULL, getter_AddRefs(wrappedJS));
    if (NS_FAILED(rv) || !wrappedJS) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestCallbackInterface");
      return false;
    }

    // Use a temp nsCOMPtr for the null-check, because arg0 might be
    // OwningNonNull, not an nsCOMPtr.
    nsCOMPtr<mozilla::dom::TestCallbackInterface> tmp = do_QueryObject(wrappedJS.get());
    if (!tmp) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestCallbackInterface");
      return false;
    }
    arg0 = tmp.forget();
  } else if (argv[0].isNullOrUndefined()) {
    arg0 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->SetNullableCallbackInterface(arg0);

  return true;
}


const JSJitInfo nullableCallbackInterface_getterinfo = {
  (JSJitPropertyOp)get_nullableCallbackInterface,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo nullableCallbackInterface_setterinfo = {
  (JSJitPropertyOp)set_nullableCallbackInterface,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalCallbackInterface(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  const Optional< nsRefPtr<mozilla::dom::TestCallbackInterface> > arg0;
  if (0 < argc) {
    const_cast< Optional< nsRefPtr<mozilla::dom::TestCallbackInterface> > &>(arg0).Construct();
    if (argv[0].isObject()) {
      if (!IsConvertibleToCallbackInterface(cx, &argv[0].toObject())) {
          ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestCallbackInterface");
          return false;
      }

      nsresult rv;
      XPCCallContext ccx(JS_CALLER, cx);
      if (!ccx.IsValid()) {
        rv = NS_ERROR_XPC_BAD_CONVERT_JS;
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestCallbackInterface");
        return false;
      }

      const nsIID& iid = NS_GET_IID(mozilla::dom::TestCallbackInterface);
      nsRefPtr<nsXPCWrappedJS> wrappedJS;
      rv = nsXPCWrappedJS::GetNewOrUsed(ccx, &argv[0].toObject(), iid,
                                        NULL, getter_AddRefs(wrappedJS));
      if (NS_FAILED(rv) || !wrappedJS) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestCallbackInterface");
        return false;
      }

      // Use a temp nsCOMPtr for the null-check, because const_cast< nsRefPtr<mozilla::dom::TestCallbackInterface> & >(arg0.Value()) might be
      // OwningNonNull, not an nsCOMPtr.
      nsCOMPtr<mozilla::dom::TestCallbackInterface> tmp = do_QueryObject(wrappedJS.get());
      if (!tmp) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestCallbackInterface");
        return false;
      }
      const_cast< nsRefPtr<mozilla::dom::TestCallbackInterface> & >(arg0.Value()) = tmp.forget();
    } else if (argv[0].isNullOrUndefined()) {
      const_cast< nsRefPtr<mozilla::dom::TestCallbackInterface> & >(arg0.Value()) = NULL;
    } else {
      ThrowErrorMessage(cx, MSG_NOT_OBJECT);
      return false;
    }
  }
  self->PassOptionalCallbackInterface(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalCallbackInterface_methodinfo = {
  (JSJitPropertyOp)passOptionalCallbackInterface,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalNonNullCallbackInterface(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  const Optional< OwningNonNull<mozilla::dom::TestCallbackInterface> > arg0;
  if (0 < argc) {
    const_cast< Optional< OwningNonNull<mozilla::dom::TestCallbackInterface> > &>(arg0).Construct();
    if (argv[0].isObject()) {
      if (!IsConvertibleToCallbackInterface(cx, &argv[0].toObject())) {
          ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestCallbackInterface");
          return false;
      }

      nsresult rv;
      XPCCallContext ccx(JS_CALLER, cx);
      if (!ccx.IsValid()) {
        rv = NS_ERROR_XPC_BAD_CONVERT_JS;
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestCallbackInterface");
        return false;
      }

      const nsIID& iid = NS_GET_IID(mozilla::dom::TestCallbackInterface);
      nsRefPtr<nsXPCWrappedJS> wrappedJS;
      rv = nsXPCWrappedJS::GetNewOrUsed(ccx, &argv[0].toObject(), iid,
                                        NULL, getter_AddRefs(wrappedJS));
      if (NS_FAILED(rv) || !wrappedJS) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestCallbackInterface");
        return false;
      }

      // Use a temp nsCOMPtr for the null-check, because const_cast< OwningNonNull<mozilla::dom::TestCallbackInterface> & >(arg0.Value()) might be
      // OwningNonNull, not an nsCOMPtr.
      nsCOMPtr<mozilla::dom::TestCallbackInterface> tmp = do_QueryObject(wrappedJS.get());
      if (!tmp) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestCallbackInterface");
        return false;
      }
      const_cast< OwningNonNull<mozilla::dom::TestCallbackInterface> & >(arg0.Value()) = tmp.forget();
    } else {
      ThrowErrorMessage(cx, MSG_NOT_OBJECT);
      return false;
    }
  }
  self->PassOptionalNonNullCallbackInterface(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalNonNullCallbackInterface_methodinfo = {
  (JSJitPropertyOp)passOptionalNonNullCallbackInterface,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalCallbackInterfaceWithDefault(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  nsRefPtr<mozilla::dom::TestCallbackInterface> arg0;
  if (0 < argc) {
    if (argv[0].isObject()) {
      if (!IsConvertibleToCallbackInterface(cx, &argv[0].toObject())) {
          ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestCallbackInterface");
          return false;
      }

      nsresult rv;
      XPCCallContext ccx(JS_CALLER, cx);
      if (!ccx.IsValid()) {
        rv = NS_ERROR_XPC_BAD_CONVERT_JS;
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestCallbackInterface");
        return false;
      }

      const nsIID& iid = NS_GET_IID(mozilla::dom::TestCallbackInterface);
      nsRefPtr<nsXPCWrappedJS> wrappedJS;
      rv = nsXPCWrappedJS::GetNewOrUsed(ccx, &argv[0].toObject(), iid,
                                        NULL, getter_AddRefs(wrappedJS));
      if (NS_FAILED(rv) || !wrappedJS) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestCallbackInterface");
        return false;
      }

      // Use a temp nsCOMPtr for the null-check, because arg0 might be
      // OwningNonNull, not an nsCOMPtr.
      nsCOMPtr<mozilla::dom::TestCallbackInterface> tmp = do_QueryObject(wrappedJS.get());
      if (!tmp) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestCallbackInterface");
        return false;
      }
      arg0 = tmp.forget();
    } else if (argv[0].isNullOrUndefined()) {
      arg0 = NULL;
    } else {
      ThrowErrorMessage(cx, MSG_NOT_OBJECT);
      return false;
    }
  } else {
    arg0 = NULL;
  }
  self->PassOptionalCallbackInterfaceWithDefault(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalCallbackInterfaceWithDefault_methodinfo = {
  (JSJitPropertyOp)passOptionalCallbackInterfaceWithDefault,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveConsequentialInterface(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{
  nsRefPtr<mozilla::dom::IndirectlyImplementedInterface> result;
  result = self->ReceiveConsequentialInterface();
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}


const JSJitInfo receiveConsequentialInterface_methodinfo = {
  (JSJitPropertyOp)receiveConsequentialInterface,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
passConsequentialInterface(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.passConsequentialInterface");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  nsRefPtr<mozilla::dom::IndirectlyImplementedInterface> arg0_holder;
  NonNull<mozilla::dom::IndirectlyImplementedInterface> arg0;
  if (argv[0].isObject()) {
    jsval tmpVal = argv[0];
    mozilla::dom::IndirectlyImplementedInterface* tmp;
    if (NS_FAILED(xpc_qsUnwrapArg<mozilla::dom::IndirectlyImplementedInterface>(cx, argv[0], &tmp, static_cast<mozilla::dom::IndirectlyImplementedInterface**>(getter_AddRefs(arg0_holder)), &tmpVal))) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "IndirectlyImplementedInterface");return false;
    }
    MOZ_ASSERT(tmp);
    if (tmpVal != argv[0] && !arg0_holder) {
      // We have to have a strong ref, because we got this off
      // some random object that might get GCed
      arg0_holder = tmp;
    }
    arg0 = tmp;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassConsequentialInterface(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passConsequentialInterface_methodinfo = {
  (JSJitPropertyOp)passConsequentialInterface,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveSequence(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{
  nsTArray< int32_t > result;
  self->ReceiveSequence(result);

  uint32_t length = result.Length();
  JSObject *returnArray = JS_NewArrayObject(cx, length, NULL);
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    jsval tmp;
    for (uint32_t i = 0; i < length; ++i) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        tmp = INT_TO_JSVAL(int32_t(result[i]));
        break;
      } while (0);
      if (!JS_DefineElement(cx, returnArray, i, tmp,
                            nullptr, nullptr, JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  *vp = JS::ObjectValue(*returnArray);
  return true;
}


const JSJitInfo receiveSequence_methodinfo = {
  (JSJitPropertyOp)receiveSequence,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveNullableSequence(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{
  Nullable< nsTArray< int32_t > > result;
  self->ReceiveNullableSequence(result);

  if (result.IsNull()) {
    *vp = JSVAL_NULL;
    return true;
  }

  uint32_t length = result.Value().Length();
  JSObject *returnArray = JS_NewArrayObject(cx, length, NULL);
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    jsval tmp;
    for (uint32_t i = 0; i < length; ++i) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        tmp = INT_TO_JSVAL(int32_t(result.Value()[i]));
        break;
      } while (0);
      if (!JS_DefineElement(cx, returnArray, i, tmp,
                            nullptr, nullptr, JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  *vp = JS::ObjectValue(*returnArray);
  return true;
}


const JSJitInfo receiveNullableSequence_methodinfo = {
  (JSJitPropertyOp)receiveNullableSequence,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveSequenceOfNullableInts(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{
  nsTArray< Nullable<int32_t> > result;
  self->ReceiveSequenceOfNullableInts(result);

  uint32_t length = result.Length();
  JSObject *returnArray = JS_NewArrayObject(cx, length, NULL);
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    jsval tmp;
    for (uint32_t i = 0; i < length; ++i) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (result[i].IsNull()) {
          tmp = JSVAL_NULL;
          break;
        }
        tmp = INT_TO_JSVAL(int32_t(result[i].Value()));
        break;
      } while (0);
      if (!JS_DefineElement(cx, returnArray, i, tmp,
                            nullptr, nullptr, JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  *vp = JS::ObjectValue(*returnArray);
  return true;
}


const JSJitInfo receiveSequenceOfNullableInts_methodinfo = {
  (JSJitPropertyOp)receiveSequenceOfNullableInts,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveNullableSequenceOfNullableInts(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{
  Nullable< nsTArray< Nullable<int32_t> > > result;
  self->ReceiveNullableSequenceOfNullableInts(result);

  if (result.IsNull()) {
    *vp = JSVAL_NULL;
    return true;
  }

  uint32_t length = result.Value().Length();
  JSObject *returnArray = JS_NewArrayObject(cx, length, NULL);
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    jsval tmp;
    for (uint32_t i = 0; i < length; ++i) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (result.Value()[i].IsNull()) {
          tmp = JSVAL_NULL;
          break;
        }
        tmp = INT_TO_JSVAL(int32_t(result.Value()[i].Value()));
        break;
      } while (0);
      if (!JS_DefineElement(cx, returnArray, i, tmp,
                            nullptr, nullptr, JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  *vp = JS::ObjectValue(*returnArray);
  return true;
}


const JSJitInfo receiveNullableSequenceOfNullableInts_methodinfo = {
  (JSJitPropertyOp)receiveNullableSequenceOfNullableInts,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
passSequence(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.passSequence");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  const Sequence< int32_t > arg0;
  if (argv[0].isObject()) {
    JSObject* seq = &argv[0].toObject();

    if (!IsArrayLike(cx, seq)) {
      ThrowErrorMessage(cx, MSG_NOT_SEQUENCE);
      return false;
    }
    uint32_t length;
    // JS_GetArrayLength actually works on all objects
    if (!JS_GetArrayLength(cx, seq, &length)) {
      return false;
    }
    Sequence< int32_t > &arr = const_cast< Sequence< int32_t >& >(arg0);
    if (!arr.SetCapacity(length)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t i = 0; i < length; ++i) {
      jsval temp;
      if (!JS_GetElement(cx, seq, i, &temp)) {
        return false;
      }
      int32_t& slot = *arr.AppendElement();
      if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, &slot)) {
        return false;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassSequence(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passSequence_methodinfo = {
  (JSJitPropertyOp)passSequence,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passNullableSequence(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.passNullableSequence");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  const Nullable< Sequence< int32_t > > arg0;
  if (argv[0].isObject()) {
    JSObject* seq = &argv[0].toObject();

    if (!IsArrayLike(cx, seq)) {
      ThrowErrorMessage(cx, MSG_NOT_SEQUENCE);
      return false;
    }
    uint32_t length;
    // JS_GetArrayLength actually works on all objects
    if (!JS_GetArrayLength(cx, seq, &length)) {
      return false;
    }
    Sequence< int32_t > &arr = const_cast< Sequence< int32_t >& >(arg0.Value());
    if (!arr.SetCapacity(length)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t i = 0; i < length; ++i) {
      jsval temp;
      if (!JS_GetElement(cx, seq, i, &temp)) {
        return false;
      }
      int32_t& slot = *arr.AppendElement();
      if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, &slot)) {
        return false;
      }
    }
  } else if (argv[0].isNullOrUndefined()) {
    const_cast< Nullable< Sequence< int32_t > > & >(arg0).SetNull();
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassNullableSequence(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passNullableSequence_methodinfo = {
  (JSJitPropertyOp)passNullableSequence,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passSequenceOfNullableInts(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.passSequenceOfNullableInts");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  const Sequence< Nullable<int32_t> > arg0;
  if (argv[0].isObject()) {
    JSObject* seq = &argv[0].toObject();

    if (!IsArrayLike(cx, seq)) {
      ThrowErrorMessage(cx, MSG_NOT_SEQUENCE);
      return false;
    }
    uint32_t length;
    // JS_GetArrayLength actually works on all objects
    if (!JS_GetArrayLength(cx, seq, &length)) {
      return false;
    }
    Sequence< Nullable<int32_t> > &arr = const_cast< Sequence< Nullable<int32_t> >& >(arg0);
    if (!arr.SetCapacity(length)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t i = 0; i < length; ++i) {
      jsval temp;
      if (!JS_GetElement(cx, seq, i, &temp)) {
        return false;
      }
      Nullable<int32_t>& slot = *arr.AppendElement();
      if (temp.isNullOrUndefined()) {
        const_cast< Nullable<int32_t>& >(slot).SetNull();
      } else if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, &const_cast< Nullable<int32_t>& >(slot).SetValue())) {
        return false;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassSequenceOfNullableInts(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passSequenceOfNullableInts_methodinfo = {
  (JSJitPropertyOp)passSequenceOfNullableInts,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalSequenceOfNullableInts(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  const Optional< Sequence< Nullable<int32_t> > > arg0;
  if (0 < argc) {
    const_cast< Optional< Sequence< Nullable<int32_t> > > &>(arg0).Construct();
    if (argv[0].isObject()) {
      JSObject* seq = &argv[0].toObject();

      if (!IsArrayLike(cx, seq)) {
        ThrowErrorMessage(cx, MSG_NOT_SEQUENCE);
        return false;
      }
      uint32_t length;
      // JS_GetArrayLength actually works on all objects
      if (!JS_GetArrayLength(cx, seq, &length)) {
        return false;
      }
      Sequence< Nullable<int32_t> > &arr = const_cast< Sequence< Nullable<int32_t> >& >(const_cast< Sequence< Nullable<int32_t> > & >(arg0.Value()));
      if (!arr.SetCapacity(length)) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      for (uint32_t i = 0; i < length; ++i) {
        jsval temp;
        if (!JS_GetElement(cx, seq, i, &temp)) {
          return false;
        }
        Nullable<int32_t>& slot = *arr.AppendElement();
        if (temp.isNullOrUndefined()) {
          const_cast< Nullable<int32_t>& >(slot).SetNull();
        } else if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, &const_cast< Nullable<int32_t>& >(slot).SetValue())) {
          return false;
        }
      }
    } else {
      ThrowErrorMessage(cx, MSG_NOT_OBJECT);
      return false;
    }
  }
  self->PassOptionalSequenceOfNullableInts(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalSequenceOfNullableInts_methodinfo = {
  (JSJitPropertyOp)passOptionalSequenceOfNullableInts,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalNullableSequenceOfNullableInts(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  const Optional< Nullable< Sequence< Nullable<int32_t> > > > arg0;
  if (0 < argc) {
    const_cast< Optional< Nullable< Sequence< Nullable<int32_t> > > > &>(arg0).Construct();
    if (argv[0].isObject()) {
      JSObject* seq = &argv[0].toObject();

      if (!IsArrayLike(cx, seq)) {
        ThrowErrorMessage(cx, MSG_NOT_SEQUENCE);
        return false;
      }
      uint32_t length;
      // JS_GetArrayLength actually works on all objects
      if (!JS_GetArrayLength(cx, seq, &length)) {
        return false;
      }
      Sequence< Nullable<int32_t> > &arr = const_cast< Sequence< Nullable<int32_t> >& >(const_cast< Nullable< Sequence< Nullable<int32_t> > > & >(arg0.Value()).Value());
      if (!arr.SetCapacity(length)) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      for (uint32_t i = 0; i < length; ++i) {
        jsval temp;
        if (!JS_GetElement(cx, seq, i, &temp)) {
          return false;
        }
        Nullable<int32_t>& slot = *arr.AppendElement();
        if (temp.isNullOrUndefined()) {
          const_cast< Nullable<int32_t>& >(slot).SetNull();
        } else if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, &const_cast< Nullable<int32_t>& >(slot).SetValue())) {
          return false;
        }
      }
    } else if (argv[0].isNullOrUndefined()) {
      const_cast< Nullable< Sequence< Nullable<int32_t> > > & >(const_cast< Nullable< Sequence< Nullable<int32_t> > > & >(arg0.Value())).SetNull();
    } else {
      ThrowErrorMessage(cx, MSG_NOT_OBJECT);
      return false;
    }
  }
  self->PassOptionalNullableSequenceOfNullableInts(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalNullableSequenceOfNullableInts_methodinfo = {
  (JSJitPropertyOp)passOptionalNullableSequenceOfNullableInts,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveCastableObjectSequence(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{
  nsTArray< nsRefPtr<mozilla::dom::TestInterface> > result;
  self->ReceiveCastableObjectSequence(result);

  uint32_t length = result.Length();
  JSObject *returnArray = JS_NewArrayObject(cx, length, NULL);
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    jsval tmp;
    for (uint32_t i = 0; i < length; ++i) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!WrapNewBindingObject(cx, returnArray, result[i], &tmp)) {
          MOZ_ASSERT(JS_IsExceptionPending(cx));
          return false;
        }
        break;
      } while (0);
      if (!JS_DefineElement(cx, returnArray, i, tmp,
                            nullptr, nullptr, JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  *vp = JS::ObjectValue(*returnArray);
  return true;
}


const JSJitInfo receiveCastableObjectSequence_methodinfo = {
  (JSJitPropertyOp)receiveCastableObjectSequence,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveCallbackObjectSequence(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{
  nsTArray< nsRefPtr<mozilla::dom::TestCallbackInterface> > result;
  self->ReceiveCallbackObjectSequence(result);

  uint32_t length = result.Length();
  JSObject *returnArray = JS_NewArrayObject(cx, length, NULL);
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    jsval tmp;
    for (uint32_t i = 0; i < length; ++i) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!WrapCallbackInterface(cx, returnArray, result[i], &tmp)) {
          return false;
        }
        break;
      } while (0);
      if (!JS_DefineElement(cx, returnArray, i, tmp,
                            nullptr, nullptr, JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  *vp = JS::ObjectValue(*returnArray);
  return true;
}


const JSJitInfo receiveCallbackObjectSequence_methodinfo = {
  (JSJitPropertyOp)receiveCallbackObjectSequence,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveNullableCastableObjectSequence(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{
  nsTArray< nsRefPtr<mozilla::dom::TestInterface> > result;
  self->ReceiveNullableCastableObjectSequence(result);

  uint32_t length = result.Length();
  JSObject *returnArray = JS_NewArrayObject(cx, length, NULL);
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    jsval tmp;
    for (uint32_t i = 0; i < length; ++i) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!result[i]) {
          tmp = JSVAL_NULL;
          break;
        }
        if (!WrapNewBindingObject(cx, returnArray, result[i], &tmp)) {
          MOZ_ASSERT(JS_IsExceptionPending(cx));
          return false;
        }
        break;
      } while (0);
      if (!JS_DefineElement(cx, returnArray, i, tmp,
                            nullptr, nullptr, JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  *vp = JS::ObjectValue(*returnArray);
  return true;
}


const JSJitInfo receiveNullableCastableObjectSequence_methodinfo = {
  (JSJitPropertyOp)receiveNullableCastableObjectSequence,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveNullableCallbackObjectSequence(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{
  nsTArray< nsRefPtr<mozilla::dom::TestCallbackInterface> > result;
  self->ReceiveNullableCallbackObjectSequence(result);

  uint32_t length = result.Length();
  JSObject *returnArray = JS_NewArrayObject(cx, length, NULL);
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    jsval tmp;
    for (uint32_t i = 0; i < length; ++i) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!result[i]) {
          tmp = JSVAL_NULL;
          break;
        }
        if (!WrapCallbackInterface(cx, returnArray, result[i], &tmp)) {
          return false;
        }
        break;
      } while (0);
      if (!JS_DefineElement(cx, returnArray, i, tmp,
                            nullptr, nullptr, JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  *vp = JS::ObjectValue(*returnArray);
  return true;
}


const JSJitInfo receiveNullableCallbackObjectSequence_methodinfo = {
  (JSJitPropertyOp)receiveNullableCallbackObjectSequence,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveCastableObjectNullableSequence(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{
  Nullable< nsTArray< nsRefPtr<mozilla::dom::TestInterface> > > result;
  self->ReceiveCastableObjectNullableSequence(result);

  if (result.IsNull()) {
    *vp = JSVAL_NULL;
    return true;
  }

  uint32_t length = result.Value().Length();
  JSObject *returnArray = JS_NewArrayObject(cx, length, NULL);
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    jsval tmp;
    for (uint32_t i = 0; i < length; ++i) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!WrapNewBindingObject(cx, returnArray, result.Value()[i], &tmp)) {
          MOZ_ASSERT(JS_IsExceptionPending(cx));
          return false;
        }
        break;
      } while (0);
      if (!JS_DefineElement(cx, returnArray, i, tmp,
                            nullptr, nullptr, JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  *vp = JS::ObjectValue(*returnArray);
  return true;
}


const JSJitInfo receiveCastableObjectNullableSequence_methodinfo = {
  (JSJitPropertyOp)receiveCastableObjectNullableSequence,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveNullableCastableObjectNullableSequence(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{
  Nullable< nsTArray< nsRefPtr<mozilla::dom::TestInterface> > > result;
  self->ReceiveNullableCastableObjectNullableSequence(result);

  if (result.IsNull()) {
    *vp = JSVAL_NULL;
    return true;
  }

  uint32_t length = result.Value().Length();
  JSObject *returnArray = JS_NewArrayObject(cx, length, NULL);
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    jsval tmp;
    for (uint32_t i = 0; i < length; ++i) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!result.Value()[i]) {
          tmp = JSVAL_NULL;
          break;
        }
        if (!WrapNewBindingObject(cx, returnArray, result.Value()[i], &tmp)) {
          MOZ_ASSERT(JS_IsExceptionPending(cx));
          return false;
        }
        break;
      } while (0);
      if (!JS_DefineElement(cx, returnArray, i, tmp,
                            nullptr, nullptr, JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  *vp = JS::ObjectValue(*returnArray);
  return true;
}


const JSJitInfo receiveNullableCastableObjectNullableSequence_methodinfo = {
  (JSJitPropertyOp)receiveNullableCastableObjectNullableSequence,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveWeakCastableObjectSequence(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{
  nsTArray< mozilla::dom::TestInterface* > result;
  self->ReceiveWeakCastableObjectSequence(result);

  uint32_t length = result.Length();
  JSObject *returnArray = JS_NewArrayObject(cx, length, NULL);
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    jsval tmp;
    for (uint32_t i = 0; i < length; ++i) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!WrapNewBindingObject(cx, returnArray, result[i], &tmp)) {
          MOZ_ASSERT(JS_IsExceptionPending(cx));
          return false;
        }
        break;
      } while (0);
      if (!JS_DefineElement(cx, returnArray, i, tmp,
                            nullptr, nullptr, JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  *vp = JS::ObjectValue(*returnArray);
  return true;
}


const JSJitInfo receiveWeakCastableObjectSequence_methodinfo = {
  (JSJitPropertyOp)receiveWeakCastableObjectSequence,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveWeakNullableCastableObjectSequence(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{
  nsTArray< mozilla::dom::TestInterface* > result;
  self->ReceiveWeakNullableCastableObjectSequence(result);

  uint32_t length = result.Length();
  JSObject *returnArray = JS_NewArrayObject(cx, length, NULL);
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    jsval tmp;
    for (uint32_t i = 0; i < length; ++i) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!result[i]) {
          tmp = JSVAL_NULL;
          break;
        }
        if (!WrapNewBindingObject(cx, returnArray, result[i], &tmp)) {
          MOZ_ASSERT(JS_IsExceptionPending(cx));
          return false;
        }
        break;
      } while (0);
      if (!JS_DefineElement(cx, returnArray, i, tmp,
                            nullptr, nullptr, JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  *vp = JS::ObjectValue(*returnArray);
  return true;
}


const JSJitInfo receiveWeakNullableCastableObjectSequence_methodinfo = {
  (JSJitPropertyOp)receiveWeakNullableCastableObjectSequence,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveWeakCastableObjectNullableSequence(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{
  Nullable< nsTArray< mozilla::dom::TestInterface* > > result;
  self->ReceiveWeakCastableObjectNullableSequence(result);

  if (result.IsNull()) {
    *vp = JSVAL_NULL;
    return true;
  }

  uint32_t length = result.Value().Length();
  JSObject *returnArray = JS_NewArrayObject(cx, length, NULL);
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    jsval tmp;
    for (uint32_t i = 0; i < length; ++i) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!WrapNewBindingObject(cx, returnArray, result.Value()[i], &tmp)) {
          MOZ_ASSERT(JS_IsExceptionPending(cx));
          return false;
        }
        break;
      } while (0);
      if (!JS_DefineElement(cx, returnArray, i, tmp,
                            nullptr, nullptr, JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  *vp = JS::ObjectValue(*returnArray);
  return true;
}


const JSJitInfo receiveWeakCastableObjectNullableSequence_methodinfo = {
  (JSJitPropertyOp)receiveWeakCastableObjectNullableSequence,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveWeakNullableCastableObjectNullableSequence(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{
  Nullable< nsTArray< mozilla::dom::TestInterface* > > result;
  self->ReceiveWeakNullableCastableObjectNullableSequence(result);

  if (result.IsNull()) {
    *vp = JSVAL_NULL;
    return true;
  }

  uint32_t length = result.Value().Length();
  JSObject *returnArray = JS_NewArrayObject(cx, length, NULL);
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    jsval tmp;
    for (uint32_t i = 0; i < length; ++i) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!result.Value()[i]) {
          tmp = JSVAL_NULL;
          break;
        }
        if (!WrapNewBindingObject(cx, returnArray, result.Value()[i], &tmp)) {
          MOZ_ASSERT(JS_IsExceptionPending(cx));
          return false;
        }
        break;
      } while (0);
      if (!JS_DefineElement(cx, returnArray, i, tmp,
                            nullptr, nullptr, JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  *vp = JS::ObjectValue(*returnArray);
  return true;
}


const JSJitInfo receiveWeakNullableCastableObjectNullableSequence_methodinfo = {
  (JSJitPropertyOp)receiveWeakNullableCastableObjectNullableSequence,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
passCastableObjectSequence(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.passCastableObjectSequence");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  const Sequence< OwningNonNull<mozilla::dom::TestInterface> > arg0;
  if (argv[0].isObject()) {
    JSObject* seq = &argv[0].toObject();

    if (!IsArrayLike(cx, seq)) {
      ThrowErrorMessage(cx, MSG_NOT_SEQUENCE);
      return false;
    }
    uint32_t length;
    // JS_GetArrayLength actually works on all objects
    if (!JS_GetArrayLength(cx, seq, &length)) {
      return false;
    }
    Sequence< OwningNonNull<mozilla::dom::TestInterface> > &arr = const_cast< Sequence< OwningNonNull<mozilla::dom::TestInterface> >& >(arg0);
    if (!arr.SetCapacity(length)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t i = 0; i < length; ++i) {
      jsval temp;
      if (!JS_GetElement(cx, seq, i, &temp)) {
        return false;
      }
      OwningNonNull<mozilla::dom::TestInterface>& slot = *arr.AppendElement();
      if (temp.isObject()) {
        {
          nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(cx, &temp.toObject(), slot);
          if (NS_FAILED(rv)) {
            ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestInterface");
            return false;
          }
        }
      } else {
        ThrowErrorMessage(cx, MSG_NOT_OBJECT);
        return false;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassCastableObjectSequence(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passCastableObjectSequence_methodinfo = {
  (JSJitPropertyOp)passCastableObjectSequence,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passNullableCastableObjectSequence(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.passNullableCastableObjectSequence");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  const Sequence< nsRefPtr<mozilla::dom::TestInterface> > arg0;
  if (argv[0].isObject()) {
    JSObject* seq = &argv[0].toObject();

    if (!IsArrayLike(cx, seq)) {
      ThrowErrorMessage(cx, MSG_NOT_SEQUENCE);
      return false;
    }
    uint32_t length;
    // JS_GetArrayLength actually works on all objects
    if (!JS_GetArrayLength(cx, seq, &length)) {
      return false;
    }
    Sequence< nsRefPtr<mozilla::dom::TestInterface> > &arr = const_cast< Sequence< nsRefPtr<mozilla::dom::TestInterface> >& >(arg0);
    if (!arr.SetCapacity(length)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t i = 0; i < length; ++i) {
      jsval temp;
      if (!JS_GetElement(cx, seq, i, &temp)) {
        return false;
      }
      nsRefPtr<mozilla::dom::TestInterface>& slot = *arr.AppendElement();
      if (temp.isObject()) {
        {
          nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(cx, &temp.toObject(), slot);
          if (NS_FAILED(rv)) {
            ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestInterface");
            return false;
          }
        }
      } else if (temp.isNullOrUndefined()) {
        slot = NULL;
      } else {
        ThrowErrorMessage(cx, MSG_NOT_OBJECT);
        return false;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassNullableCastableObjectSequence(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passNullableCastableObjectSequence_methodinfo = {
  (JSJitPropertyOp)passNullableCastableObjectSequence,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passCastableObjectNullableSequence(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.passCastableObjectNullableSequence");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  const Nullable< Sequence< OwningNonNull<mozilla::dom::TestInterface> > > arg0;
  if (argv[0].isObject()) {
    JSObject* seq = &argv[0].toObject();

    if (!IsArrayLike(cx, seq)) {
      ThrowErrorMessage(cx, MSG_NOT_SEQUENCE);
      return false;
    }
    uint32_t length;
    // JS_GetArrayLength actually works on all objects
    if (!JS_GetArrayLength(cx, seq, &length)) {
      return false;
    }
    Sequence< OwningNonNull<mozilla::dom::TestInterface> > &arr = const_cast< Sequence< OwningNonNull<mozilla::dom::TestInterface> >& >(arg0.Value());
    if (!arr.SetCapacity(length)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t i = 0; i < length; ++i) {
      jsval temp;
      if (!JS_GetElement(cx, seq, i, &temp)) {
        return false;
      }
      OwningNonNull<mozilla::dom::TestInterface>& slot = *arr.AppendElement();
      if (temp.isObject()) {
        {
          nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(cx, &temp.toObject(), slot);
          if (NS_FAILED(rv)) {
            ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestInterface");
            return false;
          }
        }
      } else {
        ThrowErrorMessage(cx, MSG_NOT_OBJECT);
        return false;
      }
    }
  } else if (argv[0].isNullOrUndefined()) {
    const_cast< Nullable< Sequence< OwningNonNull<mozilla::dom::TestInterface> > > & >(arg0).SetNull();
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassCastableObjectNullableSequence(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passCastableObjectNullableSequence_methodinfo = {
  (JSJitPropertyOp)passCastableObjectNullableSequence,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passNullableCastableObjectNullableSequence(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.passNullableCastableObjectNullableSequence");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  const Nullable< Sequence< nsRefPtr<mozilla::dom::TestInterface> > > arg0;
  if (argv[0].isObject()) {
    JSObject* seq = &argv[0].toObject();

    if (!IsArrayLike(cx, seq)) {
      ThrowErrorMessage(cx, MSG_NOT_SEQUENCE);
      return false;
    }
    uint32_t length;
    // JS_GetArrayLength actually works on all objects
    if (!JS_GetArrayLength(cx, seq, &length)) {
      return false;
    }
    Sequence< nsRefPtr<mozilla::dom::TestInterface> > &arr = const_cast< Sequence< nsRefPtr<mozilla::dom::TestInterface> >& >(arg0.Value());
    if (!arr.SetCapacity(length)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t i = 0; i < length; ++i) {
      jsval temp;
      if (!JS_GetElement(cx, seq, i, &temp)) {
        return false;
      }
      nsRefPtr<mozilla::dom::TestInterface>& slot = *arr.AppendElement();
      if (temp.isObject()) {
        {
          nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(cx, &temp.toObject(), slot);
          if (NS_FAILED(rv)) {
            ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestInterface");
            return false;
          }
        }
      } else if (temp.isNullOrUndefined()) {
        slot = NULL;
      } else {
        ThrowErrorMessage(cx, MSG_NOT_OBJECT);
        return false;
      }
    }
  } else if (argv[0].isNullOrUndefined()) {
    const_cast< Nullable< Sequence< nsRefPtr<mozilla::dom::TestInterface> > > & >(arg0).SetNull();
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassNullableCastableObjectNullableSequence(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passNullableCastableObjectNullableSequence_methodinfo = {
  (JSJitPropertyOp)passNullableCastableObjectNullableSequence,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalSequence(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  const Optional< Sequence< int32_t > > arg0;
  if (0 < argc) {
    const_cast< Optional< Sequence< int32_t > > &>(arg0).Construct();
    if (argv[0].isObject()) {
      JSObject* seq = &argv[0].toObject();

      if (!IsArrayLike(cx, seq)) {
        ThrowErrorMessage(cx, MSG_NOT_SEQUENCE);
        return false;
      }
      uint32_t length;
      // JS_GetArrayLength actually works on all objects
      if (!JS_GetArrayLength(cx, seq, &length)) {
        return false;
      }
      Sequence< int32_t > &arr = const_cast< Sequence< int32_t >& >(const_cast< Sequence< int32_t > & >(arg0.Value()));
      if (!arr.SetCapacity(length)) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      for (uint32_t i = 0; i < length; ++i) {
        jsval temp;
        if (!JS_GetElement(cx, seq, i, &temp)) {
          return false;
        }
        int32_t& slot = *arr.AppendElement();
        if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, &slot)) {
          return false;
        }
      }
    } else {
      ThrowErrorMessage(cx, MSG_NOT_OBJECT);
      return false;
    }
  }
  self->PassOptionalSequence(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalSequence_methodinfo = {
  (JSJitPropertyOp)passOptionalSequence,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalNullableSequence(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  const Optional< Nullable< Sequence< int32_t > > > arg0;
  if (0 < argc) {
    const_cast< Optional< Nullable< Sequence< int32_t > > > &>(arg0).Construct();
    if (argv[0].isObject()) {
      JSObject* seq = &argv[0].toObject();

      if (!IsArrayLike(cx, seq)) {
        ThrowErrorMessage(cx, MSG_NOT_SEQUENCE);
        return false;
      }
      uint32_t length;
      // JS_GetArrayLength actually works on all objects
      if (!JS_GetArrayLength(cx, seq, &length)) {
        return false;
      }
      Sequence< int32_t > &arr = const_cast< Sequence< int32_t >& >(const_cast< Nullable< Sequence< int32_t > > & >(arg0.Value()).Value());
      if (!arr.SetCapacity(length)) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      for (uint32_t i = 0; i < length; ++i) {
        jsval temp;
        if (!JS_GetElement(cx, seq, i, &temp)) {
          return false;
        }
        int32_t& slot = *arr.AppendElement();
        if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, &slot)) {
          return false;
        }
      }
    } else if (argv[0].isNullOrUndefined()) {
      const_cast< Nullable< Sequence< int32_t > > & >(const_cast< Nullable< Sequence< int32_t > > & >(arg0.Value())).SetNull();
    } else {
      ThrowErrorMessage(cx, MSG_NOT_OBJECT);
      return false;
    }
  }
  self->PassOptionalNullableSequence(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalNullableSequence_methodinfo = {
  (JSJitPropertyOp)passOptionalNullableSequence,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalNullableSequenceWithDefaultValue(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  const Nullable< Sequence< int32_t > > arg0;
  if (0 < argc) {
    if (argv[0].isObject()) {
      JSObject* seq = &argv[0].toObject();

      if (!IsArrayLike(cx, seq)) {
        ThrowErrorMessage(cx, MSG_NOT_SEQUENCE);
        return false;
      }
      uint32_t length;
      // JS_GetArrayLength actually works on all objects
      if (!JS_GetArrayLength(cx, seq, &length)) {
        return false;
      }
      Sequence< int32_t > &arr = const_cast< Sequence< int32_t >& >(arg0.Value());
      if (!arr.SetCapacity(length)) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      for (uint32_t i = 0; i < length; ++i) {
        jsval temp;
        if (!JS_GetElement(cx, seq, i, &temp)) {
          return false;
        }
        int32_t& slot = *arr.AppendElement();
        if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, &slot)) {
          return false;
        }
      }
    } else if (argv[0].isNullOrUndefined()) {
      const_cast< Nullable< Sequence< int32_t > > & >(arg0).SetNull();
    } else {
      ThrowErrorMessage(cx, MSG_NOT_OBJECT);
      return false;
    }
  } else {
    const_cast< Nullable< Sequence< int32_t > > & >(arg0).SetNull();
  }
  self->PassOptionalNullableSequenceWithDefaultValue(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalNullableSequenceWithDefaultValue_methodinfo = {
  (JSJitPropertyOp)passOptionalNullableSequenceWithDefaultValue,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalObjectSequence(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  const Optional< Sequence< OwningNonNull<mozilla::dom::TestInterface> > > arg0;
  if (0 < argc) {
    const_cast< Optional< Sequence< OwningNonNull<mozilla::dom::TestInterface> > > &>(arg0).Construct();
    if (argv[0].isObject()) {
      JSObject* seq = &argv[0].toObject();

      if (!IsArrayLike(cx, seq)) {
        ThrowErrorMessage(cx, MSG_NOT_SEQUENCE);
        return false;
      }
      uint32_t length;
      // JS_GetArrayLength actually works on all objects
      if (!JS_GetArrayLength(cx, seq, &length)) {
        return false;
      }
      Sequence< OwningNonNull<mozilla::dom::TestInterface> > &arr = const_cast< Sequence< OwningNonNull<mozilla::dom::TestInterface> >& >(const_cast< Sequence< OwningNonNull<mozilla::dom::TestInterface> > & >(arg0.Value()));
      if (!arr.SetCapacity(length)) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      for (uint32_t i = 0; i < length; ++i) {
        jsval temp;
        if (!JS_GetElement(cx, seq, i, &temp)) {
          return false;
        }
        OwningNonNull<mozilla::dom::TestInterface>& slot = *arr.AppendElement();
        if (temp.isObject()) {
          {
            nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(cx, &temp.toObject(), slot);
            if (NS_FAILED(rv)) {
              ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestInterface");
              return false;
            }
          }
        } else {
          ThrowErrorMessage(cx, MSG_NOT_OBJECT);
          return false;
        }
      }
    } else {
      ThrowErrorMessage(cx, MSG_NOT_OBJECT);
      return false;
    }
  }
  self->PassOptionalObjectSequence(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalObjectSequence_methodinfo = {
  (JSJitPropertyOp)passOptionalObjectSequence,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passExternalInterfaceSequence(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.passExternalInterfaceSequence");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  const Sequence< nsRefPtr<mozilla::dom::TestExternalInterface> > arg0;
  if (argv[0].isObject()) {
    JSObject* seq = &argv[0].toObject();

    if (!IsArrayLike(cx, seq)) {
      ThrowErrorMessage(cx, MSG_NOT_SEQUENCE);
      return false;
    }
    uint32_t length;
    // JS_GetArrayLength actually works on all objects
    if (!JS_GetArrayLength(cx, seq, &length)) {
      return false;
    }
    Sequence< nsRefPtr<mozilla::dom::TestExternalInterface> > &arr = const_cast< Sequence< nsRefPtr<mozilla::dom::TestExternalInterface> >& >(arg0);
    if (!arr.SetCapacity(length)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t i = 0; i < length; ++i) {
      jsval temp;
      if (!JS_GetElement(cx, seq, i, &temp)) {
        return false;
      }
      nsRefPtr<mozilla::dom::TestExternalInterface>& slot = *arr.AppendElement();
      if (temp.isObject()) {
        nsRefPtr<mozilla::dom::TestExternalInterface> tempHolder;
        jsval tmpVal = temp;
        mozilla::dom::TestExternalInterface* tmp;
        if (NS_FAILED(xpc_qsUnwrapArg<mozilla::dom::TestExternalInterface>(cx, temp, &tmp, static_cast<mozilla::dom::TestExternalInterface**>(getter_AddRefs(tempHolder)), &tmpVal))) {
          ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestExternalInterface");return false;
        }
        MOZ_ASSERT(tmp);
        slot = tmp;
      } else {
        ThrowErrorMessage(cx, MSG_NOT_OBJECT);
        return false;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassExternalInterfaceSequence(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passExternalInterfaceSequence_methodinfo = {
  (JSJitPropertyOp)passExternalInterfaceSequence,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passNullableExternalInterfaceSequence(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.passNullableExternalInterfaceSequence");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  const Sequence< nsRefPtr<mozilla::dom::TestExternalInterface> > arg0;
  if (argv[0].isObject()) {
    JSObject* seq = &argv[0].toObject();

    if (!IsArrayLike(cx, seq)) {
      ThrowErrorMessage(cx, MSG_NOT_SEQUENCE);
      return false;
    }
    uint32_t length;
    // JS_GetArrayLength actually works on all objects
    if (!JS_GetArrayLength(cx, seq, &length)) {
      return false;
    }
    Sequence< nsRefPtr<mozilla::dom::TestExternalInterface> > &arr = const_cast< Sequence< nsRefPtr<mozilla::dom::TestExternalInterface> >& >(arg0);
    if (!arr.SetCapacity(length)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t i = 0; i < length; ++i) {
      jsval temp;
      if (!JS_GetElement(cx, seq, i, &temp)) {
        return false;
      }
      nsRefPtr<mozilla::dom::TestExternalInterface>& slot = *arr.AppendElement();
      if (temp.isObject()) {
        nsRefPtr<mozilla::dom::TestExternalInterface> tempHolder;
        jsval tmpVal = temp;
        mozilla::dom::TestExternalInterface* tmp;
        if (NS_FAILED(xpc_qsUnwrapArg<mozilla::dom::TestExternalInterface>(cx, temp, &tmp, static_cast<mozilla::dom::TestExternalInterface**>(getter_AddRefs(tempHolder)), &tmpVal))) {
          ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestExternalInterface");return false;
        }
        MOZ_ASSERT(tmp);
        slot = tmp;
      } else if (temp.isNullOrUndefined()) {
        slot = NULL;
      } else {
        ThrowErrorMessage(cx, MSG_NOT_OBJECT);
        return false;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassNullableExternalInterfaceSequence(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passNullableExternalInterfaceSequence_methodinfo = {
  (JSJitPropertyOp)passNullableExternalInterfaceSequence,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveStringSequence(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{
  nsTArray< nsString > result;
  self->ReceiveStringSequence(result);

  uint32_t length = result.Length();
  JSObject *returnArray = JS_NewArrayObject(cx, length, NULL);
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    jsval tmp;
    for (uint32_t i = 0; i < length; ++i) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!xpc::NonVoidStringToJsval(cx, result[i], &tmp)) {
          return false;
        }
        break;
      } while (0);
      if (!JS_DefineElement(cx, returnArray, i, tmp,
                            nullptr, nullptr, JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  *vp = JS::ObjectValue(*returnArray);
  return true;
}


const JSJitInfo receiveStringSequence_methodinfo = {
  (JSJitPropertyOp)receiveStringSequence,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
passStringSequence(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.passStringSequence");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  const Sequence< nsString > arg0;
  if (argv[0].isObject()) {
    JSObject* seq = &argv[0].toObject();

    if (!IsArrayLike(cx, seq)) {
      ThrowErrorMessage(cx, MSG_NOT_SEQUENCE);
      return false;
    }
    uint32_t length;
    // JS_GetArrayLength actually works on all objects
    if (!JS_GetArrayLength(cx, seq, &length)) {
      return false;
    }
    Sequence< nsString > &arr = const_cast< Sequence< nsString >& >(arg0);
    if (!arr.SetCapacity(length)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t i = 0; i < length; ++i) {
      jsval temp;
      if (!JS_GetElement(cx, seq, i, &temp)) {
        return false;
      }
      nsString& slot = *arr.AppendElement();
      {
        FakeDependentString str;
        if (!ConvertJSValueToString(cx, temp, &temp, eStringify, eStringify, str)) {
          return false;
        }
        slot = str;
      }

    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassStringSequence(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passStringSequence_methodinfo = {
  (JSJitPropertyOp)passStringSequence,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveAnySequence(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{
  nsTArray< JS::Value > result;
  self->ReceiveAnySequence(cx, result);

  uint32_t length = result.Length();
  JSObject *returnArray = JS_NewArrayObject(cx, length, NULL);
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    jsval tmp;
    for (uint32_t i = 0; i < length; ++i) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        tmp = result[i];
        if (!MaybeWrapValue(cx, &tmp)) {
          return false;
        }
        break;
      } while (0);
      if (!JS_DefineElement(cx, returnArray, i, tmp,
                            nullptr, nullptr, JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  *vp = JS::ObjectValue(*returnArray);
  return true;
}


const JSJitInfo receiveAnySequence_methodinfo = {
  (JSJitPropertyOp)receiveAnySequence,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveNullableAnySequence(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{
  Nullable< nsTArray< JS::Value > > result;
  self->ReceiveNullableAnySequence(cx, result);

  if (result.IsNull()) {
    *vp = JSVAL_NULL;
    return true;
  }

  uint32_t length = result.Value().Length();
  JSObject *returnArray = JS_NewArrayObject(cx, length, NULL);
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    jsval tmp;
    for (uint32_t i = 0; i < length; ++i) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        tmp = result.Value()[i];
        if (!MaybeWrapValue(cx, &tmp)) {
          return false;
        }
        break;
      } while (0);
      if (!JS_DefineElement(cx, returnArray, i, tmp,
                            nullptr, nullptr, JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  *vp = JS::ObjectValue(*returnArray);
  return true;
}


const JSJitInfo receiveNullableAnySequence_methodinfo = {
  (JSJitPropertyOp)receiveNullableAnySequence,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
passArrayBuffer(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.passArrayBuffer");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  Maybe<ArrayBuffer> arg0_holder;
  NonNull<ArrayBuffer> arg0;
  if (argv[0].isObject()) {
    arg0_holder.construct(&argv[0].toObject());
    if (!arg0_holder.ref().inited()) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "ArrayBuffer");return false;
    }
    arg0 = arg0_holder.addr();
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassArrayBuffer(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passArrayBuffer_methodinfo = {
  (JSJitPropertyOp)passArrayBuffer,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passNullableArrayBuffer(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.passNullableArrayBuffer");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  Maybe<ArrayBuffer> arg0_holder;
  ArrayBuffer* arg0;
  if (argv[0].isObject()) {
    arg0_holder.construct(&argv[0].toObject());
    if (!arg0_holder.ref().inited()) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "ArrayBuffer");return false;
    }
    arg0 = arg0_holder.addr();
  } else if (argv[0].isNullOrUndefined()) {
    arg0 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassNullableArrayBuffer(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passNullableArrayBuffer_methodinfo = {
  (JSJitPropertyOp)passNullableArrayBuffer,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalArrayBuffer(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  const Optional<ArrayBuffer> arg0;
  if (0 < argc) {
    if (argv[0].isObject()) {
      (const_cast<Optional<ArrayBuffer>& >(arg0)).Construct(&argv[0].toObject());
      if (!(const_cast<Optional<ArrayBuffer>& >(arg0)).Value().inited()) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "ArrayBuffer");return false;
      }

    } else {
      ThrowErrorMessage(cx, MSG_NOT_OBJECT);
      return false;
    }
  }
  self->PassOptionalArrayBuffer(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalArrayBuffer_methodinfo = {
  (JSJitPropertyOp)passOptionalArrayBuffer,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalNullableArrayBuffer(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  Maybe<ArrayBuffer> arg0_holder;
  const Optional<ArrayBuffer*> arg0;
  if (0 < argc) {
    if (argv[0].isObject()) {
      arg0_holder.construct(&argv[0].toObject());
      if (!arg0_holder.ref().inited()) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "ArrayBuffer");return false;
      }
      (const_cast<Optional<ArrayBuffer*>& >(arg0)).Construct();
      (const_cast<Optional<ArrayBuffer*>& >(arg0)).Value() = arg0_holder.addr();
    } else if (argv[0].isNullOrUndefined()) {
      (const_cast<Optional<ArrayBuffer*>& >(arg0)).Value() = NULL;
    } else {
      ThrowErrorMessage(cx, MSG_NOT_OBJECT);
      return false;
    }
  }
  self->PassOptionalNullableArrayBuffer(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalNullableArrayBuffer_methodinfo = {
  (JSJitPropertyOp)passOptionalNullableArrayBuffer,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalNullableArrayBufferWithDefaultValue(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  Maybe<ArrayBuffer> arg0_holder;
  ArrayBuffer* arg0;
  if (0 < argc) {
    if (argv[0].isObject()) {
      arg0_holder.construct(&argv[0].toObject());
      if (!arg0_holder.ref().inited()) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "ArrayBuffer");return false;
      }
      arg0 = arg0_holder.addr();
    } else if (argv[0].isNullOrUndefined()) {
      arg0 = NULL;
    } else {
      ThrowErrorMessage(cx, MSG_NOT_OBJECT);
      return false;
    }
  } else {
    arg0 = NULL;
  }
  self->PassOptionalNullableArrayBufferWithDefaultValue(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalNullableArrayBufferWithDefaultValue_methodinfo = {
  (JSJitPropertyOp)passOptionalNullableArrayBufferWithDefaultValue,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passArrayBufferView(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.passArrayBufferView");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  Maybe<ArrayBufferView> arg0_holder;
  NonNull<ArrayBufferView> arg0;
  if (argv[0].isObject()) {
    arg0_holder.construct(&argv[0].toObject());
    if (!arg0_holder.ref().inited()) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "ArrayBufferView");return false;
    }
    arg0 = arg0_holder.addr();
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassArrayBufferView(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passArrayBufferView_methodinfo = {
  (JSJitPropertyOp)passArrayBufferView,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passInt8Array(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.passInt8Array");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  Maybe<Int8Array> arg0_holder;
  NonNull<Int8Array> arg0;
  if (argv[0].isObject()) {
    arg0_holder.construct(&argv[0].toObject());
    if (!arg0_holder.ref().inited()) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "Int8Array");return false;
    }
    arg0 = arg0_holder.addr();
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassInt8Array(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passInt8Array_methodinfo = {
  (JSJitPropertyOp)passInt8Array,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passInt16Array(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.passInt16Array");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  Maybe<Int16Array> arg0_holder;
  NonNull<Int16Array> arg0;
  if (argv[0].isObject()) {
    arg0_holder.construct(&argv[0].toObject());
    if (!arg0_holder.ref().inited()) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "Int16Array");return false;
    }
    arg0 = arg0_holder.addr();
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassInt16Array(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passInt16Array_methodinfo = {
  (JSJitPropertyOp)passInt16Array,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passInt32Array(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.passInt32Array");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  Maybe<Int32Array> arg0_holder;
  NonNull<Int32Array> arg0;
  if (argv[0].isObject()) {
    arg0_holder.construct(&argv[0].toObject());
    if (!arg0_holder.ref().inited()) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "Int32Array");return false;
    }
    arg0 = arg0_holder.addr();
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassInt32Array(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passInt32Array_methodinfo = {
  (JSJitPropertyOp)passInt32Array,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passUint8Array(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.passUint8Array");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  Maybe<Uint8Array> arg0_holder;
  NonNull<Uint8Array> arg0;
  if (argv[0].isObject()) {
    arg0_holder.construct(&argv[0].toObject());
    if (!arg0_holder.ref().inited()) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "Uint8Array");return false;
    }
    arg0 = arg0_holder.addr();
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassUint8Array(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passUint8Array_methodinfo = {
  (JSJitPropertyOp)passUint8Array,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passUint16Array(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.passUint16Array");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  Maybe<Uint16Array> arg0_holder;
  NonNull<Uint16Array> arg0;
  if (argv[0].isObject()) {
    arg0_holder.construct(&argv[0].toObject());
    if (!arg0_holder.ref().inited()) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "Uint16Array");return false;
    }
    arg0 = arg0_holder.addr();
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassUint16Array(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passUint16Array_methodinfo = {
  (JSJitPropertyOp)passUint16Array,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passUint32Array(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.passUint32Array");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  Maybe<Uint32Array> arg0_holder;
  NonNull<Uint32Array> arg0;
  if (argv[0].isObject()) {
    arg0_holder.construct(&argv[0].toObject());
    if (!arg0_holder.ref().inited()) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "Uint32Array");return false;
    }
    arg0 = arg0_holder.addr();
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassUint32Array(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passUint32Array_methodinfo = {
  (JSJitPropertyOp)passUint32Array,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passUint8ClampedArray(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.passUint8ClampedArray");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  Maybe<Uint8ClampedArray> arg0_holder;
  NonNull<Uint8ClampedArray> arg0;
  if (argv[0].isObject()) {
    arg0_holder.construct(&argv[0].toObject());
    if (!arg0_holder.ref().inited()) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "Uint8ClampedArray");return false;
    }
    arg0 = arg0_holder.addr();
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassUint8ClampedArray(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passUint8ClampedArray_methodinfo = {
  (JSJitPropertyOp)passUint8ClampedArray,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passFloat32Array(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.passFloat32Array");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  Maybe<Float32Array> arg0_holder;
  NonNull<Float32Array> arg0;
  if (argv[0].isObject()) {
    arg0_holder.construct(&argv[0].toObject());
    if (!arg0_holder.ref().inited()) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "Float32Array");return false;
    }
    arg0 = arg0_holder.addr();
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassFloat32Array(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passFloat32Array_methodinfo = {
  (JSJitPropertyOp)passFloat32Array,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passFloat64Array(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.passFloat64Array");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  Maybe<Float64Array> arg0_holder;
  NonNull<Float64Array> arg0;
  if (argv[0].isObject()) {
    arg0_holder.construct(&argv[0].toObject());
    if (!arg0_holder.ref().inited()) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "Float64Array");return false;
    }
    arg0 = arg0_holder.addr();
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassFloat64Array(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passFloat64Array_methodinfo = {
  (JSJitPropertyOp)passFloat64Array,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveUint8Array(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{
  JSObject* result;
  result = self->ReceiveUint8Array(cx);
  *vp = JS::ObjectValue(*result);
  if (!MaybeWrapValue(cx, vp)) {
    return false;
  }
  return true;
}


const JSJitInfo receiveUint8Array_methodinfo = {
  (JSJitPropertyOp)receiveUint8Array,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
passString(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.passString");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eStringify, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  self->PassString(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passString_methodinfo = {
  (JSJitPropertyOp)passString,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passNullableString(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.passNullableString");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eNull, eNull, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  self->PassNullableString(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passNullableString_methodinfo = {
  (JSJitPropertyOp)passNullableString,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalString(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  FakeDependentString arg0_holder;
  const Optional<nsAString> arg0;
  if (0 < argc) {
    if (!ConvertJSValueToString(cx, argv[0], &argv[0], eStringify, eStringify, arg0_holder)) {
      return false;
    }
    const_cast<Optional<nsAString>&>(arg0) = &arg0_holder;
  }
  self->PassOptionalString(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalString_methodinfo = {
  (JSJitPropertyOp)passOptionalString,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalStringWithDefaultValue(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (0 < argc) {
    if (!ConvertJSValueToString(cx, argv[0], &argv[0], eStringify, eStringify, arg0_holder)) {
      return false;
    }
  } else {
    static const PRUnichar data[] = { 'a', 'b', 'c', 0 };
    arg0_holder.SetData(data, ArrayLength(data) - 1);
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  self->PassOptionalStringWithDefaultValue(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalStringWithDefaultValue_methodinfo = {
  (JSJitPropertyOp)passOptionalStringWithDefaultValue,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalNullableString(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  FakeDependentString arg0_holder;
  const Optional<nsAString> arg0;
  if (0 < argc) {
    if (!ConvertJSValueToString(cx, argv[0], &argv[0], eNull, eNull, arg0_holder)) {
      return false;
    }
    const_cast<Optional<nsAString>&>(arg0) = &arg0_holder;
  }
  self->PassOptionalNullableString(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalNullableString_methodinfo = {
  (JSJitPropertyOp)passOptionalNullableString,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalNullableStringWithDefaultValue(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (0 < argc) {
    if (!ConvertJSValueToString(cx, argv[0], &argv[0], eNull, eNull, arg0_holder)) {
      return false;
    }
  } else {
    arg0_holder.SetNull();
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  self->PassOptionalNullableStringWithDefaultValue(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalNullableStringWithDefaultValue_methodinfo = {
  (JSJitPropertyOp)passOptionalNullableStringWithDefaultValue,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passVariadicString(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  const Sequence< nsString > arg0;
  if (argc > 0) {
    Sequence< nsString >& arr = const_cast< Sequence< nsString >& >(arg0);
    if (!arr.SetCapacity(argc - 0)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t variadicArg = 0; variadicArg < argc; ++variadicArg) {
      nsString& slot = *arr.AppendElement();
      {
        FakeDependentString str;
        if (!ConvertJSValueToString(cx, argv[variadicArg], &argv[variadicArg], eStringify, eStringify, str)) {
          return false;
        }
        slot = str;
      }

    }
  }
  self->PassVariadicString(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passVariadicString_methodinfo = {
  (JSJitPropertyOp)passVariadicString,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passEnum(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.passEnum");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  TestEnum arg0;
  {
    bool ok;
    int index = FindEnumStringIndex<true>(cx, argv[0], TestEnumValues::strings, "TestEnum", &ok);
    if (!ok) {
      return false;
    }
    MOZ_ASSERT(index >= 0);
    arg0 = static_cast<TestEnum>(index);
  }
  self->PassEnum(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passEnum_methodinfo = {
  (JSJitPropertyOp)passEnum,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalEnum(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  const Optional< TestEnum > arg0;
  if (0 < argc) {
    const_cast< Optional< TestEnum > &>(arg0).Construct();
    {
      bool ok;
      int index = FindEnumStringIndex<true>(cx, argv[0], TestEnumValues::strings, "TestEnum", &ok);
      if (!ok) {
        return false;
      }
      MOZ_ASSERT(index >= 0);
      const_cast< TestEnum & >(arg0.Value()) = static_cast<TestEnum>(index);
    }
  }
  self->PassOptionalEnum(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalEnum_methodinfo = {
  (JSJitPropertyOp)passOptionalEnum,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passEnumWithDefault(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  TestEnum arg0;
  if (0 < argc) {
    {
      bool ok;
      int index = FindEnumStringIndex<true>(cx, argv[0], TestEnumValues::strings, "TestEnum", &ok);
      if (!ok) {
        return false;
      }
      MOZ_ASSERT(index >= 0);
      arg0 = static_cast<TestEnum>(index);
    }
  } else {
    arg0 = TestEnumValues::A;
  }
  self->PassEnumWithDefault(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passEnumWithDefault_methodinfo = {
  (JSJitPropertyOp)passEnumWithDefault,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveEnum(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{
  TestEnum result;
  result = self->ReceiveEnum();
  MOZ_ASSERT(uint32_t(result) < ArrayLength(TestEnumValues::strings));
  JSString* result_str = JS_NewStringCopyN(cx, TestEnumValues::strings[uint32_t(result)].value, TestEnumValues::strings[uint32_t(result)].length);
  if (!result_str) {
  return false;
  }
  *vp = JS::StringValue(result_str);
  return true;
}


const JSJitInfo receiveEnum_methodinfo = {
  (JSJitPropertyOp)receiveEnum,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_enumAttribute(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* vp)
{
  TestEnum result;
  result = self->EnumAttribute();
  MOZ_ASSERT(uint32_t(result) < ArrayLength(TestEnumValues::strings));
  JSString* result_str = JS_NewStringCopyN(cx, TestEnumValues::strings[uint32_t(result)].value, TestEnumValues::strings[uint32_t(result)].length);
  if (!result_str) {
  return false;
  }
  *vp = JS::StringValue(result_str);
  return true;
}

static bool
set_enumAttribute(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* argv)
{
  TestEnum arg0;
  {
    bool ok;
    int index = FindEnumStringIndex<false>(cx, argv[0], TestEnumValues::strings, "TestEnum", &ok);
    if (!ok) {
      return false;
    }
    if (index < 0) {
      return true;
    }
    arg0 = static_cast<TestEnum>(index);
  }
  self->SetEnumAttribute(arg0);

  return true;
}


const JSJitInfo enumAttribute_getterinfo = {
  (JSJitPropertyOp)get_enumAttribute,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo enumAttribute_setterinfo = {
  (JSJitPropertyOp)set_enumAttribute,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_readonlyEnumAttribute(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* vp)
{
  TestEnum result;
  result = self->ReadonlyEnumAttribute();
  MOZ_ASSERT(uint32_t(result) < ArrayLength(TestEnumValues::strings));
  JSString* result_str = JS_NewStringCopyN(cx, TestEnumValues::strings[uint32_t(result)].value, TestEnumValues::strings[uint32_t(result)].length);
  if (!result_str) {
  return false;
  }
  *vp = JS::StringValue(result_str);
  return true;
}


const JSJitInfo readonlyEnumAttribute_getterinfo = {
  (JSJitPropertyOp)get_readonlyEnumAttribute,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

static bool
passCallback(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.passCallback");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  OwningNonNull<TestCallback> arg0;
  if (argv[0].isObject()) {
    if (JS_ObjectIsCallable(cx, &argv[0].toObject())) {
      bool inited;
      arg0 = new TestCallback(cx, obj, &argv[0].toObject(), &inited);
      if (!inited) {
        return false;
      }
    } else {
      ThrowErrorMessage(cx, MSG_NOT_CALLABLE);
      return false;
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassCallback(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passCallback_methodinfo = {
  (JSJitPropertyOp)passCallback,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passNullableCallback(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.passNullableCallback");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  nsRefPtr<TestCallback> arg0;
  if (argv[0].isObject()) {
    if (JS_ObjectIsCallable(cx, &argv[0].toObject())) {
      bool inited;
      arg0 = new TestCallback(cx, obj, &argv[0].toObject(), &inited);
      if (!inited) {
        return false;
      }
    } else {
      ThrowErrorMessage(cx, MSG_NOT_CALLABLE);
      return false;
    }
  } else if (argv[0].isNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassNullableCallback(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passNullableCallback_methodinfo = {
  (JSJitPropertyOp)passNullableCallback,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalCallback(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  const Optional< OwningNonNull<TestCallback> > arg0;
  if (0 < argc) {
    const_cast< Optional< OwningNonNull<TestCallback> > &>(arg0).Construct();
    if (argv[0].isObject()) {
      if (JS_ObjectIsCallable(cx, &argv[0].toObject())) {
        bool inited;
        const_cast< OwningNonNull<TestCallback> & >(arg0.Value()) = new TestCallback(cx, obj, &argv[0].toObject(), &inited);
        if (!inited) {
          return false;
        }
      } else {
        ThrowErrorMessage(cx, MSG_NOT_CALLABLE);
        return false;
      }
    } else {
      ThrowErrorMessage(cx, MSG_NOT_OBJECT);
      return false;
    }
  }
  self->PassOptionalCallback(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalCallback_methodinfo = {
  (JSJitPropertyOp)passOptionalCallback,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalNullableCallback(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  const Optional< nsRefPtr<TestCallback> > arg0;
  if (0 < argc) {
    const_cast< Optional< nsRefPtr<TestCallback> > &>(arg0).Construct();
    if (argv[0].isObject()) {
      if (JS_ObjectIsCallable(cx, &argv[0].toObject())) {
        bool inited;
        const_cast< nsRefPtr<TestCallback> & >(arg0.Value()) = new TestCallback(cx, obj, &argv[0].toObject(), &inited);
        if (!inited) {
          return false;
        }
      } else {
        ThrowErrorMessage(cx, MSG_NOT_CALLABLE);
        return false;
      }
    } else if (argv[0].isNullOrUndefined()) {
      const_cast< nsRefPtr<TestCallback> & >(arg0.Value()) = nullptr;
    } else {
      ThrowErrorMessage(cx, MSG_NOT_OBJECT);
      return false;
    }
  }
  self->PassOptionalNullableCallback(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalNullableCallback_methodinfo = {
  (JSJitPropertyOp)passOptionalNullableCallback,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalNullableCallbackWithDefaultValue(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  nsRefPtr<TestCallback> arg0;
  if (0 < argc) {
    if (argv[0].isObject()) {
      if (JS_ObjectIsCallable(cx, &argv[0].toObject())) {
        bool inited;
        arg0 = new TestCallback(cx, obj, &argv[0].toObject(), &inited);
        if (!inited) {
          return false;
        }
      } else {
        ThrowErrorMessage(cx, MSG_NOT_CALLABLE);
        return false;
      }
    } else if (argv[0].isNullOrUndefined()) {
      arg0 = nullptr;
    } else {
      ThrowErrorMessage(cx, MSG_NOT_OBJECT);
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  self->PassOptionalNullableCallbackWithDefaultValue(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalNullableCallbackWithDefaultValue_methodinfo = {
  (JSJitPropertyOp)passOptionalNullableCallbackWithDefaultValue,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveCallback(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{
  nsRefPtr<TestCallback> result;
  result = self->ReceiveCallback();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}


const JSJitInfo receiveCallback_methodinfo = {
  (JSJitPropertyOp)receiveCallback,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveNullableCallback(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{
  nsRefPtr<TestCallback> result;
  result = self->ReceiveNullableCallback();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}


const JSJitInfo receiveNullableCallback_methodinfo = {
  (JSJitPropertyOp)receiveNullableCallback,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
passNullableTreatAsNullCallback(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.passNullableTreatAsNullCallback");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  nsRefPtr<TestTreatAsNullCallback> arg0;
  if (argv[0].isObject()) {
    if (JS_ObjectIsCallable(cx, &argv[0].toObject())) {
      bool inited;
      arg0 = new TestTreatAsNullCallback(cx, obj, &argv[0].toObject(), &inited);
      if (!inited) {
        return false;
      }
    } else {
      ThrowErrorMessage(cx, MSG_NOT_CALLABLE);
      return false;
    }
  } else if (argv[0].isNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassNullableTreatAsNullCallback(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passNullableTreatAsNullCallback_methodinfo = {
  (JSJitPropertyOp)passNullableTreatAsNullCallback,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalNullableTreatAsNullCallback(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  const Optional< nsRefPtr<TestTreatAsNullCallback> > arg0;
  if (0 < argc) {
    const_cast< Optional< nsRefPtr<TestTreatAsNullCallback> > &>(arg0).Construct();
    if (argv[0].isObject()) {
      if (JS_ObjectIsCallable(cx, &argv[0].toObject())) {
        bool inited;
        const_cast< nsRefPtr<TestTreatAsNullCallback> & >(arg0.Value()) = new TestTreatAsNullCallback(cx, obj, &argv[0].toObject(), &inited);
        if (!inited) {
          return false;
        }
      } else {
        ThrowErrorMessage(cx, MSG_NOT_CALLABLE);
        return false;
      }
    } else if (argv[0].isNullOrUndefined()) {
      const_cast< nsRefPtr<TestTreatAsNullCallback> & >(arg0.Value()) = nullptr;
    } else {
      ThrowErrorMessage(cx, MSG_NOT_OBJECT);
      return false;
    }
  }
  self->PassOptionalNullableTreatAsNullCallback(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalNullableTreatAsNullCallback_methodinfo = {
  (JSJitPropertyOp)passOptionalNullableTreatAsNullCallback,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalNullableTreatAsNullCallbackWithDefaultValue(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  nsRefPtr<TestTreatAsNullCallback> arg0;
  if (0 < argc) {
    if (argv[0].isObject()) {
      if (JS_ObjectIsCallable(cx, &argv[0].toObject())) {
        bool inited;
        arg0 = new TestTreatAsNullCallback(cx, obj, &argv[0].toObject(), &inited);
        if (!inited) {
          return false;
        }
      } else {
        ThrowErrorMessage(cx, MSG_NOT_CALLABLE);
        return false;
      }
    } else if (argv[0].isNullOrUndefined()) {
      arg0 = nullptr;
    } else {
      ThrowErrorMessage(cx, MSG_NOT_OBJECT);
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  self->PassOptionalNullableTreatAsNullCallbackWithDefaultValue(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalNullableTreatAsNullCallbackWithDefaultValue_methodinfo = {
  (JSJitPropertyOp)passOptionalNullableTreatAsNullCallbackWithDefaultValue,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_treatAsNullCallback(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* vp)
{
  nsRefPtr<TestTreatAsNullCallback> result;
  result = self->TreatAsNullCallback();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_treatAsNullCallback(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* argv)
{
  OwningNonNull<TestTreatAsNullCallback> arg0;
  if (argv[0].isObject()) {
    if (JS_ObjectIsCallable(cx, &argv[0].toObject())) {
      bool inited;
      arg0 = new TestTreatAsNullCallback(cx, obj, &argv[0].toObject(), &inited);
      if (!inited) {
        return false;
      }
    } else {
      ThrowErrorMessage(cx, MSG_NOT_CALLABLE);
      return false;
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->SetTreatAsNullCallback(arg0);

  return true;
}


const JSJitInfo treatAsNullCallback_getterinfo = {
  (JSJitPropertyOp)get_treatAsNullCallback,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo treatAsNullCallback_setterinfo = {
  (JSJitPropertyOp)set_treatAsNullCallback,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_nullableTreatAsNullCallback(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* vp)
{
  nsRefPtr<TestTreatAsNullCallback> result;
  result = self->GetNullableTreatAsNullCallback();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_nullableTreatAsNullCallback(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* argv)
{
  nsRefPtr<TestTreatAsNullCallback> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new TestTreatAsNullCallback(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  self->SetNullableTreatAsNullCallback(arg0);

  return true;
}


const JSJitInfo nullableTreatAsNullCallback_getterinfo = {
  (JSJitPropertyOp)get_nullableTreatAsNullCallback,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo nullableTreatAsNullCallback_setterinfo = {
  (JSJitPropertyOp)set_nullableTreatAsNullCallback,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passAny(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.passAny");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  JS::Value arg0;
  arg0 = argv[0];
  self->PassAny(cx, arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passAny_methodinfo = {
  (JSJitPropertyOp)passAny,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalAny(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  const Optional< JS::Value > arg0;
  if (0 < argc) {
    const_cast< Optional< JS::Value > &>(arg0).Construct();
    const_cast< JS::Value & >(arg0.Value()) = argv[0];
  }
  self->PassOptionalAny(cx, arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalAny_methodinfo = {
  (JSJitPropertyOp)passOptionalAny,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passAnyDefaultNull(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  JS::Value arg0;
  if (0 < argc) {
    arg0 = argv[0];
  } else {
    arg0 = JS::NullValue();
  }
  self->PassAnyDefaultNull(cx, arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passAnyDefaultNull_methodinfo = {
  (JSJitPropertyOp)passAnyDefaultNull,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveAny(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{
  JS::Value result;
  result = self->ReceiveAny(cx);
  *vp = result;
  if (!MaybeWrapValue(cx, vp)) {
    return false;
  }
  return true;
}


const JSJitInfo receiveAny_methodinfo = {
  (JSJitPropertyOp)receiveAny,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
passObject(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.passObject");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  NonNull<JSObject> arg0;
  if (argv[0].isObject()) {
    arg0 = &argv[0].toObject();
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassObject(cx, (JSObject&)arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passObject_methodinfo = {
  (JSJitPropertyOp)passObject,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passNullableObject(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.passNullableObject");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  JSObject* arg0;
  if (argv[0].isObject()) {
    arg0 = &argv[0].toObject();
  } else if (argv[0].isNullOrUndefined()) {
    arg0 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassNullableObject(cx, arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passNullableObject_methodinfo = {
  (JSJitPropertyOp)passNullableObject,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalObject(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  const Optional< NonNull<JSObject> > arg0;
  if (0 < argc) {
    const_cast< Optional< NonNull<JSObject> > &>(arg0).Construct();
    if (argv[0].isObject()) {
      const_cast< NonNull<JSObject> & >(arg0.Value()) = &argv[0].toObject();
    } else {
      ThrowErrorMessage(cx, MSG_NOT_OBJECT);
      return false;
    }
  }
  self->PassOptionalObject(cx, arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalObject_methodinfo = {
  (JSJitPropertyOp)passOptionalObject,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalNullableObject(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  const Optional< JSObject* > arg0;
  if (0 < argc) {
    const_cast< Optional< JSObject* > &>(arg0).Construct();
    if (argv[0].isObject()) {
      const_cast< JSObject* & >(arg0.Value()) = &argv[0].toObject();
    } else if (argv[0].isNullOrUndefined()) {
      const_cast< JSObject* & >(arg0.Value()) = NULL;
    } else {
      ThrowErrorMessage(cx, MSG_NOT_OBJECT);
      return false;
    }
  }
  self->PassOptionalNullableObject(cx, arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalNullableObject_methodinfo = {
  (JSJitPropertyOp)passOptionalNullableObject,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalNullableObjectWithDefaultValue(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  JSObject* arg0;
  if (0 < argc) {
    if (argv[0].isObject()) {
      arg0 = &argv[0].toObject();
    } else if (argv[0].isNullOrUndefined()) {
      arg0 = NULL;
    } else {
      ThrowErrorMessage(cx, MSG_NOT_OBJECT);
      return false;
    }
  } else {
    arg0 = NULL;
  }
  self->PassOptionalNullableObjectWithDefaultValue(cx, arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalNullableObjectWithDefaultValue_methodinfo = {
  (JSJitPropertyOp)passOptionalNullableObjectWithDefaultValue,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveObject(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{
  JSObject* result;
  result = self->ReceiveObject(cx);
  *vp = JS::ObjectValue(*result);
  if (!MaybeWrapValue(cx, vp)) {
    return false;
  }
  return true;
}


const JSJitInfo receiveObject_methodinfo = {
  (JSJitPropertyOp)receiveObject,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveNullableObject(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{
  JSObject* result;
  result = self->ReceiveNullableObject(cx);
  *vp = JS::ObjectOrNullValue(result);
  if (!MaybeWrapValue(cx, vp)) {
    return false;
  }
  return true;
}


const JSJitInfo receiveNullableObject_methodinfo = {
  (JSJitPropertyOp)receiveNullableObject,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
passUnion(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.passUnion");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  const ObjectOrLong arg0;
  ObjectOrLongArgument arg0_holder(arg0);
  {
    bool done = false, failed = false, tryNext;
    if (argv[0].isObject()) {
      JSObject& argObj = argv[0].toObject();
      arg0_holder.SetToObject(&argObj);
      done = true;
    } else {
      done = (failed = !arg0_holder.TrySetToLong(cx, obj, argv[0], &argv[0], tryNext)) || !tryNext;
    }
    if (failed) {
      return false;
    }
    if (!done) {
      ThrowErrorMessage(cx, MSG_NOT_IN_UNION, "Long");
      return false;
    }
  }
  self->PassUnion(cx, arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passUnion_methodinfo = {
  (JSJitPropertyOp)passUnion,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passUnionWithNullable(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.passUnionWithNullable");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  const ObjectOrNullOrLong arg0;
  ObjectOrNullOrLongArgument arg0_holder(arg0);
  if (argv[0].isNullOrUndefined()) {
    arg0_holder.SetNull();
  } else {
    {
      bool done = false, failed = false, tryNext;
      if (argv[0].isObject()) {
        JSObject& argObj = argv[0].toObject();
        arg0_holder.SetToObject(&argObj);
        done = true;
      } else {
        done = (failed = !arg0_holder.TrySetToLong(cx, obj, argv[0], &argv[0], tryNext)) || !tryNext;
      }
      if (failed) {
        return false;
      }
      if (!done) {
        ThrowErrorMessage(cx, MSG_NOT_IN_UNION, "Long");
        return false;
      }
    }
  }
  self->PassUnionWithNullable(cx, arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passUnionWithNullable_methodinfo = {
  (JSJitPropertyOp)passUnionWithNullable,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passNullableUnion(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.passNullableUnion");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  Maybe<ObjectOrLongArgument > arg0_holder;
  const Nullable<ObjectOrLong > arg0;
  if (argv[0].isNullOrUndefined()) {
    const_cast<Nullable<ObjectOrLong >& >(arg0).SetNull();
  } else {
    arg0_holder.construct(const_cast<Nullable<ObjectOrLong >& >(arg0).SetValue());
    {
      bool done = false, failed = false, tryNext;
      if (argv[0].isObject()) {
        JSObject& argObj = argv[0].toObject();
        arg0_holder.ref().SetToObject(&argObj);
        done = true;
      } else {
        done = (failed = !arg0_holder.ref().TrySetToLong(cx, obj, argv[0], &argv[0], tryNext)) || !tryNext;
      }
      if (failed) {
        return false;
      }
      if (!done) {
        ThrowErrorMessage(cx, MSG_NOT_IN_UNION, "Long");
        return false;
      }
    }
  }
  self->PassNullableUnion(cx, arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passNullableUnion_methodinfo = {
  (JSJitPropertyOp)passNullableUnion,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalUnion(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  Maybe<ObjectOrLongArgument > arg0_holder;
  const Optional<ObjectOrLong > arg0;
  if (0 < argc) {
    const_cast<Optional<ObjectOrLong >& >(arg0).Construct();
    arg0_holder.construct(arg0.Value());
    {
      bool done = false, failed = false, tryNext;
      if (argv[0].isObject()) {
        JSObject& argObj = argv[0].toObject();
        arg0_holder.ref().SetToObject(&argObj);
        done = true;
      } else {
        done = (failed = !arg0_holder.ref().TrySetToLong(cx, obj, argv[0], &argv[0], tryNext)) || !tryNext;
      }
      if (failed) {
        return false;
      }
      if (!done) {
        ThrowErrorMessage(cx, MSG_NOT_IN_UNION, "Long");
        return false;
      }
    }
  }
  self->PassOptionalUnion(cx, arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalUnion_methodinfo = {
  (JSJitPropertyOp)passOptionalUnion,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalNullableUnion(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  Maybe<ObjectOrLongArgument > arg0_holder;
  const Optional<Nullable<ObjectOrLong > > arg0;
  if (0 < argc) {
    const_cast<Optional<Nullable<ObjectOrLong > >& >(arg0).Construct();
    if (argv[0].isNullOrUndefined()) {
      const_cast<Optional<Nullable<ObjectOrLong > >& >(arg0).Value().SetNull();
    } else {
      arg0_holder.construct(const_cast<Optional<Nullable<ObjectOrLong > >& >(arg0).Value().SetValue());
      {
        bool done = false, failed = false, tryNext;
        if (argv[0].isObject()) {
          JSObject& argObj = argv[0].toObject();
          arg0_holder.ref().SetToObject(&argObj);
          done = true;
        } else {
          done = (failed = !arg0_holder.ref().TrySetToLong(cx, obj, argv[0], &argv[0], tryNext)) || !tryNext;
        }
        if (failed) {
          return false;
        }
        if (!done) {
          ThrowErrorMessage(cx, MSG_NOT_IN_UNION, "Long");
          return false;
        }
      }
    }
  }
  self->PassOptionalNullableUnion(cx, arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalNullableUnion_methodinfo = {
  (JSJitPropertyOp)passOptionalNullableUnion,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalNullableUnionWithDefaultValue(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  Maybe<ObjectOrLongArgument > arg0_holder;
  const Nullable<ObjectOrLong > arg0;
  if (!(0 < argc) || argv[0].isNullOrUndefined()) {
    const_cast<Nullable<ObjectOrLong >& >(arg0).SetNull();
  } else {
    arg0_holder.construct(const_cast<Nullable<ObjectOrLong >& >(arg0).SetValue());
    {
      bool done = false, failed = false, tryNext;
      if (argv[0].isObject()) {
        JSObject& argObj = argv[0].toObject();
        arg0_holder.ref().SetToObject(&argObj);
        done = true;
      } else {
        done = (failed = !arg0_holder.ref().TrySetToLong(cx, obj, argv[0], &argv[0], tryNext)) || !tryNext;
      }
      if (failed) {
        return false;
      }
      if (!done) {
        ThrowErrorMessage(cx, MSG_NOT_IN_UNION, "Long");
        return false;
      }
    }
  }
  self->PassOptionalNullableUnionWithDefaultValue(cx, arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalNullableUnionWithDefaultValue_methodinfo = {
  (JSJitPropertyOp)passOptionalNullableUnionWithDefaultValue,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passUnionWithArrayBuffer(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.passUnionWithArrayBuffer");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  const ArrayBufferOrLong arg0;
  ArrayBufferOrLongArgument arg0_holder(arg0);
  {
    bool done = false, failed = false, tryNext;
    if (argv[0].isObject()) {
      done = (failed = !arg0_holder.TrySetToArrayBuffer(cx, obj, argv[0], &argv[0], tryNext)) || !tryNext;

    }
    if (!done) {
      done = (failed = !arg0_holder.TrySetToLong(cx, obj, argv[0], &argv[0], tryNext)) || !tryNext;
    }
    if (failed) {
      return false;
    }
    if (!done) {
      ThrowErrorMessage(cx, MSG_NOT_IN_UNION, "ArrayBuffer, Long");
      return false;
    }
  }
  self->PassUnionWithArrayBuffer(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passUnionWithArrayBuffer_methodinfo = {
  (JSJitPropertyOp)passUnionWithArrayBuffer,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passUnionWithString(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.passUnionWithString");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  const StringOrObject arg0;
  StringOrObjectArgument arg0_holder(arg0);
  {
    bool done = false, failed = false, tryNext;
    if (argv[0].isObject()) {
      JSObject& argObj = argv[0].toObject();
      arg0_holder.SetToObject(&argObj);
      done = true;
    } else {
      done = (failed = !arg0_holder.TrySetToString(cx, obj, argv[0], &argv[0], tryNext)) || !tryNext;
    }
    if (failed) {
      return false;
    }
    if (!done) {
      ThrowErrorMessage(cx, MSG_NOT_IN_UNION, "String");
      return false;
    }
  }
  self->PassUnionWithString(cx, arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passUnionWithString_methodinfo = {
  (JSJitPropertyOp)passUnionWithString,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passUnionWithObject(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.passUnionWithObject");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  const ObjectOrLong arg0;
  ObjectOrLongArgument arg0_holder(arg0);
  {
    bool done = false, failed = false, tryNext;
    if (argv[0].isObject()) {
      JSObject& argObj = argv[0].toObject();
      arg0_holder.SetToObject(&argObj);
      done = true;
    } else {
      done = (failed = !arg0_holder.TrySetToLong(cx, obj, argv[0], &argv[0], tryNext)) || !tryNext;
    }
    if (failed) {
      return false;
    }
    if (!done) {
      ThrowErrorMessage(cx, MSG_NOT_IN_UNION, "Long");
      return false;
    }
  }
  self->PassUnionWithObject(cx, arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passUnionWithObject_methodinfo = {
  (JSJitPropertyOp)passUnionWithObject,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
methodRenamedFrom(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  unsigned argcount = NS_MIN(argc, 1u);
  switch (argcount) {
    case 0: {
      self->MethodRenamedTo();
      *vp = JSVAL_VOID;
      return true;
      break;
    }
    case 1: {

      JS::Value* argv = JS_ARGV(cx, vp);

      int8_t arg0;
      if (!ValueToPrimitive<int8_t, eDefault>(cx, argv[0], &arg0)) {
        return false;
      }
      self->MethodRenamedTo(arg0);
      *vp = JSVAL_VOID;
      return true;
      break;
    }
    default: {
      return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.methodRenamedFrom");

      break;
    }
  }
  MOZ_NOT_REACHED("We have an always-returning default case");
  return false;
}


const JSJitInfo methodRenamedFrom_methodinfo = {
  (JSJitPropertyOp)methodRenamedFrom,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_attributeGetterRenamedFrom(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* vp)
{
  int8_t result;
  result = self->AttributeGetterRenamedTo();
  *vp = INT_TO_JSVAL(int32_t(result));
  return true;
}


const JSJitInfo attributeGetterRenamedFrom_getterinfo = {
  (JSJitPropertyOp)get_attributeGetterRenamedFrom,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_attributeRenamedFrom(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* vp)
{
  int8_t result;
  result = self->AttributeRenamedTo();
  *vp = INT_TO_JSVAL(int32_t(result));
  return true;
}

static bool
set_attributeRenamedFrom(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* argv)
{
  int8_t arg0;
  if (!ValueToPrimitive<int8_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  self->SetAttributeRenamedTo(arg0);

  return true;
}


const JSJitInfo attributeRenamedFrom_getterinfo = {
  (JSJitPropertyOp)get_attributeRenamedFrom,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo attributeRenamedFrom_setterinfo = {
  (JSJitPropertyOp)set_attributeRenamedFrom,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passDictionary(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  const Dict arg0;
  if (!const_cast<Dict&>(arg0).Init(cx, obj, (0 < argc) ? argv[0] : JSVAL_NULL)) {
    return false;
  }
  self->PassDictionary(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passDictionary_methodinfo = {
  (JSJitPropertyOp)passDictionary,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveDictionary(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{
  DictInitializer result;
  self->ReceiveDictionary(result);
  if (!result.ToObject(cx, obj, vp)) {
    return false;
  }
  return true;
}


const JSJitInfo receiveDictionary_methodinfo = {
  (JSJitPropertyOp)receiveDictionary,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOtherDictionary(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  const GrandparentDict arg0;
  if (!const_cast<GrandparentDict&>(arg0).Init(cx, obj, (0 < argc) ? argv[0] : JSVAL_NULL)) {
    return false;
  }
  self->PassOtherDictionary(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOtherDictionary_methodinfo = {
  (JSJitPropertyOp)passOtherDictionary,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passSequenceOfDictionaries(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.passSequenceOfDictionaries");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  const Sequence< Dict > arg0;
  if (argv[0].isObject()) {
    JSObject* seq = &argv[0].toObject();

    if (!IsArrayLike(cx, seq)) {
      ThrowErrorMessage(cx, MSG_NOT_SEQUENCE);
      return false;
    }
    uint32_t length;
    // JS_GetArrayLength actually works on all objects
    if (!JS_GetArrayLength(cx, seq, &length)) {
      return false;
    }
    Sequence< Dict > &arr = const_cast< Sequence< Dict >& >(arg0);
    if (!arr.SetCapacity(length)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t i = 0; i < length; ++i) {
      jsval temp;
      if (!JS_GetElement(cx, seq, i, &temp)) {
        return false;
      }
      Dict& slot = *arr.AppendElement();
      if (!slot.Init(cx, obj, temp)) {
        return false;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassSequenceOfDictionaries(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passSequenceOfDictionaries_methodinfo = {
  (JSJitPropertyOp)passSequenceOfDictionaries,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passDictionaryOrLong(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  unsigned argcount = NS_MIN(argc, 1u);
  switch (argcount) {
    case 0: {

      JS::Value* argv = JS_ARGV(cx, vp);

      const Dict arg0;
      if (!const_cast<Dict&>(arg0).Init(cx, obj, (0 < argc) ? argv[0] : JSVAL_NULL)) {
        return false;
      }
      self->PassDictionaryOrLong(arg0);
      *vp = JSVAL_VOID;
      return true;
      break;
    }
    case 1: {
      JS::Value* argv_start = JS_ARGV(cx, vp);
      if (argv_start[0].isNullOrUndefined()) {
        const Dict arg0;
        if (!const_cast<Dict&>(arg0).Init(cx, obj, argv_start[0])) {
          return false;
        }
        self->PassDictionaryOrLong(arg0);
        *vp = JSVAL_VOID;
        return true;
      }
      if (argv_start[0].isObject()) {
        do {
          const Dict arg0;
          if (!IsConvertibleToDictionary(cx, &argv_start[0].toObject())) {
            break;
          }

          if (!const_cast<Dict&>(arg0).Init(cx, obj, argv_start[0])) {
            return false;
          }
          self->PassDictionaryOrLong(arg0);
          *vp = JSVAL_VOID;
          return true;
        } while (0);
      }

      JS::Value* argv = JS_ARGV(cx, vp);

      int32_t arg0;
      if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[0], &arg0)) {
        return false;
      }
      self->PassDictionaryOrLong(arg0);
      *vp = JSVAL_VOID;
      return true;
      break;
    }
    default: {
      return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.passDictionaryOrLong");

      break;
    }
  }
  MOZ_NOT_REACHED("We have an always-returning default case");
  return false;
}


const JSJitInfo passDictionaryOrLong_methodinfo = {
  (JSJitPropertyOp)passDictionaryOrLong,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passDictContainingDict(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  const DictContainingDict arg0;
  if (!const_cast<DictContainingDict&>(arg0).Init(cx, obj, (0 < argc) ? argv[0] : JSVAL_NULL)) {
    return false;
  }
  self->PassDictContainingDict(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passDictContainingDict_methodinfo = {
  (JSJitPropertyOp)passDictContainingDict,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passDictContainingSequence(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  const DictContainingSequence arg0;
  if (!const_cast<DictContainingSequence&>(arg0).Init(cx, obj, (0 < argc) ? argv[0] : JSVAL_NULL)) {
    return false;
  }
  self->PassDictContainingSequence(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passDictContainingSequence_methodinfo = {
  (JSJitPropertyOp)passDictContainingSequence,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveDictContainingSequence(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{
  DictContainingSequenceInitializer result;
  self->ReceiveDictContainingSequence(result);
  if (!result.ToObject(cx, obj, vp)) {
    return false;
  }
  return true;
}


const JSJitInfo receiveDictContainingSequence_methodinfo = {
  (JSJitPropertyOp)receiveDictContainingSequence,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
dontEnforceRangeOrClamp(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.dontEnforceRangeOrClamp");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  int8_t arg0;
  if (!ValueToPrimitive<int8_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  self->DontEnforceRangeOrClamp(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo dontEnforceRangeOrClamp_methodinfo = {
  (JSJitPropertyOp)dontEnforceRangeOrClamp,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
doEnforceRange(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.doEnforceRange");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  int8_t arg0;
  if (!ValueToPrimitive<int8_t, eEnforceRange>(cx, argv[0], &arg0)) {
    return false;
  }
  self->DoEnforceRange(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo doEnforceRange_methodinfo = {
  (JSJitPropertyOp)doEnforceRange,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
doClamp(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.doClamp");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  int8_t arg0;
  if (!ValueToPrimitive<int8_t, eClamp>(cx, argv[0], &arg0)) {
    return false;
  }
  self->DoClamp(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo doClamp_methodinfo = {
  (JSJitPropertyOp)doClamp,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
exerciseTypedefInterfaces1(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.exerciseTypedefInterfaces1");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  NonNull<mozilla::dom::TestInterface> arg0;
  if (argv[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(cx, &argv[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestInterface");
        return false;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->ExerciseTypedefInterfaces1(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo exerciseTypedefInterfaces1_methodinfo = {
  (JSJitPropertyOp)exerciseTypedefInterfaces1,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
exerciseTypedefInterfaces2(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.exerciseTypedefInterfaces2");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  mozilla::dom::TestInterface* arg0;
  if (argv[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(cx, &argv[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestInterface");
        return false;
      }
    }
  } else if (argv[0].isNullOrUndefined()) {
    arg0 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  nsRefPtr<mozilla::dom::TestInterface> result;
  result = self->ExerciseTypedefInterfaces2(arg0);
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}


const JSJitInfo exerciseTypedefInterfaces2_methodinfo = {
  (JSJitPropertyOp)exerciseTypedefInterfaces2,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
exerciseTypedefInterfaces3(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.exerciseTypedefInterfaces3");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  NonNull<mozilla::dom::TestInterface> arg0;
  if (argv[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(cx, &argv[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestInterface");
        return false;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->ExerciseTypedefInterfaces3(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo exerciseTypedefInterfaces3_methodinfo = {
  (JSJitPropertyOp)exerciseTypedefInterfaces3,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static JSBool
get_staticAttribute(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  // We have to be careful to leave "obj" in its existing compartment, even
  // while we grab our global from the real underlying object, because we
  // use it for unwrapping the other arguments later.
  nsISupports* global;
  xpc_qsSelfRef globalRef;
  {
    JS::Value val;
    Maybe<JSAutoCompartment> ac;
    if (js::IsWrapper(obj)) {
      JSObject* realObj = XPCWrapper::Unwrap(cx, obj, false);
      if (!realObj) {
        return Throw<true>(cx, NS_ERROR_XPC_SECURITY_MANAGER_VETO);
      }
      ac.construct(cx, realObj);
      val.setObject(*JS_GetGlobalForObject(cx, realObj));
    } else {
      val.setObject(*JS_GetGlobalForObject(cx, obj));
    }

    nsresult rv = xpc_qsUnwrapArg<nsISupports>(cx, val, &global, &globalRef.ptr,
                                               &val);
    if (NS_FAILED(rv)) {
      return Throw<true>(cx, NS_ERROR_XPC_BAD_CONVERT_JS);
    }
  }

  bool result;
  result = mozilla::dom::TestInterface::StaticAttribute(global);
  *vp = BOOLEAN_TO_JSVAL(result);
  return true;
}

static JSBool
set_staticAttribute(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  // We have to be careful to leave "obj" in its existing compartment, even
  // while we grab our global from the real underlying object, because we
  // use it for unwrapping the other arguments later.
  nsISupports* global;
  xpc_qsSelfRef globalRef;
  {
    JS::Value val;
    Maybe<JSAutoCompartment> ac;
    if (js::IsWrapper(obj)) {
      JSObject* realObj = XPCWrapper::Unwrap(cx, obj, false);
      if (!realObj) {
        return Throw<true>(cx, NS_ERROR_XPC_SECURITY_MANAGER_VETO);
      }
      ac.construct(cx, realObj);
      val.setObject(*JS_GetGlobalForObject(cx, realObj));
    } else {
      val.setObject(*JS_GetGlobalForObject(cx, obj));
    }

    nsresult rv = xpc_qsUnwrapArg<nsISupports>(cx, val, &global, &globalRef.ptr,
                                               &val);
    if (NS_FAILED(rv)) {
      return Throw<true>(cx, NS_ERROR_XPC_BAD_CONVERT_JS);
    }
  }

  JS::Value* argv = JS_ARGV(cx, vp);
  JS::Value undef = JS::UndefinedValue();
  if (argc == 0) {
    argv = &undef;
  }
  bool arg0;
  if (!ValueToPrimitive<bool, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  mozilla::dom::TestInterface::SetStaticAttribute(global, arg0);

  return true;
}

static JSBool
staticMethod(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  // We have to be careful to leave "obj" in its existing compartment, even
  // while we grab our global from the real underlying object, because we
  // use it for unwrapping the other arguments later.
  nsISupports* global;
  xpc_qsSelfRef globalRef;
  {
    JS::Value val;
    Maybe<JSAutoCompartment> ac;
    if (js::IsWrapper(obj)) {
      JSObject* realObj = XPCWrapper::Unwrap(cx, obj, false);
      if (!realObj) {
        return Throw<true>(cx, NS_ERROR_XPC_SECURITY_MANAGER_VETO);
      }
      ac.construct(cx, realObj);
      val.setObject(*JS_GetGlobalForObject(cx, realObj));
    } else {
      val.setObject(*JS_GetGlobalForObject(cx, obj));
    }

    nsresult rv = xpc_qsUnwrapArg<nsISupports>(cx, val, &global, &globalRef.ptr,
                                               &val);
    if (NS_FAILED(rv)) {
      return Throw<true>(cx, NS_ERROR_XPC_BAD_CONVERT_JS);
    }
  }


  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.staticMethod");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  bool arg0;
  if (!ValueToPrimitive<bool, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  mozilla::dom::TestInterface::StaticMethod(global, arg0);
  *vp = JSVAL_VOID;
  return true;
}

static bool
overload1(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  unsigned argcount = NS_MIN(argc, 2u);
  switch (argcount) {
    case 1: {

      JS::Value* argv = JS_ARGV(cx, vp);

      NonNull<mozilla::dom::TestInterface> arg0;
      if (argv[0].isObject()) {
        {
          nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(cx, &argv[0].toObject(), arg0);
          if (NS_FAILED(rv)) {
            ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestInterface");
            return false;
          }
        }
      } else {
        ThrowErrorMessage(cx, MSG_NOT_OBJECT);
        return false;
      }
      bool result;
      result = self->Overload1(arg0);
      *vp = BOOLEAN_TO_JSVAL(result);
      return true;
      break;
    }
    case 2: {

      JS::Value* argv = JS_ARGV(cx, vp);

      FakeDependentString arg0_holder;
      const NonNull<nsAString> arg0;
      if (!ConvertJSValueToString(cx, argv[0], &argv[0], eStringify, eStringify, arg0_holder)) {
        return false;
      }
      const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
      NonNull<mozilla::dom::TestInterface> arg1;
      if (argv[1].isObject()) {
        {
          nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(cx, &argv[1].toObject(), arg1);
          if (NS_FAILED(rv)) {
            ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestInterface");
            return false;
          }
        }
      } else {
        ThrowErrorMessage(cx, MSG_NOT_OBJECT);
        return false;
      }
      nsRefPtr<mozilla::dom::TestInterface> result;
      result = self->Overload1(arg0, arg1);
      if (!WrapNewBindingObject(cx, obj, result, vp)) {
        MOZ_ASSERT(JS_IsExceptionPending(cx));
        return false;
      }
      return true;
      break;
    }
    default: {
      return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.overload1");

      break;
    }
  }
  MOZ_NOT_REACHED("We have an always-returning default case");
  return false;
}


const JSJitInfo overload1_methodinfo = {
  (JSJitPropertyOp)overload1,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
overload2(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  unsigned argcount = NS_MIN(argc, 1u);
  switch (argcount) {
    case 0: {

      JS::Value* argv = JS_ARGV(cx, vp);

      const Dict arg0;
      if (!const_cast<Dict&>(arg0).Init(cx, obj, (0 < argc) ? argv[0] : JSVAL_NULL)) {
        return false;
      }
      self->Overload2(arg0);
      *vp = JSVAL_VOID;
      return true;
      break;
    }
    case 1: {
      JS::Value* argv_start = JS_ARGV(cx, vp);
      if (argv_start[0].isNullOrUndefined()) {
        const Dict arg0;
        if (!const_cast<Dict&>(arg0).Init(cx, obj, argv_start[0])) {
          return false;
        }
        self->Overload2(arg0);
        *vp = JSVAL_VOID;
        return true;
      }
      if (argv_start[0].isObject()) {
        do {
          NonNull<mozilla::dom::TestInterface> arg0;
          {
            nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(cx, &argv_start[0].toObject(), arg0);
            if (NS_FAILED(rv)) {
              break;
            }
          }
          self->Overload2(arg0);
          *vp = JSVAL_VOID;
          return true;
        } while (0);
        do {
          const Dict arg0;
          if (!IsConvertibleToDictionary(cx, &argv_start[0].toObject())) {
            break;
          }

          if (!const_cast<Dict&>(arg0).Init(cx, obj, argv_start[0])) {
            return false;
          }
          self->Overload2(arg0);
          *vp = JSVAL_VOID;
          return true;
        } while (0);
      }

      JS::Value* argv = JS_ARGV(cx, vp);

      FakeDependentString arg0_holder;
      const NonNull<nsAString> arg0;
      if (!ConvertJSValueToString(cx, argv[0], &argv[0], eStringify, eStringify, arg0_holder)) {
        return false;
      }
      const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
      self->Overload2(arg0);
      *vp = JSVAL_VOID;
      return true;
      break;
    }
    default: {
      return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.overload2");

      break;
    }
  }
  MOZ_NOT_REACHED("We have an always-returning default case");
  return false;
}


const JSJitInfo overload2_methodinfo = {
  (JSJitPropertyOp)overload2,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
overload3(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  unsigned argcount = NS_MIN(argc, 1u);
  switch (argcount) {
    case 1: {
      JS::Value* argv_start = JS_ARGV(cx, vp);
      if (argv_start[0].isObject()) {
        do {
          NonNull<mozilla::dom::TestInterface> arg0;
          {
            nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(cx, &argv_start[0].toObject(), arg0);
            if (NS_FAILED(rv)) {
              break;
            }
          }
          self->Overload3(arg0);
          *vp = JSVAL_VOID;
          return true;
        } while (0);
        do {
          OwningNonNull<TestCallback> arg0;
          if (JS_ObjectIsCallable(cx, &argv_start[0].toObject())) {
            bool inited;
            arg0 = new TestCallback(cx, obj, &argv_start[0].toObject(), &inited);
            if (!inited) {
              return false;
            }
          } else {
            break;
          }
          self->Overload3(arg0);
          *vp = JSVAL_VOID;
          return true;
        } while (0);
      }

      JS::Value* argv = JS_ARGV(cx, vp);

      FakeDependentString arg0_holder;
      const NonNull<nsAString> arg0;
      if (!ConvertJSValueToString(cx, argv[0], &argv[0], eStringify, eStringify, arg0_holder)) {
        return false;
      }
      const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
      self->Overload3(arg0);
      *vp = JSVAL_VOID;
      return true;
      break;
    }
    default: {
      return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.overload3");

      break;
    }
  }
  MOZ_NOT_REACHED("We have an always-returning default case");
  return false;
}


const JSJitInfo overload3_methodinfo = {
  (JSJitPropertyOp)overload3,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
overload4(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  unsigned argcount = NS_MIN(argc, 1u);
  switch (argcount) {
    case 1: {
      JS::Value* argv_start = JS_ARGV(cx, vp);
      if (argv_start[0].isObject()) {
        do {
          NonNull<mozilla::dom::TestInterface> arg0;
          {
            nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(cx, &argv_start[0].toObject(), arg0);
            if (NS_FAILED(rv)) {
              break;
            }
          }
          self->Overload4(arg0);
          *vp = JSVAL_VOID;
          return true;
        } while (0);
        do {
          OwningNonNull<mozilla::dom::TestCallbackInterface> arg0;
          if (!IsConvertibleToCallbackInterface(cx, &argv_start[0].toObject())) {
              break;
          }

          nsresult rv;
          XPCCallContext ccx(JS_CALLER, cx);
          if (!ccx.IsValid()) {
            rv = NS_ERROR_XPC_BAD_CONVERT_JS;
            break;
          }

          const nsIID& iid = NS_GET_IID(mozilla::dom::TestCallbackInterface);
          nsRefPtr<nsXPCWrappedJS> wrappedJS;
          rv = nsXPCWrappedJS::GetNewOrUsed(ccx, &argv_start[0].toObject(), iid,
                                            NULL, getter_AddRefs(wrappedJS));
          if (NS_FAILED(rv) || !wrappedJS) {
            break;
          }

          // Use a temp nsCOMPtr for the null-check, because arg0 might be
          // OwningNonNull, not an nsCOMPtr.
          nsCOMPtr<mozilla::dom::TestCallbackInterface> tmp = do_QueryObject(wrappedJS.get());
          if (!tmp) {
            break;
          }
          arg0 = tmp.forget();
          self->Overload4(arg0);
          *vp = JSVAL_VOID;
          return true;
        } while (0);
      }

      JS::Value* argv = JS_ARGV(cx, vp);

      FakeDependentString arg0_holder;
      const NonNull<nsAString> arg0;
      if (!ConvertJSValueToString(cx, argv[0], &argv[0], eStringify, eStringify, arg0_holder)) {
        return false;
      }
      const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
      self->Overload4(arg0);
      *vp = JSVAL_VOID;
      return true;
      break;
    }
    default: {
      return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.overload4");

      break;
    }
  }
  MOZ_NOT_REACHED("We have an always-returning default case");
  return false;
}


const JSJitInfo overload4_methodinfo = {
  (JSJitPropertyOp)overload4,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passVariadicThirdArg(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 2) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.passVariadicThirdArg");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eStringify, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  int32_t arg1;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[1], &arg1)) {
    return false;
  }
  const Sequence< OwningNonNull<mozilla::dom::TestInterface> > arg2;
  if (argc > 2) {
    Sequence< OwningNonNull<mozilla::dom::TestInterface> >& arr = const_cast< Sequence< OwningNonNull<mozilla::dom::TestInterface> >& >(arg2);
    if (!arr.SetCapacity(argc - 2)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t variadicArg = 2; variadicArg < argc; ++variadicArg) {
      OwningNonNull<mozilla::dom::TestInterface>& slot = *arr.AppendElement();
      if (argv[variadicArg].isObject()) {
        {
          nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(cx, &argv[variadicArg].toObject(), slot);
          if (NS_FAILED(rv)) {
            ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestInterface");
            return false;
          }
        }
      } else {
        ThrowErrorMessage(cx, MSG_NOT_OBJECT);
        return false;
      }
    }
  }
  self->PassVariadicThirdArg(arg0, arg1, arg2);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passVariadicThirdArg_methodinfo = {
  (JSJitPropertyOp)passVariadicThirdArg,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_attrWithLenientThis(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* vp)
{
  int32_t result;
  result = self->AttrWithLenientThis();
  *vp = INT_TO_JSVAL(int32_t(result));
  return true;
}

static bool
set_attrWithLenientThis(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* argv)
{
  int32_t arg0;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  self->SetAttrWithLenientThis(arg0);

  return true;
}


const JSJitInfo attrWithLenientThis_getterinfo = {
  (JSJitPropertyOp)get_attrWithLenientThis,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo attrWithLenientThis_setterinfo = {
  (JSJitPropertyOp)set_attrWithLenientThis,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_unforgeableAttr(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* vp)
{
  int32_t result;
  result = self->UnforgeableAttr();
  *vp = INT_TO_JSVAL(int32_t(result));
  return true;
}


const JSJitInfo unforgeableAttr_getterinfo = {
  (JSJitPropertyOp)get_unforgeableAttr,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_unforgeableAttr2(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* vp)
{
  int32_t result;
  result = self->UnforgeableAttr2();
  *vp = INT_TO_JSVAL(int32_t(result));
  return true;
}


const JSJitInfo unforgeableAttr2_getterinfo = {
  (JSJitPropertyOp)get_unforgeableAttr2,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

static bool
__stringifier(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{
  nsString result;
  self->Stringify(result);
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}


const JSJitInfo __stringifier_methodinfo = {
  (JSJitPropertyOp)__stringifier,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

static bool
passRenamedInterface(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.passRenamedInterface");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  NonNull<nsRenamedInterface> arg0;
  if (argv[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::TestRenamedInterface, nsRenamedInterface>(cx, &argv[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestRenamedInterface");
        return false;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassRenamedInterface(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passRenamedInterface_methodinfo = {
  (JSJitPropertyOp)passRenamedInterface,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_putForwardsAttr(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* vp)
{
  nsRefPtr<mozilla::dom::TestInterface> result;
  result = self->PutForwardsAttr();
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static bool
set_putForwardsAttr(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* argv)
{
  js::RootedValue v(cx);
  if (!JS_GetProperty(cx, obj, "putForwardsAttr", v.address())) {
    return false;
  }

  if (!v.isObject()) {
    return ThrowErrorMessage(cx, MSG_NOT_OBJECT);
  }

  return JS_SetProperty(cx, &v.toObject(), "writableByte", argv);
}


const JSJitInfo putForwardsAttr_getterinfo = {
  (JSJitPropertyOp)get_putForwardsAttr,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo putForwardsAttr_setterinfo = {
  (JSJitPropertyOp)set_putForwardsAttr,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_putForwardsAttr2(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* vp)
{
  nsRefPtr<mozilla::dom::TestInterface> result;
  result = self->PutForwardsAttr2();
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static bool
set_putForwardsAttr2(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* argv)
{
  js::RootedValue v(cx);
  if (!JS_GetProperty(cx, obj, "putForwardsAttr2", v.address())) {
    return false;
  }

  if (!v.isObject()) {
    return ThrowErrorMessage(cx, MSG_NOT_OBJECT);
  }

  return JS_SetProperty(cx, &v.toObject(), "writableByte", argv);
}


const JSJitInfo putForwardsAttr2_getterinfo = {
  (JSJitPropertyOp)get_putForwardsAttr2,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo putForwardsAttr2_setterinfo = {
  (JSJitPropertyOp)set_putForwardsAttr2,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_putForwardsAttr3(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* vp)
{
  nsRefPtr<mozilla::dom::TestInterface> result;
  result = self->PutForwardsAttr3();
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static bool
set_putForwardsAttr3(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* argv)
{
  js::RootedValue v(cx);
  if (!JS_GetProperty(cx, obj, "putForwardsAttr3", v.address())) {
    return false;
  }

  if (!v.isObject()) {
    return ThrowErrorMessage(cx, MSG_NOT_OBJECT);
  }

  return JS_SetProperty(cx, &v.toObject(), "writableByte", argv);
}


const JSJitInfo putForwardsAttr3_getterinfo = {
  (JSJitPropertyOp)get_putForwardsAttr3,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo putForwardsAttr3_setterinfo = {
  (JSJitPropertyOp)set_putForwardsAttr3,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
throwingMethod(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{
  ErrorResult rv;
  self->ThrowingMethod(rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "TestInterface", "throwingMethod");
  }
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo throwingMethod_methodinfo = {
  (JSJitPropertyOp)throwingMethod,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_throwingAttr(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* vp)
{
  ErrorResult rv;
  bool result;
  result = self->GetThrowingAttr(rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "TestInterface", "throwingAttr");
  }
  *vp = BOOLEAN_TO_JSVAL(result);
  return true;
}

static bool
set_throwingAttr(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* argv)
{
  bool arg0;
  if (!ValueToPrimitive<bool, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  ErrorResult rv;
  self->SetThrowingAttr(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "TestInterface", "throwingAttr");
  }

  return true;
}


const JSJitInfo throwingAttr_getterinfo = {
  (JSJitPropertyOp)get_throwingAttr,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo throwingAttr_setterinfo = {
  (JSJitPropertyOp)set_throwingAttr,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_throwingGetterAttr(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* vp)
{
  ErrorResult rv;
  bool result;
  result = self->GetThrowingGetterAttr(rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "TestInterface", "throwingGetterAttr");
  }
  *vp = BOOLEAN_TO_JSVAL(result);
  return true;
}

static bool
set_throwingGetterAttr(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* argv)
{
  bool arg0;
  if (!ValueToPrimitive<bool, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  self->SetThrowingGetterAttr(arg0);

  return true;
}


const JSJitInfo throwingGetterAttr_getterinfo = {
  (JSJitPropertyOp)get_throwingGetterAttr,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo throwingGetterAttr_setterinfo = {
  (JSJitPropertyOp)set_throwingGetterAttr,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_throwingSetterAttr(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* vp)
{
  bool result;
  result = self->ThrowingSetterAttr();
  *vp = BOOLEAN_TO_JSVAL(result);
  return true;
}

static bool
set_throwingSetterAttr(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* argv)
{
  bool arg0;
  if (!ValueToPrimitive<bool, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  ErrorResult rv;
  self->SetThrowingSetterAttr(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "TestInterface", "throwingSetterAttr");
  }

  return true;
}


const JSJitInfo throwingSetterAttr_getterinfo = {
  (JSJitPropertyOp)get_throwingSetterAttr,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo throwingSetterAttr_setterinfo = {
  (JSJitPropertyOp)set_throwingSetterAttr,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_diamondImplementedProperty(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* vp)
{
  int32_t result;
  result = self->DiamondImplementedProperty();
  *vp = INT_TO_JSVAL(int32_t(result));
  return true;
}


const JSJitInfo diamondImplementedProperty_getterinfo = {
  (JSJitPropertyOp)get_diamondImplementedProperty,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

static bool
implementedMethod(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{
  self->ImplementedMethod();
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo implementedMethod_methodinfo = {
  (JSJitPropertyOp)implementedMethod,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_implementedProperty(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* vp)
{
  bool result;
  result = self->ImplementedProperty();
  *vp = BOOLEAN_TO_JSVAL(result);
  return true;
}

static bool
set_implementedProperty(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* argv)
{
  bool arg0;
  if (!ValueToPrimitive<bool, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  self->SetImplementedProperty(arg0);

  return true;
}


const JSJitInfo implementedProperty_getterinfo = {
  (JSJitPropertyOp)get_implementedProperty,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo implementedProperty_setterinfo = {
  (JSJitPropertyOp)set_implementedProperty,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
implementedParentMethod(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{
  self->ImplementedParentMethod();
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo implementedParentMethod_methodinfo = {
  (JSJitPropertyOp)implementedParentMethod,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_implementedParentProperty(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* vp)
{
  bool result;
  result = self->ImplementedParentProperty();
  *vp = BOOLEAN_TO_JSVAL(result);
  return true;
}

static bool
set_implementedParentProperty(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* argv)
{
  bool arg0;
  if (!ValueToPrimitive<bool, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  self->SetImplementedParentProperty(arg0);

  return true;
}


const JSJitInfo implementedParentProperty_getterinfo = {
  (JSJitPropertyOp)get_implementedParentProperty,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo implementedParentProperty_setterinfo = {
  (JSJitPropertyOp)set_implementedParentProperty,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
indirectlyImplementedMethod(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, unsigned argc, JS::Value* vp)
{
  self->IndirectlyImplementedMethod();
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo indirectlyImplementedMethod_methodinfo = {
  (JSJitPropertyOp)indirectlyImplementedMethod,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Method,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_indirectlyImplementedProperty(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* vp)
{
  bool result;
  result = self->IndirectlyImplementedProperty();
  *vp = BOOLEAN_TO_JSVAL(result);
  return true;
}

static bool
set_indirectlyImplementedProperty(JSContext* cx, JSHandleObject obj, mozilla::dom::TestInterface* self, JS::Value* argv)
{
  bool arg0;
  if (!ValueToPrimitive<bool, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  self->SetIndirectlyImplementedProperty(arg0);

  return true;
}


const JSJitInfo indirectlyImplementedProperty_getterinfo = {
  (JSJitPropertyOp)get_indirectlyImplementedProperty,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo indirectlyImplementedProperty_setterinfo = {
  (JSJitPropertyOp)set_indirectlyImplementedProperty,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static JSBool
genericMethod(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  mozilla::dom::TestInterface* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(cx, obj, self);
    if (NS_FAILED(rv)) {
      return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestInterface");
    }
  }
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Method);
  JSJitMethodOp method = (JSJitMethodOp)info->op;
  return method(cx, obj, self, argc, vp);
}

static JSBool
genericGetter(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  mozilla::dom::TestInterface* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(cx, obj, self);
    if (NS_FAILED(rv)) {
      return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestInterface");
    }
  }
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Getter);
  JSJitPropertyOp getter = info->op;
  return getter(cx, obj, self, vp);
}

static JSBool
genericLenientGetter(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  mozilla::dom::TestInterface* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(cx, obj, self);
    if (NS_FAILED(rv)) {
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      JS_SET_RVAL(cx, vp, JS::UndefinedValue());
      return true;
    }
  }
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Getter);
  JSJitPropertyOp getter = info->op;
  return getter(cx, obj, self, vp);
}

static JSBool
genericSetter(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  mozilla::dom::TestInterface* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(cx, obj, self);
    if (NS_FAILED(rv)) {
      return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestInterface");
    }
  }
  if (argc == 0) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface attribute setter");
  }
  JS::Value* argv = JS_ARGV(cx, vp);
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Setter);
  JSJitPropertyOp setter = info->op;
  if (!setter(cx, obj, self, argv)) {
    return false;
  }
  *vp = JSVAL_VOID;
  return true;
}

static JSBool
genericLenientSetter(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  mozilla::dom::TestInterface* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(cx, obj, self);
    if (NS_FAILED(rv)) {
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      return true;
    }
  }
  if (argc == 0) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface attribute setter");
  }
  JS::Value* argv = JS_ARGV(cx, vp);
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Setter);
  JSJitPropertyOp setter = info->op;
  if (!setter(cx, obj, self, argv)) {
    return false;
  }
  *vp = JSVAL_VOID;
  return true;
}

static JSBool
_addProperty(JSContext* cx, JSHandleObject obj, JSHandleId id, JSMutableHandleValue vp)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::dom::TestInterface>::value), "Must be an nsISupports class");
  mozilla::dom::TestInterface* self = UnwrapDOMObject<mozilla::dom::TestInterface>(obj);
  nsContentUtils::PreserveWrapper(reinterpret_cast<nsISupports*>(self), self);
  return true;
}

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::dom::TestInterface>::value), "Must be an nsISupports class");
  mozilla::dom::TestInterface* self = UnwrapDOMObject<mozilla::dom::TestInterface>(obj);
  if (self) {
    ClearWrapper(self, self);
    XPCJSRuntime *rt = nsXPConnect::GetRuntimeInstance();
    if (rt) {
      rt->DeferredRelease(reinterpret_cast<nsISupports*>(self));
    } else {
      NS_RELEASE(self);
    }
  }
}

static JSFunctionSpec sStaticMethods_specs[] = {
  JS_FNINFO("staticMethod", staticMethod, nullptr, 1, JSPROP_ENUMERATE),
  JS_FS_END
};

static Prefable<JSFunctionSpec> sStaticMethods[] = {
  { true, &sStaticMethods_specs[0] },
  { false, NULL }
};

static jsid sStaticMethods_ids[2] = { JSID_VOID };

static JSPropertySpec sStaticAttributes_specs[] = {
  { "staticAttribute", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)get_staticAttribute, nullptr }, { (JSStrictPropertyOp)set_staticAttribute, nullptr }},
  { 0, 0, 0, JSOP_NULLWRAPPER, JSOP_NULLWRAPPER }
};

static Prefable<JSPropertySpec> sStaticAttributes[] = {
  { true, &sStaticAttributes_specs[0] },
  { false, NULL }
};

static jsid sStaticAttributes_ids[2] = { JSID_VOID };

static JSFunctionSpec sMethods_specs[] = {
  JS_FNINFO("passByte", genericMethod, &passByte_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("receiveByte", genericMethod, &receiveByte_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalByte", genericMethod, &passOptionalByte_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalByteWithDefault", genericMethod, &passOptionalByteWithDefault_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passNullableByte", genericMethod, &passNullableByte_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalNullableByte", genericMethod, &passOptionalNullableByte_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passVariadicByte", genericMethod, &passVariadicByte_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passShort", genericMethod, &passShort_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("receiveShort", genericMethod, &receiveShort_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalShort", genericMethod, &passOptionalShort_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalShortWithDefault", genericMethod, &passOptionalShortWithDefault_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passLong", genericMethod, &passLong_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("receiveLong", genericMethod, &receiveLong_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalLong", genericMethod, &passOptionalLong_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalLongWithDefault", genericMethod, &passOptionalLongWithDefault_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passLongLong", genericMethod, &passLongLong_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("receiveLongLong", genericMethod, &receiveLongLong_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalLongLong", genericMethod, &passOptionalLongLong_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalLongLongWithDefault", genericMethod, &passOptionalLongLongWithDefault_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOctet", genericMethod, &passOctet_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("receiveOctet", genericMethod, &receiveOctet_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalOctet", genericMethod, &passOptionalOctet_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalOctetWithDefault", genericMethod, &passOptionalOctetWithDefault_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passUnsignedShort", genericMethod, &passUnsignedShort_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("receiveUnsignedShort", genericMethod, &receiveUnsignedShort_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalUnsignedShort", genericMethod, &passOptionalUnsignedShort_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalUnsignedShortWithDefault", genericMethod, &passOptionalUnsignedShortWithDefault_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passUnsignedLong", genericMethod, &passUnsignedLong_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("receiveUnsignedLong", genericMethod, &receiveUnsignedLong_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalUnsignedLong", genericMethod, &passOptionalUnsignedLong_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalUnsignedLongWithDefault", genericMethod, &passOptionalUnsignedLongWithDefault_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passUnsignedLongLong", genericMethod, &passUnsignedLongLong_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("receiveUnsignedLongLong", genericMethod, &receiveUnsignedLongLong_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalUnsignedLongLong", genericMethod, &passOptionalUnsignedLongLong_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalUnsignedLongLongWithDefault", genericMethod, &passOptionalUnsignedLongLongWithDefault_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passFloat", genericMethod, &passFloat_methodinfo, 16, JSPROP_ENUMERATE),
  JS_FNINFO("passLenientFloat", genericMethod, &passLenientFloat_methodinfo, 16, JSPROP_ENUMERATE),
  JS_FNINFO("receiveSelf", genericMethod, &receiveSelf_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveNullableSelf", genericMethod, &receiveNullableSelf_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveWeakSelf", genericMethod, &receiveWeakSelf_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveWeakNullableSelf", genericMethod, &receiveWeakNullableSelf_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passSelf", genericMethod, &passSelf_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passSelf2", genericMethod, &passSelf2_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passNullableSelf", genericMethod, &passNullableSelf_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalSelf", genericMethod, &passOptionalSelf_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalNonNullSelf", genericMethod, &passOptionalNonNullSelf_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalSelfWithDefault", genericMethod, &passOptionalSelfWithDefault_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveNonWrapperCacheInterface", genericMethod, &receiveNonWrapperCacheInterface_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveNullableNonWrapperCacheInterface", genericMethod, &receiveNullableNonWrapperCacheInterface_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveNonWrapperCacheInterfaceSequence", genericMethod, &receiveNonWrapperCacheInterfaceSequence_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveNullableNonWrapperCacheInterfaceSequence", genericMethod, &receiveNullableNonWrapperCacheInterfaceSequence_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveNonWrapperCacheInterfaceNullableSequence", genericMethod, &receiveNonWrapperCacheInterfaceNullableSequence_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveNullableNonWrapperCacheInterfaceNullableSequence", genericMethod, &receiveNullableNonWrapperCacheInterfaceNullableSequence_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveOther", genericMethod, &receiveOther_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveNullableOther", genericMethod, &receiveNullableOther_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveWeakOther", genericMethod, &receiveWeakOther_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveWeakNullableOther", genericMethod, &receiveWeakNullableOther_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOther", genericMethod, &passOther_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passOther2", genericMethod, &passOther2_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passNullableOther", genericMethod, &passNullableOther_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalOther", genericMethod, &passOptionalOther_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalNonNullOther", genericMethod, &passOptionalNonNullOther_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalOtherWithDefault", genericMethod, &passOptionalOtherWithDefault_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveExternal", genericMethod, &receiveExternal_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveNullableExternal", genericMethod, &receiveNullableExternal_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveWeakExternal", genericMethod, &receiveWeakExternal_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveWeakNullableExternal", genericMethod, &receiveWeakNullableExternal_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passExternal", genericMethod, &passExternal_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passExternal2", genericMethod, &passExternal2_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passNullableExternal", genericMethod, &passNullableExternal_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalExternal", genericMethod, &passOptionalExternal_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalNonNullExternal", genericMethod, &passOptionalNonNullExternal_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalExternalWithDefault", genericMethod, &passOptionalExternalWithDefault_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveCallbackInterface", genericMethod, &receiveCallbackInterface_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveNullableCallbackInterface", genericMethod, &receiveNullableCallbackInterface_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveWeakCallbackInterface", genericMethod, &receiveWeakCallbackInterface_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveWeakNullableCallbackInterface", genericMethod, &receiveWeakNullableCallbackInterface_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passCallbackInterface", genericMethod, &passCallbackInterface_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passCallbackInterface2", genericMethod, &passCallbackInterface2_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passNullableCallbackInterface", genericMethod, &passNullableCallbackInterface_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalCallbackInterface", genericMethod, &passOptionalCallbackInterface_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalNonNullCallbackInterface", genericMethod, &passOptionalNonNullCallbackInterface_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalCallbackInterfaceWithDefault", genericMethod, &passOptionalCallbackInterfaceWithDefault_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveConsequentialInterface", genericMethod, &receiveConsequentialInterface_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passConsequentialInterface", genericMethod, &passConsequentialInterface_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("receiveSequence", genericMethod, &receiveSequence_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveNullableSequence", genericMethod, &receiveNullableSequence_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveSequenceOfNullableInts", genericMethod, &receiveSequenceOfNullableInts_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveNullableSequenceOfNullableInts", genericMethod, &receiveNullableSequenceOfNullableInts_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passSequence", genericMethod, &passSequence_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passNullableSequence", genericMethod, &passNullableSequence_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passSequenceOfNullableInts", genericMethod, &passSequenceOfNullableInts_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalSequenceOfNullableInts", genericMethod, &passOptionalSequenceOfNullableInts_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalNullableSequenceOfNullableInts", genericMethod, &passOptionalNullableSequenceOfNullableInts_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveCastableObjectSequence", genericMethod, &receiveCastableObjectSequence_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveCallbackObjectSequence", genericMethod, &receiveCallbackObjectSequence_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveNullableCastableObjectSequence", genericMethod, &receiveNullableCastableObjectSequence_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveNullableCallbackObjectSequence", genericMethod, &receiveNullableCallbackObjectSequence_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveCastableObjectNullableSequence", genericMethod, &receiveCastableObjectNullableSequence_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveNullableCastableObjectNullableSequence", genericMethod, &receiveNullableCastableObjectNullableSequence_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveWeakCastableObjectSequence", genericMethod, &receiveWeakCastableObjectSequence_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveWeakNullableCastableObjectSequence", genericMethod, &receiveWeakNullableCastableObjectSequence_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveWeakCastableObjectNullableSequence", genericMethod, &receiveWeakCastableObjectNullableSequence_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveWeakNullableCastableObjectNullableSequence", genericMethod, &receiveWeakNullableCastableObjectNullableSequence_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passCastableObjectSequence", genericMethod, &passCastableObjectSequence_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passNullableCastableObjectSequence", genericMethod, &passNullableCastableObjectSequence_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passCastableObjectNullableSequence", genericMethod, &passCastableObjectNullableSequence_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passNullableCastableObjectNullableSequence", genericMethod, &passNullableCastableObjectNullableSequence_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalSequence", genericMethod, &passOptionalSequence_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalNullableSequence", genericMethod, &passOptionalNullableSequence_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalNullableSequenceWithDefaultValue", genericMethod, &passOptionalNullableSequenceWithDefaultValue_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalObjectSequence", genericMethod, &passOptionalObjectSequence_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passExternalInterfaceSequence", genericMethod, &passExternalInterfaceSequence_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passNullableExternalInterfaceSequence", genericMethod, &passNullableExternalInterfaceSequence_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("receiveStringSequence", genericMethod, &receiveStringSequence_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passStringSequence", genericMethod, &passStringSequence_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("receiveAnySequence", genericMethod, &receiveAnySequence_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveNullableAnySequence", genericMethod, &receiveNullableAnySequence_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passArrayBuffer", genericMethod, &passArrayBuffer_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passNullableArrayBuffer", genericMethod, &passNullableArrayBuffer_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalArrayBuffer", genericMethod, &passOptionalArrayBuffer_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalNullableArrayBuffer", genericMethod, &passOptionalNullableArrayBuffer_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalNullableArrayBufferWithDefaultValue", genericMethod, &passOptionalNullableArrayBufferWithDefaultValue_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passArrayBufferView", genericMethod, &passArrayBufferView_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passInt8Array", genericMethod, &passInt8Array_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passInt16Array", genericMethod, &passInt16Array_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passInt32Array", genericMethod, &passInt32Array_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passUint8Array", genericMethod, &passUint8Array_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passUint16Array", genericMethod, &passUint16Array_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passUint32Array", genericMethod, &passUint32Array_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passUint8ClampedArray", genericMethod, &passUint8ClampedArray_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passFloat32Array", genericMethod, &passFloat32Array_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passFloat64Array", genericMethod, &passFloat64Array_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("receiveUint8Array", genericMethod, &receiveUint8Array_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passString", genericMethod, &passString_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passNullableString", genericMethod, &passNullableString_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalString", genericMethod, &passOptionalString_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalStringWithDefaultValue", genericMethod, &passOptionalStringWithDefaultValue_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalNullableString", genericMethod, &passOptionalNullableString_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalNullableStringWithDefaultValue", genericMethod, &passOptionalNullableStringWithDefaultValue_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passVariadicString", genericMethod, &passVariadicString_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passEnum", genericMethod, &passEnum_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalEnum", genericMethod, &passOptionalEnum_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passEnumWithDefault", genericMethod, &passEnumWithDefault_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveEnum", genericMethod, &receiveEnum_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passCallback", genericMethod, &passCallback_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passNullableCallback", genericMethod, &passNullableCallback_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalCallback", genericMethod, &passOptionalCallback_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalNullableCallback", genericMethod, &passOptionalNullableCallback_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalNullableCallbackWithDefaultValue", genericMethod, &passOptionalNullableCallbackWithDefaultValue_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveCallback", genericMethod, &receiveCallback_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveNullableCallback", genericMethod, &receiveNullableCallback_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passNullableTreatAsNullCallback", genericMethod, &passNullableTreatAsNullCallback_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalNullableTreatAsNullCallback", genericMethod, &passOptionalNullableTreatAsNullCallback_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalNullableTreatAsNullCallbackWithDefaultValue", genericMethod, &passOptionalNullableTreatAsNullCallbackWithDefaultValue_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passAny", genericMethod, &passAny_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalAny", genericMethod, &passOptionalAny_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passAnyDefaultNull", genericMethod, &passAnyDefaultNull_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveAny", genericMethod, &receiveAny_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passObject", genericMethod, &passObject_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passNullableObject", genericMethod, &passNullableObject_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalObject", genericMethod, &passOptionalObject_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalNullableObject", genericMethod, &passOptionalNullableObject_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalNullableObjectWithDefaultValue", genericMethod, &passOptionalNullableObjectWithDefaultValue_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveObject", genericMethod, &receiveObject_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveNullableObject", genericMethod, &receiveNullableObject_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passUnion", genericMethod, &passUnion_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passUnionWithNullable", genericMethod, &passUnionWithNullable_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passNullableUnion", genericMethod, &passNullableUnion_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalUnion", genericMethod, &passOptionalUnion_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalNullableUnion", genericMethod, &passOptionalNullableUnion_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalNullableUnionWithDefaultValue", genericMethod, &passOptionalNullableUnionWithDefaultValue_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passUnionWithArrayBuffer", genericMethod, &passUnionWithArrayBuffer_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passUnionWithString", genericMethod, &passUnionWithString_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passUnionWithObject", genericMethod, &passUnionWithObject_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("methodRenamedFrom", genericMethod, &methodRenamedFrom_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passDictionary", genericMethod, &passDictionary_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveDictionary", genericMethod, &receiveDictionary_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOtherDictionary", genericMethod, &passOtherDictionary_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passSequenceOfDictionaries", genericMethod, &passSequenceOfDictionaries_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passDictionaryOrLong", genericMethod, &passDictionaryOrLong_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passDictContainingDict", genericMethod, &passDictContainingDict_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passDictContainingSequence", genericMethod, &passDictContainingSequence_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveDictContainingSequence", genericMethod, &receiveDictContainingSequence_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("dontEnforceRangeOrClamp", genericMethod, &dontEnforceRangeOrClamp_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("doEnforceRange", genericMethod, &doEnforceRange_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("doClamp", genericMethod, &doClamp_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("exerciseTypedefInterfaces1", genericMethod, &exerciseTypedefInterfaces1_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("exerciseTypedefInterfaces2", genericMethod, &exerciseTypedefInterfaces2_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("exerciseTypedefInterfaces3", genericMethod, &exerciseTypedefInterfaces3_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("overload1", genericMethod, &overload1_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("overload2", genericMethod, &overload2_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("overload3", genericMethod, &overload3_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("overload4", genericMethod, &overload4_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passVariadicThirdArg", genericMethod, &passVariadicThirdArg_methodinfo, 2, JSPROP_ENUMERATE),
  JS_FNINFO("passRenamedInterface", genericMethod, &passRenamedInterface_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("throwingMethod", genericMethod, &throwingMethod_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("implementedMethod", genericMethod, &implementedMethod_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("implementedParentMethod", genericMethod, &implementedParentMethod_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("indirectlyImplementedMethod", genericMethod, &indirectlyImplementedMethod_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("toString", genericMethod, &__stringifier_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FS_END
};

static Prefable<JSFunctionSpec> sMethods[] = {
  { true, &sMethods_specs[0] },
  { false, NULL }
};

static jsid sMethods_ids[202] = { JSID_VOID };

static JSFunctionSpec sChromeMethods_specs[] = {
  JS_FNINFO("QueryInterface", QueryInterface, nullptr, 1, 0),
  JS_FS_END
};

static Prefable<JSFunctionSpec> sChromeMethods[] = {
  { true, &sChromeMethods_specs[0] },
  { false, NULL }
};

static jsid sChromeMethods_ids[2] = { JSID_VOID };

static JSPropertySpec sAttributes_specs[] = {
  { "readonlyByte", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &readonlyByte_getterinfo }, JSOP_NULLWRAPPER},
  { "writableByte", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &writableByte_getterinfo }, { (JSStrictPropertyOp)genericSetter, &writableByte_setterinfo }},
  { "readonlyShort", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &readonlyShort_getterinfo }, JSOP_NULLWRAPPER},
  { "writableShort", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &writableShort_getterinfo }, { (JSStrictPropertyOp)genericSetter, &writableShort_setterinfo }},
  { "readonlyLong", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &readonlyLong_getterinfo }, JSOP_NULLWRAPPER},
  { "writableLong", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &writableLong_getterinfo }, { (JSStrictPropertyOp)genericSetter, &writableLong_setterinfo }},
  { "readonlyLongLong", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &readonlyLongLong_getterinfo }, JSOP_NULLWRAPPER},
  { "writableLongLong", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &writableLongLong_getterinfo }, { (JSStrictPropertyOp)genericSetter, &writableLongLong_setterinfo }},
  { "readonlyOctet", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &readonlyOctet_getterinfo }, JSOP_NULLWRAPPER},
  { "writableOctet", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &writableOctet_getterinfo }, { (JSStrictPropertyOp)genericSetter, &writableOctet_setterinfo }},
  { "readonlyUnsignedShort", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &readonlyUnsignedShort_getterinfo }, JSOP_NULLWRAPPER},
  { "writableUnsignedShort", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &writableUnsignedShort_getterinfo }, { (JSStrictPropertyOp)genericSetter, &writableUnsignedShort_setterinfo }},
  { "readonlyUnsignedLong", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &readonlyUnsignedLong_getterinfo }, JSOP_NULLWRAPPER},
  { "writableUnsignedLong", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &writableUnsignedLong_getterinfo }, { (JSStrictPropertyOp)genericSetter, &writableUnsignedLong_setterinfo }},
  { "readonlyUnsignedLongLong", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &readonlyUnsignedLongLong_getterinfo }, JSOP_NULLWRAPPER},
  { "writableUnsignedLongLong", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &writableUnsignedLongLong_getterinfo }, { (JSStrictPropertyOp)genericSetter, &writableUnsignedLongLong_setterinfo }},
  { "writableFloat", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &writableFloat_getterinfo }, { (JSStrictPropertyOp)genericSetter, &writableFloat_setterinfo }},
  { "writableUnrestrictedFloat", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &writableUnrestrictedFloat_getterinfo }, { (JSStrictPropertyOp)genericSetter, &writableUnrestrictedFloat_setterinfo }},
  { "writableNullableFloat", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &writableNullableFloat_getterinfo }, { (JSStrictPropertyOp)genericSetter, &writableNullableFloat_setterinfo }},
  { "writableNullableUnrestrictedFloat", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &writableNullableUnrestrictedFloat_getterinfo }, { (JSStrictPropertyOp)genericSetter, &writableNullableUnrestrictedFloat_setterinfo }},
  { "writableDouble", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &writableDouble_getterinfo }, { (JSStrictPropertyOp)genericSetter, &writableDouble_setterinfo }},
  { "writableUnrestrictedDouble", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &writableUnrestrictedDouble_getterinfo }, { (JSStrictPropertyOp)genericSetter, &writableUnrestrictedDouble_setterinfo }},
  { "writableNullableDouble", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &writableNullableDouble_getterinfo }, { (JSStrictPropertyOp)genericSetter, &writableNullableDouble_setterinfo }},
  { "writableNullableUnrestrictedDouble", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &writableNullableUnrestrictedDouble_getterinfo }, { (JSStrictPropertyOp)genericSetter, &writableNullableUnrestrictedDouble_setterinfo }},
  { "lenientFloatAttr", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &lenientFloatAttr_getterinfo }, { (JSStrictPropertyOp)genericSetter, &lenientFloatAttr_setterinfo }},
  { "lenientDoubleAttr", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &lenientDoubleAttr_getterinfo }, { (JSStrictPropertyOp)genericSetter, &lenientDoubleAttr_setterinfo }},
  { "nonNullSelf", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &nonNullSelf_getterinfo }, { (JSStrictPropertyOp)genericSetter, &nonNullSelf_setterinfo }},
  { "nullableSelf", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &nullableSelf_getterinfo }, { (JSStrictPropertyOp)genericSetter, &nullableSelf_setterinfo }},
  { "nonNullOther", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &nonNullOther_getterinfo }, { (JSStrictPropertyOp)genericSetter, &nonNullOther_setterinfo }},
  { "nullableOther", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &nullableOther_getterinfo }, { (JSStrictPropertyOp)genericSetter, &nullableOther_setterinfo }},
  { "nonNullExternal", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &nonNullExternal_getterinfo }, { (JSStrictPropertyOp)genericSetter, &nonNullExternal_setterinfo }},
  { "nullableExternal", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &nullableExternal_getterinfo }, { (JSStrictPropertyOp)genericSetter, &nullableExternal_setterinfo }},
  { "nonNullCallbackInterface", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &nonNullCallbackInterface_getterinfo }, { (JSStrictPropertyOp)genericSetter, &nonNullCallbackInterface_setterinfo }},
  { "nullableCallbackInterface", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &nullableCallbackInterface_getterinfo }, { (JSStrictPropertyOp)genericSetter, &nullableCallbackInterface_setterinfo }},
  { "enumAttribute", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &enumAttribute_getterinfo }, { (JSStrictPropertyOp)genericSetter, &enumAttribute_setterinfo }},
  { "readonlyEnumAttribute", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &readonlyEnumAttribute_getterinfo }, JSOP_NULLWRAPPER},
  { "treatAsNullCallback", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &treatAsNullCallback_getterinfo }, { (JSStrictPropertyOp)genericSetter, &treatAsNullCallback_setterinfo }},
  { "nullableTreatAsNullCallback", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &nullableTreatAsNullCallback_getterinfo }, { (JSStrictPropertyOp)genericSetter, &nullableTreatAsNullCallback_setterinfo }},
  { "attributeGetterRenamedFrom", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &attributeGetterRenamedFrom_getterinfo }, JSOP_NULLWRAPPER},
  { "attributeRenamedFrom", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &attributeRenamedFrom_getterinfo }, { (JSStrictPropertyOp)genericSetter, &attributeRenamedFrom_setterinfo }},
  { "attrWithLenientThis", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericLenientGetter, &attrWithLenientThis_getterinfo }, { (JSStrictPropertyOp)genericLenientSetter, &attrWithLenientThis_setterinfo }},
  { "putForwardsAttr", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &putForwardsAttr_getterinfo }, { (JSStrictPropertyOp)genericSetter, &putForwardsAttr_setterinfo }},
  { "putForwardsAttr2", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericLenientGetter, &putForwardsAttr2_getterinfo }, { (JSStrictPropertyOp)genericLenientSetter, &putForwardsAttr2_setterinfo }},
  { "throwingAttr", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &throwingAttr_getterinfo }, { (JSStrictPropertyOp)genericSetter, &throwingAttr_setterinfo }},
  { "throwingGetterAttr", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &throwingGetterAttr_getterinfo }, { (JSStrictPropertyOp)genericSetter, &throwingGetterAttr_setterinfo }},
  { "throwingSetterAttr", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &throwingSetterAttr_getterinfo }, { (JSStrictPropertyOp)genericSetter, &throwingSetterAttr_setterinfo }},
  { "diamondImplementedProperty", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &diamondImplementedProperty_getterinfo }, JSOP_NULLWRAPPER},
  { "implementedProperty", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &implementedProperty_getterinfo }, { (JSStrictPropertyOp)genericSetter, &implementedProperty_setterinfo }},
  { "implementedParentProperty", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &implementedParentProperty_getterinfo }, { (JSStrictPropertyOp)genericSetter, &implementedParentProperty_setterinfo }},
  { "indirectlyImplementedProperty", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &indirectlyImplementedProperty_getterinfo }, { (JSStrictPropertyOp)genericSetter, &indirectlyImplementedProperty_setterinfo }},
  { 0, 0, 0, JSOP_NULLWRAPPER, JSOP_NULLWRAPPER }
};

static Prefable<JSPropertySpec> sAttributes[] = {
  { true, &sAttributes_specs[0] },
  { false, NULL }
};

static jsid sAttributes_ids[51] = { JSID_VOID };

static JSPropertySpec sChromeAttributes_specs[] = {
  { "putForwardsAttr3", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &putForwardsAttr3_getterinfo }, { (JSStrictPropertyOp)genericSetter, &putForwardsAttr3_setterinfo }},
  { 0, 0, 0, JSOP_NULLWRAPPER, JSOP_NULLWRAPPER }
};

static Prefable<JSPropertySpec> sChromeAttributes[] = {
  { true, &sChromeAttributes_specs[0] },
  { false, NULL }
};

static jsid sChromeAttributes_ids[2] = { JSID_VOID };

static JSPropertySpec sUnforgeableAttributes_specs[] = {
  { "unforgeableAttr", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS | JSPROP_PERMANENT, { (JSPropertyOp)genericGetter, &unforgeableAttr_getterinfo }, JSOP_NULLWRAPPER},
  { 0, 0, 0, JSOP_NULLWRAPPER, JSOP_NULLWRAPPER }
};

static Prefable<JSPropertySpec> sUnforgeableAttributes[] = {
  { true, &sUnforgeableAttributes_specs[0] },
  { false, NULL }
};

static jsid sUnforgeableAttributes_ids[2] = { JSID_VOID };

static JSPropertySpec sChromeUnforgeableAttributes_specs[] = {
  { "unforgeableAttr2", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS | JSPROP_PERMANENT, { (JSPropertyOp)genericGetter, &unforgeableAttr2_getterinfo }, JSOP_NULLWRAPPER},
  { 0, 0, 0, JSOP_NULLWRAPPER, JSOP_NULLWRAPPER }
};

static Prefable<JSPropertySpec> sChromeUnforgeableAttributes[] = {
  { true, &sChromeUnforgeableAttributes_specs[0] },
  { false, NULL }
};

static jsid sChromeUnforgeableAttributes_ids[2] = { JSID_VOID };

static ConstantSpec sConstants_specs[] = {
  { "myLongConstant", INT_TO_JSVAL(5) },
  { "implementedConstant", INT_TO_JSVAL(5) },
  { "implementedParentConstant", INT_TO_JSVAL(8) },
  { "indirectlyImplementedConstant", INT_TO_JSVAL(9) },
  { 0, JSVAL_VOID }
};

static Prefable<ConstantSpec> sConstants[] = {
  { true, &sConstants_specs[0] },
  { false, NULL }
};

static jsid sConstants_ids[5] = { JSID_VOID };


static const NativeProperties sNativeProperties = {
  sStaticMethods, sStaticMethods_ids, sStaticMethods_specs,
  sStaticAttributes, sStaticAttributes_ids, sStaticAttributes_specs,
  sMethods, sMethods_ids, sMethods_specs,
  sAttributes, sAttributes_ids, sAttributes_specs,
  sUnforgeableAttributes, sUnforgeableAttributes_ids, sUnforgeableAttributes_specs,
  sConstants, sConstants_ids, sConstants_specs
};

static const NativeProperties sChromeOnlyNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sChromeMethods, sChromeMethods_ids, sChromeMethods_specs,
  sChromeAttributes, sChromeAttributes_ids, sChromeAttributes_specs,
  sChromeUnforgeableAttributes, sChromeUnforgeableAttributes_ids, sChromeUnforgeableAttributes_specs,
  nullptr, nullptr, nullptr
};
const NativePropertyHooks sNativePropertyHooks = {
  nullptr,
  nullptr,
  { &sNativeProperties, &sChromeOnlyNativeProperties },
  prototypes::id::TestInterface,
  constructors::id::TestInterface,
  NULL
};

static JSBool
_constructor(JSContext* cx, unsigned argc, JS::Value* vp)
{

  JSObject* obj = JS_GetGlobalForObject(cx, JSVAL_TO_OBJECT(JS_CALLEE(cx, vp)));

  nsISupports* global;
  xpc_qsSelfRef globalRef;
  {
    nsresult rv;
    JS::Value val = OBJECT_TO_JSVAL(obj);
    rv = xpc_qsUnwrapArg<nsISupports>(cx, val, &global, &globalRef.ptr, &val);
    if (NS_FAILED(rv)) {
      return ThrowErrorMessage(cx, MSG_GLOBAL_NOT_NATIVE);
    }
  }

  unsigned argcount = NS_MIN(argc, 2u);
  switch (argcount) {
    case 0: {
      ErrorResult rv;
      nsRefPtr<mozilla::dom::TestInterface> result;
      result = mozilla::dom::TestInterface::Constructor(global, rv);
      if (rv.Failed()) {
        return ThrowMethodFailedWithDetails<true>(cx, rv, "TestInterface", "constructor");
      }
      if (!WrapNewBindingObject(cx, obj, result, vp)) {
        MOZ_ASSERT(JS_IsExceptionPending(cx));
        return false;
      }
      return true;
      break;
    }
    case 1: {
      JS::Value* argv_start = JS_ARGV(cx, vp);
      if (argv_start[0].isNullOrUndefined()) {
        mozilla::dom::TestInterface* arg0;
        arg0 = NULL;
        ErrorResult rv;
        nsRefPtr<mozilla::dom::TestInterface> result;
        result = mozilla::dom::TestInterface::Constructor(global, arg0, rv);
        if (rv.Failed()) {
          return ThrowMethodFailedWithDetails<true>(cx, rv, "TestInterface", "constructor");
        }
        if (!WrapNewBindingObject(cx, obj, result, vp)) {
          MOZ_ASSERT(JS_IsExceptionPending(cx));
          return false;
        }
        return true;
      }
      if (argv_start[0].isObject()) {
        do {
          mozilla::dom::TestInterface* arg0;
          {
            nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(cx, &argv_start[0].toObject(), arg0);
            if (NS_FAILED(rv)) {
              break;
            }
          }
          ErrorResult rv;
          nsRefPtr<mozilla::dom::TestInterface> result;
          result = mozilla::dom::TestInterface::Constructor(global, arg0, rv);
          if (rv.Failed()) {
            return ThrowMethodFailedWithDetails<true>(cx, rv, "TestInterface", "constructor");
          }
          if (!WrapNewBindingObject(cx, obj, result, vp)) {
            MOZ_ASSERT(JS_IsExceptionPending(cx));
            return false;
          }
          return true;
        } while (0);
        do {
          nsRefPtr<mozilla::dom::TestNonCastableInterface> arg0_holder;
          NonNull<mozilla::dom::TestNonCastableInterface> arg0;
          jsval tmpVal = argv_start[0];
          mozilla::dom::TestNonCastableInterface* tmp;
          if (NS_FAILED(xpc_qsUnwrapArg<mozilla::dom::TestNonCastableInterface>(cx, argv_start[0], &tmp, static_cast<mozilla::dom::TestNonCastableInterface**>(getter_AddRefs(arg0_holder)), &tmpVal))) {
            break;
          }
          MOZ_ASSERT(tmp);
          arg0 = tmp;
          ErrorResult rv;
          nsRefPtr<mozilla::dom::TestInterface> result;
          result = mozilla::dom::TestInterface::Constructor(global, arg0, rv);
          if (rv.Failed()) {
            return ThrowMethodFailedWithDetails<true>(cx, rv, "TestInterface", "constructor");
          }
          if (!WrapNewBindingObject(cx, obj, result, vp)) {
            MOZ_ASSERT(JS_IsExceptionPending(cx));
            return false;
          }
          return true;
        } while (0);
      }

      JS::Value* argv = JS_ARGV(cx, vp);

      FakeDependentString arg0_holder;
      const NonNull<nsAString> arg0;
      if (!ConvertJSValueToString(cx, argv[0], &argv[0], eStringify, eStringify, arg0_holder)) {
        return false;
      }
      const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
      ErrorResult rv;
      nsRefPtr<mozilla::dom::TestInterface> result;
      result = mozilla::dom::TestInterface::Constructor(global, arg0, rv);
      if (rv.Failed()) {
        return ThrowMethodFailedWithDetails<true>(cx, rv, "TestInterface", "constructor");
      }
      if (!WrapNewBindingObject(cx, obj, result, vp)) {
        MOZ_ASSERT(JS_IsExceptionPending(cx));
        return false;
      }
      return true;
      break;
    }
    case 2: {

      JS::Value* argv = JS_ARGV(cx, vp);

      uint32_t arg0;
      if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[0], &arg0)) {
        return false;
      }
      const Nullable<bool> arg1;
      if (argv[1].isNullOrUndefined()) {
        const_cast< Nullable<bool>& >(arg1).SetNull();
      } else if (!ValueToPrimitive<bool, eDefault>(cx, argv[1], &const_cast< Nullable<bool>& >(arg1).SetValue())) {
        return false;
      }
      ErrorResult rv;
      nsRefPtr<mozilla::dom::TestInterface> result;
      result = mozilla::dom::TestInterface::Constructor(global, arg0, arg1, rv);
      if (rv.Failed()) {
        return ThrowMethodFailedWithDetails<true>(cx, rv, "TestInterface", "constructor");
      }
      if (!WrapNewBindingObject(cx, obj, result, vp)) {
        MOZ_ASSERT(JS_IsExceptionPending(cx));
        return false;
      }
      return true;
      break;
    }
    default: {
      return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestInterface.constructor");

      break;
    }
  }
  MOZ_NOT_REACHED("We have an always-returning default case");
  return false;
}

JSNativeHolder _constructor_holder = {
  _constructor,
  &sNativePropertyHooks
};

static DOMIfaceAndProtoJSClass PrototypeClass = {
  {
    "TestInterfacePrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(2),
    JS_PropertyStub,       /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    nullptr,               /* finalize */
    nullptr,               /* checkAccess */
    nullptr,               /* call */
    nullptr,               /* hasInstance */
    nullptr,               /* construct */
    nullptr,               /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  eInterfacePrototype,
  &sNativePropertyHooks
};

void
CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray)
{
  JSObject* parentProto = JS_GetObjectPrototype(aCx, aGlobal);
  if (!parentProto) {
    return;
  }


  if (sStaticMethods_ids[0] == JSID_VOID &&
      (!InitIds(aCx, sStaticMethods, sStaticMethods_ids) ||
       !InitIds(aCx, sStaticAttributes, sStaticAttributes_ids) ||
       !InitIds(aCx, sChromeMethods, sChromeMethods_ids) ||
       !InitIds(aCx, sMethods, sMethods_ids) ||
       !InitIds(aCx, sChromeAttributes, sChromeAttributes_ids) ||
       !InitIds(aCx, sAttributes, sAttributes_ids) ||
       !InitIds(aCx, sChromeUnforgeableAttributes, sChromeUnforgeableAttributes_ids) ||
       !InitIds(aCx, sUnforgeableAttributes, sUnforgeableAttributes_ids) ||
       !InitIds(aCx, sConstants, sConstants_ids))) {
    sStaticMethods_ids[0] = JSID_VOID;
    return;
  }

  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &PrototypeClass.mBase, &protoAndIfaceArray[prototypes::id::TestInterface],
                              nullptr, &_constructor_holder, 0, &protoAndIfaceArray[constructors::id::TestInterface],
                              &Class.mClass,
                              &sNativeProperties,
                              xpc::AccessCheck::isChrome(aGlobal) ? &sChromeOnlyNativeProperties : nullptr,
                              "TestInterface");
}

JSObject*
DefineDOMInterface(JSContext* aCx, JSObject* aGlobal, bool* aEnabled)
{

  *aEnabled = true;
  return GetConstructorObject(aCx, aGlobal);
}


DOMJSClass Class = {
  { "TestInterface",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(3),
    _addProperty, /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    _finalize, /* finalize */
    NULL,                  /* checkAccess */
    NULL,                  /* call */
    NULL,                  /* hasInstance */
    NULL,                  /* construct */
    NULL, /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  {
    { prototypes::id::TestInterface, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
    true,
    &sNativePropertyHooks,
    GetParentObject<mozilla::dom::TestInterface>::Get,
    GetProtoObject,
    nullptr
  }
};

JSObject*
Wrap(JSContext* aCx, JSObject* aScope, mozilla::dom::TestInterface* aObject, nsWrapperCache* aCache, bool* aTriedToWrap)
{
  MOZ_ASSERT(static_cast<mozilla::dom::TestInterface*>(aObject) ==
             reinterpret_cast<mozilla::dom::TestInterface*>(aObject));

  *aTriedToWrap = true;

  JSObject* parent = WrapNativeParent(aCx, aScope, aObject->GetParentObject());
  if (!parent) {
    return NULL;
  }

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.  Scope so we don't
  // collide with the "obj" we declare in CreateBindingJSObject.
  {
    JSObject* obj = aCache->GetWrapper();
    if (obj) {
      return obj;
    }
  }

  JSAutoCompartment ac(aCx, parent);
  JSObject* global = JS_GetGlobalForObject(aCx, parent);

  JSObject* proto = GetProtoObject(aCx, global);
  if (!proto) {
    return NULL;
  }

  JSObject* obj = JS_NewObject(aCx, &Class.mBase, proto, parent);
  if (!obj) {
    return NULL;
  }

  js::SetReservedSlot(obj, DOM_OBJECT_SLOT, PRIVATE_TO_JSVAL(aObject));
  NS_ADDREF(aObject);


  // Important: do unforgeable property setup after we have handed
  // over ownership of the C++ object to obj as needed, so that if
  // we fail and it ends up GCed it won't have problems in the
  // finalizer trying to drop its ownership of the C++ object.
  if (!DefineUnforgeableAttributes(aCx, obj, sUnforgeableAttributes)) {
    return nullptr;
  }
  if (xpc::AccessCheck::isChrome(global)) {
    if (!DefineUnforgeableAttributes(aCx, obj, sChromeUnforgeableAttributes)) {
      return nullptr;
    }
  }

  aCache->SetWrapper(obj);

  return obj;
}

} // namespace TestInterfaceBinding



namespace TestNamedDeleterInterfaceBinding {

static JSFunctionSpec sChromeMethods_specs[] = {
  JS_FNINFO("QueryInterface", QueryInterface, nullptr, 1, 0),
  JS_FS_END
};

static Prefable<JSFunctionSpec> sChromeMethods[] = {
  { true, &sChromeMethods_specs[0] },
  { false, NULL }
};

static jsid sChromeMethods_ids[2] = { JSID_VOID };


static const NativeProperties sChromeOnlyNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sChromeMethods, sChromeMethods_ids, sChromeMethods_specs,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr
};
const NativePropertyHooks sNativePropertyHooks = {
  ResolveOwnProperty,
  EnumerateOwnProperties,
  { nullptr, &sChromeOnlyNativeProperties },
  prototypes::id::TestNamedDeleterInterface,
  constructors::id::TestNamedDeleterInterface,
  NULL
};

JSNativeHolder _constructor_holder = {
  ThrowingConstructor,
  &sNativePropertyHooks
};

static DOMIfaceAndProtoJSClass PrototypeClass = {
  {
    "TestNamedDeleterInterfacePrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(2),
    JS_PropertyStub,       /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    nullptr,               /* finalize */
    nullptr,               /* checkAccess */
    nullptr,               /* call */
    nullptr,               /* hasInstance */
    nullptr,               /* construct */
    nullptr,               /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  eInterfacePrototype,
  &sNativePropertyHooks
};

void
CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray)
{
  JSObject* parentProto = JS_GetObjectPrototype(aCx, aGlobal);
  if (!parentProto) {
    return;
  }


  if (sChromeMethods_ids[0] == JSID_VOID &&
      !InitIds(aCx, sChromeMethods, sChromeMethods_ids)) {
    sChromeMethods_ids[0] = JSID_VOID;
    return;
  }

  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &PrototypeClass.mBase, &protoAndIfaceArray[prototypes::id::TestNamedDeleterInterface],
                              nullptr, &_constructor_holder, 0, &protoAndIfaceArray[constructors::id::TestNamedDeleterInterface],
                              &Class,
                              nullptr,
                              xpc::AccessCheck::isChrome(aGlobal) ? &sChromeOnlyNativeProperties : nullptr,
                              "TestNamedDeleterInterface");
}

bool
ResolveOwnProperty(JSContext* cx, JSObject* wrapper, JSObject* obj, jsid id, JSPropertyDescriptor* desc, unsigned flags)
{
  // We rely on getOwnPropertyDescriptor not shadowing prototype properties by named
  // properties. If that changes we'll need to filter here.
  return js::GetProxyHandler(obj)->getOwnPropertyDescriptor(cx, wrapper, id, desc, flags);

}

bool
EnumerateOwnProperties(JSContext* cx, JSObject* wrapper, JSObject* obj, JS::AutoIdVector& props)
{
  // We rely on getOwnPropertyNames not shadowing prototype properties by named
  // properties. If that changes we'll need to filter here.
  return js::GetProxyHandler(obj)->getOwnPropertyNames(cx, wrapper, props);

}

JSObject*
DefineDOMInterface(JSContext* aCx, JSObject* aGlobal, bool* aEnabled)
{

  *aEnabled = true;
  return GetConstructorObject(aCx, aGlobal);
}

MOZ_ALWAYS_INLINE bool
IsProxy(JSObject* obj)
{
  return js::IsProxy(obj) && js::GetProxyHandler(obj) == DOMProxyHandler::getInstance();
}

MOZ_ALWAYS_INLINE mozilla::dom::TestNamedDeleterInterface*
UnwrapProxy(JSObject* obj)
{
  if (xpc::WrapperFactory::IsXrayWrapper(obj)) {
    obj = js::UnwrapObject(obj);
  }
  MOZ_ASSERT(IsProxy(obj));
  return static_cast<mozilla::dom::TestNamedDeleterInterface*>(js::GetProxyPrivate(obj).toPrivate());
}


const DOMClass Class = {
  { prototypes::id::TestNamedDeleterInterface, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
  true,
  &sNativePropertyHooks,
  GetParentObject<mozilla::dom::TestNamedDeleterInterface>::Get,
  GetProtoObject,
  nullptr
};



DOMProxyHandler::DOMProxyHandler()
  : mozilla::dom::DOMProxyHandler(Class)
{

}


bool
DOMProxyHandler::getOwnPropertyDescriptor(JSContext* cx, JSObject* proxy, jsid id, JSPropertyDescriptor* desc, unsigned flags)
{
  JSObject* expando;
  if (!xpc::WrapperFactory::IsXrayWrapper(proxy) && (expando = GetExpandoObject(proxy))) {
    if (!JS_GetPropertyDescriptorById(cx, expando, id, flags, desc)) {
      return false;
    }
    if (desc->obj) {
      // Pretend the property lives on the wrapper.
      desc->obj = proxy;
      return true;
    }
  }

  if (!(flags & JSRESOLVE_ASSIGNING) && !HasPropertyOnPrototype(cx, proxy, this, id)) {
    JS::Value nameVal = js::IdToValue(id);
    FakeDependentString name;
    if (!ConvertJSValueToString(cx, nameVal, &nameVal,
                                eStringify, eStringify, name)) {
      return false;
    }

    mozilla::dom::TestNamedDeleterInterface* self = UnwrapProxy(proxy);
    bool found;
    int32_t result;
    result = self->NamedGetter(name, found);

    if (found) {
      desc->value = INT_TO_JSVAL(int32_t(result));
      FillPropertyDescriptor(desc, proxy, true);
      return true;
    }
  }

  desc->obj = NULL;
  return true;
}


bool
DOMProxyHandler::getOwnPropertyNames(JSContext* cx, JSObject* proxy, JS::AutoIdVector& props)
{
  nsTArray<nsString> names;
  UnwrapProxy(proxy)->GetSupportedNames(names);
  if (!AppendNamedPropertyIds(cx, proxy, names, props)) {
    return false;
  }

  JSObject* expando;
  if (!xpc::WrapperFactory::IsXrayWrapper(proxy) && (expando = DOMProxyHandler::GetExpandoObject(proxy)) &&
      !js::GetPropertyNames(cx, expando, JSITER_OWNONLY | JSITER_HIDDEN, &props)) {
    return false;
  }

  return true;
}


bool
DOMProxyHandler::hasOwn(JSContext* cx, JSObject* proxy, jsid id, bool* bp)
{
  JSObject* expando = GetExpandoObject(proxy);
  if (expando) {
    JSBool b = true;
    JSBool ok = JS_HasPropertyById(cx, expando, id, &b);
    *bp = !!b;
    if (!ok || *bp) {
      return ok;
    }
  }

  if (!HasPropertyOnPrototype(cx, proxy, this, id)) {
    JS::Value nameVal = js::IdToValue(id);
    FakeDependentString name;
    if (!ConvertJSValueToString(cx, nameVal, &nameVal,
                                eStringify, eStringify, name)) {
      return false;
    }

    mozilla::dom::TestNamedDeleterInterface* self = UnwrapProxy(proxy);
    bool found;
    int32_t result;
    result = self->NamedGetter(name, found);
    (void)result;

    *bp = found;
    return true;
  }

  *bp = false;
  return true;
}


bool
DOMProxyHandler::get(JSContext* cx, JSObject* proxy, JSObject* receiver, jsid id, JS::Value* vp)
{
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
              "Should not have a XrayWrapper here");

  JSObject* expando = DOMProxyHandler::GetExpandoObject(proxy);
  if (expando) {
    JSBool hasProp;
    if (!JS_HasPropertyById(cx, expando, id, &hasProp)) {
      return false;
    }

    if (hasProp) {
      return JS_GetPropertyById(cx, expando, id, vp);
    }
  }

  {  // Scope for this "found" so it doesn't leak to things below
    bool found;
    if (!GetPropertyOnPrototype(cx, proxy, id, &found, vp)) {
      return false;
    }

    if (found) {
      return true;
    }
  }
  JS::Value nameVal = js::IdToValue(id);
  FakeDependentString name;
  if (!ConvertJSValueToString(cx, nameVal, &nameVal,
                              eStringify, eStringify, name)) {
    return false;
  }

  mozilla::dom::TestNamedDeleterInterface* self = UnwrapProxy(proxy);
  bool found;
  int32_t result;
  result = self->NamedGetter(name, found);

  if (found) {
    *vp = INT_TO_JSVAL(int32_t(result));
    return true;
  }

  vp->setUndefined();
  return true;
}


JSString*
DOMProxyHandler::obj_toString(JSContext* cx, JSObject* proxy)
{
  return mozilla::dom::DOMProxyHandler::obj_toString(cx, "TestNamedDeleterInterface");
}


void
DOMProxyHandler::finalize(JSFreeOp* fop, JSObject* proxy)
{
  mozilla::dom::TestNamedDeleterInterface* self = UnwrapProxy(proxy);

  if (self) {
    ClearWrapper(self, self);
    XPCJSRuntime *rt = nsXPConnect::GetRuntimeInstance();
    if (rt) {
      rt->DeferredRelease(reinterpret_cast<nsISupports*>(self));
    } else {
      NS_RELEASE(self);
    }
  }
}


bool
DOMProxyHandler::getElementIfPresent(JSContext* cx, JSObject* proxy, JSObject* receiver, uint32_t index, JS::Value* vp, bool* present)
{
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
               "Should not have a XrayWrapper here");

  JS::Value nameVal = UINT_TO_JSVAL(index);
  FakeDependentString name;
  if (!ConvertJSValueToString(cx, nameVal, &nameVal,
                              eStringify, eStringify, name)) {
    return false;
  }

  mozilla::dom::TestNamedDeleterInterface* self = UnwrapProxy(proxy);
  bool found;
  int32_t result;
  result = self->NamedGetter(name, found);

  if (found) {
    *vp = INT_TO_JSVAL(int32_t(result));
    *present = found;
    return true;
  }

  JSObject* expando = GetExpandoObject(proxy);
  if (expando) {
    JSBool isPresent;
    if (!JS_GetElementIfPresent(cx, expando, index, expando, vp, &isPresent)) {
      return false;
    }
    if (isPresent) {
      *present = true;
      return true;
    }
  }

  JSObject *proto;
  if (!js::GetObjectProto(cx, proxy, &proto)) {
    return false;
  }
  if (proto) {
    JSBool isPresent;
    if (!JS_GetElementIfPresent(cx, proto, index, proxy, vp, &isPresent)) {
      return false;
    }
    *present = isPresent;
    return true;
  }

  *present = false;
  // Can't Debug_SetValueRangeToCrashOnTouch because it's not public
  return true;
}


DOMProxyHandler*
DOMProxyHandler::getInstance()
{
  static DOMProxyHandler instance;
  return &instance;
}


bool
DOMProxyHandler::delete_(JSContext* cx, JSObject* proxy, jsid id, bool* bp)
{
  if (!HasPropertyOnPrototype(cx, proxy, this, id)) {
    JS::Value nameVal = js::IdToValue(id);
    FakeDependentString name;
    if (!ConvertJSValueToString(cx, nameVal, &nameVal,
                                eStringify, eStringify, name)) {
      return false;
    }

    mozilla::dom::TestNamedDeleterInterface* self = UnwrapProxy(proxy);
    bool found;
    self->NamedDeleter(name, found);
    *bp = true;
    if (found) {
      return true;
    }
  }
  return dom::DOMProxyHandler::delete_(cx, proxy, id, bp);
}


bool
Is(JSObject* obj)
{
  return IsProxy(obj);
}

JSObject*
Wrap(JSContext* aCx, JSObject* aScope, mozilla::dom::TestNamedDeleterInterface* aObject, nsWrapperCache* aCache, bool* aTriedToWrap)
{
  MOZ_ASSERT(static_cast<mozilla::dom::TestNamedDeleterInterface*>(aObject) ==
             reinterpret_cast<mozilla::dom::TestNamedDeleterInterface*>(aObject));

  *aTriedToWrap = true;

  JSObject* parent = WrapNativeParent(aCx, aScope, aObject->GetParentObject());
  if (!parent) {
    return NULL;
  }

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.  Scope so we don't
  // collide with the "obj" we declare in CreateBindingJSObject.
  {
    JSObject* obj = aCache->GetWrapper();
    if (obj) {
      return obj;
    }
  }

  JSAutoCompartment ac(aCx, parent);
  JSObject* global = JS_GetGlobalForObject(aCx, parent);

  JSObject* proto = GetProtoObject(aCx, global);
  if (!proto) {
    return NULL;
  }

  JSObject *obj = NewProxyObject(aCx, DOMProxyHandler::getInstance(),
                                 JS::PrivateValue(aObject), proto, parent);
  if (!obj) {
    return NULL;
  }

  NS_ADDREF(aObject);


  aCache->SetWrapper(obj);

  return obj;
}

} // namespace TestNamedDeleterInterfaceBinding



namespace TestNamedDeleterWithRetvalInterfaceBinding {

static bool
delNamedItem(JSContext* cx, JSHandleObject obj, mozilla::dom::TestNamedDeleterWithRetvalInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestNamedDeleterWithRetvalInterface.delNamedItem");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eStringify, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  bool result;
  result = self->DelNamedItem(arg0);
  *vp = BOOLEAN_TO_JSVAL(result);
  return true;
}


const JSJitInfo delNamedItem_methodinfo = {
  (JSJitPropertyOp)delNamedItem,
  prototypes::id::TestNamedDeleterWithRetvalInterface,
  PrototypeTraits<prototypes::id::TestNamedDeleterWithRetvalInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

static JSBool
genericMethod(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  mozilla::dom::TestNamedDeleterWithRetvalInterface* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::TestNamedDeleterWithRetvalInterface, mozilla::dom::TestNamedDeleterWithRetvalInterface>(cx, obj, self);
    if (NS_FAILED(rv)) {
      return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestNamedDeleterWithRetvalInterface");
    }
  }
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Method);
  JSJitMethodOp method = (JSJitMethodOp)info->op;
  return method(cx, obj, self, argc, vp);
}

static JSFunctionSpec sMethods_specs[] = {
  JS_FNINFO("delNamedItem", genericMethod, &delNamedItem_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FS_END
};

static Prefable<JSFunctionSpec> sMethods[] = {
  { true, &sMethods_specs[0] },
  { false, NULL }
};

static jsid sMethods_ids[2] = { JSID_VOID };

static JSFunctionSpec sChromeMethods_specs[] = {
  JS_FNINFO("QueryInterface", QueryInterface, nullptr, 1, 0),
  JS_FS_END
};

static Prefable<JSFunctionSpec> sChromeMethods[] = {
  { true, &sChromeMethods_specs[0] },
  { false, NULL }
};

static jsid sChromeMethods_ids[2] = { JSID_VOID };


static const NativeProperties sNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sMethods, sMethods_ids, sMethods_specs,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr
};

static const NativeProperties sChromeOnlyNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sChromeMethods, sChromeMethods_ids, sChromeMethods_specs,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr
};
const NativePropertyHooks sNativePropertyHooks = {
  ResolveOwnProperty,
  EnumerateOwnProperties,
  { &sNativeProperties, &sChromeOnlyNativeProperties },
  prototypes::id::TestNamedDeleterWithRetvalInterface,
  constructors::id::TestNamedDeleterWithRetvalInterface,
  NULL
};

JSNativeHolder _constructor_holder = {
  ThrowingConstructor,
  &sNativePropertyHooks
};

static DOMIfaceAndProtoJSClass PrototypeClass = {
  {
    "TestNamedDeleterWithRetvalInterfacePrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(2),
    JS_PropertyStub,       /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    nullptr,               /* finalize */
    nullptr,               /* checkAccess */
    nullptr,               /* call */
    nullptr,               /* hasInstance */
    nullptr,               /* construct */
    nullptr,               /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  eInterfacePrototype,
  &sNativePropertyHooks
};

void
CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray)
{
  JSObject* parentProto = JS_GetObjectPrototype(aCx, aGlobal);
  if (!parentProto) {
    return;
  }


  if (sChromeMethods_ids[0] == JSID_VOID &&
      (!InitIds(aCx, sChromeMethods, sChromeMethods_ids) ||
       !InitIds(aCx, sMethods, sMethods_ids))) {
    sChromeMethods_ids[0] = JSID_VOID;
    return;
  }

  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &PrototypeClass.mBase, &protoAndIfaceArray[prototypes::id::TestNamedDeleterWithRetvalInterface],
                              nullptr, &_constructor_holder, 0, &protoAndIfaceArray[constructors::id::TestNamedDeleterWithRetvalInterface],
                              &Class,
                              &sNativeProperties,
                              xpc::AccessCheck::isChrome(aGlobal) ? &sChromeOnlyNativeProperties : nullptr,
                              "TestNamedDeleterWithRetvalInterface");
}

bool
ResolveOwnProperty(JSContext* cx, JSObject* wrapper, JSObject* obj, jsid id, JSPropertyDescriptor* desc, unsigned flags)
{
  // We rely on getOwnPropertyDescriptor not shadowing prototype properties by named
  // properties. If that changes we'll need to filter here.
  return js::GetProxyHandler(obj)->getOwnPropertyDescriptor(cx, wrapper, id, desc, flags);

}

bool
EnumerateOwnProperties(JSContext* cx, JSObject* wrapper, JSObject* obj, JS::AutoIdVector& props)
{
  // We rely on getOwnPropertyNames not shadowing prototype properties by named
  // properties. If that changes we'll need to filter here.
  return js::GetProxyHandler(obj)->getOwnPropertyNames(cx, wrapper, props);

}

JSObject*
DefineDOMInterface(JSContext* aCx, JSObject* aGlobal, bool* aEnabled)
{

  *aEnabled = true;
  return GetConstructorObject(aCx, aGlobal);
}

MOZ_ALWAYS_INLINE bool
IsProxy(JSObject* obj)
{
  return js::IsProxy(obj) && js::GetProxyHandler(obj) == DOMProxyHandler::getInstance();
}

MOZ_ALWAYS_INLINE mozilla::dom::TestNamedDeleterWithRetvalInterface*
UnwrapProxy(JSObject* obj)
{
  if (xpc::WrapperFactory::IsXrayWrapper(obj)) {
    obj = js::UnwrapObject(obj);
  }
  MOZ_ASSERT(IsProxy(obj));
  return static_cast<mozilla::dom::TestNamedDeleterWithRetvalInterface*>(js::GetProxyPrivate(obj).toPrivate());
}


const DOMClass Class = {
  { prototypes::id::TestNamedDeleterWithRetvalInterface, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
  true,
  &sNativePropertyHooks,
  GetParentObject<mozilla::dom::TestNamedDeleterWithRetvalInterface>::Get,
  GetProtoObject,
  nullptr
};



DOMProxyHandler::DOMProxyHandler()
  : mozilla::dom::DOMProxyHandler(Class)
{

}


bool
DOMProxyHandler::getOwnPropertyDescriptor(JSContext* cx, JSObject* proxy, jsid id, JSPropertyDescriptor* desc, unsigned flags)
{
  JSObject* expando;
  if (!xpc::WrapperFactory::IsXrayWrapper(proxy) && (expando = GetExpandoObject(proxy))) {
    if (!JS_GetPropertyDescriptorById(cx, expando, id, flags, desc)) {
      return false;
    }
    if (desc->obj) {
      // Pretend the property lives on the wrapper.
      desc->obj = proxy;
      return true;
    }
  }

  if (!(flags & JSRESOLVE_ASSIGNING) && !HasPropertyOnPrototype(cx, proxy, this, id)) {
    JS::Value nameVal = js::IdToValue(id);
    FakeDependentString name;
    if (!ConvertJSValueToString(cx, nameVal, &nameVal,
                                eStringify, eStringify, name)) {
      return false;
    }

    mozilla::dom::TestNamedDeleterWithRetvalInterface* self = UnwrapProxy(proxy);
    bool found;
    int32_t result;
    result = self->NamedGetter(name, found);

    if (found) {
      desc->value = INT_TO_JSVAL(int32_t(result));
      FillPropertyDescriptor(desc, proxy, true);
      return true;
    }
  }

  desc->obj = NULL;
  return true;
}


bool
DOMProxyHandler::getOwnPropertyNames(JSContext* cx, JSObject* proxy, JS::AutoIdVector& props)
{
  nsTArray<nsString> names;
  UnwrapProxy(proxy)->GetSupportedNames(names);
  if (!AppendNamedPropertyIds(cx, proxy, names, props)) {
    return false;
  }

  JSObject* expando;
  if (!xpc::WrapperFactory::IsXrayWrapper(proxy) && (expando = DOMProxyHandler::GetExpandoObject(proxy)) &&
      !js::GetPropertyNames(cx, expando, JSITER_OWNONLY | JSITER_HIDDEN, &props)) {
    return false;
  }

  return true;
}


bool
DOMProxyHandler::hasOwn(JSContext* cx, JSObject* proxy, jsid id, bool* bp)
{
  JSObject* expando = GetExpandoObject(proxy);
  if (expando) {
    JSBool b = true;
    JSBool ok = JS_HasPropertyById(cx, expando, id, &b);
    *bp = !!b;
    if (!ok || *bp) {
      return ok;
    }
  }

  if (!HasPropertyOnPrototype(cx, proxy, this, id)) {
    JS::Value nameVal = js::IdToValue(id);
    FakeDependentString name;
    if (!ConvertJSValueToString(cx, nameVal, &nameVal,
                                eStringify, eStringify, name)) {
      return false;
    }

    mozilla::dom::TestNamedDeleterWithRetvalInterface* self = UnwrapProxy(proxy);
    bool found;
    int32_t result;
    result = self->NamedGetter(name, found);
    (void)result;

    *bp = found;
    return true;
  }

  *bp = false;
  return true;
}


bool
DOMProxyHandler::get(JSContext* cx, JSObject* proxy, JSObject* receiver, jsid id, JS::Value* vp)
{
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
              "Should not have a XrayWrapper here");

  JSObject* expando = DOMProxyHandler::GetExpandoObject(proxy);
  if (expando) {
    JSBool hasProp;
    if (!JS_HasPropertyById(cx, expando, id, &hasProp)) {
      return false;
    }

    if (hasProp) {
      return JS_GetPropertyById(cx, expando, id, vp);
    }
  }

  {  // Scope for this "found" so it doesn't leak to things below
    bool found;
    if (!GetPropertyOnPrototype(cx, proxy, id, &found, vp)) {
      return false;
    }

    if (found) {
      return true;
    }
  }
  JS::Value nameVal = js::IdToValue(id);
  FakeDependentString name;
  if (!ConvertJSValueToString(cx, nameVal, &nameVal,
                              eStringify, eStringify, name)) {
    return false;
  }

  mozilla::dom::TestNamedDeleterWithRetvalInterface* self = UnwrapProxy(proxy);
  bool found;
  int32_t result;
  result = self->NamedGetter(name, found);

  if (found) {
    *vp = INT_TO_JSVAL(int32_t(result));
    return true;
  }

  vp->setUndefined();
  return true;
}


JSString*
DOMProxyHandler::obj_toString(JSContext* cx, JSObject* proxy)
{
  return mozilla::dom::DOMProxyHandler::obj_toString(cx, "TestNamedDeleterWithRetvalInterface");
}


void
DOMProxyHandler::finalize(JSFreeOp* fop, JSObject* proxy)
{
  mozilla::dom::TestNamedDeleterWithRetvalInterface* self = UnwrapProxy(proxy);

  if (self) {
    ClearWrapper(self, self);
    XPCJSRuntime *rt = nsXPConnect::GetRuntimeInstance();
    if (rt) {
      rt->DeferredRelease(reinterpret_cast<nsISupports*>(self));
    } else {
      NS_RELEASE(self);
    }
  }
}


bool
DOMProxyHandler::getElementIfPresent(JSContext* cx, JSObject* proxy, JSObject* receiver, uint32_t index, JS::Value* vp, bool* present)
{
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
               "Should not have a XrayWrapper here");

  JS::Value nameVal = UINT_TO_JSVAL(index);
  FakeDependentString name;
  if (!ConvertJSValueToString(cx, nameVal, &nameVal,
                              eStringify, eStringify, name)) {
    return false;
  }

  mozilla::dom::TestNamedDeleterWithRetvalInterface* self = UnwrapProxy(proxy);
  bool found;
  int32_t result;
  result = self->NamedGetter(name, found);

  if (found) {
    *vp = INT_TO_JSVAL(int32_t(result));
    *present = found;
    return true;
  }

  JSObject* expando = GetExpandoObject(proxy);
  if (expando) {
    JSBool isPresent;
    if (!JS_GetElementIfPresent(cx, expando, index, expando, vp, &isPresent)) {
      return false;
    }
    if (isPresent) {
      *present = true;
      return true;
    }
  }

  JSObject *proto;
  if (!js::GetObjectProto(cx, proxy, &proto)) {
    return false;
  }
  if (proto) {
    JSBool isPresent;
    if (!JS_GetElementIfPresent(cx, proto, index, proxy, vp, &isPresent)) {
      return false;
    }
    *present = isPresent;
    return true;
  }

  *present = false;
  // Can't Debug_SetValueRangeToCrashOnTouch because it's not public
  return true;
}


DOMProxyHandler*
DOMProxyHandler::getInstance()
{
  static DOMProxyHandler instance;
  return &instance;
}


bool
DOMProxyHandler::delete_(JSContext* cx, JSObject* proxy, jsid id, bool* bp)
{
  if (!HasPropertyOnPrototype(cx, proxy, this, id)) {
    JS::Value nameVal = js::IdToValue(id);
    FakeDependentString name;
    if (!ConvertJSValueToString(cx, nameVal, &nameVal,
                                eStringify, eStringify, name)) {
      return false;
    }

    mozilla::dom::TestNamedDeleterWithRetvalInterface* self = UnwrapProxy(proxy);
    bool found;
    bool result;
    result = self->NamedDeleter(name, found);
    if (found) {
      // XXXbz we should throw as needed if Throw is true
      *bp = result;
    } else {
      *bp = true;
    }
    if (found) {
      return true;
    }
  }
  return dom::DOMProxyHandler::delete_(cx, proxy, id, bp);
}


bool
Is(JSObject* obj)
{
  return IsProxy(obj);
}

JSObject*
Wrap(JSContext* aCx, JSObject* aScope, mozilla::dom::TestNamedDeleterWithRetvalInterface* aObject, nsWrapperCache* aCache, bool* aTriedToWrap)
{
  MOZ_ASSERT(static_cast<mozilla::dom::TestNamedDeleterWithRetvalInterface*>(aObject) ==
             reinterpret_cast<mozilla::dom::TestNamedDeleterWithRetvalInterface*>(aObject));

  *aTriedToWrap = true;

  JSObject* parent = WrapNativeParent(aCx, aScope, aObject->GetParentObject());
  if (!parent) {
    return NULL;
  }

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.  Scope so we don't
  // collide with the "obj" we declare in CreateBindingJSObject.
  {
    JSObject* obj = aCache->GetWrapper();
    if (obj) {
      return obj;
    }
  }

  JSAutoCompartment ac(aCx, parent);
  JSObject* global = JS_GetGlobalForObject(aCx, parent);

  JSObject* proto = GetProtoObject(aCx, global);
  if (!proto) {
    return NULL;
  }

  JSObject *obj = NewProxyObject(aCx, DOMProxyHandler::getInstance(),
                                 JS::PrivateValue(aObject), proto, parent);
  if (!obj) {
    return NULL;
  }

  NS_ADDREF(aObject);


  aCache->SetWrapper(obj);

  return obj;
}

} // namespace TestNamedDeleterWithRetvalInterfaceBinding



namespace TestNamedGetterInterfaceBinding {

static JSFunctionSpec sChromeMethods_specs[] = {
  JS_FNINFO("QueryInterface", QueryInterface, nullptr, 1, 0),
  JS_FS_END
};

static Prefable<JSFunctionSpec> sChromeMethods[] = {
  { true, &sChromeMethods_specs[0] },
  { false, NULL }
};

static jsid sChromeMethods_ids[2] = { JSID_VOID };


static const NativeProperties sChromeOnlyNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sChromeMethods, sChromeMethods_ids, sChromeMethods_specs,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr
};
const NativePropertyHooks sNativePropertyHooks = {
  ResolveOwnProperty,
  EnumerateOwnProperties,
  { nullptr, &sChromeOnlyNativeProperties },
  prototypes::id::TestNamedGetterInterface,
  constructors::id::TestNamedGetterInterface,
  NULL
};

JSNativeHolder _constructor_holder = {
  ThrowingConstructor,
  &sNativePropertyHooks
};

static DOMIfaceAndProtoJSClass PrototypeClass = {
  {
    "TestNamedGetterInterfacePrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(2),
    JS_PropertyStub,       /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    nullptr,               /* finalize */
    nullptr,               /* checkAccess */
    nullptr,               /* call */
    nullptr,               /* hasInstance */
    nullptr,               /* construct */
    nullptr,               /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  eInterfacePrototype,
  &sNativePropertyHooks
};

void
CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray)
{
  JSObject* parentProto = JS_GetObjectPrototype(aCx, aGlobal);
  if (!parentProto) {
    return;
  }


  if (sChromeMethods_ids[0] == JSID_VOID &&
      !InitIds(aCx, sChromeMethods, sChromeMethods_ids)) {
    sChromeMethods_ids[0] = JSID_VOID;
    return;
  }

  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &PrototypeClass.mBase, &protoAndIfaceArray[prototypes::id::TestNamedGetterInterface],
                              nullptr, &_constructor_holder, 0, &protoAndIfaceArray[constructors::id::TestNamedGetterInterface],
                              &Class,
                              nullptr,
                              xpc::AccessCheck::isChrome(aGlobal) ? &sChromeOnlyNativeProperties : nullptr,
                              "TestNamedGetterInterface");
}

bool
ResolveOwnProperty(JSContext* cx, JSObject* wrapper, JSObject* obj, jsid id, JSPropertyDescriptor* desc, unsigned flags)
{
  // We rely on getOwnPropertyDescriptor not shadowing prototype properties by named
  // properties. If that changes we'll need to filter here.
  return js::GetProxyHandler(obj)->getOwnPropertyDescriptor(cx, wrapper, id, desc, flags);

}

bool
EnumerateOwnProperties(JSContext* cx, JSObject* wrapper, JSObject* obj, JS::AutoIdVector& props)
{
  // We rely on getOwnPropertyNames not shadowing prototype properties by named
  // properties. If that changes we'll need to filter here.
  return js::GetProxyHandler(obj)->getOwnPropertyNames(cx, wrapper, props);

}

JSObject*
DefineDOMInterface(JSContext* aCx, JSObject* aGlobal, bool* aEnabled)
{

  *aEnabled = true;
  return GetConstructorObject(aCx, aGlobal);
}

MOZ_ALWAYS_INLINE bool
IsProxy(JSObject* obj)
{
  return js::IsProxy(obj) && js::GetProxyHandler(obj) == DOMProxyHandler::getInstance();
}

MOZ_ALWAYS_INLINE mozilla::dom::TestNamedGetterInterface*
UnwrapProxy(JSObject* obj)
{
  if (xpc::WrapperFactory::IsXrayWrapper(obj)) {
    obj = js::UnwrapObject(obj);
  }
  MOZ_ASSERT(IsProxy(obj));
  return static_cast<mozilla::dom::TestNamedGetterInterface*>(js::GetProxyPrivate(obj).toPrivate());
}


const DOMClass Class = {
  { prototypes::id::TestNamedGetterInterface, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
  true,
  &sNativePropertyHooks,
  GetParentObject<mozilla::dom::TestNamedGetterInterface>::Get,
  GetProtoObject,
  nullptr
};



DOMProxyHandler::DOMProxyHandler()
  : mozilla::dom::DOMProxyHandler(Class)
{

}


bool
DOMProxyHandler::getOwnPropertyDescriptor(JSContext* cx, JSObject* proxy, jsid id, JSPropertyDescriptor* desc, unsigned flags)
{
  JSObject* expando;
  if (!xpc::WrapperFactory::IsXrayWrapper(proxy) && (expando = GetExpandoObject(proxy))) {
    if (!JS_GetPropertyDescriptorById(cx, expando, id, flags, desc)) {
      return false;
    }
    if (desc->obj) {
      // Pretend the property lives on the wrapper.
      desc->obj = proxy;
      return true;
    }
  }

  if (!(flags & JSRESOLVE_ASSIGNING) && !HasPropertyOnPrototype(cx, proxy, this, id)) {
    JS::Value nameVal = js::IdToValue(id);
    FakeDependentString name;
    if (!ConvertJSValueToString(cx, nameVal, &nameVal,
                                eStringify, eStringify, name)) {
      return false;
    }

    mozilla::dom::TestNamedGetterInterface* self = UnwrapProxy(proxy);
    bool found;
    nsString result;
    self->NamedGetter(name, found, result);

    if (found) {
      if (!xpc::NonVoidStringToJsval(cx, result, &desc->value)) {
        return false;
      }
      FillPropertyDescriptor(desc, proxy, true);
      return true;
    }
  }

  desc->obj = NULL;
  return true;
}


bool
DOMProxyHandler::getOwnPropertyNames(JSContext* cx, JSObject* proxy, JS::AutoIdVector& props)
{
  nsTArray<nsString> names;
  UnwrapProxy(proxy)->GetSupportedNames(names);
  if (!AppendNamedPropertyIds(cx, proxy, names, props)) {
    return false;
  }

  JSObject* expando;
  if (!xpc::WrapperFactory::IsXrayWrapper(proxy) && (expando = DOMProxyHandler::GetExpandoObject(proxy)) &&
      !js::GetPropertyNames(cx, expando, JSITER_OWNONLY | JSITER_HIDDEN, &props)) {
    return false;
  }

  return true;
}


bool
DOMProxyHandler::hasOwn(JSContext* cx, JSObject* proxy, jsid id, bool* bp)
{
  JSObject* expando = GetExpandoObject(proxy);
  if (expando) {
    JSBool b = true;
    JSBool ok = JS_HasPropertyById(cx, expando, id, &b);
    *bp = !!b;
    if (!ok || *bp) {
      return ok;
    }
  }

  if (!HasPropertyOnPrototype(cx, proxy, this, id)) {
    JS::Value nameVal = js::IdToValue(id);
    FakeDependentString name;
    if (!ConvertJSValueToString(cx, nameVal, &nameVal,
                                eStringify, eStringify, name)) {
      return false;
    }

    mozilla::dom::TestNamedGetterInterface* self = UnwrapProxy(proxy);
    bool found;
    nsString result;
    self->NamedGetter(name, found, result);
    (void)result;

    *bp = found;
    return true;
  }

  *bp = false;
  return true;
}


bool
DOMProxyHandler::get(JSContext* cx, JSObject* proxy, JSObject* receiver, jsid id, JS::Value* vp)
{
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
              "Should not have a XrayWrapper here");

  JSObject* expando = DOMProxyHandler::GetExpandoObject(proxy);
  if (expando) {
    JSBool hasProp;
    if (!JS_HasPropertyById(cx, expando, id, &hasProp)) {
      return false;
    }

    if (hasProp) {
      return JS_GetPropertyById(cx, expando, id, vp);
    }
  }

  {  // Scope for this "found" so it doesn't leak to things below
    bool found;
    if (!GetPropertyOnPrototype(cx, proxy, id, &found, vp)) {
      return false;
    }

    if (found) {
      return true;
    }
  }
  JS::Value nameVal = js::IdToValue(id);
  FakeDependentString name;
  if (!ConvertJSValueToString(cx, nameVal, &nameVal,
                              eStringify, eStringify, name)) {
    return false;
  }

  mozilla::dom::TestNamedGetterInterface* self = UnwrapProxy(proxy);
  bool found;
  nsString result;
  self->NamedGetter(name, found, result);

  if (found) {
    if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
      return false;
    }
    return true;
  }

  vp->setUndefined();
  return true;
}


JSString*
DOMProxyHandler::obj_toString(JSContext* cx, JSObject* proxy)
{
  return mozilla::dom::DOMProxyHandler::obj_toString(cx, "TestNamedGetterInterface");
}


void
DOMProxyHandler::finalize(JSFreeOp* fop, JSObject* proxy)
{
  mozilla::dom::TestNamedGetterInterface* self = UnwrapProxy(proxy);

  if (self) {
    ClearWrapper(self, self);
    XPCJSRuntime *rt = nsXPConnect::GetRuntimeInstance();
    if (rt) {
      rt->DeferredRelease(reinterpret_cast<nsISupports*>(self));
    } else {
      NS_RELEASE(self);
    }
  }
}


bool
DOMProxyHandler::getElementIfPresent(JSContext* cx, JSObject* proxy, JSObject* receiver, uint32_t index, JS::Value* vp, bool* present)
{
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
               "Should not have a XrayWrapper here");

  JS::Value nameVal = UINT_TO_JSVAL(index);
  FakeDependentString name;
  if (!ConvertJSValueToString(cx, nameVal, &nameVal,
                              eStringify, eStringify, name)) {
    return false;
  }

  mozilla::dom::TestNamedGetterInterface* self = UnwrapProxy(proxy);
  bool found;
  nsString result;
  self->NamedGetter(name, found, result);

  if (found) {
    if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
      return false;
    }
    *present = found;
    return true;
  }

  JSObject* expando = GetExpandoObject(proxy);
  if (expando) {
    JSBool isPresent;
    if (!JS_GetElementIfPresent(cx, expando, index, expando, vp, &isPresent)) {
      return false;
    }
    if (isPresent) {
      *present = true;
      return true;
    }
  }

  JSObject *proto;
  if (!js::GetObjectProto(cx, proxy, &proto)) {
    return false;
  }
  if (proto) {
    JSBool isPresent;
    if (!JS_GetElementIfPresent(cx, proto, index, proxy, vp, &isPresent)) {
      return false;
    }
    *present = isPresent;
    return true;
  }

  *present = false;
  // Can't Debug_SetValueRangeToCrashOnTouch because it's not public
  return true;
}


DOMProxyHandler*
DOMProxyHandler::getInstance()
{
  static DOMProxyHandler instance;
  return &instance;
}


bool
DOMProxyHandler::delete_(JSContext* cx, JSObject* proxy, jsid id, bool* bp)
{
  if (!HasPropertyOnPrototype(cx, proxy, this, id)) {
    JS::Value nameVal = js::IdToValue(id);
    FakeDependentString name;
    if (!ConvertJSValueToString(cx, nameVal, &nameVal,
                                eStringify, eStringify, name)) {
      return false;
    }

    mozilla::dom::TestNamedGetterInterface* self = UnwrapProxy(proxy);
    bool found;
    nsString result;
    self->NamedGetter(name, found, result);
    (void)result;
    if (found) {
      // XXXbz we should throw if Throw is true!
      *bp = false;
    } else {
      *bp = true;
    }
    if (found) {
      return true;
    }
  }
  return dom::DOMProxyHandler::delete_(cx, proxy, id, bp);
}


bool
Is(JSObject* obj)
{
  return IsProxy(obj);
}

JSObject*
Wrap(JSContext* aCx, JSObject* aScope, mozilla::dom::TestNamedGetterInterface* aObject, nsWrapperCache* aCache, bool* aTriedToWrap)
{
  MOZ_ASSERT(static_cast<mozilla::dom::TestNamedGetterInterface*>(aObject) ==
             reinterpret_cast<mozilla::dom::TestNamedGetterInterface*>(aObject));

  *aTriedToWrap = true;

  JSObject* parent = WrapNativeParent(aCx, aScope, aObject->GetParentObject());
  if (!parent) {
    return NULL;
  }

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.  Scope so we don't
  // collide with the "obj" we declare in CreateBindingJSObject.
  {
    JSObject* obj = aCache->GetWrapper();
    if (obj) {
      return obj;
    }
  }

  JSAutoCompartment ac(aCx, parent);
  JSObject* global = JS_GetGlobalForObject(aCx, parent);

  JSObject* proto = GetProtoObject(aCx, global);
  if (!proto) {
    return NULL;
  }

  JSObject *obj = NewProxyObject(aCx, DOMProxyHandler::getInstance(),
                                 JS::PrivateValue(aObject), proto, parent);
  if (!obj) {
    return NULL;
  }

  NS_ADDREF(aObject);


  aCache->SetWrapper(obj);

  return obj;
}

} // namespace TestNamedGetterInterfaceBinding



namespace TestNamedSetterInterfaceBinding {

static JSFunctionSpec sChromeMethods_specs[] = {
  JS_FNINFO("QueryInterface", QueryInterface, nullptr, 1, 0),
  JS_FS_END
};

static Prefable<JSFunctionSpec> sChromeMethods[] = {
  { true, &sChromeMethods_specs[0] },
  { false, NULL }
};

static jsid sChromeMethods_ids[2] = { JSID_VOID };


static const NativeProperties sChromeOnlyNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sChromeMethods, sChromeMethods_ids, sChromeMethods_specs,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr
};
const NativePropertyHooks sNativePropertyHooks = {
  ResolveOwnProperty,
  EnumerateOwnProperties,
  { nullptr, &sChromeOnlyNativeProperties },
  prototypes::id::TestNamedSetterInterface,
  constructors::id::TestNamedSetterInterface,
  NULL
};

JSNativeHolder _constructor_holder = {
  ThrowingConstructor,
  &sNativePropertyHooks
};

static DOMIfaceAndProtoJSClass PrototypeClass = {
  {
    "TestNamedSetterInterfacePrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(2),
    JS_PropertyStub,       /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    nullptr,               /* finalize */
    nullptr,               /* checkAccess */
    nullptr,               /* call */
    nullptr,               /* hasInstance */
    nullptr,               /* construct */
    nullptr,               /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  eInterfacePrototype,
  &sNativePropertyHooks
};

void
CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray)
{
  JSObject* parentProto = JS_GetObjectPrototype(aCx, aGlobal);
  if (!parentProto) {
    return;
  }


  if (sChromeMethods_ids[0] == JSID_VOID &&
      !InitIds(aCx, sChromeMethods, sChromeMethods_ids)) {
    sChromeMethods_ids[0] = JSID_VOID;
    return;
  }

  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &PrototypeClass.mBase, &protoAndIfaceArray[prototypes::id::TestNamedSetterInterface],
                              nullptr, &_constructor_holder, 0, &protoAndIfaceArray[constructors::id::TestNamedSetterInterface],
                              &Class,
                              nullptr,
                              xpc::AccessCheck::isChrome(aGlobal) ? &sChromeOnlyNativeProperties : nullptr,
                              "TestNamedSetterInterface");
}

bool
ResolveOwnProperty(JSContext* cx, JSObject* wrapper, JSObject* obj, jsid id, JSPropertyDescriptor* desc, unsigned flags)
{
  // We rely on getOwnPropertyDescriptor not shadowing prototype properties by named
  // properties. If that changes we'll need to filter here.
  return js::GetProxyHandler(obj)->getOwnPropertyDescriptor(cx, wrapper, id, desc, flags);

}

bool
EnumerateOwnProperties(JSContext* cx, JSObject* wrapper, JSObject* obj, JS::AutoIdVector& props)
{
  // We rely on getOwnPropertyNames not shadowing prototype properties by named
  // properties. If that changes we'll need to filter here.
  return js::GetProxyHandler(obj)->getOwnPropertyNames(cx, wrapper, props);

}

JSObject*
DefineDOMInterface(JSContext* aCx, JSObject* aGlobal, bool* aEnabled)
{

  *aEnabled = true;
  return GetConstructorObject(aCx, aGlobal);
}

MOZ_ALWAYS_INLINE bool
IsProxy(JSObject* obj)
{
  return js::IsProxy(obj) && js::GetProxyHandler(obj) == DOMProxyHandler::getInstance();
}

MOZ_ALWAYS_INLINE mozilla::dom::TestNamedSetterInterface*
UnwrapProxy(JSObject* obj)
{
  if (xpc::WrapperFactory::IsXrayWrapper(obj)) {
    obj = js::UnwrapObject(obj);
  }
  MOZ_ASSERT(IsProxy(obj));
  return static_cast<mozilla::dom::TestNamedSetterInterface*>(js::GetProxyPrivate(obj).toPrivate());
}


const DOMClass Class = {
  { prototypes::id::TestNamedSetterInterface, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
  true,
  &sNativePropertyHooks,
  GetParentObject<mozilla::dom::TestNamedSetterInterface>::Get,
  GetProtoObject,
  nullptr
};



DOMProxyHandler::DOMProxyHandler()
  : mozilla::dom::DOMProxyHandler(Class)
{

}


bool
DOMProxyHandler::getOwnPropertyDescriptor(JSContext* cx, JSObject* proxy, jsid id, JSPropertyDescriptor* desc, unsigned flags)
{
  if (flags & JSRESOLVE_ASSIGNING) {
    FillPropertyDescriptor(desc, proxy, JSVAL_VOID, false);
    return true;
  }

  JSObject* expando;
  if (!xpc::WrapperFactory::IsXrayWrapper(proxy) && (expando = GetExpandoObject(proxy))) {
    if (!JS_GetPropertyDescriptorById(cx, expando, id, flags, desc)) {
      return false;
    }
    if (desc->obj) {
      // Pretend the property lives on the wrapper.
      desc->obj = proxy;
      return true;
    }
  }

  if (!(flags & JSRESOLVE_ASSIGNING) && !HasPropertyOnPrototype(cx, proxy, this, id)) {
    JS::Value nameVal = js::IdToValue(id);
    FakeDependentString name;
    if (!ConvertJSValueToString(cx, nameVal, &nameVal,
                                eStringify, eStringify, name)) {
      return false;
    }

    mozilla::dom::TestNamedSetterInterface* self = UnwrapProxy(proxy);
    bool found;
    nsRefPtr<mozilla::dom::TestIndexedSetterInterface> result;
    result = self->NamedGetter(name, found);

    if (found) {
      if (!WrapNewBindingObject(cx, proxy, result, &desc->value)) {
        MOZ_ASSERT(JS_IsExceptionPending(cx));
        return false;
      }
      FillPropertyDescriptor(desc, proxy, false);
      return true;
    }
  }

  desc->obj = NULL;
  return true;
}


bool
DOMProxyHandler::defineProperty(JSContext* cx, JSObject* proxy, jsid id, JSPropertyDescriptor* desc)
{
  JS::Value nameVal = js::IdToValue(id);
  FakeDependentString myName;
  if (!ConvertJSValueToString(cx, nameVal, &nameVal,
                              eStringify, eStringify, myName)) {
    return false;
  }

  mozilla::dom::TestNamedSetterInterface* self = UnwrapProxy(proxy);
  NonNull<mozilla::dom::TestIndexedSetterInterface> item;
  if (desc->value.isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::TestIndexedSetterInterface, mozilla::dom::TestIndexedSetterInterface>(cx, &desc->value.toObject(), item);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestIndexedSetterInterface");
        return false;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->NamedSetter(myName, item);

  return true;

}


bool
DOMProxyHandler::getOwnPropertyNames(JSContext* cx, JSObject* proxy, JS::AutoIdVector& props)
{
  nsTArray<nsString> names;
  UnwrapProxy(proxy)->GetSupportedNames(names);
  if (!AppendNamedPropertyIds(cx, proxy, names, props)) {
    return false;
  }

  JSObject* expando;
  if (!xpc::WrapperFactory::IsXrayWrapper(proxy) && (expando = DOMProxyHandler::GetExpandoObject(proxy)) &&
      !js::GetPropertyNames(cx, expando, JSITER_OWNONLY | JSITER_HIDDEN, &props)) {
    return false;
  }

  return true;
}


bool
DOMProxyHandler::hasOwn(JSContext* cx, JSObject* proxy, jsid id, bool* bp)
{
  JSObject* expando = GetExpandoObject(proxy);
  if (expando) {
    JSBool b = true;
    JSBool ok = JS_HasPropertyById(cx, expando, id, &b);
    *bp = !!b;
    if (!ok || *bp) {
      return ok;
    }
  }

  if (!HasPropertyOnPrototype(cx, proxy, this, id)) {
    JS::Value nameVal = js::IdToValue(id);
    FakeDependentString name;
    if (!ConvertJSValueToString(cx, nameVal, &nameVal,
                                eStringify, eStringify, name)) {
      return false;
    }

    mozilla::dom::TestNamedSetterInterface* self = UnwrapProxy(proxy);
    bool found;
    nsRefPtr<mozilla::dom::TestIndexedSetterInterface> result;
    result = self->NamedGetter(name, found);
    (void)result;

    *bp = found;
    return true;
  }

  *bp = false;
  return true;
}


bool
DOMProxyHandler::get(JSContext* cx, JSObject* proxy, JSObject* receiver, jsid id, JS::Value* vp)
{
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
              "Should not have a XrayWrapper here");

  JSObject* expando = DOMProxyHandler::GetExpandoObject(proxy);
  if (expando) {
    JSBool hasProp;
    if (!JS_HasPropertyById(cx, expando, id, &hasProp)) {
      return false;
    }

    if (hasProp) {
      return JS_GetPropertyById(cx, expando, id, vp);
    }
  }

  {  // Scope for this "found" so it doesn't leak to things below
    bool found;
    if (!GetPropertyOnPrototype(cx, proxy, id, &found, vp)) {
      return false;
    }

    if (found) {
      return true;
    }
  }
  JS::Value nameVal = js::IdToValue(id);
  FakeDependentString name;
  if (!ConvertJSValueToString(cx, nameVal, &nameVal,
                              eStringify, eStringify, name)) {
    return false;
  }

  mozilla::dom::TestNamedSetterInterface* self = UnwrapProxy(proxy);
  bool found;
  nsRefPtr<mozilla::dom::TestIndexedSetterInterface> result;
  result = self->NamedGetter(name, found);

  if (found) {
    if (!WrapNewBindingObject(cx, proxy, result, vp)) {
      MOZ_ASSERT(JS_IsExceptionPending(cx));
      return false;
    }
    return true;
  }

  vp->setUndefined();
  return true;
}


JSString*
DOMProxyHandler::obj_toString(JSContext* cx, JSObject* proxy)
{
  return mozilla::dom::DOMProxyHandler::obj_toString(cx, "TestNamedSetterInterface");
}


void
DOMProxyHandler::finalize(JSFreeOp* fop, JSObject* proxy)
{
  mozilla::dom::TestNamedSetterInterface* self = UnwrapProxy(proxy);

  if (self) {
    ClearWrapper(self, self);
    XPCJSRuntime *rt = nsXPConnect::GetRuntimeInstance();
    if (rt) {
      rt->DeferredRelease(reinterpret_cast<nsISupports*>(self));
    } else {
      NS_RELEASE(self);
    }
  }
}


bool
DOMProxyHandler::getElementIfPresent(JSContext* cx, JSObject* proxy, JSObject* receiver, uint32_t index, JS::Value* vp, bool* present)
{
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
               "Should not have a XrayWrapper here");

  JS::Value nameVal = UINT_TO_JSVAL(index);
  FakeDependentString name;
  if (!ConvertJSValueToString(cx, nameVal, &nameVal,
                              eStringify, eStringify, name)) {
    return false;
  }

  mozilla::dom::TestNamedSetterInterface* self = UnwrapProxy(proxy);
  bool found;
  nsRefPtr<mozilla::dom::TestIndexedSetterInterface> result;
  result = self->NamedGetter(name, found);

  if (found) {
    if (!WrapNewBindingObject(cx, proxy, result, vp)) {
      MOZ_ASSERT(JS_IsExceptionPending(cx));
      return false;
    }
    *present = found;
    return true;
  }

  JSObject* expando = GetExpandoObject(proxy);
  if (expando) {
    JSBool isPresent;
    if (!JS_GetElementIfPresent(cx, expando, index, expando, vp, &isPresent)) {
      return false;
    }
    if (isPresent) {
      *present = true;
      return true;
    }
  }

  JSObject *proto;
  if (!js::GetObjectProto(cx, proxy, &proto)) {
    return false;
  }
  if (proto) {
    JSBool isPresent;
    if (!JS_GetElementIfPresent(cx, proto, index, proxy, vp, &isPresent)) {
      return false;
    }
    *present = isPresent;
    return true;
  }

  *present = false;
  // Can't Debug_SetValueRangeToCrashOnTouch because it's not public
  return true;
}


DOMProxyHandler*
DOMProxyHandler::getInstance()
{
  static DOMProxyHandler instance;
  return &instance;
}


bool
DOMProxyHandler::delete_(JSContext* cx, JSObject* proxy, jsid id, bool* bp)
{
  if (!HasPropertyOnPrototype(cx, proxy, this, id)) {
    JS::Value nameVal = js::IdToValue(id);
    FakeDependentString name;
    if (!ConvertJSValueToString(cx, nameVal, &nameVal,
                                eStringify, eStringify, name)) {
      return false;
    }

    mozilla::dom::TestNamedSetterInterface* self = UnwrapProxy(proxy);
    bool found;
    nsRefPtr<mozilla::dom::TestIndexedSetterInterface> result;
    result = self->NamedGetter(name, found);
    (void)result;
    if (found) {
      // XXXbz we should throw if Throw is true!
      *bp = false;
    } else {
      *bp = true;
    }
    if (found) {
      return true;
    }
  }
  return dom::DOMProxyHandler::delete_(cx, proxy, id, bp);
}


bool
Is(JSObject* obj)
{
  return IsProxy(obj);
}

JSObject*
Wrap(JSContext* aCx, JSObject* aScope, mozilla::dom::TestNamedSetterInterface* aObject, nsWrapperCache* aCache, bool* aTriedToWrap)
{
  MOZ_ASSERT(static_cast<mozilla::dom::TestNamedSetterInterface*>(aObject) ==
             reinterpret_cast<mozilla::dom::TestNamedSetterInterface*>(aObject));

  *aTriedToWrap = true;

  JSObject* parent = WrapNativeParent(aCx, aScope, aObject->GetParentObject());
  if (!parent) {
    return NULL;
  }

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.  Scope so we don't
  // collide with the "obj" we declare in CreateBindingJSObject.
  {
    JSObject* obj = aCache->GetWrapper();
    if (obj) {
      return obj;
    }
  }

  JSAutoCompartment ac(aCx, parent);
  JSObject* global = JS_GetGlobalForObject(aCx, parent);

  JSObject* proto = GetProtoObject(aCx, global);
  if (!proto) {
    return NULL;
  }

  JSObject *obj = NewProxyObject(aCx, DOMProxyHandler::getInstance(),
                                 JS::PrivateValue(aObject), proto, parent);
  if (!obj) {
    return NULL;
  }

  NS_ADDREF(aObject);


  aCache->SetWrapper(obj);

  return obj;
}

} // namespace TestNamedSetterInterfaceBinding



namespace TestNonCastableInterfaceBinding {

static JSBool
_addProperty(JSContext* cx, JSHandleObject obj, JSHandleId id, JSMutableHandleValue vp)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::dom::TestNonCastableInterface>::value), "Must be an nsISupports class");
  mozilla::dom::TestNonCastableInterface* self = UnwrapDOMObject<mozilla::dom::TestNonCastableInterface>(obj);
  nsContentUtils::PreserveWrapper(reinterpret_cast<nsISupports*>(self), self);
  return true;
}

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::dom::TestNonCastableInterface>::value), "Must be an nsISupports class");
  mozilla::dom::TestNonCastableInterface* self = UnwrapDOMObject<mozilla::dom::TestNonCastableInterface>(obj);
  if (self) {
    ClearWrapper(self, self);
    XPCJSRuntime *rt = nsXPConnect::GetRuntimeInstance();
    if (rt) {
      rt->DeferredRelease(reinterpret_cast<nsISupports*>(self));
    } else {
      NS_RELEASE(self);
    }
  }
}

static JSFunctionSpec sChromeMethods_specs[] = {
  JS_FNINFO("QueryInterface", QueryInterface, nullptr, 1, 0),
  JS_FS_END
};

static Prefable<JSFunctionSpec> sChromeMethods[] = {
  { true, &sChromeMethods_specs[0] },
  { false, NULL }
};

static jsid sChromeMethods_ids[2] = { JSID_VOID };


static const NativeProperties sChromeOnlyNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sChromeMethods, sChromeMethods_ids, sChromeMethods_specs,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr
};
const NativePropertyHooks sNativePropertyHooks = {
  nullptr,
  nullptr,
  { nullptr, &sChromeOnlyNativeProperties },
  prototypes::id::TestNonCastableInterface,
  constructors::id::TestNonCastableInterface,
  NULL
};

JSNativeHolder _constructor_holder = {
  ThrowingConstructor,
  &sNativePropertyHooks
};

static DOMIfaceAndProtoJSClass PrototypeClass = {
  {
    "TestNonCastableInterfacePrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(2),
    JS_PropertyStub,       /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    nullptr,               /* finalize */
    nullptr,               /* checkAccess */
    nullptr,               /* call */
    nullptr,               /* hasInstance */
    nullptr,               /* construct */
    nullptr,               /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  eInterfacePrototype,
  &sNativePropertyHooks
};

void
CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray)
{
  JSObject* parentProto = JS_GetObjectPrototype(aCx, aGlobal);
  if (!parentProto) {
    return;
  }


  if (sChromeMethods_ids[0] == JSID_VOID &&
      !InitIds(aCx, sChromeMethods, sChromeMethods_ids)) {
    sChromeMethods_ids[0] = JSID_VOID;
    return;
  }

  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &PrototypeClass.mBase, &protoAndIfaceArray[prototypes::id::TestNonCastableInterface],
                              nullptr, &_constructor_holder, 0, &protoAndIfaceArray[constructors::id::TestNonCastableInterface],
                              &Class.mClass,
                              nullptr,
                              xpc::AccessCheck::isChrome(aGlobal) ? &sChromeOnlyNativeProperties : nullptr,
                              "TestNonCastableInterface");
}

JSObject*
DefineDOMInterface(JSContext* aCx, JSObject* aGlobal, bool* aEnabled)
{

  *aEnabled = true;
  return GetConstructorObject(aCx, aGlobal);
}


DOMJSClass Class = {
  { "TestNonCastableInterface",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(3),
    _addProperty, /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    _finalize, /* finalize */
    NULL,                  /* checkAccess */
    NULL,                  /* call */
    NULL,                  /* hasInstance */
    NULL,                  /* construct */
    NULL, /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  {
    { prototypes::id::TestNonCastableInterface, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
    true,
    &sNativePropertyHooks,
    GetParentObject<mozilla::dom::TestNonCastableInterface>::Get,
    GetProtoObject,
    nullptr
  }
};

JSObject*
Wrap(JSContext* aCx, JSObject* aScope, mozilla::dom::TestNonCastableInterface* aObject, nsWrapperCache* aCache, bool* aTriedToWrap)
{
  MOZ_ASSERT(static_cast<mozilla::dom::TestNonCastableInterface*>(aObject) ==
             reinterpret_cast<mozilla::dom::TestNonCastableInterface*>(aObject));

  *aTriedToWrap = true;

  JSObject* parent = WrapNativeParent(aCx, aScope, aObject->GetParentObject());
  if (!parent) {
    return NULL;
  }

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.  Scope so we don't
  // collide with the "obj" we declare in CreateBindingJSObject.
  {
    JSObject* obj = aCache->GetWrapper();
    if (obj) {
      return obj;
    }
  }

  JSAutoCompartment ac(aCx, parent);
  JSObject* global = JS_GetGlobalForObject(aCx, parent);

  JSObject* proto = GetProtoObject(aCx, global);
  if (!proto) {
    return NULL;
  }

  JSObject* obj = JS_NewObject(aCx, &Class.mBase, proto, parent);
  if (!obj) {
    return NULL;
  }

  js::SetReservedSlot(obj, DOM_OBJECT_SLOT, PRIVATE_TO_JSVAL(aObject));
  NS_ADDREF(aObject);


  aCache->SetWrapper(obj);

  return obj;
}

} // namespace TestNonCastableInterfaceBinding



namespace TestNonWrapperCacheInterfaceBinding {

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::dom::TestNonWrapperCacheInterface>::value), "Must be an nsISupports class");
  mozilla::dom::TestNonWrapperCacheInterface* self = UnwrapDOMObject<mozilla::dom::TestNonWrapperCacheInterface>(obj);
  if (self) {
    XPCJSRuntime *rt = nsXPConnect::GetRuntimeInstance();
    if (rt) {
      rt->DeferredRelease(reinterpret_cast<nsISupports*>(self));
    } else {
      NS_RELEASE(self);
    }
  }
}

static JSFunctionSpec sChromeMethods_specs[] = {
  JS_FNINFO("QueryInterface", QueryInterface, nullptr, 1, 0),
  JS_FS_END
};

static Prefable<JSFunctionSpec> sChromeMethods[] = {
  { true, &sChromeMethods_specs[0] },
  { false, NULL }
};

static jsid sChromeMethods_ids[2] = { JSID_VOID };


static const NativeProperties sChromeOnlyNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sChromeMethods, sChromeMethods_ids, sChromeMethods_specs,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr
};
const NativePropertyHooks sNativePropertyHooks = {
  nullptr,
  nullptr,
  { nullptr, &sChromeOnlyNativeProperties },
  prototypes::id::TestNonWrapperCacheInterface,
  constructors::id::TestNonWrapperCacheInterface,
  NULL
};

JSNativeHolder _constructor_holder = {
  ThrowingConstructor,
  &sNativePropertyHooks
};

static DOMIfaceAndProtoJSClass PrototypeClass = {
  {
    "TestNonWrapperCacheInterfacePrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(2),
    JS_PropertyStub,       /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    nullptr,               /* finalize */
    nullptr,               /* checkAccess */
    nullptr,               /* call */
    nullptr,               /* hasInstance */
    nullptr,               /* construct */
    nullptr,               /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  eInterfacePrototype,
  &sNativePropertyHooks
};

void
CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray)
{
  JSObject* parentProto = JS_GetObjectPrototype(aCx, aGlobal);
  if (!parentProto) {
    return;
  }


  if (sChromeMethods_ids[0] == JSID_VOID &&
      !InitIds(aCx, sChromeMethods, sChromeMethods_ids)) {
    sChromeMethods_ids[0] = JSID_VOID;
    return;
  }

  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &PrototypeClass.mBase, &protoAndIfaceArray[prototypes::id::TestNonWrapperCacheInterface],
                              nullptr, &_constructor_holder, 0, &protoAndIfaceArray[constructors::id::TestNonWrapperCacheInterface],
                              &Class.mClass,
                              nullptr,
                              xpc::AccessCheck::isChrome(aGlobal) ? &sChromeOnlyNativeProperties : nullptr,
                              "TestNonWrapperCacheInterface");
}

JSObject*
DefineDOMInterface(JSContext* aCx, JSObject* aGlobal, bool* aEnabled)
{

  *aEnabled = true;
  return GetConstructorObject(aCx, aGlobal);
}


DOMJSClass Class = {
  { "TestNonWrapperCacheInterface",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(3),
    JS_PropertyStub, /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    _finalize, /* finalize */
    NULL,                  /* checkAccess */
    NULL,                  /* call */
    NULL,                  /* hasInstance */
    NULL,                  /* construct */
    NULL, /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  {
    { prototypes::id::TestNonWrapperCacheInterface, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
    true,
    &sNativePropertyHooks,
    GetParentObject<mozilla::dom::TestNonWrapperCacheInterface>::Get,
    GetProtoObject,
    nullptr
  }
};

JSObject*
Wrap(JSContext* aCx, JSObject* aScope, mozilla::dom::TestNonWrapperCacheInterface* aObject)
{
  MOZ_ASSERT(static_cast<mozilla::dom::TestNonWrapperCacheInterface*>(aObject) ==
             reinterpret_cast<mozilla::dom::TestNonWrapperCacheInterface*>(aObject));

  JSObject* global = JS_GetGlobalForObject(aCx, aScope);
  JSObject* proto = GetProtoObject(aCx, global);
  if (!proto) {
    return NULL;
  }

  JSObject* obj = JS_NewObject(aCx, &Class.mBase, proto, global);
  if (!obj) {
    return NULL;
  }

  js::SetReservedSlot(obj, DOM_OBJECT_SLOT, PRIVATE_TO_JSVAL(aObject));
  NS_ADDREF(aObject);


  return obj;
}

} // namespace TestNonWrapperCacheInterfaceBinding



namespace TestRenamedInterfaceBinding {

static JSBool
_addProperty(JSContext* cx, JSHandleObject obj, JSHandleId id, JSMutableHandleValue vp)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, nsRenamedInterface>::value), "Must be an nsISupports class");
  nsRenamedInterface* self = UnwrapDOMObject<nsRenamedInterface>(obj);
  nsContentUtils::PreserveWrapper(reinterpret_cast<nsISupports*>(self), self);
  return true;
}

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, nsRenamedInterface>::value), "Must be an nsISupports class");
  nsRenamedInterface* self = UnwrapDOMObject<nsRenamedInterface>(obj);
  if (self) {
    ClearWrapper(self, self);
    XPCJSRuntime *rt = nsXPConnect::GetRuntimeInstance();
    if (rt) {
      rt->DeferredRelease(reinterpret_cast<nsISupports*>(self));
    } else {
      NS_RELEASE(self);
    }
  }
}

static JSFunctionSpec sChromeMethods_specs[] = {
  JS_FNINFO("QueryInterface", QueryInterface, nullptr, 1, 0),
  JS_FS_END
};

static Prefable<JSFunctionSpec> sChromeMethods[] = {
  { true, &sChromeMethods_specs[0] },
  { false, NULL }
};

static jsid sChromeMethods_ids[2] = { JSID_VOID };


static const NativeProperties sChromeOnlyNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sChromeMethods, sChromeMethods_ids, sChromeMethods_specs,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr
};
const NativePropertyHooks sNativePropertyHooks = {
  nullptr,
  nullptr,
  { nullptr, &sChromeOnlyNativeProperties },
  prototypes::id::TestRenamedInterface,
  constructors::id::TestRenamedInterface,
  NULL
};

JSNativeHolder _constructor_holder = {
  ThrowingConstructor,
  &sNativePropertyHooks
};

static DOMIfaceAndProtoJSClass PrototypeClass = {
  {
    "TestRenamedInterfacePrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(2),
    JS_PropertyStub,       /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    nullptr,               /* finalize */
    nullptr,               /* checkAccess */
    nullptr,               /* call */
    nullptr,               /* hasInstance */
    nullptr,               /* construct */
    nullptr,               /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  eInterfacePrototype,
  &sNativePropertyHooks
};

void
CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray)
{
  JSObject* parentProto = JS_GetObjectPrototype(aCx, aGlobal);
  if (!parentProto) {
    return;
  }


  if (sChromeMethods_ids[0] == JSID_VOID &&
      !InitIds(aCx, sChromeMethods, sChromeMethods_ids)) {
    sChromeMethods_ids[0] = JSID_VOID;
    return;
  }

  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &PrototypeClass.mBase, &protoAndIfaceArray[prototypes::id::TestRenamedInterface],
                              nullptr, &_constructor_holder, 0, &protoAndIfaceArray[constructors::id::TestRenamedInterface],
                              &Class.mClass,
                              nullptr,
                              xpc::AccessCheck::isChrome(aGlobal) ? &sChromeOnlyNativeProperties : nullptr,
                              "TestRenamedInterface");
}

JSObject*
DefineDOMInterface(JSContext* aCx, JSObject* aGlobal, bool* aEnabled)
{

  *aEnabled = true;
  return GetConstructorObject(aCx, aGlobal);
}


DOMJSClass Class = {
  { "TestRenamedInterface",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(3),
    _addProperty, /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    _finalize, /* finalize */
    NULL,                  /* checkAccess */
    NULL,                  /* call */
    NULL,                  /* hasInstance */
    NULL,                  /* construct */
    NULL, /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  {
    { prototypes::id::TestRenamedInterface, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
    true,
    &sNativePropertyHooks,
    GetParentObject<nsRenamedInterface>::Get,
    GetProtoObject,
    nullptr
  }
};

JSObject*
Wrap(JSContext* aCx, JSObject* aScope, nsRenamedInterface* aObject, nsWrapperCache* aCache, bool* aTriedToWrap)
{
  MOZ_ASSERT(static_cast<nsRenamedInterface*>(aObject) ==
             reinterpret_cast<nsRenamedInterface*>(aObject));

  *aTriedToWrap = true;

  JSObject* parent = WrapNativeParent(aCx, aScope, aObject->GetParentObject());
  if (!parent) {
    return NULL;
  }

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.  Scope so we don't
  // collide with the "obj" we declare in CreateBindingJSObject.
  {
    JSObject* obj = aCache->GetWrapper();
    if (obj) {
      return obj;
    }
  }

  JSAutoCompartment ac(aCx, parent);
  JSObject* global = JS_GetGlobalForObject(aCx, parent);

  JSObject* proto = GetProtoObject(aCx, global);
  if (!proto) {
    return NULL;
  }

  JSObject* obj = JS_NewObject(aCx, &Class.mBase, proto, parent);
  if (!obj) {
    return NULL;
  }

  js::SetReservedSlot(obj, DOM_OBJECT_SLOT, PRIVATE_TO_JSVAL(aObject));
  NS_ADDREF(aObject);


  aCache->SetWrapper(obj);

  return obj;
}

} // namespace TestRenamedInterfaceBinding



} // namespace dom
} // namespace mozilla
