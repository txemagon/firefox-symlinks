/* THIS FILE IS AUTOGENERATED - DO NOT EDIT */

#include "AccessCheck.h"
#include "DocumentBinding.h"
#include "EventListenerBinding.h"
#include "EventTargetBinding.h"
#include "HTMLCollectionBinding.h"
#include "HTMLDocumentBinding.h"
#include "HTMLElementBinding.h"
#include "LocationBinding.h"
#include "NodeBinding.h"
#include "NodeListBinding.h"
#include "PrimitiveConversions.h"
#include "WorkerPrivate.h"
#include "XPCQuickStubs.h"
#include "XPCWrapper.h"
#include "mozilla/Preferences.h"
#include "mozilla/dom/BindingUtils.h"
#include "mozilla/dom/Element.h"
#include "mozilla/dom/NonRefcountedDOMObject.h"
#include "mozilla/dom/Nullable.h"
#include "nsContentUtils.h"
#include "nsDOMQS.h"
#include "nsGenericHTMLElement.h"
#include "nsHTMLDocument.h"
#include "nsIDOMEvent.h"
#include "nsIDOMHTMLDocument.h"
#include "nsIDOMLocation.h"
#include "nsIDOMWindow.h"
#include "nsIDocument.h"
#include "nsIHTMLCollection.h"
#include "nsINodeList.h"
#include "nsISelection.h"

using namespace mozilla::dom;
namespace mozilla {
namespace dom {

namespace HTMLDocumentBinding {

static bool
get_domain(JSContext* cx, JSHandleObject obj, nsHTMLDocument* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetDomain(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "HTMLDocument", "domain");
  }
  if (!xpc::StringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_domain(JSContext* cx, JSHandleObject obj, nsHTMLDocument* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eNull, eNull, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetDomain(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "HTMLDocument", "domain");
  }

  return true;
}


const JSJitInfo domain_getterinfo = {
  (JSJitPropertyOp)get_domain,
  prototypes::id::HTMLDocument,
  PrototypeTraits<prototypes::id::HTMLDocument>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo domain_setterinfo = {
  (JSJitPropertyOp)set_domain,
  prototypes::id::HTMLDocument,
  PrototypeTraits<prototypes::id::HTMLDocument>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_cookie(JSContext* cx, JSHandleObject obj, nsHTMLDocument* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetCookie(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "HTMLDocument", "cookie");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_cookie(JSContext* cx, JSHandleObject obj, nsHTMLDocument* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eStringify, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetCookie(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "HTMLDocument", "cookie");
  }

  return true;
}


const JSJitInfo cookie_getterinfo = {
  (JSJitPropertyOp)get_cookie,
  prototypes::id::HTMLDocument,
  PrototypeTraits<prototypes::id::HTMLDocument>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo cookie_setterinfo = {
  (JSJitPropertyOp)set_cookie,
  prototypes::id::HTMLDocument,
  PrototypeTraits<prototypes::id::HTMLDocument>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_body(JSContext* cx, JSHandleObject obj, nsHTMLDocument* self, JS::Value* vp)
{
  nsGenericHTMLElement* result;
  result = self->GetBody();
  if (!result) {
    *vp = JSVAL_NULL;
    return true;
  }
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    if (!HandleNewBindingWrappingFailure(cx, obj, result, vp)) {
      return false;
    }
    return true;
  }
  return true;
}

static bool
set_body(JSContext* cx, JSHandleObject obj, nsHTMLDocument* self, JS::Value* argv)
{
  nsGenericHTMLElement* arg0;
  if (argv[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::HTMLElement, nsGenericHTMLElement>(cx, &argv[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        nsGenericHTMLElement *objPtr;
        xpc_qsSelfRef objRef;
        JS::Value val = JS::ObjectValue(*&argv[0].toObject());
        nsresult rv = xpc_qsUnwrapArg<nsGenericHTMLElement>(cx, val, &objPtr, &objRef.ptr, &val);
        if (NS_FAILED(rv)) {
            ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "HTMLElement");
            return false;
        }
        // We should be castable!
        MOZ_ASSERT(!objRef.ptr);
        // We should have an object, too!
        MOZ_ASSERT(objPtr);
        arg0 = objPtr;
      }
    }
  } else if (argv[0].isNullOrUndefined()) {
    arg0 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  ErrorResult rv;
  self->SetBody(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "HTMLDocument", "body");
  }

  return true;
}


const JSJitInfo body_getterinfo = {
  (JSJitPropertyOp)get_body,
  prototypes::id::HTMLDocument,
  PrototypeTraits<prototypes::id::HTMLDocument>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo body_setterinfo = {
  (JSJitPropertyOp)set_body,
  prototypes::id::HTMLDocument,
  PrototypeTraits<prototypes::id::HTMLDocument>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_head(JSContext* cx, JSHandleObject obj, nsHTMLDocument* self, JS::Value* vp)
{
  mozilla::dom::Element* result;
  result = self->GetHead();
  if (!result) {
    *vp = JSVAL_NULL;
    return true;
  }
  if (!WrapObject(cx, obj, result, vp)) {
    return false;
  }
  return true;
}


const JSJitInfo head_getterinfo = {
  (JSJitPropertyOp)get_head,
  prototypes::id::HTMLDocument,
  PrototypeTraits<prototypes::id::HTMLDocument>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_images(JSContext* cx, JSHandleObject obj, nsHTMLDocument* self, JS::Value* vp)
{
  nsIHTMLCollection* result;
  result = self->Images();
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}


const JSJitInfo images_getterinfo = {
  (JSJitPropertyOp)get_images,
  prototypes::id::HTMLDocument,
  PrototypeTraits<prototypes::id::HTMLDocument>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_embeds(JSContext* cx, JSHandleObject obj, nsHTMLDocument* self, JS::Value* vp)
{
  nsIHTMLCollection* result;
  result = self->Embeds();
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}


const JSJitInfo embeds_getterinfo = {
  (JSJitPropertyOp)get_embeds,
  prototypes::id::HTMLDocument,
  PrototypeTraits<prototypes::id::HTMLDocument>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_plugins(JSContext* cx, JSHandleObject obj, nsHTMLDocument* self, JS::Value* vp)
{
  nsIHTMLCollection* result;
  result = self->Plugins();
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}


const JSJitInfo plugins_getterinfo = {
  (JSJitPropertyOp)get_plugins,
  prototypes::id::HTMLDocument,
  PrototypeTraits<prototypes::id::HTMLDocument>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_links(JSContext* cx, JSHandleObject obj, nsHTMLDocument* self, JS::Value* vp)
{
  nsIHTMLCollection* result;
  result = self->Links();
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}


const JSJitInfo links_getterinfo = {
  (JSJitPropertyOp)get_links,
  prototypes::id::HTMLDocument,
  PrototypeTraits<prototypes::id::HTMLDocument>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_forms(JSContext* cx, JSHandleObject obj, nsHTMLDocument* self, JS::Value* vp)
{
  nsIHTMLCollection* result;
  result = self->Forms();
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}


const JSJitInfo forms_getterinfo = {
  (JSJitPropertyOp)get_forms,
  prototypes::id::HTMLDocument,
  PrototypeTraits<prototypes::id::HTMLDocument>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_scripts(JSContext* cx, JSHandleObject obj, nsHTMLDocument* self, JS::Value* vp)
{
  nsIHTMLCollection* result;
  result = self->Scripts();
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}


const JSJitInfo scripts_getterinfo = {
  (JSJitPropertyOp)get_scripts,
  prototypes::id::HTMLDocument,
  PrototypeTraits<prototypes::id::HTMLDocument>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
getElementsByName(JSContext* cx, JSHandleObject obj, nsHTMLDocument* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "HTMLDocument.getElementsByName");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eStringify, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  nsRefPtr<nsINodeList> result;
  result = self->GetElementsByName(arg0);
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}


const JSJitInfo getElementsByName_methodinfo = {
  (JSJitPropertyOp)getElementsByName,
  prototypes::id::HTMLDocument,
  PrototypeTraits<prototypes::id::HTMLDocument>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
getItems(JSContext* cx, JSHandleObject obj, nsHTMLDocument* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (0 < argc) {
    if (!ConvertJSValueToString(cx, argv[0], &argv[0], eStringify, eStringify, arg0_holder)) {
      return false;
    }
  } else {
    static const PRUnichar data[] = { 0 };
    arg0_holder.SetData(data, ArrayLength(data) - 1);
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  nsRefPtr<nsINodeList> result;
  result = self->GetItems(arg0);
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}


const JSJitInfo getItems_methodinfo = {
  (JSJitPropertyOp)getItems,
  prototypes::id::HTMLDocument,
  PrototypeTraits<prototypes::id::HTMLDocument>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
open(JSContext* cx, JSHandleObject obj, nsHTMLDocument* self, unsigned argc, JS::Value* vp)
{

  unsigned argcount = NS_MIN(argc, 4u);
  switch (argcount) {
    case 0: {
      /* Fall through */
    }
    case 1: {
      /* Fall through */
    }
    case 2: {

      JS::Value* argv = JS_ARGV(cx, vp);

      FakeDependentString arg0_holder;
      const NonNull<nsAString> arg0;
      if (0 < argc) {
        if (!ConvertJSValueToString(cx, argv[0], &argv[0], eStringify, eStringify, arg0_holder)) {
          return false;
        }
      } else {
        static const PRUnichar data[] = { 't', 'e', 'x', 't', '/', 'h', 't', 'm', 'l', 0 };
        arg0_holder.SetData(data, ArrayLength(data) - 1);
      }
      const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
      FakeDependentString arg1_holder;
      const NonNull<nsAString> arg1;
      if (1 < argc) {
        if (!ConvertJSValueToString(cx, argv[1], &argv[1], eStringify, eStringify, arg1_holder)) {
          return false;
        }
      } else {
        static const PRUnichar data[] = { 0 };
        arg1_holder.SetData(data, ArrayLength(data) - 1);
      }
      const_cast<NonNull<nsAString>&>(arg1) = &arg1_holder;
      ErrorResult rv;
      nsRefPtr<nsIDocument> result;
      result = self->Open(cx, arg0, arg1, rv);
      if (rv.Failed()) {
        return ThrowMethodFailedWithDetails<true>(cx, rv, "HTMLDocument", "open");
      }
      if (!WrapNewBindingObject(cx, obj, result, vp)) {
        if (!HandleNewBindingWrappingFailure(cx, obj, result, vp)) {
          return false;
        }
        return true;
      }
      return true;
      break;
    }
    case 3: {
      /* Fall through */
    }
    case 4: {

      JS::Value* argv = JS_ARGV(cx, vp);

      FakeDependentString arg0_holder;
      const NonNull<nsAString> arg0;
      if (!ConvertJSValueToString(cx, argv[0], &argv[0], eStringify, eStringify, arg0_holder)) {
        return false;
      }
      const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
      FakeDependentString arg1_holder;
      const NonNull<nsAString> arg1;
      if (!ConvertJSValueToString(cx, argv[1], &argv[1], eStringify, eStringify, arg1_holder)) {
        return false;
      }
      const_cast<NonNull<nsAString>&>(arg1) = &arg1_holder;
      FakeDependentString arg2_holder;
      const NonNull<nsAString> arg2;
      if (!ConvertJSValueToString(cx, argv[2], &argv[2], eStringify, eStringify, arg2_holder)) {
        return false;
      }
      const_cast<NonNull<nsAString>&>(arg2) = &arg2_holder;
      bool arg3;
      if (3 < argc) {
        if (!ValueToPrimitive<bool, eDefault>(cx, argv[3], &arg3)) {
          return false;
        }
      } else {
        arg3 = false;
      }
      ErrorResult rv;
      nsRefPtr<nsIDOMWindow> result;
      result = self->Open(cx, arg0, arg1, arg2, arg3, rv);
      if (rv.Failed()) {
        return ThrowMethodFailedWithDetails<true>(cx, rv, "HTMLDocument", "open");
      }
      if (!WrapObject(cx, obj, result, vp)) {
        return false;
      }
      return true;
      break;
    }
    default: {
      return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "HTMLDocument.open");

      break;
    }
  }
  MOZ_NOT_REACHED("We have an always-returning default case");
  return false;
}


const JSJitInfo open_methodinfo = {
  (JSJitPropertyOp)open,
  prototypes::id::HTMLDocument,
  PrototypeTraits<prototypes::id::HTMLDocument>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
close(JSContext* cx, JSHandleObject obj, nsHTMLDocument* self, unsigned argc, JS::Value* vp)
{
  ErrorResult rv;
  self->Close(rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "HTMLDocument", "close");
  }
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo close_methodinfo = {
  (JSJitPropertyOp)close,
  prototypes::id::HTMLDocument,
  PrototypeTraits<prototypes::id::HTMLDocument>::Depth,
  JSJitInfo::Method,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
write(JSContext* cx, JSHandleObject obj, nsHTMLDocument* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  const Sequence< nsString > arg0;
  if (argc > 0) {
    Sequence< nsString >& arr = const_cast< Sequence< nsString >& >(arg0);
    if (!arr.SetCapacity(argc - 0)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t variadicArg = 0; variadicArg < argc; ++variadicArg) {
      nsString& slot = *arr.AppendElement();
      {
        FakeDependentString str;
        if (!ConvertJSValueToString(cx, argv[variadicArg], &argv[variadicArg], eStringify, eStringify, str)) {
          return false;
        }
        slot = str;
      }

    }
  }
  ErrorResult rv;
  self->Write(cx, arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "HTMLDocument", "write");
  }
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo write_methodinfo = {
  (JSJitPropertyOp)write,
  prototypes::id::HTMLDocument,
  PrototypeTraits<prototypes::id::HTMLDocument>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
writeln(JSContext* cx, JSHandleObject obj, nsHTMLDocument* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  const Sequence< nsString > arg0;
  if (argc > 0) {
    Sequence< nsString >& arr = const_cast< Sequence< nsString >& >(arg0);
    if (!arr.SetCapacity(argc - 0)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t variadicArg = 0; variadicArg < argc; ++variadicArg) {
      nsString& slot = *arr.AppendElement();
      {
        FakeDependentString str;
        if (!ConvertJSValueToString(cx, argv[variadicArg], &argv[variadicArg], eStringify, eStringify, str)) {
          return false;
        }
        slot = str;
      }

    }
  }
  ErrorResult rv;
  self->Writeln(cx, arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "HTMLDocument", "writeln");
  }
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo writeln_methodinfo = {
  (JSJitPropertyOp)writeln,
  prototypes::id::HTMLDocument,
  PrototypeTraits<prototypes::id::HTMLDocument>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_designMode(JSContext* cx, JSHandleObject obj, nsHTMLDocument* self, JS::Value* vp)
{
  nsString result;
  self->GetDesignMode(result);
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_designMode(JSContext* cx, JSHandleObject obj, nsHTMLDocument* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eStringify, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetDesignMode(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "HTMLDocument", "designMode");
  }

  return true;
}


const JSJitInfo designMode_getterinfo = {
  (JSJitPropertyOp)get_designMode,
  prototypes::id::HTMLDocument,
  PrototypeTraits<prototypes::id::HTMLDocument>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo designMode_setterinfo = {
  (JSJitPropertyOp)set_designMode,
  prototypes::id::HTMLDocument,
  PrototypeTraits<prototypes::id::HTMLDocument>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
execCommand(JSContext* cx, JSHandleObject obj, nsHTMLDocument* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "HTMLDocument.execCommand");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eStringify, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  bool arg1;
  if (1 < argc) {
    if (!ValueToPrimitive<bool, eDefault>(cx, argv[1], &arg1)) {
      return false;
    }
  } else {
    arg1 = false;
  }
  FakeDependentString arg2_holder;
  const NonNull<nsAString> arg2;
  if (2 < argc) {
    if (!ConvertJSValueToString(cx, argv[2], &argv[2], eStringify, eStringify, arg2_holder)) {
      return false;
    }
  } else {
    static const PRUnichar data[] = { 0 };
    arg2_holder.SetData(data, ArrayLength(data) - 1);
  }
  const_cast<NonNull<nsAString>&>(arg2) = &arg2_holder;
  ErrorResult rv;
  bool result;
  result = self->ExecCommand(arg0, arg1, arg2, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "HTMLDocument", "execCommand");
  }
  *vp = BOOLEAN_TO_JSVAL(result);
  return true;
}


const JSJitInfo execCommand_methodinfo = {
  (JSJitPropertyOp)execCommand,
  prototypes::id::HTMLDocument,
  PrototypeTraits<prototypes::id::HTMLDocument>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

static bool
queryCommandEnabled(JSContext* cx, JSHandleObject obj, nsHTMLDocument* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "HTMLDocument.queryCommandEnabled");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eStringify, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  bool result;
  result = self->QueryCommandEnabled(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "HTMLDocument", "queryCommandEnabled");
  }
  *vp = BOOLEAN_TO_JSVAL(result);
  return true;
}


const JSJitInfo queryCommandEnabled_methodinfo = {
  (JSJitPropertyOp)queryCommandEnabled,
  prototypes::id::HTMLDocument,
  PrototypeTraits<prototypes::id::HTMLDocument>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

static bool
queryCommandIndeterm(JSContext* cx, JSHandleObject obj, nsHTMLDocument* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "HTMLDocument.queryCommandIndeterm");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eStringify, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  bool result;
  result = self->QueryCommandIndeterm(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "HTMLDocument", "queryCommandIndeterm");
  }
  *vp = BOOLEAN_TO_JSVAL(result);
  return true;
}


const JSJitInfo queryCommandIndeterm_methodinfo = {
  (JSJitPropertyOp)queryCommandIndeterm,
  prototypes::id::HTMLDocument,
  PrototypeTraits<prototypes::id::HTMLDocument>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

static bool
queryCommandState(JSContext* cx, JSHandleObject obj, nsHTMLDocument* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "HTMLDocument.queryCommandState");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eStringify, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  bool result;
  result = self->QueryCommandState(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "HTMLDocument", "queryCommandState");
  }
  *vp = BOOLEAN_TO_JSVAL(result);
  return true;
}


const JSJitInfo queryCommandState_methodinfo = {
  (JSJitPropertyOp)queryCommandState,
  prototypes::id::HTMLDocument,
  PrototypeTraits<prototypes::id::HTMLDocument>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

static bool
queryCommandSupported(JSContext* cx, JSHandleObject obj, nsHTMLDocument* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "HTMLDocument.queryCommandSupported");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eStringify, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  bool result;
  result = self->QueryCommandSupported(arg0);
  *vp = BOOLEAN_TO_JSVAL(result);
  return true;
}


const JSJitInfo queryCommandSupported_methodinfo = {
  (JSJitPropertyOp)queryCommandSupported,
  prototypes::id::HTMLDocument,
  PrototypeTraits<prototypes::id::HTMLDocument>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

static bool
queryCommandValue(JSContext* cx, JSHandleObject obj, nsHTMLDocument* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "HTMLDocument.queryCommandValue");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eStringify, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  nsString result;
  self->QueryCommandValue(arg0, result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "HTMLDocument", "queryCommandValue");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}


const JSJitInfo queryCommandValue_methodinfo = {
  (JSJitPropertyOp)queryCommandValue,
  prototypes::id::HTMLDocument,
  PrototypeTraits<prototypes::id::HTMLDocument>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_fgColor(JSContext* cx, JSHandleObject obj, nsHTMLDocument* self, JS::Value* vp)
{
  nsString result;
  self->GetFgColor(result);
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_fgColor(JSContext* cx, JSHandleObject obj, nsHTMLDocument* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  self->SetFgColor(arg0);

  return true;
}


const JSJitInfo fgColor_getterinfo = {
  (JSJitPropertyOp)get_fgColor,
  prototypes::id::HTMLDocument,
  PrototypeTraits<prototypes::id::HTMLDocument>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo fgColor_setterinfo = {
  (JSJitPropertyOp)set_fgColor,
  prototypes::id::HTMLDocument,
  PrototypeTraits<prototypes::id::HTMLDocument>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_linkColor(JSContext* cx, JSHandleObject obj, nsHTMLDocument* self, JS::Value* vp)
{
  nsString result;
  self->GetLinkColor(result);
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_linkColor(JSContext* cx, JSHandleObject obj, nsHTMLDocument* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  self->SetLinkColor(arg0);

  return true;
}


const JSJitInfo linkColor_getterinfo = {
  (JSJitPropertyOp)get_linkColor,
  prototypes::id::HTMLDocument,
  PrototypeTraits<prototypes::id::HTMLDocument>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo linkColor_setterinfo = {
  (JSJitPropertyOp)set_linkColor,
  prototypes::id::HTMLDocument,
  PrototypeTraits<prototypes::id::HTMLDocument>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_vlinkColor(JSContext* cx, JSHandleObject obj, nsHTMLDocument* self, JS::Value* vp)
{
  nsString result;
  self->GetVlinkColor(result);
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_vlinkColor(JSContext* cx, JSHandleObject obj, nsHTMLDocument* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  self->SetVlinkColor(arg0);

  return true;
}


const JSJitInfo vlinkColor_getterinfo = {
  (JSJitPropertyOp)get_vlinkColor,
  prototypes::id::HTMLDocument,
  PrototypeTraits<prototypes::id::HTMLDocument>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo vlinkColor_setterinfo = {
  (JSJitPropertyOp)set_vlinkColor,
  prototypes::id::HTMLDocument,
  PrototypeTraits<prototypes::id::HTMLDocument>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_alinkColor(JSContext* cx, JSHandleObject obj, nsHTMLDocument* self, JS::Value* vp)
{
  nsString result;
  self->GetAlinkColor(result);
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_alinkColor(JSContext* cx, JSHandleObject obj, nsHTMLDocument* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  self->SetAlinkColor(arg0);

  return true;
}


const JSJitInfo alinkColor_getterinfo = {
  (JSJitPropertyOp)get_alinkColor,
  prototypes::id::HTMLDocument,
  PrototypeTraits<prototypes::id::HTMLDocument>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo alinkColor_setterinfo = {
  (JSJitPropertyOp)set_alinkColor,
  prototypes::id::HTMLDocument,
  PrototypeTraits<prototypes::id::HTMLDocument>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_bgColor(JSContext* cx, JSHandleObject obj, nsHTMLDocument* self, JS::Value* vp)
{
  nsString result;
  self->GetBgColor(result);
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_bgColor(JSContext* cx, JSHandleObject obj, nsHTMLDocument* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  self->SetBgColor(arg0);

  return true;
}


const JSJitInfo bgColor_getterinfo = {
  (JSJitPropertyOp)get_bgColor,
  prototypes::id::HTMLDocument,
  PrototypeTraits<prototypes::id::HTMLDocument>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo bgColor_setterinfo = {
  (JSJitPropertyOp)set_bgColor,
  prototypes::id::HTMLDocument,
  PrototypeTraits<prototypes::id::HTMLDocument>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_anchors(JSContext* cx, JSHandleObject obj, nsHTMLDocument* self, JS::Value* vp)
{
  nsIHTMLCollection* result;
  result = self->Anchors();
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}


const JSJitInfo anchors_getterinfo = {
  (JSJitPropertyOp)get_anchors,
  prototypes::id::HTMLDocument,
  PrototypeTraits<prototypes::id::HTMLDocument>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_applets(JSContext* cx, JSHandleObject obj, nsHTMLDocument* self, JS::Value* vp)
{
  nsIHTMLCollection* result;
  result = self->Applets();
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}


const JSJitInfo applets_getterinfo = {
  (JSJitPropertyOp)get_applets,
  prototypes::id::HTMLDocument,
  PrototypeTraits<prototypes::id::HTMLDocument>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
clear(JSContext* cx, JSHandleObject obj, nsHTMLDocument* self, unsigned argc, JS::Value* vp)
{
  self->Clear();
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo clear_methodinfo = {
  (JSJitPropertyOp)clear,
  prototypes::id::HTMLDocument,
  PrototypeTraits<prototypes::id::HTMLDocument>::Depth,
  JSJitInfo::Method,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
getSelection(JSContext* cx, JSHandleObject obj, nsHTMLDocument* self, unsigned argc, JS::Value* vp)
{
  ErrorResult rv;
  nsRefPtr<nsISelection> result;
  result = self->GetSelection(rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "HTMLDocument", "getSelection");
  }
  if (!WrapObject(cx, obj, result, vp)) {
    return false;
  }
  return true;
}


const JSJitInfo getSelection_methodinfo = {
  (JSJitPropertyOp)getSelection,
  prototypes::id::HTMLDocument,
  PrototypeTraits<prototypes::id::HTMLDocument>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
captureEvents(JSContext* cx, JSHandleObject obj, nsHTMLDocument* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "HTMLDocument.captureEvents");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  int32_t arg0;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  self->CaptureEvents(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo captureEvents_methodinfo = {
  (JSJitPropertyOp)captureEvents,
  prototypes::id::HTMLDocument,
  PrototypeTraits<prototypes::id::HTMLDocument>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
releaseEvents(JSContext* cx, JSHandleObject obj, nsHTMLDocument* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "HTMLDocument.releaseEvents");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  int32_t arg0;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  self->ReleaseEvents(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo releaseEvents_methodinfo = {
  (JSJitPropertyOp)releaseEvents,
  prototypes::id::HTMLDocument,
  PrototypeTraits<prototypes::id::HTMLDocument>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
routeEvent(JSContext* cx, JSHandleObject obj, nsHTMLDocument* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "HTMLDocument.routeEvent");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  nsRefPtr<nsIDOMEvent> arg0_holder;
  nsIDOMEvent* arg0;
  if (argv[0].isObject()) {
    jsval tmpVal = argv[0];
    nsIDOMEvent* tmp;
    if (NS_FAILED(xpc_qsUnwrapArg<nsIDOMEvent>(cx, argv[0], &tmp, static_cast<nsIDOMEvent**>(getter_AddRefs(arg0_holder)), &tmpVal))) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "Event");return false;
    }
    MOZ_ASSERT(tmp);
    if (tmpVal != argv[0] && !arg0_holder) {
      // We have to have a strong ref, because we got this off
      // some random object that might get GCed
      arg0_holder = tmp;
    }
    arg0 = tmp;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->RouteEvent(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo routeEvent_methodinfo = {
  (JSJitPropertyOp)routeEvent,
  prototypes::id::HTMLDocument,
  PrototypeTraits<prototypes::id::HTMLDocument>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_location(JSContext* cx, JSHandleObject obj, nsHTMLDocument* self, JS::Value* vp)
{
  nsRefPtr<nsIDOMLocation> result;
  result = self->GetLocation();
  if (!result) {
    *vp = JSVAL_NULL;
    return true;
  }
  if (!WrapObject(cx, obj, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_location(JSContext* cx, JSHandleObject obj, nsHTMLDocument* self, JS::Value* argv)
{
  js::RootedValue v(cx);
  if (!JS_GetProperty(cx, obj, "location", v.address())) {
    return false;
  }

  if (!v.isObject()) {
    return ThrowErrorMessage(cx, MSG_NOT_OBJECT);
  }

  return JS_SetProperty(cx, &v.toObject(), "href", argv);
}


const JSJitInfo location_getterinfo = {
  (JSJitPropertyOp)get_location,
  prototypes::id::HTMLDocument,
  PrototypeTraits<prototypes::id::HTMLDocument>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo location_setterinfo = {
  (JSJitPropertyOp)set_location,
  prototypes::id::HTMLDocument,
  PrototypeTraits<prototypes::id::HTMLDocument>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static JSBool
genericMethod(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  nsHTMLDocument* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::HTMLDocument, nsHTMLDocument>(cx, obj, self);
    if (NS_FAILED(rv)) {
      nsHTMLDocument *objPtr;
      xpc_qsSelfRef objRef;
      JS::Value val = JS::ObjectValue(*obj);
      nsresult rv = xpc_qsUnwrapArg<nsHTMLDocument>(cx, val, &objPtr, &objRef.ptr, &val);
      if (NS_FAILED(rv)) {
          return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "HTMLDocument");
      }
      // We should be castable!
      MOZ_ASSERT(!objRef.ptr);
      // We should have an object, too!
      MOZ_ASSERT(objPtr);
      self = objPtr;
    }
  }
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Method);
  JSJitMethodOp method = (JSJitMethodOp)info->op;
  return method(cx, obj, self, argc, vp);
}

static JSBool
genericGetter(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  nsHTMLDocument* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::HTMLDocument, nsHTMLDocument>(cx, obj, self);
    if (NS_FAILED(rv)) {
      nsHTMLDocument *objPtr;
      xpc_qsSelfRef objRef;
      JS::Value val = JS::ObjectValue(*obj);
      nsresult rv = xpc_qsUnwrapArg<nsHTMLDocument>(cx, val, &objPtr, &objRef.ptr, &val);
      if (NS_FAILED(rv)) {
          return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "HTMLDocument");
      }
      // We should be castable!
      MOZ_ASSERT(!objRef.ptr);
      // We should have an object, too!
      MOZ_ASSERT(objPtr);
      self = objPtr;
    }
  }
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Getter);
  JSJitPropertyOp getter = info->op;
  return getter(cx, obj, self, vp);
}

static JSBool
genericSetter(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  nsHTMLDocument* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::HTMLDocument, nsHTMLDocument>(cx, obj, self);
    if (NS_FAILED(rv)) {
      nsHTMLDocument *objPtr;
      xpc_qsSelfRef objRef;
      JS::Value val = JS::ObjectValue(*obj);
      nsresult rv = xpc_qsUnwrapArg<nsHTMLDocument>(cx, val, &objPtr, &objRef.ptr, &val);
      if (NS_FAILED(rv)) {
          return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "HTMLDocument");
      }
      // We should be castable!
      MOZ_ASSERT(!objRef.ptr);
      // We should have an object, too!
      MOZ_ASSERT(objPtr);
      self = objPtr;
    }
  }
  if (argc == 0) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "HTMLDocument attribute setter");
  }
  JS::Value* argv = JS_ARGV(cx, vp);
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Setter);
  JSJitPropertyOp setter = info->op;
  if (!setter(cx, obj, self, argv)) {
    return false;
  }
  *vp = JSVAL_VOID;
  return true;
}

static JSBool
_addProperty(JSContext* cx, JSHandleObject obj, JSHandleId id, JSMutableHandleValue vp)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, nsHTMLDocument>::value), "Must be an nsISupports class");
  nsHTMLDocument* self = UnwrapDOMObject<nsHTMLDocument>(obj);
  nsContentUtils::PreserveWrapper(reinterpret_cast<nsISupports*>(self), self);
  return true;
}

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, nsHTMLDocument>::value), "Must be an nsISupports class");
  nsHTMLDocument* self = UnwrapDOMObject<nsHTMLDocument>(obj);
  if (self) {
    ClearWrapper(self, self);
    XPCJSRuntime *rt = nsXPConnect::GetRuntimeInstance();
    if (rt) {
      rt->DeferredRelease(reinterpret_cast<nsISupports*>(self));
    } else {
      NS_RELEASE(self);
    }
  }
}

static JSFunctionSpec sMethods_specs[] = {
  JS_FNINFO("getElementsByName", genericMethod, &getElementsByName_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("getItems", genericMethod, &getItems_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("open", genericMethod, &open_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("close", genericMethod, &close_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("write", genericMethod, &write_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("writeln", genericMethod, &writeln_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("execCommand", genericMethod, &execCommand_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("queryCommandEnabled", genericMethod, &queryCommandEnabled_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("queryCommandIndeterm", genericMethod, &queryCommandIndeterm_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("queryCommandState", genericMethod, &queryCommandState_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("queryCommandSupported", genericMethod, &queryCommandSupported_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("queryCommandValue", genericMethod, &queryCommandValue_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("clear", genericMethod, &clear_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("getSelection", genericMethod, &getSelection_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("captureEvents", genericMethod, &captureEvents_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("releaseEvents", genericMethod, &releaseEvents_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("routeEvent", genericMethod, &routeEvent_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FS_END
};

static Prefable<JSFunctionSpec> sMethods[] = {
  { true, &sMethods_specs[0] },
  { false, NULL }
};

static jsid sMethods_ids[18] = { JSID_VOID };

static JSPropertySpec sAttributes_specs[] = {
  { "domain", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &domain_getterinfo }, { (JSStrictPropertyOp)genericSetter, &domain_setterinfo }},
  { "cookie", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &cookie_getterinfo }, { (JSStrictPropertyOp)genericSetter, &cookie_setterinfo }},
  { "body", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &body_getterinfo }, { (JSStrictPropertyOp)genericSetter, &body_setterinfo }},
  { "head", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &head_getterinfo }, JSOP_NULLWRAPPER},
  { "images", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &images_getterinfo }, JSOP_NULLWRAPPER},
  { "embeds", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &embeds_getterinfo }, JSOP_NULLWRAPPER},
  { "plugins", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &plugins_getterinfo }, JSOP_NULLWRAPPER},
  { "links", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &links_getterinfo }, JSOP_NULLWRAPPER},
  { "forms", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &forms_getterinfo }, JSOP_NULLWRAPPER},
  { "scripts", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &scripts_getterinfo }, JSOP_NULLWRAPPER},
  { "designMode", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &designMode_getterinfo }, { (JSStrictPropertyOp)genericSetter, &designMode_setterinfo }},
  { "fgColor", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &fgColor_getterinfo }, { (JSStrictPropertyOp)genericSetter, &fgColor_setterinfo }},
  { "linkColor", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &linkColor_getterinfo }, { (JSStrictPropertyOp)genericSetter, &linkColor_setterinfo }},
  { "vlinkColor", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &vlinkColor_getterinfo }, { (JSStrictPropertyOp)genericSetter, &vlinkColor_setterinfo }},
  { "alinkColor", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &alinkColor_getterinfo }, { (JSStrictPropertyOp)genericSetter, &alinkColor_setterinfo }},
  { "bgColor", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &bgColor_getterinfo }, { (JSStrictPropertyOp)genericSetter, &bgColor_setterinfo }},
  { "anchors", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &anchors_getterinfo }, JSOP_NULLWRAPPER},
  { "applets", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &applets_getterinfo }, JSOP_NULLWRAPPER},
  { 0, 0, 0, JSOP_NULLWRAPPER, JSOP_NULLWRAPPER }
};

static Prefable<JSPropertySpec> sAttributes[] = {
  { true, &sAttributes_specs[0] },
  { false, NULL }
};

static jsid sAttributes_ids[19] = { JSID_VOID };

static JSPropertySpec sUnforgeableAttributes_specs[] = {
  { "location", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS | JSPROP_PERMANENT, { (JSPropertyOp)genericGetter, &location_getterinfo }, { (JSStrictPropertyOp)genericSetter, &location_setterinfo }},
  { 0, 0, 0, JSOP_NULLWRAPPER, JSOP_NULLWRAPPER }
};

static Prefable<JSPropertySpec> sUnforgeableAttributes[] = {
  { true, &sUnforgeableAttributes_specs[0] },
  { false, NULL }
};

static jsid sUnforgeableAttributes_ids[2] = { JSID_VOID };


static const NativeProperties sNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sMethods, sMethods_ids, sMethods_specs,
  sAttributes, sAttributes_ids, sAttributes_specs,
  sUnforgeableAttributes, sUnforgeableAttributes_ids, sUnforgeableAttributes_specs,
  nullptr, nullptr, nullptr
};
const NativePropertyHooks sNativePropertyHooks = {
  nullptr,
  nullptr,
  { &sNativeProperties, nullptr },
  prototypes::id::HTMLDocument,
  constructors::id::HTMLDocument,
  &DocumentBinding::sNativePropertyHooks
};

static JSBool
_hasInstance(JSContext* cx, JSHandleObject obj, JSMutableHandleValue vp, JSBool* bp)
{
  if (!vp.isObject()) {
    *bp = false;
    return true;
  }

  jsval protov;
  if (!JS_GetProperty(cx, obj, "prototype", &protov))
    return false;
  if (!protov.isObject()) {
    JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_BAD_PROTOTYPE,
                         "HTMLDocument");
    return false;
  }
  JSObject *objProto = &protov.toObject();

  JSObject* instance = &vp.toObject();
  JSObject* proto;
  if (!JS_GetPrototype(cx, instance, &proto))
    return false;
  while (proto) {
    if (proto == objProto) {
      *bp = true;
      return true;
    }
    if (!JS_GetPrototype(cx, proto, &proto))
      return false;
  }

  // FIXME Limit this to chrome by checking xpc::AccessCheck::isChrome(obj).
  nsISupports* native =
    nsContentUtils::XPConnect()->GetNativeOfWrapper(cx, instance);
  nsCOMPtr<nsIDOMHTMLDocument> qiResult = do_QueryInterface(native);
  *bp = !!qiResult;
  return true;

}


static DOMIfaceAndProtoJSClass InterfaceObjectClass = {
  {
    "Function",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(2),
    JS_PropertyStub,       /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    nullptr,               /* finalize */
    nullptr,               /* checkAccess */
    ThrowingConstructor, /* call */
    _hasInstance, /* hasInstance */
    ThrowingConstructor, /* construct */
    nullptr,               /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  eInterface,
  &sNativePropertyHooks
};

static DOMIfaceAndProtoJSClass PrototypeClass = {
  {
    "HTMLDocumentPrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(2),
    JS_PropertyStub,       /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    nullptr,               /* finalize */
    nullptr,               /* checkAccess */
    nullptr,               /* call */
    nullptr,               /* hasInstance */
    nullptr,               /* construct */
    nullptr,               /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  eInterfacePrototype,
  &sNativePropertyHooks
};

void
CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray)
{
  JSObject* parentProto = DocumentBinding::GetProtoObject(aCx, aGlobal);
  if (!parentProto) {
    return;
  }


  if (sMethods_ids[0] == JSID_VOID &&
      (!InitIds(aCx, sMethods, sMethods_ids) ||
       !InitIds(aCx, sAttributes, sAttributes_ids) ||
       !InitIds(aCx, sUnforgeableAttributes, sUnforgeableAttributes_ids))) {
    sMethods_ids[0] = JSID_VOID;
    return;
  }

  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &PrototypeClass.mBase, &protoAndIfaceArray[prototypes::id::HTMLDocument],
                              &InterfaceObjectClass.mBase, nullptr, 0, &protoAndIfaceArray[constructors::id::HTMLDocument],
                              &Class.mClass,
                              &sNativeProperties,
                              nullptr,
                              "HTMLDocument");
}

JSObject*
DefineDOMInterface(JSContext* aCx, JSObject* aGlobal, bool* aEnabled)
{

  *aEnabled = true;
  return GetConstructorObject(aCx, aGlobal);
}


DOMJSClass Class = {
  { "HTMLDocument",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(3),
    _addProperty, /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    _finalize, /* finalize */
    NULL,                  /* checkAccess */
    NULL,                  /* call */
    NULL,                  /* hasInstance */
    NULL,                  /* construct */
    NULL, /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  {
    { prototypes::id::EventTarget, prototypes::id::Node, prototypes::id::Document, prototypes::id::HTMLDocument, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
    true,
    &sNativePropertyHooks,
    GetParentObject<nsHTMLDocument>::Get,
    GetProtoObject,
    nullptr
  }
};

JSObject*
Wrap(JSContext* aCx, JSObject* aScope, nsHTMLDocument* aObject, nsWrapperCache* aCache, bool* aTriedToWrap)
{
  MOZ_ASSERT(static_cast<nsHTMLDocument*>(aObject) ==
             reinterpret_cast<nsHTMLDocument*>(aObject));
  MOZ_ASSERT(static_cast<nsIDocument*>(aObject) ==
             reinterpret_cast<nsIDocument*>(aObject));
  MOZ_ASSERT(static_cast<nsINode*>(aObject) ==
             reinterpret_cast<nsINode*>(aObject));
  MOZ_ASSERT(static_cast<mozilla::dom::EventTarget*>(aObject) ==
             reinterpret_cast<mozilla::dom::EventTarget*>(aObject));

  *aTriedToWrap = true;

  JSObject* parent = WrapNativeParent(aCx, aScope, aObject->GetParentObject());
  if (!parent) {
    return NULL;
  }

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.  Scope so we don't
  // collide with the "obj" we declare in CreateBindingJSObject.
  {
    JSObject* obj = aCache->GetWrapper();
    if (obj) {
      return obj;
    }
  }

  JSAutoCompartment ac(aCx, parent);
  JSObject* global = JS_GetGlobalForObject(aCx, parent);

  JSObject* proto = GetProtoObject(aCx, global);
  if (!proto) {
    return NULL;
  }

  JSObject* obj = JS_NewObject(aCx, &Class.mBase, proto, parent);
  if (!obj) {
    return NULL;
  }

  js::SetReservedSlot(obj, DOM_OBJECT_SLOT, PRIVATE_TO_JSVAL(aObject));
  NS_ADDREF(aObject);


  // Important: do unforgeable property setup after we have handed
  // over ownership of the C++ object to obj as needed, so that if
  // we fail and it ends up GCed it won't have problems in the
  // finalizer trying to drop its ownership of the C++ object.
  if (!DefineUnforgeableAttributes(aCx, obj, sUnforgeableAttributes)) {
    return nullptr;
  }

  aCache->SetWrapper(obj);

  return obj;
}

} // namespace HTMLDocumentBinding



} // namespace dom
} // namespace mozilla
