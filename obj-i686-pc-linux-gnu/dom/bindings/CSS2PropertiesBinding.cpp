/* THIS FILE IS AUTOGENERATED - DO NOT EDIT */

#include "AccessCheck.h"
#include "CSS2PropertiesBinding.h"
#include "CSSStyleDeclarationBinding.h"
#include "PrimitiveConversions.h"
#include "WorkerPrivate.h"
#include "XPCQuickStubs.h"
#include "XPCWrapper.h"
#include "mozilla/Preferences.h"
#include "mozilla/dom/BindingUtils.h"
#include "mozilla/dom/NonRefcountedDOMObject.h"
#include "mozilla/dom/Nullable.h"
#include "nsContentUtils.h"
#include "nsDOMCSSDeclaration.h"
#include "nsDOMQS.h"

using namespace mozilla::dom;
namespace mozilla {
namespace dom {

namespace CSS2PropertiesBinding {

static bool
get_MozAppearance(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozAppearance(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozAppearance");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozAppearance(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozAppearance(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozAppearance");
  }

  return true;
}


const JSJitInfo MozAppearance_getterinfo = {
  (JSJitPropertyOp)get_MozAppearance,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozAppearance_setterinfo = {
  (JSJitPropertyOp)set_MozAppearance,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozOutlineRadius(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozOutlineRadius(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozOutlineRadius");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozOutlineRadius(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozOutlineRadius(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozOutlineRadius");
  }

  return true;
}


const JSJitInfo MozOutlineRadius_getterinfo = {
  (JSJitPropertyOp)get_MozOutlineRadius,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozOutlineRadius_setterinfo = {
  (JSJitPropertyOp)set_MozOutlineRadius,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozOutlineRadiusTopleft(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozOutlineRadiusTopleft(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozOutlineRadiusTopleft");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozOutlineRadiusTopleft(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozOutlineRadiusTopleft(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozOutlineRadiusTopleft");
  }

  return true;
}


const JSJitInfo MozOutlineRadiusTopleft_getterinfo = {
  (JSJitPropertyOp)get_MozOutlineRadiusTopleft,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozOutlineRadiusTopleft_setterinfo = {
  (JSJitPropertyOp)set_MozOutlineRadiusTopleft,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozOutlineRadiusTopright(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozOutlineRadiusTopright(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozOutlineRadiusTopright");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozOutlineRadiusTopright(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozOutlineRadiusTopright(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozOutlineRadiusTopright");
  }

  return true;
}


const JSJitInfo MozOutlineRadiusTopright_getterinfo = {
  (JSJitPropertyOp)get_MozOutlineRadiusTopright,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozOutlineRadiusTopright_setterinfo = {
  (JSJitPropertyOp)set_MozOutlineRadiusTopright,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozOutlineRadiusBottomright(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozOutlineRadiusBottomright(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozOutlineRadiusBottomright");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozOutlineRadiusBottomright(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozOutlineRadiusBottomright(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozOutlineRadiusBottomright");
  }

  return true;
}


const JSJitInfo MozOutlineRadiusBottomright_getterinfo = {
  (JSJitPropertyOp)get_MozOutlineRadiusBottomright,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozOutlineRadiusBottomright_setterinfo = {
  (JSJitPropertyOp)set_MozOutlineRadiusBottomright,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozOutlineRadiusBottomleft(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozOutlineRadiusBottomleft(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozOutlineRadiusBottomleft");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozOutlineRadiusBottomleft(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozOutlineRadiusBottomleft(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozOutlineRadiusBottomleft");
  }

  return true;
}


const JSJitInfo MozOutlineRadiusBottomleft_getterinfo = {
  (JSJitPropertyOp)get_MozOutlineRadiusBottomleft,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozOutlineRadiusBottomleft_setterinfo = {
  (JSJitPropertyOp)set_MozOutlineRadiusBottomleft,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozTabSize(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozTabSize(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozTabSize");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozTabSize(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozTabSize(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozTabSize");
  }

  return true;
}


const JSJitInfo MozTabSize_getterinfo = {
  (JSJitPropertyOp)get_MozTabSize,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozTabSize_setterinfo = {
  (JSJitPropertyOp)set_MozTabSize,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_animation(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetAnimation(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "animation");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_animation(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetAnimation(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "animation");
  }

  return true;
}


const JSJitInfo animation_getterinfo = {
  (JSJitPropertyOp)get_animation,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo animation_setterinfo = {
  (JSJitPropertyOp)set_animation,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_animationDelay(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetAnimationDelay(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "animationDelay");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_animationDelay(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetAnimationDelay(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "animationDelay");
  }

  return true;
}


const JSJitInfo animationDelay_getterinfo = {
  (JSJitPropertyOp)get_animationDelay,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo animationDelay_setterinfo = {
  (JSJitPropertyOp)set_animationDelay,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_animationDirection(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetAnimationDirection(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "animationDirection");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_animationDirection(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetAnimationDirection(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "animationDirection");
  }

  return true;
}


const JSJitInfo animationDirection_getterinfo = {
  (JSJitPropertyOp)get_animationDirection,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo animationDirection_setterinfo = {
  (JSJitPropertyOp)set_animationDirection,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_animationDuration(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetAnimationDuration(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "animationDuration");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_animationDuration(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetAnimationDuration(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "animationDuration");
  }

  return true;
}


const JSJitInfo animationDuration_getterinfo = {
  (JSJitPropertyOp)get_animationDuration,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo animationDuration_setterinfo = {
  (JSJitPropertyOp)set_animationDuration,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_animationFillMode(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetAnimationFillMode(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "animationFillMode");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_animationFillMode(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetAnimationFillMode(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "animationFillMode");
  }

  return true;
}


const JSJitInfo animationFillMode_getterinfo = {
  (JSJitPropertyOp)get_animationFillMode,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo animationFillMode_setterinfo = {
  (JSJitPropertyOp)set_animationFillMode,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_animationIterationCount(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetAnimationIterationCount(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "animationIterationCount");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_animationIterationCount(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetAnimationIterationCount(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "animationIterationCount");
  }

  return true;
}


const JSJitInfo animationIterationCount_getterinfo = {
  (JSJitPropertyOp)get_animationIterationCount,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo animationIterationCount_setterinfo = {
  (JSJitPropertyOp)set_animationIterationCount,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_animationName(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetAnimationName(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "animationName");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_animationName(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetAnimationName(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "animationName");
  }

  return true;
}


const JSJitInfo animationName_getterinfo = {
  (JSJitPropertyOp)get_animationName,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo animationName_setterinfo = {
  (JSJitPropertyOp)set_animationName,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_animationPlayState(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetAnimationPlayState(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "animationPlayState");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_animationPlayState(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetAnimationPlayState(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "animationPlayState");
  }

  return true;
}


const JSJitInfo animationPlayState_getterinfo = {
  (JSJitPropertyOp)get_animationPlayState,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo animationPlayState_setterinfo = {
  (JSJitPropertyOp)set_animationPlayState,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_animationTimingFunction(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetAnimationTimingFunction(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "animationTimingFunction");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_animationTimingFunction(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetAnimationTimingFunction(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "animationTimingFunction");
  }

  return true;
}


const JSJitInfo animationTimingFunction_getterinfo = {
  (JSJitPropertyOp)get_animationTimingFunction,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo animationTimingFunction_setterinfo = {
  (JSJitPropertyOp)set_animationTimingFunction,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_background(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetBackground(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "background");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_background(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetBackground(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "background");
  }

  return true;
}


const JSJitInfo background_getterinfo = {
  (JSJitPropertyOp)get_background,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo background_setterinfo = {
  (JSJitPropertyOp)set_background,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_backgroundAttachment(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetBackgroundAttachment(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "backgroundAttachment");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_backgroundAttachment(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetBackgroundAttachment(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "backgroundAttachment");
  }

  return true;
}


const JSJitInfo backgroundAttachment_getterinfo = {
  (JSJitPropertyOp)get_backgroundAttachment,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo backgroundAttachment_setterinfo = {
  (JSJitPropertyOp)set_backgroundAttachment,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_backgroundClip(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetBackgroundClip(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "backgroundClip");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_backgroundClip(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetBackgroundClip(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "backgroundClip");
  }

  return true;
}


const JSJitInfo backgroundClip_getterinfo = {
  (JSJitPropertyOp)get_backgroundClip,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo backgroundClip_setterinfo = {
  (JSJitPropertyOp)set_backgroundClip,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_backgroundColor(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetBackgroundColor(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "backgroundColor");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_backgroundColor(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetBackgroundColor(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "backgroundColor");
  }

  return true;
}


const JSJitInfo backgroundColor_getterinfo = {
  (JSJitPropertyOp)get_backgroundColor,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo backgroundColor_setterinfo = {
  (JSJitPropertyOp)set_backgroundColor,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_backgroundImage(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetBackgroundImage(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "backgroundImage");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_backgroundImage(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetBackgroundImage(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "backgroundImage");
  }

  return true;
}


const JSJitInfo backgroundImage_getterinfo = {
  (JSJitPropertyOp)get_backgroundImage,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo backgroundImage_setterinfo = {
  (JSJitPropertyOp)set_backgroundImage,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozBackgroundInlinePolicy(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozBackgroundInlinePolicy(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozBackgroundInlinePolicy");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozBackgroundInlinePolicy(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozBackgroundInlinePolicy(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozBackgroundInlinePolicy");
  }

  return true;
}


const JSJitInfo MozBackgroundInlinePolicy_getterinfo = {
  (JSJitPropertyOp)get_MozBackgroundInlinePolicy,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozBackgroundInlinePolicy_setterinfo = {
  (JSJitPropertyOp)set_MozBackgroundInlinePolicy,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_backgroundOrigin(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetBackgroundOrigin(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "backgroundOrigin");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_backgroundOrigin(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetBackgroundOrigin(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "backgroundOrigin");
  }

  return true;
}


const JSJitInfo backgroundOrigin_getterinfo = {
  (JSJitPropertyOp)get_backgroundOrigin,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo backgroundOrigin_setterinfo = {
  (JSJitPropertyOp)set_backgroundOrigin,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_backgroundPosition(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetBackgroundPosition(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "backgroundPosition");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_backgroundPosition(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetBackgroundPosition(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "backgroundPosition");
  }

  return true;
}


const JSJitInfo backgroundPosition_getterinfo = {
  (JSJitPropertyOp)get_backgroundPosition,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo backgroundPosition_setterinfo = {
  (JSJitPropertyOp)set_backgroundPosition,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_backgroundRepeat(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetBackgroundRepeat(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "backgroundRepeat");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_backgroundRepeat(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetBackgroundRepeat(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "backgroundRepeat");
  }

  return true;
}


const JSJitInfo backgroundRepeat_getterinfo = {
  (JSJitPropertyOp)get_backgroundRepeat,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo backgroundRepeat_setterinfo = {
  (JSJitPropertyOp)set_backgroundRepeat,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_backgroundSize(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetBackgroundSize(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "backgroundSize");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_backgroundSize(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetBackgroundSize(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "backgroundSize");
  }

  return true;
}


const JSJitInfo backgroundSize_getterinfo = {
  (JSJitPropertyOp)get_backgroundSize,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo backgroundSize_setterinfo = {
  (JSJitPropertyOp)set_backgroundSize,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozBinding(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozBinding(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozBinding");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozBinding(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozBinding(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozBinding");
  }

  return true;
}


const JSJitInfo MozBinding_getterinfo = {
  (JSJitPropertyOp)get_MozBinding,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozBinding_setterinfo = {
  (JSJitPropertyOp)set_MozBinding,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_border(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetBorder(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "border");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_border(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetBorder(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "border");
  }

  return true;
}


const JSJitInfo border_getterinfo = {
  (JSJitPropertyOp)get_border,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo border_setterinfo = {
  (JSJitPropertyOp)set_border,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_borderBottom(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetBorderBottom(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "borderBottom");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_borderBottom(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetBorderBottom(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "borderBottom");
  }

  return true;
}


const JSJitInfo borderBottom_getterinfo = {
  (JSJitPropertyOp)get_borderBottom,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo borderBottom_setterinfo = {
  (JSJitPropertyOp)set_borderBottom,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_borderBottomColor(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetBorderBottomColor(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "borderBottomColor");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_borderBottomColor(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetBorderBottomColor(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "borderBottomColor");
  }

  return true;
}


const JSJitInfo borderBottomColor_getterinfo = {
  (JSJitPropertyOp)get_borderBottomColor,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo borderBottomColor_setterinfo = {
  (JSJitPropertyOp)set_borderBottomColor,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozBorderBottomColors(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozBorderBottomColors(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozBorderBottomColors");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozBorderBottomColors(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozBorderBottomColors(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozBorderBottomColors");
  }

  return true;
}


const JSJitInfo MozBorderBottomColors_getterinfo = {
  (JSJitPropertyOp)get_MozBorderBottomColors,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozBorderBottomColors_setterinfo = {
  (JSJitPropertyOp)set_MozBorderBottomColors,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_borderBottomStyle(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetBorderBottomStyle(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "borderBottomStyle");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_borderBottomStyle(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetBorderBottomStyle(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "borderBottomStyle");
  }

  return true;
}


const JSJitInfo borderBottomStyle_getterinfo = {
  (JSJitPropertyOp)get_borderBottomStyle,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo borderBottomStyle_setterinfo = {
  (JSJitPropertyOp)set_borderBottomStyle,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_borderBottomWidth(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetBorderBottomWidth(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "borderBottomWidth");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_borderBottomWidth(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetBorderBottomWidth(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "borderBottomWidth");
  }

  return true;
}


const JSJitInfo borderBottomWidth_getterinfo = {
  (JSJitPropertyOp)get_borderBottomWidth,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo borderBottomWidth_setterinfo = {
  (JSJitPropertyOp)set_borderBottomWidth,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_borderCollapse(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetBorderCollapse(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "borderCollapse");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_borderCollapse(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetBorderCollapse(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "borderCollapse");
  }

  return true;
}


const JSJitInfo borderCollapse_getterinfo = {
  (JSJitPropertyOp)get_borderCollapse,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo borderCollapse_setterinfo = {
  (JSJitPropertyOp)set_borderCollapse,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_borderColor(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetBorderColor(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "borderColor");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_borderColor(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetBorderColor(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "borderColor");
  }

  return true;
}


const JSJitInfo borderColor_getterinfo = {
  (JSJitPropertyOp)get_borderColor,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo borderColor_setterinfo = {
  (JSJitPropertyOp)set_borderColor,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozBorderEnd(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozBorderEnd(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozBorderEnd");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozBorderEnd(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozBorderEnd(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozBorderEnd");
  }

  return true;
}


const JSJitInfo MozBorderEnd_getterinfo = {
  (JSJitPropertyOp)get_MozBorderEnd,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozBorderEnd_setterinfo = {
  (JSJitPropertyOp)set_MozBorderEnd,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozBorderEndColor(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozBorderEndColor(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozBorderEndColor");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozBorderEndColor(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozBorderEndColor(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozBorderEndColor");
  }

  return true;
}


const JSJitInfo MozBorderEndColor_getterinfo = {
  (JSJitPropertyOp)get_MozBorderEndColor,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozBorderEndColor_setterinfo = {
  (JSJitPropertyOp)set_MozBorderEndColor,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozBorderEndStyle(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozBorderEndStyle(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozBorderEndStyle");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozBorderEndStyle(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozBorderEndStyle(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozBorderEndStyle");
  }

  return true;
}


const JSJitInfo MozBorderEndStyle_getterinfo = {
  (JSJitPropertyOp)get_MozBorderEndStyle,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozBorderEndStyle_setterinfo = {
  (JSJitPropertyOp)set_MozBorderEndStyle,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozBorderEndWidth(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozBorderEndWidth(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozBorderEndWidth");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozBorderEndWidth(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozBorderEndWidth(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozBorderEndWidth");
  }

  return true;
}


const JSJitInfo MozBorderEndWidth_getterinfo = {
  (JSJitPropertyOp)get_MozBorderEndWidth,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozBorderEndWidth_setterinfo = {
  (JSJitPropertyOp)set_MozBorderEndWidth,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_borderImage(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetBorderImage(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "borderImage");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_borderImage(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetBorderImage(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "borderImage");
  }

  return true;
}


const JSJitInfo borderImage_getterinfo = {
  (JSJitPropertyOp)get_borderImage,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo borderImage_setterinfo = {
  (JSJitPropertyOp)set_borderImage,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_borderImageSource(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetBorderImageSource(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "borderImageSource");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_borderImageSource(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetBorderImageSource(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "borderImageSource");
  }

  return true;
}


const JSJitInfo borderImageSource_getterinfo = {
  (JSJitPropertyOp)get_borderImageSource,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo borderImageSource_setterinfo = {
  (JSJitPropertyOp)set_borderImageSource,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_borderImageSlice(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetBorderImageSlice(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "borderImageSlice");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_borderImageSlice(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetBorderImageSlice(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "borderImageSlice");
  }

  return true;
}


const JSJitInfo borderImageSlice_getterinfo = {
  (JSJitPropertyOp)get_borderImageSlice,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo borderImageSlice_setterinfo = {
  (JSJitPropertyOp)set_borderImageSlice,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_borderImageWidth(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetBorderImageWidth(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "borderImageWidth");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_borderImageWidth(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetBorderImageWidth(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "borderImageWidth");
  }

  return true;
}


const JSJitInfo borderImageWidth_getterinfo = {
  (JSJitPropertyOp)get_borderImageWidth,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo borderImageWidth_setterinfo = {
  (JSJitPropertyOp)set_borderImageWidth,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_borderImageOutset(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetBorderImageOutset(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "borderImageOutset");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_borderImageOutset(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetBorderImageOutset(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "borderImageOutset");
  }

  return true;
}


const JSJitInfo borderImageOutset_getterinfo = {
  (JSJitPropertyOp)get_borderImageOutset,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo borderImageOutset_setterinfo = {
  (JSJitPropertyOp)set_borderImageOutset,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_borderImageRepeat(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetBorderImageRepeat(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "borderImageRepeat");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_borderImageRepeat(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetBorderImageRepeat(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "borderImageRepeat");
  }

  return true;
}


const JSJitInfo borderImageRepeat_getterinfo = {
  (JSJitPropertyOp)get_borderImageRepeat,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo borderImageRepeat_setterinfo = {
  (JSJitPropertyOp)set_borderImageRepeat,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_borderLeft(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetBorderLeft(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "borderLeft");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_borderLeft(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetBorderLeft(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "borderLeft");
  }

  return true;
}


const JSJitInfo borderLeft_getterinfo = {
  (JSJitPropertyOp)get_borderLeft,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo borderLeft_setterinfo = {
  (JSJitPropertyOp)set_borderLeft,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_borderLeftColor(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetBorderLeftColor(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "borderLeftColor");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_borderLeftColor(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetBorderLeftColor(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "borderLeftColor");
  }

  return true;
}


const JSJitInfo borderLeftColor_getterinfo = {
  (JSJitPropertyOp)get_borderLeftColor,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo borderLeftColor_setterinfo = {
  (JSJitPropertyOp)set_borderLeftColor,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozBorderLeftColors(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozBorderLeftColors(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozBorderLeftColors");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozBorderLeftColors(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozBorderLeftColors(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozBorderLeftColors");
  }

  return true;
}


const JSJitInfo MozBorderLeftColors_getterinfo = {
  (JSJitPropertyOp)get_MozBorderLeftColors,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozBorderLeftColors_setterinfo = {
  (JSJitPropertyOp)set_MozBorderLeftColors,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_borderLeftStyle(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetBorderLeftStyle(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "borderLeftStyle");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_borderLeftStyle(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetBorderLeftStyle(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "borderLeftStyle");
  }

  return true;
}


const JSJitInfo borderLeftStyle_getterinfo = {
  (JSJitPropertyOp)get_borderLeftStyle,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo borderLeftStyle_setterinfo = {
  (JSJitPropertyOp)set_borderLeftStyle,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_borderLeftWidth(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetBorderLeftWidth(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "borderLeftWidth");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_borderLeftWidth(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetBorderLeftWidth(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "borderLeftWidth");
  }

  return true;
}


const JSJitInfo borderLeftWidth_getterinfo = {
  (JSJitPropertyOp)get_borderLeftWidth,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo borderLeftWidth_setterinfo = {
  (JSJitPropertyOp)set_borderLeftWidth,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_borderRight(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetBorderRight(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "borderRight");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_borderRight(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetBorderRight(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "borderRight");
  }

  return true;
}


const JSJitInfo borderRight_getterinfo = {
  (JSJitPropertyOp)get_borderRight,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo borderRight_setterinfo = {
  (JSJitPropertyOp)set_borderRight,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_borderRightColor(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetBorderRightColor(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "borderRightColor");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_borderRightColor(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetBorderRightColor(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "borderRightColor");
  }

  return true;
}


const JSJitInfo borderRightColor_getterinfo = {
  (JSJitPropertyOp)get_borderRightColor,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo borderRightColor_setterinfo = {
  (JSJitPropertyOp)set_borderRightColor,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozBorderRightColors(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozBorderRightColors(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozBorderRightColors");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozBorderRightColors(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozBorderRightColors(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozBorderRightColors");
  }

  return true;
}


const JSJitInfo MozBorderRightColors_getterinfo = {
  (JSJitPropertyOp)get_MozBorderRightColors,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozBorderRightColors_setterinfo = {
  (JSJitPropertyOp)set_MozBorderRightColors,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_borderRightStyle(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetBorderRightStyle(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "borderRightStyle");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_borderRightStyle(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetBorderRightStyle(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "borderRightStyle");
  }

  return true;
}


const JSJitInfo borderRightStyle_getterinfo = {
  (JSJitPropertyOp)get_borderRightStyle,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo borderRightStyle_setterinfo = {
  (JSJitPropertyOp)set_borderRightStyle,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_borderRightWidth(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetBorderRightWidth(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "borderRightWidth");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_borderRightWidth(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetBorderRightWidth(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "borderRightWidth");
  }

  return true;
}


const JSJitInfo borderRightWidth_getterinfo = {
  (JSJitPropertyOp)get_borderRightWidth,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo borderRightWidth_setterinfo = {
  (JSJitPropertyOp)set_borderRightWidth,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_borderSpacing(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetBorderSpacing(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "borderSpacing");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_borderSpacing(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetBorderSpacing(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "borderSpacing");
  }

  return true;
}


const JSJitInfo borderSpacing_getterinfo = {
  (JSJitPropertyOp)get_borderSpacing,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo borderSpacing_setterinfo = {
  (JSJitPropertyOp)set_borderSpacing,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozBorderStart(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozBorderStart(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozBorderStart");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozBorderStart(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozBorderStart(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozBorderStart");
  }

  return true;
}


const JSJitInfo MozBorderStart_getterinfo = {
  (JSJitPropertyOp)get_MozBorderStart,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozBorderStart_setterinfo = {
  (JSJitPropertyOp)set_MozBorderStart,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozBorderStartColor(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozBorderStartColor(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozBorderStartColor");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozBorderStartColor(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozBorderStartColor(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozBorderStartColor");
  }

  return true;
}


const JSJitInfo MozBorderStartColor_getterinfo = {
  (JSJitPropertyOp)get_MozBorderStartColor,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozBorderStartColor_setterinfo = {
  (JSJitPropertyOp)set_MozBorderStartColor,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozBorderStartStyle(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozBorderStartStyle(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozBorderStartStyle");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozBorderStartStyle(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozBorderStartStyle(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozBorderStartStyle");
  }

  return true;
}


const JSJitInfo MozBorderStartStyle_getterinfo = {
  (JSJitPropertyOp)get_MozBorderStartStyle,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozBorderStartStyle_setterinfo = {
  (JSJitPropertyOp)set_MozBorderStartStyle,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozBorderStartWidth(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozBorderStartWidth(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozBorderStartWidth");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozBorderStartWidth(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozBorderStartWidth(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozBorderStartWidth");
  }

  return true;
}


const JSJitInfo MozBorderStartWidth_getterinfo = {
  (JSJitPropertyOp)get_MozBorderStartWidth,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozBorderStartWidth_setterinfo = {
  (JSJitPropertyOp)set_MozBorderStartWidth,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_borderStyle(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetBorderStyle(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "borderStyle");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_borderStyle(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetBorderStyle(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "borderStyle");
  }

  return true;
}


const JSJitInfo borderStyle_getterinfo = {
  (JSJitPropertyOp)get_borderStyle,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo borderStyle_setterinfo = {
  (JSJitPropertyOp)set_borderStyle,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_borderTop(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetBorderTop(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "borderTop");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_borderTop(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetBorderTop(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "borderTop");
  }

  return true;
}


const JSJitInfo borderTop_getterinfo = {
  (JSJitPropertyOp)get_borderTop,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo borderTop_setterinfo = {
  (JSJitPropertyOp)set_borderTop,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_borderTopColor(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetBorderTopColor(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "borderTopColor");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_borderTopColor(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetBorderTopColor(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "borderTopColor");
  }

  return true;
}


const JSJitInfo borderTopColor_getterinfo = {
  (JSJitPropertyOp)get_borderTopColor,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo borderTopColor_setterinfo = {
  (JSJitPropertyOp)set_borderTopColor,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozBorderTopColors(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozBorderTopColors(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozBorderTopColors");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozBorderTopColors(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozBorderTopColors(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozBorderTopColors");
  }

  return true;
}


const JSJitInfo MozBorderTopColors_getterinfo = {
  (JSJitPropertyOp)get_MozBorderTopColors,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozBorderTopColors_setterinfo = {
  (JSJitPropertyOp)set_MozBorderTopColors,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_borderTopStyle(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetBorderTopStyle(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "borderTopStyle");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_borderTopStyle(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetBorderTopStyle(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "borderTopStyle");
  }

  return true;
}


const JSJitInfo borderTopStyle_getterinfo = {
  (JSJitPropertyOp)get_borderTopStyle,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo borderTopStyle_setterinfo = {
  (JSJitPropertyOp)set_borderTopStyle,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_borderTopWidth(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetBorderTopWidth(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "borderTopWidth");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_borderTopWidth(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetBorderTopWidth(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "borderTopWidth");
  }

  return true;
}


const JSJitInfo borderTopWidth_getterinfo = {
  (JSJitPropertyOp)get_borderTopWidth,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo borderTopWidth_setterinfo = {
  (JSJitPropertyOp)set_borderTopWidth,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_borderWidth(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetBorderWidth(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "borderWidth");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_borderWidth(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetBorderWidth(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "borderWidth");
  }

  return true;
}


const JSJitInfo borderWidth_getterinfo = {
  (JSJitPropertyOp)get_borderWidth,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo borderWidth_setterinfo = {
  (JSJitPropertyOp)set_borderWidth,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_borderRadius(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetBorderRadius(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "borderRadius");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_borderRadius(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetBorderRadius(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "borderRadius");
  }

  return true;
}


const JSJitInfo borderRadius_getterinfo = {
  (JSJitPropertyOp)get_borderRadius,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo borderRadius_setterinfo = {
  (JSJitPropertyOp)set_borderRadius,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_borderTopLeftRadius(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetBorderTopLeftRadius(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "borderTopLeftRadius");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_borderTopLeftRadius(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetBorderTopLeftRadius(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "borderTopLeftRadius");
  }

  return true;
}


const JSJitInfo borderTopLeftRadius_getterinfo = {
  (JSJitPropertyOp)get_borderTopLeftRadius,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo borderTopLeftRadius_setterinfo = {
  (JSJitPropertyOp)set_borderTopLeftRadius,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_borderTopRightRadius(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetBorderTopRightRadius(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "borderTopRightRadius");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_borderTopRightRadius(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetBorderTopRightRadius(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "borderTopRightRadius");
  }

  return true;
}


const JSJitInfo borderTopRightRadius_getterinfo = {
  (JSJitPropertyOp)get_borderTopRightRadius,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo borderTopRightRadius_setterinfo = {
  (JSJitPropertyOp)set_borderTopRightRadius,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_borderBottomRightRadius(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetBorderBottomRightRadius(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "borderBottomRightRadius");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_borderBottomRightRadius(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetBorderBottomRightRadius(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "borderBottomRightRadius");
  }

  return true;
}


const JSJitInfo borderBottomRightRadius_getterinfo = {
  (JSJitPropertyOp)get_borderBottomRightRadius,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo borderBottomRightRadius_setterinfo = {
  (JSJitPropertyOp)set_borderBottomRightRadius,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_borderBottomLeftRadius(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetBorderBottomLeftRadius(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "borderBottomLeftRadius");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_borderBottomLeftRadius(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetBorderBottomLeftRadius(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "borderBottomLeftRadius");
  }

  return true;
}


const JSJitInfo borderBottomLeftRadius_getterinfo = {
  (JSJitPropertyOp)get_borderBottomLeftRadius,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo borderBottomLeftRadius_setterinfo = {
  (JSJitPropertyOp)set_borderBottomLeftRadius,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_bottom(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetBottom(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "bottom");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_bottom(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetBottom(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "bottom");
  }

  return true;
}


const JSJitInfo bottom_getterinfo = {
  (JSJitPropertyOp)get_bottom,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo bottom_setterinfo = {
  (JSJitPropertyOp)set_bottom,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_boxShadow(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetBoxShadow(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "boxShadow");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_boxShadow(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetBoxShadow(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "boxShadow");
  }

  return true;
}


const JSJitInfo boxShadow_getterinfo = {
  (JSJitPropertyOp)get_boxShadow,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo boxShadow_setterinfo = {
  (JSJitPropertyOp)set_boxShadow,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozBoxSizing(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozBoxSizing(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozBoxSizing");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozBoxSizing(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozBoxSizing(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozBoxSizing");
  }

  return true;
}


const JSJitInfo MozBoxSizing_getterinfo = {
  (JSJitPropertyOp)get_MozBoxSizing,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozBoxSizing_setterinfo = {
  (JSJitPropertyOp)set_MozBoxSizing,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_captionSide(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetCaptionSide(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "captionSide");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_captionSide(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetCaptionSide(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "captionSide");
  }

  return true;
}


const JSJitInfo captionSide_getterinfo = {
  (JSJitPropertyOp)get_captionSide,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo captionSide_setterinfo = {
  (JSJitPropertyOp)set_captionSide,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_clear(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetClear(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "clear");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_clear(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetClear(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "clear");
  }

  return true;
}


const JSJitInfo clear_getterinfo = {
  (JSJitPropertyOp)get_clear,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo clear_setterinfo = {
  (JSJitPropertyOp)set_clear,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_clip(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetClip(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "clip");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_clip(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetClip(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "clip");
  }

  return true;
}


const JSJitInfo clip_getterinfo = {
  (JSJitPropertyOp)get_clip,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo clip_setterinfo = {
  (JSJitPropertyOp)set_clip,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_color(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetColor(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "color");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_color(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetColor(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "color");
  }

  return true;
}


const JSJitInfo color_getterinfo = {
  (JSJitPropertyOp)get_color,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo color_setterinfo = {
  (JSJitPropertyOp)set_color,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozColumns(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozColumns(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozColumns");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozColumns(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozColumns(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozColumns");
  }

  return true;
}


const JSJitInfo MozColumns_getterinfo = {
  (JSJitPropertyOp)get_MozColumns,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozColumns_setterinfo = {
  (JSJitPropertyOp)set_MozColumns,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozColumnCount(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozColumnCount(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozColumnCount");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozColumnCount(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozColumnCount(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozColumnCount");
  }

  return true;
}


const JSJitInfo MozColumnCount_getterinfo = {
  (JSJitPropertyOp)get_MozColumnCount,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozColumnCount_setterinfo = {
  (JSJitPropertyOp)set_MozColumnCount,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozColumnWidth(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozColumnWidth(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozColumnWidth");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozColumnWidth(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozColumnWidth(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozColumnWidth");
  }

  return true;
}


const JSJitInfo MozColumnWidth_getterinfo = {
  (JSJitPropertyOp)get_MozColumnWidth,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozColumnWidth_setterinfo = {
  (JSJitPropertyOp)set_MozColumnWidth,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozColumnGap(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozColumnGap(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozColumnGap");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozColumnGap(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozColumnGap(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozColumnGap");
  }

  return true;
}


const JSJitInfo MozColumnGap_getterinfo = {
  (JSJitPropertyOp)get_MozColumnGap,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozColumnGap_setterinfo = {
  (JSJitPropertyOp)set_MozColumnGap,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozColumnRule(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozColumnRule(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozColumnRule");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozColumnRule(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozColumnRule(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozColumnRule");
  }

  return true;
}


const JSJitInfo MozColumnRule_getterinfo = {
  (JSJitPropertyOp)get_MozColumnRule,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozColumnRule_setterinfo = {
  (JSJitPropertyOp)set_MozColumnRule,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozColumnRuleColor(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozColumnRuleColor(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozColumnRuleColor");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozColumnRuleColor(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozColumnRuleColor(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozColumnRuleColor");
  }

  return true;
}


const JSJitInfo MozColumnRuleColor_getterinfo = {
  (JSJitPropertyOp)get_MozColumnRuleColor,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozColumnRuleColor_setterinfo = {
  (JSJitPropertyOp)set_MozColumnRuleColor,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozColumnRuleStyle(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozColumnRuleStyle(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozColumnRuleStyle");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozColumnRuleStyle(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozColumnRuleStyle(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozColumnRuleStyle");
  }

  return true;
}


const JSJitInfo MozColumnRuleStyle_getterinfo = {
  (JSJitPropertyOp)get_MozColumnRuleStyle,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozColumnRuleStyle_setterinfo = {
  (JSJitPropertyOp)set_MozColumnRuleStyle,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozColumnRuleWidth(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozColumnRuleWidth(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozColumnRuleWidth");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozColumnRuleWidth(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozColumnRuleWidth(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozColumnRuleWidth");
  }

  return true;
}


const JSJitInfo MozColumnRuleWidth_getterinfo = {
  (JSJitPropertyOp)get_MozColumnRuleWidth,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozColumnRuleWidth_setterinfo = {
  (JSJitPropertyOp)set_MozColumnRuleWidth,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_content(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetContent(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "content");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_content(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetContent(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "content");
  }

  return true;
}


const JSJitInfo content_getterinfo = {
  (JSJitPropertyOp)get_content,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo content_setterinfo = {
  (JSJitPropertyOp)set_content,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_counterIncrement(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetCounterIncrement(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "counterIncrement");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_counterIncrement(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetCounterIncrement(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "counterIncrement");
  }

  return true;
}


const JSJitInfo counterIncrement_getterinfo = {
  (JSJitPropertyOp)get_counterIncrement,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo counterIncrement_setterinfo = {
  (JSJitPropertyOp)set_counterIncrement,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_counterReset(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetCounterReset(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "counterReset");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_counterReset(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetCounterReset(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "counterReset");
  }

  return true;
}


const JSJitInfo counterReset_getterinfo = {
  (JSJitPropertyOp)get_counterReset,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo counterReset_setterinfo = {
  (JSJitPropertyOp)set_counterReset,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_cursor(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetCursor(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "cursor");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_cursor(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetCursor(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "cursor");
  }

  return true;
}


const JSJitInfo cursor_getterinfo = {
  (JSJitPropertyOp)get_cursor,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo cursor_setterinfo = {
  (JSJitPropertyOp)set_cursor,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_direction(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetDirection(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "direction");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_direction(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetDirection(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "direction");
  }

  return true;
}


const JSJitInfo direction_getterinfo = {
  (JSJitPropertyOp)get_direction,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo direction_setterinfo = {
  (JSJitPropertyOp)set_direction,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_display(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetDisplay(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "display");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_display(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetDisplay(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "display");
  }

  return true;
}


const JSJitInfo display_getterinfo = {
  (JSJitPropertyOp)get_display,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo display_setterinfo = {
  (JSJitPropertyOp)set_display,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_emptyCells(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetEmptyCells(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "emptyCells");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_emptyCells(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetEmptyCells(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "emptyCells");
  }

  return true;
}


const JSJitInfo emptyCells_getterinfo = {
  (JSJitPropertyOp)get_emptyCells,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo emptyCells_setterinfo = {
  (JSJitPropertyOp)set_emptyCells,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_alignItems(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetAlignItems(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "alignItems");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_alignItems(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetAlignItems(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "alignItems");
  }

  return true;
}


const JSJitInfo alignItems_getterinfo = {
  (JSJitPropertyOp)get_alignItems,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo alignItems_setterinfo = {
  (JSJitPropertyOp)set_alignItems,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_alignSelf(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetAlignSelf(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "alignSelf");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_alignSelf(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetAlignSelf(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "alignSelf");
  }

  return true;
}


const JSJitInfo alignSelf_getterinfo = {
  (JSJitPropertyOp)get_alignSelf,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo alignSelf_setterinfo = {
  (JSJitPropertyOp)set_alignSelf,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_flex(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetFlex(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "flex");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_flex(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetFlex(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "flex");
  }

  return true;
}


const JSJitInfo flex_getterinfo = {
  (JSJitPropertyOp)get_flex,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo flex_setterinfo = {
  (JSJitPropertyOp)set_flex,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_flexBasis(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetFlexBasis(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "flexBasis");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_flexBasis(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetFlexBasis(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "flexBasis");
  }

  return true;
}


const JSJitInfo flexBasis_getterinfo = {
  (JSJitPropertyOp)get_flexBasis,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo flexBasis_setterinfo = {
  (JSJitPropertyOp)set_flexBasis,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_flexDirection(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetFlexDirection(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "flexDirection");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_flexDirection(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetFlexDirection(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "flexDirection");
  }

  return true;
}


const JSJitInfo flexDirection_getterinfo = {
  (JSJitPropertyOp)get_flexDirection,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo flexDirection_setterinfo = {
  (JSJitPropertyOp)set_flexDirection,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_flexGrow(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetFlexGrow(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "flexGrow");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_flexGrow(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetFlexGrow(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "flexGrow");
  }

  return true;
}


const JSJitInfo flexGrow_getterinfo = {
  (JSJitPropertyOp)get_flexGrow,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo flexGrow_setterinfo = {
  (JSJitPropertyOp)set_flexGrow,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_flexShrink(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetFlexShrink(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "flexShrink");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_flexShrink(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetFlexShrink(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "flexShrink");
  }

  return true;
}


const JSJitInfo flexShrink_getterinfo = {
  (JSJitPropertyOp)get_flexShrink,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo flexShrink_setterinfo = {
  (JSJitPropertyOp)set_flexShrink,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_order(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetOrder(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "order");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_order(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetOrder(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "order");
  }

  return true;
}


const JSJitInfo order_getterinfo = {
  (JSJitPropertyOp)get_order,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo order_setterinfo = {
  (JSJitPropertyOp)set_order,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_justifyContent(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetJustifyContent(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "justifyContent");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_justifyContent(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetJustifyContent(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "justifyContent");
  }

  return true;
}


const JSJitInfo justifyContent_getterinfo = {
  (JSJitPropertyOp)get_justifyContent,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo justifyContent_setterinfo = {
  (JSJitPropertyOp)set_justifyContent,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_cssFloat(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetCssFloat(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "cssFloat");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_cssFloat(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetCssFloat(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "cssFloat");
  }

  return true;
}


const JSJitInfo cssFloat_getterinfo = {
  (JSJitPropertyOp)get_cssFloat,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo cssFloat_setterinfo = {
  (JSJitPropertyOp)set_cssFloat,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozFloatEdge(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozFloatEdge(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozFloatEdge");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozFloatEdge(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozFloatEdge(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozFloatEdge");
  }

  return true;
}


const JSJitInfo MozFloatEdge_getterinfo = {
  (JSJitPropertyOp)get_MozFloatEdge,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozFloatEdge_setterinfo = {
  (JSJitPropertyOp)set_MozFloatEdge,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_font(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetFont(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "font");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_font(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetFont(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "font");
  }

  return true;
}


const JSJitInfo font_getterinfo = {
  (JSJitPropertyOp)get_font,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo font_setterinfo = {
  (JSJitPropertyOp)set_font,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_fontFamily(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetFontFamily(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "fontFamily");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_fontFamily(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetFontFamily(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "fontFamily");
  }

  return true;
}


const JSJitInfo fontFamily_getterinfo = {
  (JSJitPropertyOp)get_fontFamily,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo fontFamily_setterinfo = {
  (JSJitPropertyOp)set_fontFamily,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozFontFeatureSettings(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozFontFeatureSettings(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozFontFeatureSettings");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozFontFeatureSettings(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozFontFeatureSettings(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozFontFeatureSettings");
  }

  return true;
}


const JSJitInfo MozFontFeatureSettings_getterinfo = {
  (JSJitPropertyOp)get_MozFontFeatureSettings,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozFontFeatureSettings_setterinfo = {
  (JSJitPropertyOp)set_MozFontFeatureSettings,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozFontLanguageOverride(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozFontLanguageOverride(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozFontLanguageOverride");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozFontLanguageOverride(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozFontLanguageOverride(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozFontLanguageOverride");
  }

  return true;
}


const JSJitInfo MozFontLanguageOverride_getterinfo = {
  (JSJitPropertyOp)get_MozFontLanguageOverride,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozFontLanguageOverride_setterinfo = {
  (JSJitPropertyOp)set_MozFontLanguageOverride,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_fontSize(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetFontSize(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "fontSize");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_fontSize(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetFontSize(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "fontSize");
  }

  return true;
}


const JSJitInfo fontSize_getterinfo = {
  (JSJitPropertyOp)get_fontSize,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo fontSize_setterinfo = {
  (JSJitPropertyOp)set_fontSize,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_fontSizeAdjust(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetFontSizeAdjust(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "fontSizeAdjust");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_fontSizeAdjust(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetFontSizeAdjust(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "fontSizeAdjust");
  }

  return true;
}


const JSJitInfo fontSizeAdjust_getterinfo = {
  (JSJitPropertyOp)get_fontSizeAdjust,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo fontSizeAdjust_setterinfo = {
  (JSJitPropertyOp)set_fontSizeAdjust,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_fontStretch(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetFontStretch(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "fontStretch");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_fontStretch(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetFontStretch(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "fontStretch");
  }

  return true;
}


const JSJitInfo fontStretch_getterinfo = {
  (JSJitPropertyOp)get_fontStretch,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo fontStretch_setterinfo = {
  (JSJitPropertyOp)set_fontStretch,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_fontStyle(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetFontStyle(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "fontStyle");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_fontStyle(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetFontStyle(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "fontStyle");
  }

  return true;
}


const JSJitInfo fontStyle_getterinfo = {
  (JSJitPropertyOp)get_fontStyle,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo fontStyle_setterinfo = {
  (JSJitPropertyOp)set_fontStyle,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_fontVariant(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetFontVariant(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "fontVariant");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_fontVariant(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetFontVariant(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "fontVariant");
  }

  return true;
}


const JSJitInfo fontVariant_getterinfo = {
  (JSJitPropertyOp)get_fontVariant,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo fontVariant_setterinfo = {
  (JSJitPropertyOp)set_fontVariant,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_fontWeight(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetFontWeight(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "fontWeight");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_fontWeight(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetFontWeight(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "fontWeight");
  }

  return true;
}


const JSJitInfo fontWeight_getterinfo = {
  (JSJitPropertyOp)get_fontWeight,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo fontWeight_setterinfo = {
  (JSJitPropertyOp)set_fontWeight,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozForceBrokenImageIcon(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozForceBrokenImageIcon(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozForceBrokenImageIcon");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozForceBrokenImageIcon(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozForceBrokenImageIcon(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozForceBrokenImageIcon");
  }

  return true;
}


const JSJitInfo MozForceBrokenImageIcon_getterinfo = {
  (JSJitPropertyOp)get_MozForceBrokenImageIcon,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozForceBrokenImageIcon_setterinfo = {
  (JSJitPropertyOp)set_MozForceBrokenImageIcon,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_height(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetHeight(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "height");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_height(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetHeight(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "height");
  }

  return true;
}


const JSJitInfo height_getterinfo = {
  (JSJitPropertyOp)get_height,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo height_setterinfo = {
  (JSJitPropertyOp)set_height,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozImageRegion(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozImageRegion(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozImageRegion");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozImageRegion(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozImageRegion(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozImageRegion");
  }

  return true;
}


const JSJitInfo MozImageRegion_getterinfo = {
  (JSJitPropertyOp)get_MozImageRegion,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozImageRegion_setterinfo = {
  (JSJitPropertyOp)set_MozImageRegion,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_imeMode(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetImeMode(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "imeMode");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_imeMode(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetImeMode(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "imeMode");
  }

  return true;
}


const JSJitInfo imeMode_getterinfo = {
  (JSJitPropertyOp)get_imeMode,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo imeMode_setterinfo = {
  (JSJitPropertyOp)set_imeMode,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_left(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetLeft(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "left");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_left(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetLeft(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "left");
  }

  return true;
}


const JSJitInfo left_getterinfo = {
  (JSJitPropertyOp)get_left,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo left_setterinfo = {
  (JSJitPropertyOp)set_left,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_letterSpacing(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetLetterSpacing(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "letterSpacing");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_letterSpacing(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetLetterSpacing(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "letterSpacing");
  }

  return true;
}


const JSJitInfo letterSpacing_getterinfo = {
  (JSJitPropertyOp)get_letterSpacing,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo letterSpacing_setterinfo = {
  (JSJitPropertyOp)set_letterSpacing,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_lineHeight(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetLineHeight(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "lineHeight");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_lineHeight(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetLineHeight(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "lineHeight");
  }

  return true;
}


const JSJitInfo lineHeight_getterinfo = {
  (JSJitPropertyOp)get_lineHeight,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo lineHeight_setterinfo = {
  (JSJitPropertyOp)set_lineHeight,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_listStyle(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetListStyle(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "listStyle");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_listStyle(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetListStyle(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "listStyle");
  }

  return true;
}


const JSJitInfo listStyle_getterinfo = {
  (JSJitPropertyOp)get_listStyle,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo listStyle_setterinfo = {
  (JSJitPropertyOp)set_listStyle,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_listStyleImage(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetListStyleImage(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "listStyleImage");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_listStyleImage(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetListStyleImage(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "listStyleImage");
  }

  return true;
}


const JSJitInfo listStyleImage_getterinfo = {
  (JSJitPropertyOp)get_listStyleImage,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo listStyleImage_setterinfo = {
  (JSJitPropertyOp)set_listStyleImage,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_listStylePosition(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetListStylePosition(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "listStylePosition");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_listStylePosition(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetListStylePosition(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "listStylePosition");
  }

  return true;
}


const JSJitInfo listStylePosition_getterinfo = {
  (JSJitPropertyOp)get_listStylePosition,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo listStylePosition_setterinfo = {
  (JSJitPropertyOp)set_listStylePosition,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_listStyleType(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetListStyleType(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "listStyleType");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_listStyleType(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetListStyleType(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "listStyleType");
  }

  return true;
}


const JSJitInfo listStyleType_getterinfo = {
  (JSJitPropertyOp)get_listStyleType,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo listStyleType_setterinfo = {
  (JSJitPropertyOp)set_listStyleType,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_margin(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMargin(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "margin");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_margin(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMargin(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "margin");
  }

  return true;
}


const JSJitInfo margin_getterinfo = {
  (JSJitPropertyOp)get_margin,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo margin_setterinfo = {
  (JSJitPropertyOp)set_margin,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_marginBottom(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMarginBottom(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "marginBottom");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_marginBottom(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMarginBottom(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "marginBottom");
  }

  return true;
}


const JSJitInfo marginBottom_getterinfo = {
  (JSJitPropertyOp)get_marginBottom,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo marginBottom_setterinfo = {
  (JSJitPropertyOp)set_marginBottom,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozMarginEnd(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozMarginEnd(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozMarginEnd");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozMarginEnd(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozMarginEnd(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozMarginEnd");
  }

  return true;
}


const JSJitInfo MozMarginEnd_getterinfo = {
  (JSJitPropertyOp)get_MozMarginEnd,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozMarginEnd_setterinfo = {
  (JSJitPropertyOp)set_MozMarginEnd,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_marginLeft(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMarginLeft(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "marginLeft");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_marginLeft(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMarginLeft(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "marginLeft");
  }

  return true;
}


const JSJitInfo marginLeft_getterinfo = {
  (JSJitPropertyOp)get_marginLeft,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo marginLeft_setterinfo = {
  (JSJitPropertyOp)set_marginLeft,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_marginRight(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMarginRight(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "marginRight");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_marginRight(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMarginRight(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "marginRight");
  }

  return true;
}


const JSJitInfo marginRight_getterinfo = {
  (JSJitPropertyOp)get_marginRight,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo marginRight_setterinfo = {
  (JSJitPropertyOp)set_marginRight,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozMarginStart(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozMarginStart(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozMarginStart");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozMarginStart(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozMarginStart(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozMarginStart");
  }

  return true;
}


const JSJitInfo MozMarginStart_getterinfo = {
  (JSJitPropertyOp)get_MozMarginStart,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozMarginStart_setterinfo = {
  (JSJitPropertyOp)set_MozMarginStart,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_marginTop(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMarginTop(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "marginTop");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_marginTop(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMarginTop(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "marginTop");
  }

  return true;
}


const JSJitInfo marginTop_getterinfo = {
  (JSJitPropertyOp)get_marginTop,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo marginTop_setterinfo = {
  (JSJitPropertyOp)set_marginTop,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_markerOffset(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMarkerOffset(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "markerOffset");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_markerOffset(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMarkerOffset(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "markerOffset");
  }

  return true;
}


const JSJitInfo markerOffset_getterinfo = {
  (JSJitPropertyOp)get_markerOffset,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo markerOffset_setterinfo = {
  (JSJitPropertyOp)set_markerOffset,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_marks(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMarks(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "marks");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_marks(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMarks(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "marks");
  }

  return true;
}


const JSJitInfo marks_getterinfo = {
  (JSJitPropertyOp)get_marks,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo marks_setterinfo = {
  (JSJitPropertyOp)set_marks,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_maxHeight(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMaxHeight(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "maxHeight");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_maxHeight(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMaxHeight(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "maxHeight");
  }

  return true;
}


const JSJitInfo maxHeight_getterinfo = {
  (JSJitPropertyOp)get_maxHeight,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo maxHeight_setterinfo = {
  (JSJitPropertyOp)set_maxHeight,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_maxWidth(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMaxWidth(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "maxWidth");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_maxWidth(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMaxWidth(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "maxWidth");
  }

  return true;
}


const JSJitInfo maxWidth_getterinfo = {
  (JSJitPropertyOp)get_maxWidth,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo maxWidth_setterinfo = {
  (JSJitPropertyOp)set_maxWidth,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_minHeight(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMinHeight(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "minHeight");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_minHeight(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMinHeight(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "minHeight");
  }

  return true;
}


const JSJitInfo minHeight_getterinfo = {
  (JSJitPropertyOp)get_minHeight,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo minHeight_setterinfo = {
  (JSJitPropertyOp)set_minHeight,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_minWidth(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMinWidth(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "minWidth");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_minWidth(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMinWidth(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "minWidth");
  }

  return true;
}


const JSJitInfo minWidth_getterinfo = {
  (JSJitPropertyOp)get_minWidth,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo minWidth_setterinfo = {
  (JSJitPropertyOp)set_minWidth,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_opacity(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetOpacity(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "opacity");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_opacity(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetOpacity(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "opacity");
  }

  return true;
}


const JSJitInfo opacity_getterinfo = {
  (JSJitPropertyOp)get_opacity,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo opacity_setterinfo = {
  (JSJitPropertyOp)set_opacity,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozOrient(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozOrient(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozOrient");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozOrient(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozOrient(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozOrient");
  }

  return true;
}


const JSJitInfo MozOrient_getterinfo = {
  (JSJitPropertyOp)get_MozOrient,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozOrient_setterinfo = {
  (JSJitPropertyOp)set_MozOrient,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_orphans(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetOrphans(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "orphans");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_orphans(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetOrphans(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "orphans");
  }

  return true;
}


const JSJitInfo orphans_getterinfo = {
  (JSJitPropertyOp)get_orphans,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo orphans_setterinfo = {
  (JSJitPropertyOp)set_orphans,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_outline(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetOutline(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "outline");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_outline(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetOutline(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "outline");
  }

  return true;
}


const JSJitInfo outline_getterinfo = {
  (JSJitPropertyOp)get_outline,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo outline_setterinfo = {
  (JSJitPropertyOp)set_outline,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_outlineColor(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetOutlineColor(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "outlineColor");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_outlineColor(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetOutlineColor(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "outlineColor");
  }

  return true;
}


const JSJitInfo outlineColor_getterinfo = {
  (JSJitPropertyOp)get_outlineColor,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo outlineColor_setterinfo = {
  (JSJitPropertyOp)set_outlineColor,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_outlineStyle(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetOutlineStyle(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "outlineStyle");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_outlineStyle(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetOutlineStyle(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "outlineStyle");
  }

  return true;
}


const JSJitInfo outlineStyle_getterinfo = {
  (JSJitPropertyOp)get_outlineStyle,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo outlineStyle_setterinfo = {
  (JSJitPropertyOp)set_outlineStyle,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_outlineWidth(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetOutlineWidth(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "outlineWidth");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_outlineWidth(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetOutlineWidth(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "outlineWidth");
  }

  return true;
}


const JSJitInfo outlineWidth_getterinfo = {
  (JSJitPropertyOp)get_outlineWidth,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo outlineWidth_setterinfo = {
  (JSJitPropertyOp)set_outlineWidth,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_outlineOffset(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetOutlineOffset(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "outlineOffset");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_outlineOffset(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetOutlineOffset(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "outlineOffset");
  }

  return true;
}


const JSJitInfo outlineOffset_getterinfo = {
  (JSJitPropertyOp)get_outlineOffset,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo outlineOffset_setterinfo = {
  (JSJitPropertyOp)set_outlineOffset,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_overflow(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetOverflow(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "overflow");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_overflow(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetOverflow(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "overflow");
  }

  return true;
}


const JSJitInfo overflow_getterinfo = {
  (JSJitPropertyOp)get_overflow,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo overflow_setterinfo = {
  (JSJitPropertyOp)set_overflow,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_overflowX(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetOverflowX(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "overflowX");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_overflowX(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetOverflowX(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "overflowX");
  }

  return true;
}


const JSJitInfo overflowX_getterinfo = {
  (JSJitPropertyOp)get_overflowX,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo overflowX_setterinfo = {
  (JSJitPropertyOp)set_overflowX,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_overflowY(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetOverflowY(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "overflowY");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_overflowY(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetOverflowY(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "overflowY");
  }

  return true;
}


const JSJitInfo overflowY_getterinfo = {
  (JSJitPropertyOp)get_overflowY,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo overflowY_setterinfo = {
  (JSJitPropertyOp)set_overflowY,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_padding(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetPadding(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "padding");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_padding(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetPadding(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "padding");
  }

  return true;
}


const JSJitInfo padding_getterinfo = {
  (JSJitPropertyOp)get_padding,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo padding_setterinfo = {
  (JSJitPropertyOp)set_padding,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_paddingBottom(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetPaddingBottom(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "paddingBottom");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_paddingBottom(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetPaddingBottom(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "paddingBottom");
  }

  return true;
}


const JSJitInfo paddingBottom_getterinfo = {
  (JSJitPropertyOp)get_paddingBottom,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo paddingBottom_setterinfo = {
  (JSJitPropertyOp)set_paddingBottom,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozPaddingEnd(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozPaddingEnd(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozPaddingEnd");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozPaddingEnd(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozPaddingEnd(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozPaddingEnd");
  }

  return true;
}


const JSJitInfo MozPaddingEnd_getterinfo = {
  (JSJitPropertyOp)get_MozPaddingEnd,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozPaddingEnd_setterinfo = {
  (JSJitPropertyOp)set_MozPaddingEnd,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_paddingLeft(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetPaddingLeft(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "paddingLeft");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_paddingLeft(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetPaddingLeft(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "paddingLeft");
  }

  return true;
}


const JSJitInfo paddingLeft_getterinfo = {
  (JSJitPropertyOp)get_paddingLeft,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo paddingLeft_setterinfo = {
  (JSJitPropertyOp)set_paddingLeft,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_paddingRight(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetPaddingRight(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "paddingRight");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_paddingRight(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetPaddingRight(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "paddingRight");
  }

  return true;
}


const JSJitInfo paddingRight_getterinfo = {
  (JSJitPropertyOp)get_paddingRight,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo paddingRight_setterinfo = {
  (JSJitPropertyOp)set_paddingRight,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozPaddingStart(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozPaddingStart(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozPaddingStart");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozPaddingStart(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozPaddingStart(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozPaddingStart");
  }

  return true;
}


const JSJitInfo MozPaddingStart_getterinfo = {
  (JSJitPropertyOp)get_MozPaddingStart,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozPaddingStart_setterinfo = {
  (JSJitPropertyOp)set_MozPaddingStart,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_paddingTop(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetPaddingTop(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "paddingTop");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_paddingTop(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetPaddingTop(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "paddingTop");
  }

  return true;
}


const JSJitInfo paddingTop_getterinfo = {
  (JSJitPropertyOp)get_paddingTop,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo paddingTop_setterinfo = {
  (JSJitPropertyOp)set_paddingTop,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_page(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetPage(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "page");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_page(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetPage(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "page");
  }

  return true;
}


const JSJitInfo page_getterinfo = {
  (JSJitPropertyOp)get_page,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo page_setterinfo = {
  (JSJitPropertyOp)set_page,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_pageBreakAfter(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetPageBreakAfter(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "pageBreakAfter");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_pageBreakAfter(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetPageBreakAfter(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "pageBreakAfter");
  }

  return true;
}


const JSJitInfo pageBreakAfter_getterinfo = {
  (JSJitPropertyOp)get_pageBreakAfter,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo pageBreakAfter_setterinfo = {
  (JSJitPropertyOp)set_pageBreakAfter,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_pageBreakBefore(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetPageBreakBefore(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "pageBreakBefore");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_pageBreakBefore(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetPageBreakBefore(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "pageBreakBefore");
  }

  return true;
}


const JSJitInfo pageBreakBefore_getterinfo = {
  (JSJitPropertyOp)get_pageBreakBefore,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo pageBreakBefore_setterinfo = {
  (JSJitPropertyOp)set_pageBreakBefore,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_pageBreakInside(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetPageBreakInside(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "pageBreakInside");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_pageBreakInside(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetPageBreakInside(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "pageBreakInside");
  }

  return true;
}


const JSJitInfo pageBreakInside_getterinfo = {
  (JSJitPropertyOp)get_pageBreakInside,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo pageBreakInside_setterinfo = {
  (JSJitPropertyOp)set_pageBreakInside,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_pointerEvents(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetPointerEvents(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "pointerEvents");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_pointerEvents(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetPointerEvents(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "pointerEvents");
  }

  return true;
}


const JSJitInfo pointerEvents_getterinfo = {
  (JSJitPropertyOp)get_pointerEvents,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo pointerEvents_setterinfo = {
  (JSJitPropertyOp)set_pointerEvents,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_position(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetPosition(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "position");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_position(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetPosition(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "position");
  }

  return true;
}


const JSJitInfo position_getterinfo = {
  (JSJitPropertyOp)get_position,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo position_setterinfo = {
  (JSJitPropertyOp)set_position,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_quotes(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetQuotes(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "quotes");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_quotes(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetQuotes(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "quotes");
  }

  return true;
}


const JSJitInfo quotes_getterinfo = {
  (JSJitPropertyOp)get_quotes,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo quotes_setterinfo = {
  (JSJitPropertyOp)set_quotes,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_resize(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetResize(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "resize");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_resize(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetResize(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "resize");
  }

  return true;
}


const JSJitInfo resize_getterinfo = {
  (JSJitPropertyOp)get_resize,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo resize_setterinfo = {
  (JSJitPropertyOp)set_resize,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_right(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetRight(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "right");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_right(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetRight(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "right");
  }

  return true;
}


const JSJitInfo right_getterinfo = {
  (JSJitPropertyOp)get_right,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo right_setterinfo = {
  (JSJitPropertyOp)set_right,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_size(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetSize(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "size");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_size(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetSize(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "size");
  }

  return true;
}


const JSJitInfo size_getterinfo = {
  (JSJitPropertyOp)get_size,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo size_setterinfo = {
  (JSJitPropertyOp)set_size,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_tableLayout(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetTableLayout(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "tableLayout");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_tableLayout(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetTableLayout(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "tableLayout");
  }

  return true;
}


const JSJitInfo tableLayout_getterinfo = {
  (JSJitPropertyOp)get_tableLayout,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo tableLayout_setterinfo = {
  (JSJitPropertyOp)set_tableLayout,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_textAlign(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetTextAlign(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "textAlign");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_textAlign(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetTextAlign(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "textAlign");
  }

  return true;
}


const JSJitInfo textAlign_getterinfo = {
  (JSJitPropertyOp)get_textAlign,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo textAlign_setterinfo = {
  (JSJitPropertyOp)set_textAlign,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozTextAlignLast(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozTextAlignLast(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozTextAlignLast");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozTextAlignLast(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozTextAlignLast(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozTextAlignLast");
  }

  return true;
}


const JSJitInfo MozTextAlignLast_getterinfo = {
  (JSJitPropertyOp)get_MozTextAlignLast,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozTextAlignLast_setterinfo = {
  (JSJitPropertyOp)set_MozTextAlignLast,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_textDecoration(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetTextDecoration(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "textDecoration");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_textDecoration(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetTextDecoration(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "textDecoration");
  }

  return true;
}


const JSJitInfo textDecoration_getterinfo = {
  (JSJitPropertyOp)get_textDecoration,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo textDecoration_setterinfo = {
  (JSJitPropertyOp)set_textDecoration,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozTextBlink(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozTextBlink(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozTextBlink");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozTextBlink(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozTextBlink(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozTextBlink");
  }

  return true;
}


const JSJitInfo MozTextBlink_getterinfo = {
  (JSJitPropertyOp)get_MozTextBlink,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozTextBlink_setterinfo = {
  (JSJitPropertyOp)set_MozTextBlink,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozTextDecorationColor(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozTextDecorationColor(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozTextDecorationColor");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozTextDecorationColor(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozTextDecorationColor(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozTextDecorationColor");
  }

  return true;
}


const JSJitInfo MozTextDecorationColor_getterinfo = {
  (JSJitPropertyOp)get_MozTextDecorationColor,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozTextDecorationColor_setterinfo = {
  (JSJitPropertyOp)set_MozTextDecorationColor,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozTextDecorationLine(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozTextDecorationLine(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozTextDecorationLine");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozTextDecorationLine(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozTextDecorationLine(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozTextDecorationLine");
  }

  return true;
}


const JSJitInfo MozTextDecorationLine_getterinfo = {
  (JSJitPropertyOp)get_MozTextDecorationLine,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozTextDecorationLine_setterinfo = {
  (JSJitPropertyOp)set_MozTextDecorationLine,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozTextDecorationStyle(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozTextDecorationStyle(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozTextDecorationStyle");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozTextDecorationStyle(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozTextDecorationStyle(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozTextDecorationStyle");
  }

  return true;
}


const JSJitInfo MozTextDecorationStyle_getterinfo = {
  (JSJitPropertyOp)get_MozTextDecorationStyle,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozTextDecorationStyle_setterinfo = {
  (JSJitPropertyOp)set_MozTextDecorationStyle,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_textIndent(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetTextIndent(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "textIndent");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_textIndent(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetTextIndent(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "textIndent");
  }

  return true;
}


const JSJitInfo textIndent_getterinfo = {
  (JSJitPropertyOp)get_textIndent,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo textIndent_setterinfo = {
  (JSJitPropertyOp)set_textIndent,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_textOverflow(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetTextOverflow(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "textOverflow");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_textOverflow(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetTextOverflow(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "textOverflow");
  }

  return true;
}


const JSJitInfo textOverflow_getterinfo = {
  (JSJitPropertyOp)get_textOverflow,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo textOverflow_setterinfo = {
  (JSJitPropertyOp)set_textOverflow,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_textShadow(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetTextShadow(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "textShadow");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_textShadow(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetTextShadow(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "textShadow");
  }

  return true;
}


const JSJitInfo textShadow_getterinfo = {
  (JSJitPropertyOp)get_textShadow,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo textShadow_setterinfo = {
  (JSJitPropertyOp)set_textShadow,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozTextSizeAdjust(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozTextSizeAdjust(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozTextSizeAdjust");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozTextSizeAdjust(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozTextSizeAdjust(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozTextSizeAdjust");
  }

  return true;
}


const JSJitInfo MozTextSizeAdjust_getterinfo = {
  (JSJitPropertyOp)get_MozTextSizeAdjust,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozTextSizeAdjust_setterinfo = {
  (JSJitPropertyOp)set_MozTextSizeAdjust,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_textTransform(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetTextTransform(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "textTransform");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_textTransform(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetTextTransform(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "textTransform");
  }

  return true;
}


const JSJitInfo textTransform_getterinfo = {
  (JSJitPropertyOp)get_textTransform,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo textTransform_setterinfo = {
  (JSJitPropertyOp)set_textTransform,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_transform(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetTransform(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "transform");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_transform(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetTransform(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "transform");
  }

  return true;
}


const JSJitInfo transform_getterinfo = {
  (JSJitPropertyOp)get_transform,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo transform_setterinfo = {
  (JSJitPropertyOp)set_transform,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_transformOrigin(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetTransformOrigin(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "transformOrigin");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_transformOrigin(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetTransformOrigin(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "transformOrigin");
  }

  return true;
}


const JSJitInfo transformOrigin_getterinfo = {
  (JSJitPropertyOp)get_transformOrigin,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo transformOrigin_setterinfo = {
  (JSJitPropertyOp)set_transformOrigin,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_perspectiveOrigin(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetPerspectiveOrigin(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "perspectiveOrigin");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_perspectiveOrigin(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetPerspectiveOrigin(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "perspectiveOrigin");
  }

  return true;
}


const JSJitInfo perspectiveOrigin_getterinfo = {
  (JSJitPropertyOp)get_perspectiveOrigin,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo perspectiveOrigin_setterinfo = {
  (JSJitPropertyOp)set_perspectiveOrigin,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_perspective(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetPerspective(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "perspective");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_perspective(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetPerspective(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "perspective");
  }

  return true;
}


const JSJitInfo perspective_getterinfo = {
  (JSJitPropertyOp)get_perspective,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo perspective_setterinfo = {
  (JSJitPropertyOp)set_perspective,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_transformStyle(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetTransformStyle(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "transformStyle");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_transformStyle(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetTransformStyle(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "transformStyle");
  }

  return true;
}


const JSJitInfo transformStyle_getterinfo = {
  (JSJitPropertyOp)get_transformStyle,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo transformStyle_setterinfo = {
  (JSJitPropertyOp)set_transformStyle,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_backfaceVisibility(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetBackfaceVisibility(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "backfaceVisibility");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_backfaceVisibility(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetBackfaceVisibility(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "backfaceVisibility");
  }

  return true;
}


const JSJitInfo backfaceVisibility_getterinfo = {
  (JSJitPropertyOp)get_backfaceVisibility,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo backfaceVisibility_setterinfo = {
  (JSJitPropertyOp)set_backfaceVisibility,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_top(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetTop(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "top");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_top(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetTop(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "top");
  }

  return true;
}


const JSJitInfo top_getterinfo = {
  (JSJitPropertyOp)get_top,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo top_setterinfo = {
  (JSJitPropertyOp)set_top,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_transition(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetTransition(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "transition");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_transition(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetTransition(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "transition");
  }

  return true;
}


const JSJitInfo transition_getterinfo = {
  (JSJitPropertyOp)get_transition,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo transition_setterinfo = {
  (JSJitPropertyOp)set_transition,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_transitionDelay(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetTransitionDelay(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "transitionDelay");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_transitionDelay(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetTransitionDelay(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "transitionDelay");
  }

  return true;
}


const JSJitInfo transitionDelay_getterinfo = {
  (JSJitPropertyOp)get_transitionDelay,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo transitionDelay_setterinfo = {
  (JSJitPropertyOp)set_transitionDelay,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_transitionDuration(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetTransitionDuration(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "transitionDuration");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_transitionDuration(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetTransitionDuration(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "transitionDuration");
  }

  return true;
}


const JSJitInfo transitionDuration_getterinfo = {
  (JSJitPropertyOp)get_transitionDuration,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo transitionDuration_setterinfo = {
  (JSJitPropertyOp)set_transitionDuration,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_transitionProperty(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetTransitionProperty(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "transitionProperty");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_transitionProperty(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetTransitionProperty(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "transitionProperty");
  }

  return true;
}


const JSJitInfo transitionProperty_getterinfo = {
  (JSJitPropertyOp)get_transitionProperty,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo transitionProperty_setterinfo = {
  (JSJitPropertyOp)set_transitionProperty,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_transitionTimingFunction(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetTransitionTimingFunction(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "transitionTimingFunction");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_transitionTimingFunction(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetTransitionTimingFunction(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "transitionTimingFunction");
  }

  return true;
}


const JSJitInfo transitionTimingFunction_getterinfo = {
  (JSJitPropertyOp)get_transitionTimingFunction,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo transitionTimingFunction_setterinfo = {
  (JSJitPropertyOp)set_transitionTimingFunction,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_unicodeBidi(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetUnicodeBidi(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "unicodeBidi");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_unicodeBidi(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetUnicodeBidi(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "unicodeBidi");
  }

  return true;
}


const JSJitInfo unicodeBidi_getterinfo = {
  (JSJitPropertyOp)get_unicodeBidi,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo unicodeBidi_setterinfo = {
  (JSJitPropertyOp)set_unicodeBidi,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozUserFocus(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozUserFocus(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozUserFocus");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozUserFocus(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozUserFocus(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozUserFocus");
  }

  return true;
}


const JSJitInfo MozUserFocus_getterinfo = {
  (JSJitPropertyOp)get_MozUserFocus,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozUserFocus_setterinfo = {
  (JSJitPropertyOp)set_MozUserFocus,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozUserInput(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozUserInput(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozUserInput");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozUserInput(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozUserInput(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozUserInput");
  }

  return true;
}


const JSJitInfo MozUserInput_getterinfo = {
  (JSJitPropertyOp)get_MozUserInput,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozUserInput_setterinfo = {
  (JSJitPropertyOp)set_MozUserInput,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozUserModify(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozUserModify(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozUserModify");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozUserModify(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozUserModify(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozUserModify");
  }

  return true;
}


const JSJitInfo MozUserModify_getterinfo = {
  (JSJitPropertyOp)get_MozUserModify,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozUserModify_setterinfo = {
  (JSJitPropertyOp)set_MozUserModify,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozUserSelect(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozUserSelect(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozUserSelect");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozUserSelect(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozUserSelect(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozUserSelect");
  }

  return true;
}


const JSJitInfo MozUserSelect_getterinfo = {
  (JSJitPropertyOp)get_MozUserSelect,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozUserSelect_setterinfo = {
  (JSJitPropertyOp)set_MozUserSelect,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_verticalAlign(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetVerticalAlign(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "verticalAlign");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_verticalAlign(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetVerticalAlign(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "verticalAlign");
  }

  return true;
}


const JSJitInfo verticalAlign_getterinfo = {
  (JSJitPropertyOp)get_verticalAlign,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo verticalAlign_setterinfo = {
  (JSJitPropertyOp)set_verticalAlign,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_visibility(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetVisibility(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "visibility");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_visibility(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetVisibility(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "visibility");
  }

  return true;
}


const JSJitInfo visibility_getterinfo = {
  (JSJitPropertyOp)get_visibility,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo visibility_setterinfo = {
  (JSJitPropertyOp)set_visibility,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_whiteSpace(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetWhiteSpace(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "whiteSpace");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_whiteSpace(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetWhiteSpace(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "whiteSpace");
  }

  return true;
}


const JSJitInfo whiteSpace_getterinfo = {
  (JSJitPropertyOp)get_whiteSpace,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo whiteSpace_setterinfo = {
  (JSJitPropertyOp)set_whiteSpace,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_widows(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetWidows(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "widows");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_widows(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetWidows(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "widows");
  }

  return true;
}


const JSJitInfo widows_getterinfo = {
  (JSJitPropertyOp)get_widows,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo widows_setterinfo = {
  (JSJitPropertyOp)set_widows,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_width(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetWidth(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "width");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_width(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetWidth(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "width");
  }

  return true;
}


const JSJitInfo width_getterinfo = {
  (JSJitPropertyOp)get_width,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo width_setterinfo = {
  (JSJitPropertyOp)set_width,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozWindowShadow(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozWindowShadow(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozWindowShadow");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozWindowShadow(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozWindowShadow(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozWindowShadow");
  }

  return true;
}


const JSJitInfo MozWindowShadow_getterinfo = {
  (JSJitPropertyOp)get_MozWindowShadow,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozWindowShadow_setterinfo = {
  (JSJitPropertyOp)set_MozWindowShadow,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_wordBreak(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetWordBreak(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "wordBreak");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_wordBreak(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetWordBreak(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "wordBreak");
  }

  return true;
}


const JSJitInfo wordBreak_getterinfo = {
  (JSJitPropertyOp)get_wordBreak,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo wordBreak_setterinfo = {
  (JSJitPropertyOp)set_wordBreak,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_wordSpacing(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetWordSpacing(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "wordSpacing");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_wordSpacing(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetWordSpacing(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "wordSpacing");
  }

  return true;
}


const JSJitInfo wordSpacing_getterinfo = {
  (JSJitPropertyOp)get_wordSpacing,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo wordSpacing_setterinfo = {
  (JSJitPropertyOp)set_wordSpacing,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_wordWrap(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetWordWrap(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "wordWrap");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_wordWrap(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetWordWrap(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "wordWrap");
  }

  return true;
}


const JSJitInfo wordWrap_getterinfo = {
  (JSJitPropertyOp)get_wordWrap,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo wordWrap_setterinfo = {
  (JSJitPropertyOp)set_wordWrap,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozHyphens(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozHyphens(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozHyphens");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozHyphens(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozHyphens(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozHyphens");
  }

  return true;
}


const JSJitInfo MozHyphens_getterinfo = {
  (JSJitPropertyOp)get_MozHyphens,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozHyphens_setterinfo = {
  (JSJitPropertyOp)set_MozHyphens,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_zIndex(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetZIndex(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "zIndex");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_zIndex(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetZIndex(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "zIndex");
  }

  return true;
}


const JSJitInfo zIndex_getterinfo = {
  (JSJitPropertyOp)get_zIndex,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo zIndex_setterinfo = {
  (JSJitPropertyOp)set_zIndex,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozBoxAlign(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozBoxAlign(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozBoxAlign");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozBoxAlign(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozBoxAlign(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozBoxAlign");
  }

  return true;
}


const JSJitInfo MozBoxAlign_getterinfo = {
  (JSJitPropertyOp)get_MozBoxAlign,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozBoxAlign_setterinfo = {
  (JSJitPropertyOp)set_MozBoxAlign,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozBoxDirection(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozBoxDirection(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozBoxDirection");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozBoxDirection(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozBoxDirection(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozBoxDirection");
  }

  return true;
}


const JSJitInfo MozBoxDirection_getterinfo = {
  (JSJitPropertyOp)get_MozBoxDirection,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozBoxDirection_setterinfo = {
  (JSJitPropertyOp)set_MozBoxDirection,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozBoxFlex(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozBoxFlex(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozBoxFlex");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozBoxFlex(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozBoxFlex(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozBoxFlex");
  }

  return true;
}


const JSJitInfo MozBoxFlex_getterinfo = {
  (JSJitPropertyOp)get_MozBoxFlex,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozBoxFlex_setterinfo = {
  (JSJitPropertyOp)set_MozBoxFlex,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozBoxOrient(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozBoxOrient(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozBoxOrient");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozBoxOrient(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozBoxOrient(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozBoxOrient");
  }

  return true;
}


const JSJitInfo MozBoxOrient_getterinfo = {
  (JSJitPropertyOp)get_MozBoxOrient,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozBoxOrient_setterinfo = {
  (JSJitPropertyOp)set_MozBoxOrient,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozBoxPack(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozBoxPack(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozBoxPack");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozBoxPack(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozBoxPack(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozBoxPack");
  }

  return true;
}


const JSJitInfo MozBoxPack_getterinfo = {
  (JSJitPropertyOp)get_MozBoxPack,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozBoxPack_setterinfo = {
  (JSJitPropertyOp)set_MozBoxPack,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozBoxOrdinalGroup(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozBoxOrdinalGroup(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozBoxOrdinalGroup");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozBoxOrdinalGroup(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozBoxOrdinalGroup(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozBoxOrdinalGroup");
  }

  return true;
}


const JSJitInfo MozBoxOrdinalGroup_getterinfo = {
  (JSJitPropertyOp)get_MozBoxOrdinalGroup,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozBoxOrdinalGroup_setterinfo = {
  (JSJitPropertyOp)set_MozBoxOrdinalGroup,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozStackSizing(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozStackSizing(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozStackSizing");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozStackSizing(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozStackSizing(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozStackSizing");
  }

  return true;
}


const JSJitInfo MozStackSizing_getterinfo = {
  (JSJitPropertyOp)get_MozStackSizing,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozStackSizing_setterinfo = {
  (JSJitPropertyOp)set_MozStackSizing,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_clipPath(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetClipPath(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "clipPath");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_clipPath(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetClipPath(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "clipPath");
  }

  return true;
}


const JSJitInfo clipPath_getterinfo = {
  (JSJitPropertyOp)get_clipPath,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo clipPath_setterinfo = {
  (JSJitPropertyOp)set_clipPath,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_clipRule(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetClipRule(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "clipRule");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_clipRule(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetClipRule(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "clipRule");
  }

  return true;
}


const JSJitInfo clipRule_getterinfo = {
  (JSJitPropertyOp)get_clipRule,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo clipRule_setterinfo = {
  (JSJitPropertyOp)set_clipRule,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_colorInterpolation(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetColorInterpolation(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "colorInterpolation");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_colorInterpolation(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetColorInterpolation(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "colorInterpolation");
  }

  return true;
}


const JSJitInfo colorInterpolation_getterinfo = {
  (JSJitPropertyOp)get_colorInterpolation,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo colorInterpolation_setterinfo = {
  (JSJitPropertyOp)set_colorInterpolation,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_colorInterpolationFilters(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetColorInterpolationFilters(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "colorInterpolationFilters");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_colorInterpolationFilters(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetColorInterpolationFilters(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "colorInterpolationFilters");
  }

  return true;
}


const JSJitInfo colorInterpolationFilters_getterinfo = {
  (JSJitPropertyOp)get_colorInterpolationFilters,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo colorInterpolationFilters_setterinfo = {
  (JSJitPropertyOp)set_colorInterpolationFilters,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_dominantBaseline(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetDominantBaseline(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "dominantBaseline");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_dominantBaseline(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetDominantBaseline(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "dominantBaseline");
  }

  return true;
}


const JSJitInfo dominantBaseline_getterinfo = {
  (JSJitPropertyOp)get_dominantBaseline,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo dominantBaseline_setterinfo = {
  (JSJitPropertyOp)set_dominantBaseline,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_fill(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetFill(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "fill");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_fill(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetFill(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "fill");
  }

  return true;
}


const JSJitInfo fill_getterinfo = {
  (JSJitPropertyOp)get_fill,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo fill_setterinfo = {
  (JSJitPropertyOp)set_fill,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_fillOpacity(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetFillOpacity(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "fillOpacity");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_fillOpacity(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetFillOpacity(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "fillOpacity");
  }

  return true;
}


const JSJitInfo fillOpacity_getterinfo = {
  (JSJitPropertyOp)get_fillOpacity,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo fillOpacity_setterinfo = {
  (JSJitPropertyOp)set_fillOpacity,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_fillRule(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetFillRule(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "fillRule");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_fillRule(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetFillRule(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "fillRule");
  }

  return true;
}


const JSJitInfo fillRule_getterinfo = {
  (JSJitPropertyOp)get_fillRule,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo fillRule_setterinfo = {
  (JSJitPropertyOp)set_fillRule,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_filter(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetFilter(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "filter");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_filter(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetFilter(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "filter");
  }

  return true;
}


const JSJitInfo filter_getterinfo = {
  (JSJitPropertyOp)get_filter,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo filter_setterinfo = {
  (JSJitPropertyOp)set_filter,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_floodColor(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetFloodColor(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "floodColor");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_floodColor(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetFloodColor(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "floodColor");
  }

  return true;
}


const JSJitInfo floodColor_getterinfo = {
  (JSJitPropertyOp)get_floodColor,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo floodColor_setterinfo = {
  (JSJitPropertyOp)set_floodColor,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_floodOpacity(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetFloodOpacity(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "floodOpacity");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_floodOpacity(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetFloodOpacity(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "floodOpacity");
  }

  return true;
}


const JSJitInfo floodOpacity_getterinfo = {
  (JSJitPropertyOp)get_floodOpacity,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo floodOpacity_setterinfo = {
  (JSJitPropertyOp)set_floodOpacity,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_imageRendering(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetImageRendering(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "imageRendering");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_imageRendering(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetImageRendering(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "imageRendering");
  }

  return true;
}


const JSJitInfo imageRendering_getterinfo = {
  (JSJitPropertyOp)get_imageRendering,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo imageRendering_setterinfo = {
  (JSJitPropertyOp)set_imageRendering,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_lightingColor(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetLightingColor(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "lightingColor");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_lightingColor(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetLightingColor(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "lightingColor");
  }

  return true;
}


const JSJitInfo lightingColor_getterinfo = {
  (JSJitPropertyOp)get_lightingColor,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo lightingColor_setterinfo = {
  (JSJitPropertyOp)set_lightingColor,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_marker(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMarker(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "marker");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_marker(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMarker(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "marker");
  }

  return true;
}


const JSJitInfo marker_getterinfo = {
  (JSJitPropertyOp)get_marker,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo marker_setterinfo = {
  (JSJitPropertyOp)set_marker,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_markerEnd(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMarkerEnd(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "markerEnd");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_markerEnd(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMarkerEnd(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "markerEnd");
  }

  return true;
}


const JSJitInfo markerEnd_getterinfo = {
  (JSJitPropertyOp)get_markerEnd,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo markerEnd_setterinfo = {
  (JSJitPropertyOp)set_markerEnd,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_markerMid(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMarkerMid(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "markerMid");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_markerMid(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMarkerMid(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "markerMid");
  }

  return true;
}


const JSJitInfo markerMid_getterinfo = {
  (JSJitPropertyOp)get_markerMid,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo markerMid_setterinfo = {
  (JSJitPropertyOp)set_markerMid,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_markerStart(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMarkerStart(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "markerStart");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_markerStart(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMarkerStart(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "markerStart");
  }

  return true;
}


const JSJitInfo markerStart_getterinfo = {
  (JSJitPropertyOp)get_markerStart,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo markerStart_setterinfo = {
  (JSJitPropertyOp)set_markerStart,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_mask(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMask(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "mask");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_mask(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMask(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "mask");
  }

  return true;
}


const JSJitInfo mask_getterinfo = {
  (JSJitPropertyOp)get_mask,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo mask_setterinfo = {
  (JSJitPropertyOp)set_mask,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_maskType(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMaskType(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "maskType");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_maskType(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMaskType(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "maskType");
  }

  return true;
}


const JSJitInfo maskType_getterinfo = {
  (JSJitPropertyOp)get_maskType,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo maskType_setterinfo = {
  (JSJitPropertyOp)set_maskType,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_shapeRendering(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetShapeRendering(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "shapeRendering");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_shapeRendering(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetShapeRendering(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "shapeRendering");
  }

  return true;
}


const JSJitInfo shapeRendering_getterinfo = {
  (JSJitPropertyOp)get_shapeRendering,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo shapeRendering_setterinfo = {
  (JSJitPropertyOp)set_shapeRendering,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_stopColor(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetStopColor(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "stopColor");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_stopColor(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetStopColor(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "stopColor");
  }

  return true;
}


const JSJitInfo stopColor_getterinfo = {
  (JSJitPropertyOp)get_stopColor,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo stopColor_setterinfo = {
  (JSJitPropertyOp)set_stopColor,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_stopOpacity(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetStopOpacity(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "stopOpacity");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_stopOpacity(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetStopOpacity(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "stopOpacity");
  }

  return true;
}


const JSJitInfo stopOpacity_getterinfo = {
  (JSJitPropertyOp)get_stopOpacity,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo stopOpacity_setterinfo = {
  (JSJitPropertyOp)set_stopOpacity,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_stroke(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetStroke(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "stroke");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_stroke(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetStroke(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "stroke");
  }

  return true;
}


const JSJitInfo stroke_getterinfo = {
  (JSJitPropertyOp)get_stroke,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo stroke_setterinfo = {
  (JSJitPropertyOp)set_stroke,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_strokeDasharray(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetStrokeDasharray(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "strokeDasharray");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_strokeDasharray(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetStrokeDasharray(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "strokeDasharray");
  }

  return true;
}


const JSJitInfo strokeDasharray_getterinfo = {
  (JSJitPropertyOp)get_strokeDasharray,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo strokeDasharray_setterinfo = {
  (JSJitPropertyOp)set_strokeDasharray,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_strokeDashoffset(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetStrokeDashoffset(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "strokeDashoffset");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_strokeDashoffset(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetStrokeDashoffset(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "strokeDashoffset");
  }

  return true;
}


const JSJitInfo strokeDashoffset_getterinfo = {
  (JSJitPropertyOp)get_strokeDashoffset,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo strokeDashoffset_setterinfo = {
  (JSJitPropertyOp)set_strokeDashoffset,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_strokeLinecap(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetStrokeLinecap(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "strokeLinecap");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_strokeLinecap(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetStrokeLinecap(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "strokeLinecap");
  }

  return true;
}


const JSJitInfo strokeLinecap_getterinfo = {
  (JSJitPropertyOp)get_strokeLinecap,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo strokeLinecap_setterinfo = {
  (JSJitPropertyOp)set_strokeLinecap,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_strokeLinejoin(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetStrokeLinejoin(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "strokeLinejoin");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_strokeLinejoin(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetStrokeLinejoin(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "strokeLinejoin");
  }

  return true;
}


const JSJitInfo strokeLinejoin_getterinfo = {
  (JSJitPropertyOp)get_strokeLinejoin,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo strokeLinejoin_setterinfo = {
  (JSJitPropertyOp)set_strokeLinejoin,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_strokeMiterlimit(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetStrokeMiterlimit(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "strokeMiterlimit");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_strokeMiterlimit(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetStrokeMiterlimit(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "strokeMiterlimit");
  }

  return true;
}


const JSJitInfo strokeMiterlimit_getterinfo = {
  (JSJitPropertyOp)get_strokeMiterlimit,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo strokeMiterlimit_setterinfo = {
  (JSJitPropertyOp)set_strokeMiterlimit,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_strokeOpacity(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetStrokeOpacity(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "strokeOpacity");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_strokeOpacity(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetStrokeOpacity(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "strokeOpacity");
  }

  return true;
}


const JSJitInfo strokeOpacity_getterinfo = {
  (JSJitPropertyOp)get_strokeOpacity,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo strokeOpacity_setterinfo = {
  (JSJitPropertyOp)set_strokeOpacity,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_strokeWidth(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetStrokeWidth(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "strokeWidth");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_strokeWidth(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetStrokeWidth(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "strokeWidth");
  }

  return true;
}


const JSJitInfo strokeWidth_getterinfo = {
  (JSJitPropertyOp)get_strokeWidth,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo strokeWidth_setterinfo = {
  (JSJitPropertyOp)set_strokeWidth,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_textAnchor(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetTextAnchor(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "textAnchor");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_textAnchor(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetTextAnchor(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "textAnchor");
  }

  return true;
}


const JSJitInfo textAnchor_getterinfo = {
  (JSJitPropertyOp)get_textAnchor,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo textAnchor_setterinfo = {
  (JSJitPropertyOp)set_textAnchor,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_textRendering(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetTextRendering(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "textRendering");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_textRendering(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetTextRendering(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "textRendering");
  }

  return true;
}


const JSJitInfo textRendering_getterinfo = {
  (JSJitPropertyOp)get_textRendering,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo textRendering_setterinfo = {
  (JSJitPropertyOp)set_textRendering,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_vectorEffect(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetVectorEffect(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "vectorEffect");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_vectorEffect(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetVectorEffect(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "vectorEffect");
  }

  return true;
}


const JSJitInfo vectorEffect_getterinfo = {
  (JSJitPropertyOp)get_vectorEffect,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo vectorEffect_setterinfo = {
  (JSJitPropertyOp)set_vectorEffect,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozTransform(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozTransform(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozTransform");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozTransform(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozTransform(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozTransform");
  }

  return true;
}


const JSJitInfo MozTransform_getterinfo = {
  (JSJitPropertyOp)get_MozTransform,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozTransform_setterinfo = {
  (JSJitPropertyOp)set_MozTransform,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozTransformOrigin(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozTransformOrigin(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozTransformOrigin");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozTransformOrigin(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozTransformOrigin(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozTransformOrigin");
  }

  return true;
}


const JSJitInfo MozTransformOrigin_getterinfo = {
  (JSJitPropertyOp)get_MozTransformOrigin,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozTransformOrigin_setterinfo = {
  (JSJitPropertyOp)set_MozTransformOrigin,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozPerspectiveOrigin(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozPerspectiveOrigin(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozPerspectiveOrigin");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozPerspectiveOrigin(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozPerspectiveOrigin(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozPerspectiveOrigin");
  }

  return true;
}


const JSJitInfo MozPerspectiveOrigin_getterinfo = {
  (JSJitPropertyOp)get_MozPerspectiveOrigin,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozPerspectiveOrigin_setterinfo = {
  (JSJitPropertyOp)set_MozPerspectiveOrigin,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozPerspective(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozPerspective(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozPerspective");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozPerspective(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozPerspective(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozPerspective");
  }

  return true;
}


const JSJitInfo MozPerspective_getterinfo = {
  (JSJitPropertyOp)get_MozPerspective,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozPerspective_setterinfo = {
  (JSJitPropertyOp)set_MozPerspective,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozTransformStyle(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozTransformStyle(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozTransformStyle");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozTransformStyle(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozTransformStyle(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozTransformStyle");
  }

  return true;
}


const JSJitInfo MozTransformStyle_getterinfo = {
  (JSJitPropertyOp)get_MozTransformStyle,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozTransformStyle_setterinfo = {
  (JSJitPropertyOp)set_MozTransformStyle,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozBackfaceVisibility(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozBackfaceVisibility(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozBackfaceVisibility");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozBackfaceVisibility(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozBackfaceVisibility(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozBackfaceVisibility");
  }

  return true;
}


const JSJitInfo MozBackfaceVisibility_getterinfo = {
  (JSJitPropertyOp)get_MozBackfaceVisibility,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozBackfaceVisibility_setterinfo = {
  (JSJitPropertyOp)set_MozBackfaceVisibility,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozBorderImage(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozBorderImage(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozBorderImage");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozBorderImage(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozBorderImage(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozBorderImage");
  }

  return true;
}


const JSJitInfo MozBorderImage_getterinfo = {
  (JSJitPropertyOp)get_MozBorderImage,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozBorderImage_setterinfo = {
  (JSJitPropertyOp)set_MozBorderImage,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozTransition(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozTransition(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozTransition");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozTransition(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozTransition(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozTransition");
  }

  return true;
}


const JSJitInfo MozTransition_getterinfo = {
  (JSJitPropertyOp)get_MozTransition,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozTransition_setterinfo = {
  (JSJitPropertyOp)set_MozTransition,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozTransitionDelay(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozTransitionDelay(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozTransitionDelay");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozTransitionDelay(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozTransitionDelay(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozTransitionDelay");
  }

  return true;
}


const JSJitInfo MozTransitionDelay_getterinfo = {
  (JSJitPropertyOp)get_MozTransitionDelay,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozTransitionDelay_setterinfo = {
  (JSJitPropertyOp)set_MozTransitionDelay,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozTransitionDuration(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozTransitionDuration(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozTransitionDuration");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozTransitionDuration(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozTransitionDuration(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozTransitionDuration");
  }

  return true;
}


const JSJitInfo MozTransitionDuration_getterinfo = {
  (JSJitPropertyOp)get_MozTransitionDuration,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozTransitionDuration_setterinfo = {
  (JSJitPropertyOp)set_MozTransitionDuration,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozTransitionProperty(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozTransitionProperty(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozTransitionProperty");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozTransitionProperty(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozTransitionProperty(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozTransitionProperty");
  }

  return true;
}


const JSJitInfo MozTransitionProperty_getterinfo = {
  (JSJitPropertyOp)get_MozTransitionProperty,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozTransitionProperty_setterinfo = {
  (JSJitPropertyOp)set_MozTransitionProperty,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozTransitionTimingFunction(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozTransitionTimingFunction(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozTransitionTimingFunction");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozTransitionTimingFunction(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozTransitionTimingFunction(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozTransitionTimingFunction");
  }

  return true;
}


const JSJitInfo MozTransitionTimingFunction_getterinfo = {
  (JSJitPropertyOp)get_MozTransitionTimingFunction,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozTransitionTimingFunction_setterinfo = {
  (JSJitPropertyOp)set_MozTransitionTimingFunction,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozAnimation(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozAnimation(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozAnimation");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozAnimation(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozAnimation(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozAnimation");
  }

  return true;
}


const JSJitInfo MozAnimation_getterinfo = {
  (JSJitPropertyOp)get_MozAnimation,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozAnimation_setterinfo = {
  (JSJitPropertyOp)set_MozAnimation,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozAnimationDelay(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozAnimationDelay(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozAnimationDelay");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozAnimationDelay(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozAnimationDelay(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozAnimationDelay");
  }

  return true;
}


const JSJitInfo MozAnimationDelay_getterinfo = {
  (JSJitPropertyOp)get_MozAnimationDelay,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozAnimationDelay_setterinfo = {
  (JSJitPropertyOp)set_MozAnimationDelay,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozAnimationDirection(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozAnimationDirection(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozAnimationDirection");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozAnimationDirection(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozAnimationDirection(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozAnimationDirection");
  }

  return true;
}


const JSJitInfo MozAnimationDirection_getterinfo = {
  (JSJitPropertyOp)get_MozAnimationDirection,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozAnimationDirection_setterinfo = {
  (JSJitPropertyOp)set_MozAnimationDirection,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozAnimationDuration(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozAnimationDuration(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozAnimationDuration");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozAnimationDuration(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozAnimationDuration(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozAnimationDuration");
  }

  return true;
}


const JSJitInfo MozAnimationDuration_getterinfo = {
  (JSJitPropertyOp)get_MozAnimationDuration,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozAnimationDuration_setterinfo = {
  (JSJitPropertyOp)set_MozAnimationDuration,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozAnimationFillMode(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozAnimationFillMode(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozAnimationFillMode");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozAnimationFillMode(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozAnimationFillMode(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozAnimationFillMode");
  }

  return true;
}


const JSJitInfo MozAnimationFillMode_getterinfo = {
  (JSJitPropertyOp)get_MozAnimationFillMode,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozAnimationFillMode_setterinfo = {
  (JSJitPropertyOp)set_MozAnimationFillMode,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozAnimationIterationCount(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozAnimationIterationCount(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozAnimationIterationCount");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozAnimationIterationCount(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozAnimationIterationCount(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozAnimationIterationCount");
  }

  return true;
}


const JSJitInfo MozAnimationIterationCount_getterinfo = {
  (JSJitPropertyOp)get_MozAnimationIterationCount,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozAnimationIterationCount_setterinfo = {
  (JSJitPropertyOp)set_MozAnimationIterationCount,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozAnimationName(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozAnimationName(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozAnimationName");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozAnimationName(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozAnimationName(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozAnimationName");
  }

  return true;
}


const JSJitInfo MozAnimationName_getterinfo = {
  (JSJitPropertyOp)get_MozAnimationName,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozAnimationName_setterinfo = {
  (JSJitPropertyOp)set_MozAnimationName,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozAnimationPlayState(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozAnimationPlayState(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozAnimationPlayState");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozAnimationPlayState(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozAnimationPlayState(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozAnimationPlayState");
  }

  return true;
}


const JSJitInfo MozAnimationPlayState_getterinfo = {
  (JSJitPropertyOp)get_MozAnimationPlayState,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozAnimationPlayState_setterinfo = {
  (JSJitPropertyOp)set_MozAnimationPlayState,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_MozAnimationTimingFunction(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* vp)
{
  ErrorResult rv;
  nsString result;
  self->GetMozAnimationTimingFunction(result, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozAnimationTimingFunction");
  }
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_MozAnimationTimingFunction(JSContext* cx, JSHandleObject obj, nsDOMCSSDeclaration* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eEmpty, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetMozAnimationTimingFunction(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "CSS2Properties", "MozAnimationTimingFunction");
  }

  return true;
}


const JSJitInfo MozAnimationTimingFunction_getterinfo = {
  (JSJitPropertyOp)get_MozAnimationTimingFunction,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo MozAnimationTimingFunction_setterinfo = {
  (JSJitPropertyOp)set_MozAnimationTimingFunction,
  prototypes::id::CSS2Properties,
  PrototypeTraits<prototypes::id::CSS2Properties>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static JSBool
genericGetter(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  nsDOMCSSDeclaration* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::CSS2Properties, nsDOMCSSDeclaration>(cx, obj, self);
    if (NS_FAILED(rv)) {
      return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "CSS2Properties");
    }
  }
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Getter);
  JSJitPropertyOp getter = info->op;
  return getter(cx, obj, self, vp);
}

static JSBool
genericSetter(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  nsDOMCSSDeclaration* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::CSS2Properties, nsDOMCSSDeclaration>(cx, obj, self);
    if (NS_FAILED(rv)) {
      return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "CSS2Properties");
    }
  }
  if (argc == 0) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "CSS2Properties attribute setter");
  }
  JS::Value* argv = JS_ARGV(cx, vp);
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Setter);
  JSJitPropertyOp setter = info->op;
  if (!setter(cx, obj, self, argv)) {
    return false;
  }
  *vp = JSVAL_VOID;
  return true;
}

static JSPropertySpec sAttributes_specs[] = {
  { "MozAppearance", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozAppearance_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozAppearance_setterinfo }},
  { "MozOutlineRadius", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozOutlineRadius_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozOutlineRadius_setterinfo }},
  { "MozOutlineRadiusTopleft", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozOutlineRadiusTopleft_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozOutlineRadiusTopleft_setterinfo }},
  { "MozOutlineRadiusTopright", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozOutlineRadiusTopright_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozOutlineRadiusTopright_setterinfo }},
  { "MozOutlineRadiusBottomright", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozOutlineRadiusBottomright_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozOutlineRadiusBottomright_setterinfo }},
  { "MozOutlineRadiusBottomleft", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozOutlineRadiusBottomleft_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozOutlineRadiusBottomleft_setterinfo }},
  { "MozTabSize", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozTabSize_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozTabSize_setterinfo }},
  { "animation", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &animation_getterinfo }, { (JSStrictPropertyOp)genericSetter, &animation_setterinfo }},
  { "animationDelay", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &animationDelay_getterinfo }, { (JSStrictPropertyOp)genericSetter, &animationDelay_setterinfo }},
  { "animationDirection", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &animationDirection_getterinfo }, { (JSStrictPropertyOp)genericSetter, &animationDirection_setterinfo }},
  { "animationDuration", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &animationDuration_getterinfo }, { (JSStrictPropertyOp)genericSetter, &animationDuration_setterinfo }},
  { "animationFillMode", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &animationFillMode_getterinfo }, { (JSStrictPropertyOp)genericSetter, &animationFillMode_setterinfo }},
  { "animationIterationCount", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &animationIterationCount_getterinfo }, { (JSStrictPropertyOp)genericSetter, &animationIterationCount_setterinfo }},
  { "animationName", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &animationName_getterinfo }, { (JSStrictPropertyOp)genericSetter, &animationName_setterinfo }},
  { "animationPlayState", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &animationPlayState_getterinfo }, { (JSStrictPropertyOp)genericSetter, &animationPlayState_setterinfo }},
  { "animationTimingFunction", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &animationTimingFunction_getterinfo }, { (JSStrictPropertyOp)genericSetter, &animationTimingFunction_setterinfo }},
  { "background", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &background_getterinfo }, { (JSStrictPropertyOp)genericSetter, &background_setterinfo }},
  { "backgroundAttachment", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &backgroundAttachment_getterinfo }, { (JSStrictPropertyOp)genericSetter, &backgroundAttachment_setterinfo }},
  { "backgroundClip", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &backgroundClip_getterinfo }, { (JSStrictPropertyOp)genericSetter, &backgroundClip_setterinfo }},
  { "backgroundColor", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &backgroundColor_getterinfo }, { (JSStrictPropertyOp)genericSetter, &backgroundColor_setterinfo }},
  { "backgroundImage", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &backgroundImage_getterinfo }, { (JSStrictPropertyOp)genericSetter, &backgroundImage_setterinfo }},
  { "MozBackgroundInlinePolicy", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozBackgroundInlinePolicy_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozBackgroundInlinePolicy_setterinfo }},
  { "backgroundOrigin", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &backgroundOrigin_getterinfo }, { (JSStrictPropertyOp)genericSetter, &backgroundOrigin_setterinfo }},
  { "backgroundPosition", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &backgroundPosition_getterinfo }, { (JSStrictPropertyOp)genericSetter, &backgroundPosition_setterinfo }},
  { "backgroundRepeat", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &backgroundRepeat_getterinfo }, { (JSStrictPropertyOp)genericSetter, &backgroundRepeat_setterinfo }},
  { "backgroundSize", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &backgroundSize_getterinfo }, { (JSStrictPropertyOp)genericSetter, &backgroundSize_setterinfo }},
  { "MozBinding", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozBinding_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozBinding_setterinfo }},
  { "border", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &border_getterinfo }, { (JSStrictPropertyOp)genericSetter, &border_setterinfo }},
  { "borderBottom", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &borderBottom_getterinfo }, { (JSStrictPropertyOp)genericSetter, &borderBottom_setterinfo }},
  { "borderBottomColor", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &borderBottomColor_getterinfo }, { (JSStrictPropertyOp)genericSetter, &borderBottomColor_setterinfo }},
  { "MozBorderBottomColors", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozBorderBottomColors_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozBorderBottomColors_setterinfo }},
  { "borderBottomStyle", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &borderBottomStyle_getterinfo }, { (JSStrictPropertyOp)genericSetter, &borderBottomStyle_setterinfo }},
  { "borderBottomWidth", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &borderBottomWidth_getterinfo }, { (JSStrictPropertyOp)genericSetter, &borderBottomWidth_setterinfo }},
  { "borderCollapse", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &borderCollapse_getterinfo }, { (JSStrictPropertyOp)genericSetter, &borderCollapse_setterinfo }},
  { "borderColor", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &borderColor_getterinfo }, { (JSStrictPropertyOp)genericSetter, &borderColor_setterinfo }},
  { "MozBorderEnd", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozBorderEnd_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozBorderEnd_setterinfo }},
  { "MozBorderEndColor", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozBorderEndColor_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozBorderEndColor_setterinfo }},
  { "MozBorderEndStyle", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozBorderEndStyle_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozBorderEndStyle_setterinfo }},
  { "MozBorderEndWidth", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozBorderEndWidth_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozBorderEndWidth_setterinfo }},
  { "borderImage", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &borderImage_getterinfo }, { (JSStrictPropertyOp)genericSetter, &borderImage_setterinfo }},
  { "borderImageSource", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &borderImageSource_getterinfo }, { (JSStrictPropertyOp)genericSetter, &borderImageSource_setterinfo }},
  { "borderImageSlice", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &borderImageSlice_getterinfo }, { (JSStrictPropertyOp)genericSetter, &borderImageSlice_setterinfo }},
  { "borderImageWidth", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &borderImageWidth_getterinfo }, { (JSStrictPropertyOp)genericSetter, &borderImageWidth_setterinfo }},
  { "borderImageOutset", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &borderImageOutset_getterinfo }, { (JSStrictPropertyOp)genericSetter, &borderImageOutset_setterinfo }},
  { "borderImageRepeat", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &borderImageRepeat_getterinfo }, { (JSStrictPropertyOp)genericSetter, &borderImageRepeat_setterinfo }},
  { "borderLeft", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &borderLeft_getterinfo }, { (JSStrictPropertyOp)genericSetter, &borderLeft_setterinfo }},
  { "borderLeftColor", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &borderLeftColor_getterinfo }, { (JSStrictPropertyOp)genericSetter, &borderLeftColor_setterinfo }},
  { "MozBorderLeftColors", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozBorderLeftColors_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozBorderLeftColors_setterinfo }},
  { "borderLeftStyle", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &borderLeftStyle_getterinfo }, { (JSStrictPropertyOp)genericSetter, &borderLeftStyle_setterinfo }},
  { "borderLeftWidth", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &borderLeftWidth_getterinfo }, { (JSStrictPropertyOp)genericSetter, &borderLeftWidth_setterinfo }},
  { "borderRight", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &borderRight_getterinfo }, { (JSStrictPropertyOp)genericSetter, &borderRight_setterinfo }},
  { "borderRightColor", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &borderRightColor_getterinfo }, { (JSStrictPropertyOp)genericSetter, &borderRightColor_setterinfo }},
  { "MozBorderRightColors", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozBorderRightColors_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozBorderRightColors_setterinfo }},
  { "borderRightStyle", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &borderRightStyle_getterinfo }, { (JSStrictPropertyOp)genericSetter, &borderRightStyle_setterinfo }},
  { "borderRightWidth", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &borderRightWidth_getterinfo }, { (JSStrictPropertyOp)genericSetter, &borderRightWidth_setterinfo }},
  { "borderSpacing", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &borderSpacing_getterinfo }, { (JSStrictPropertyOp)genericSetter, &borderSpacing_setterinfo }},
  { "MozBorderStart", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozBorderStart_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozBorderStart_setterinfo }},
  { "MozBorderStartColor", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozBorderStartColor_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozBorderStartColor_setterinfo }},
  { "MozBorderStartStyle", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozBorderStartStyle_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozBorderStartStyle_setterinfo }},
  { "MozBorderStartWidth", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozBorderStartWidth_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozBorderStartWidth_setterinfo }},
  { "borderStyle", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &borderStyle_getterinfo }, { (JSStrictPropertyOp)genericSetter, &borderStyle_setterinfo }},
  { "borderTop", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &borderTop_getterinfo }, { (JSStrictPropertyOp)genericSetter, &borderTop_setterinfo }},
  { "borderTopColor", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &borderTopColor_getterinfo }, { (JSStrictPropertyOp)genericSetter, &borderTopColor_setterinfo }},
  { "MozBorderTopColors", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozBorderTopColors_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozBorderTopColors_setterinfo }},
  { "borderTopStyle", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &borderTopStyle_getterinfo }, { (JSStrictPropertyOp)genericSetter, &borderTopStyle_setterinfo }},
  { "borderTopWidth", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &borderTopWidth_getterinfo }, { (JSStrictPropertyOp)genericSetter, &borderTopWidth_setterinfo }},
  { "borderWidth", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &borderWidth_getterinfo }, { (JSStrictPropertyOp)genericSetter, &borderWidth_setterinfo }},
  { "borderRadius", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &borderRadius_getterinfo }, { (JSStrictPropertyOp)genericSetter, &borderRadius_setterinfo }},
  { "borderTopLeftRadius", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &borderTopLeftRadius_getterinfo }, { (JSStrictPropertyOp)genericSetter, &borderTopLeftRadius_setterinfo }},
  { "borderTopRightRadius", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &borderTopRightRadius_getterinfo }, { (JSStrictPropertyOp)genericSetter, &borderTopRightRadius_setterinfo }},
  { "borderBottomRightRadius", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &borderBottomRightRadius_getterinfo }, { (JSStrictPropertyOp)genericSetter, &borderBottomRightRadius_setterinfo }},
  { "borderBottomLeftRadius", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &borderBottomLeftRadius_getterinfo }, { (JSStrictPropertyOp)genericSetter, &borderBottomLeftRadius_setterinfo }},
  { "bottom", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &bottom_getterinfo }, { (JSStrictPropertyOp)genericSetter, &bottom_setterinfo }},
  { "boxShadow", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &boxShadow_getterinfo }, { (JSStrictPropertyOp)genericSetter, &boxShadow_setterinfo }},
  { "MozBoxSizing", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozBoxSizing_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozBoxSizing_setterinfo }},
  { "captionSide", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &captionSide_getterinfo }, { (JSStrictPropertyOp)genericSetter, &captionSide_setterinfo }},
  { "clear", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &clear_getterinfo }, { (JSStrictPropertyOp)genericSetter, &clear_setterinfo }},
  { "clip", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &clip_getterinfo }, { (JSStrictPropertyOp)genericSetter, &clip_setterinfo }},
  { "color", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &color_getterinfo }, { (JSStrictPropertyOp)genericSetter, &color_setterinfo }},
  { "MozColumns", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozColumns_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozColumns_setterinfo }},
  { "MozColumnCount", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozColumnCount_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozColumnCount_setterinfo }},
  { "MozColumnWidth", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozColumnWidth_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozColumnWidth_setterinfo }},
  { "MozColumnGap", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozColumnGap_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozColumnGap_setterinfo }},
  { "MozColumnRule", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozColumnRule_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozColumnRule_setterinfo }},
  { "MozColumnRuleColor", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozColumnRuleColor_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozColumnRuleColor_setterinfo }},
  { "MozColumnRuleStyle", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozColumnRuleStyle_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozColumnRuleStyle_setterinfo }},
  { "MozColumnRuleWidth", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozColumnRuleWidth_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozColumnRuleWidth_setterinfo }},
  { "content", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &content_getterinfo }, { (JSStrictPropertyOp)genericSetter, &content_setterinfo }},
  { "counterIncrement", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &counterIncrement_getterinfo }, { (JSStrictPropertyOp)genericSetter, &counterIncrement_setterinfo }},
  { "counterReset", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &counterReset_getterinfo }, { (JSStrictPropertyOp)genericSetter, &counterReset_setterinfo }},
  { "cursor", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &cursor_getterinfo }, { (JSStrictPropertyOp)genericSetter, &cursor_setterinfo }},
  { "direction", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &direction_getterinfo }, { (JSStrictPropertyOp)genericSetter, &direction_setterinfo }},
  { "display", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &display_getterinfo }, { (JSStrictPropertyOp)genericSetter, &display_setterinfo }},
  { "emptyCells", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &emptyCells_getterinfo }, { (JSStrictPropertyOp)genericSetter, &emptyCells_setterinfo }},
  { 0, 0, 0, JSOP_NULLWRAPPER, JSOP_NULLWRAPPER },
  { "alignItems", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &alignItems_getterinfo }, { (JSStrictPropertyOp)genericSetter, &alignItems_setterinfo }},
  { "alignSelf", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &alignSelf_getterinfo }, { (JSStrictPropertyOp)genericSetter, &alignSelf_setterinfo }},
  { "flex", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &flex_getterinfo }, { (JSStrictPropertyOp)genericSetter, &flex_setterinfo }},
  { "flexBasis", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &flexBasis_getterinfo }, { (JSStrictPropertyOp)genericSetter, &flexBasis_setterinfo }},
  { "flexDirection", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &flexDirection_getterinfo }, { (JSStrictPropertyOp)genericSetter, &flexDirection_setterinfo }},
  { "flexGrow", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &flexGrow_getterinfo }, { (JSStrictPropertyOp)genericSetter, &flexGrow_setterinfo }},
  { "flexShrink", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &flexShrink_getterinfo }, { (JSStrictPropertyOp)genericSetter, &flexShrink_setterinfo }},
  { "order", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &order_getterinfo }, { (JSStrictPropertyOp)genericSetter, &order_setterinfo }},
  { "justifyContent", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &justifyContent_getterinfo }, { (JSStrictPropertyOp)genericSetter, &justifyContent_setterinfo }},
  { 0, 0, 0, JSOP_NULLWRAPPER, JSOP_NULLWRAPPER },
  { "cssFloat", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &cssFloat_getterinfo }, { (JSStrictPropertyOp)genericSetter, &cssFloat_setterinfo }},
  { "MozFloatEdge", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozFloatEdge_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozFloatEdge_setterinfo }},
  { "font", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &font_getterinfo }, { (JSStrictPropertyOp)genericSetter, &font_setterinfo }},
  { "fontFamily", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &fontFamily_getterinfo }, { (JSStrictPropertyOp)genericSetter, &fontFamily_setterinfo }},
  { "MozFontFeatureSettings", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozFontFeatureSettings_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozFontFeatureSettings_setterinfo }},
  { "MozFontLanguageOverride", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozFontLanguageOverride_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozFontLanguageOverride_setterinfo }},
  { "fontSize", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &fontSize_getterinfo }, { (JSStrictPropertyOp)genericSetter, &fontSize_setterinfo }},
  { "fontSizeAdjust", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &fontSizeAdjust_getterinfo }, { (JSStrictPropertyOp)genericSetter, &fontSizeAdjust_setterinfo }},
  { "fontStretch", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &fontStretch_getterinfo }, { (JSStrictPropertyOp)genericSetter, &fontStretch_setterinfo }},
  { "fontStyle", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &fontStyle_getterinfo }, { (JSStrictPropertyOp)genericSetter, &fontStyle_setterinfo }},
  { "fontVariant", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &fontVariant_getterinfo }, { (JSStrictPropertyOp)genericSetter, &fontVariant_setterinfo }},
  { "fontWeight", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &fontWeight_getterinfo }, { (JSStrictPropertyOp)genericSetter, &fontWeight_setterinfo }},
  { "MozForceBrokenImageIcon", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozForceBrokenImageIcon_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozForceBrokenImageIcon_setterinfo }},
  { "height", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &height_getterinfo }, { (JSStrictPropertyOp)genericSetter, &height_setterinfo }},
  { "MozImageRegion", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozImageRegion_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozImageRegion_setterinfo }},
  { "imeMode", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &imeMode_getterinfo }, { (JSStrictPropertyOp)genericSetter, &imeMode_setterinfo }},
  { "left", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &left_getterinfo }, { (JSStrictPropertyOp)genericSetter, &left_setterinfo }},
  { "letterSpacing", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &letterSpacing_getterinfo }, { (JSStrictPropertyOp)genericSetter, &letterSpacing_setterinfo }},
  { "lineHeight", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &lineHeight_getterinfo }, { (JSStrictPropertyOp)genericSetter, &lineHeight_setterinfo }},
  { "listStyle", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &listStyle_getterinfo }, { (JSStrictPropertyOp)genericSetter, &listStyle_setterinfo }},
  { "listStyleImage", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &listStyleImage_getterinfo }, { (JSStrictPropertyOp)genericSetter, &listStyleImage_setterinfo }},
  { "listStylePosition", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &listStylePosition_getterinfo }, { (JSStrictPropertyOp)genericSetter, &listStylePosition_setterinfo }},
  { "listStyleType", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &listStyleType_getterinfo }, { (JSStrictPropertyOp)genericSetter, &listStyleType_setterinfo }},
  { "margin", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &margin_getterinfo }, { (JSStrictPropertyOp)genericSetter, &margin_setterinfo }},
  { "marginBottom", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &marginBottom_getterinfo }, { (JSStrictPropertyOp)genericSetter, &marginBottom_setterinfo }},
  { "MozMarginEnd", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozMarginEnd_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozMarginEnd_setterinfo }},
  { "marginLeft", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &marginLeft_getterinfo }, { (JSStrictPropertyOp)genericSetter, &marginLeft_setterinfo }},
  { "marginRight", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &marginRight_getterinfo }, { (JSStrictPropertyOp)genericSetter, &marginRight_setterinfo }},
  { "MozMarginStart", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozMarginStart_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozMarginStart_setterinfo }},
  { "marginTop", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &marginTop_getterinfo }, { (JSStrictPropertyOp)genericSetter, &marginTop_setterinfo }},
  { "markerOffset", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &markerOffset_getterinfo }, { (JSStrictPropertyOp)genericSetter, &markerOffset_setterinfo }},
  { "marks", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &marks_getterinfo }, { (JSStrictPropertyOp)genericSetter, &marks_setterinfo }},
  { "maxHeight", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &maxHeight_getterinfo }, { (JSStrictPropertyOp)genericSetter, &maxHeight_setterinfo }},
  { "maxWidth", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &maxWidth_getterinfo }, { (JSStrictPropertyOp)genericSetter, &maxWidth_setterinfo }},
  { "minHeight", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &minHeight_getterinfo }, { (JSStrictPropertyOp)genericSetter, &minHeight_setterinfo }},
  { "minWidth", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &minWidth_getterinfo }, { (JSStrictPropertyOp)genericSetter, &minWidth_setterinfo }},
  { "opacity", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &opacity_getterinfo }, { (JSStrictPropertyOp)genericSetter, &opacity_setterinfo }},
  { "MozOrient", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozOrient_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozOrient_setterinfo }},
  { "orphans", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &orphans_getterinfo }, { (JSStrictPropertyOp)genericSetter, &orphans_setterinfo }},
  { "outline", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &outline_getterinfo }, { (JSStrictPropertyOp)genericSetter, &outline_setterinfo }},
  { "outlineColor", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &outlineColor_getterinfo }, { (JSStrictPropertyOp)genericSetter, &outlineColor_setterinfo }},
  { "outlineStyle", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &outlineStyle_getterinfo }, { (JSStrictPropertyOp)genericSetter, &outlineStyle_setterinfo }},
  { "outlineWidth", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &outlineWidth_getterinfo }, { (JSStrictPropertyOp)genericSetter, &outlineWidth_setterinfo }},
  { "outlineOffset", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &outlineOffset_getterinfo }, { (JSStrictPropertyOp)genericSetter, &outlineOffset_setterinfo }},
  { "overflow", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &overflow_getterinfo }, { (JSStrictPropertyOp)genericSetter, &overflow_setterinfo }},
  { "overflowX", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &overflowX_getterinfo }, { (JSStrictPropertyOp)genericSetter, &overflowX_setterinfo }},
  { "overflowY", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &overflowY_getterinfo }, { (JSStrictPropertyOp)genericSetter, &overflowY_setterinfo }},
  { "padding", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &padding_getterinfo }, { (JSStrictPropertyOp)genericSetter, &padding_setterinfo }},
  { "paddingBottom", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &paddingBottom_getterinfo }, { (JSStrictPropertyOp)genericSetter, &paddingBottom_setterinfo }},
  { "MozPaddingEnd", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozPaddingEnd_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozPaddingEnd_setterinfo }},
  { "paddingLeft", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &paddingLeft_getterinfo }, { (JSStrictPropertyOp)genericSetter, &paddingLeft_setterinfo }},
  { "paddingRight", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &paddingRight_getterinfo }, { (JSStrictPropertyOp)genericSetter, &paddingRight_setterinfo }},
  { "MozPaddingStart", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozPaddingStart_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozPaddingStart_setterinfo }},
  { "paddingTop", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &paddingTop_getterinfo }, { (JSStrictPropertyOp)genericSetter, &paddingTop_setterinfo }},
  { "page", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &page_getterinfo }, { (JSStrictPropertyOp)genericSetter, &page_setterinfo }},
  { "pageBreakAfter", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &pageBreakAfter_getterinfo }, { (JSStrictPropertyOp)genericSetter, &pageBreakAfter_setterinfo }},
  { "pageBreakBefore", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &pageBreakBefore_getterinfo }, { (JSStrictPropertyOp)genericSetter, &pageBreakBefore_setterinfo }},
  { "pageBreakInside", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &pageBreakInside_getterinfo }, { (JSStrictPropertyOp)genericSetter, &pageBreakInside_setterinfo }},
  { "pointerEvents", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &pointerEvents_getterinfo }, { (JSStrictPropertyOp)genericSetter, &pointerEvents_setterinfo }},
  { "position", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &position_getterinfo }, { (JSStrictPropertyOp)genericSetter, &position_setterinfo }},
  { "quotes", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &quotes_getterinfo }, { (JSStrictPropertyOp)genericSetter, &quotes_setterinfo }},
  { "resize", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &resize_getterinfo }, { (JSStrictPropertyOp)genericSetter, &resize_setterinfo }},
  { "right", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &right_getterinfo }, { (JSStrictPropertyOp)genericSetter, &right_setterinfo }},
  { "size", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &size_getterinfo }, { (JSStrictPropertyOp)genericSetter, &size_setterinfo }},
  { "tableLayout", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &tableLayout_getterinfo }, { (JSStrictPropertyOp)genericSetter, &tableLayout_setterinfo }},
  { "textAlign", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &textAlign_getterinfo }, { (JSStrictPropertyOp)genericSetter, &textAlign_setterinfo }},
  { "MozTextAlignLast", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozTextAlignLast_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozTextAlignLast_setterinfo }},
  { "textDecoration", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &textDecoration_getterinfo }, { (JSStrictPropertyOp)genericSetter, &textDecoration_setterinfo }},
  { "MozTextBlink", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozTextBlink_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozTextBlink_setterinfo }},
  { "MozTextDecorationColor", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozTextDecorationColor_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozTextDecorationColor_setterinfo }},
  { "MozTextDecorationLine", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozTextDecorationLine_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozTextDecorationLine_setterinfo }},
  { "MozTextDecorationStyle", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozTextDecorationStyle_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozTextDecorationStyle_setterinfo }},
  { "textIndent", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &textIndent_getterinfo }, { (JSStrictPropertyOp)genericSetter, &textIndent_setterinfo }},
  { "textOverflow", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &textOverflow_getterinfo }, { (JSStrictPropertyOp)genericSetter, &textOverflow_setterinfo }},
  { "textShadow", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &textShadow_getterinfo }, { (JSStrictPropertyOp)genericSetter, &textShadow_setterinfo }},
  { "MozTextSizeAdjust", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozTextSizeAdjust_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozTextSizeAdjust_setterinfo }},
  { "textTransform", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &textTransform_getterinfo }, { (JSStrictPropertyOp)genericSetter, &textTransform_setterinfo }},
  { "transform", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &transform_getterinfo }, { (JSStrictPropertyOp)genericSetter, &transform_setterinfo }},
  { "transformOrigin", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &transformOrigin_getterinfo }, { (JSStrictPropertyOp)genericSetter, &transformOrigin_setterinfo }},
  { "perspectiveOrigin", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &perspectiveOrigin_getterinfo }, { (JSStrictPropertyOp)genericSetter, &perspectiveOrigin_setterinfo }},
  { "perspective", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &perspective_getterinfo }, { (JSStrictPropertyOp)genericSetter, &perspective_setterinfo }},
  { "transformStyle", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &transformStyle_getterinfo }, { (JSStrictPropertyOp)genericSetter, &transformStyle_setterinfo }},
  { "backfaceVisibility", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &backfaceVisibility_getterinfo }, { (JSStrictPropertyOp)genericSetter, &backfaceVisibility_setterinfo }},
  { "top", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &top_getterinfo }, { (JSStrictPropertyOp)genericSetter, &top_setterinfo }},
  { "transition", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &transition_getterinfo }, { (JSStrictPropertyOp)genericSetter, &transition_setterinfo }},
  { "transitionDelay", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &transitionDelay_getterinfo }, { (JSStrictPropertyOp)genericSetter, &transitionDelay_setterinfo }},
  { "transitionDuration", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &transitionDuration_getterinfo }, { (JSStrictPropertyOp)genericSetter, &transitionDuration_setterinfo }},
  { "transitionProperty", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &transitionProperty_getterinfo }, { (JSStrictPropertyOp)genericSetter, &transitionProperty_setterinfo }},
  { "transitionTimingFunction", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &transitionTimingFunction_getterinfo }, { (JSStrictPropertyOp)genericSetter, &transitionTimingFunction_setterinfo }},
  { "unicodeBidi", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &unicodeBidi_getterinfo }, { (JSStrictPropertyOp)genericSetter, &unicodeBidi_setterinfo }},
  { "MozUserFocus", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozUserFocus_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozUserFocus_setterinfo }},
  { "MozUserInput", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozUserInput_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozUserInput_setterinfo }},
  { "MozUserModify", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozUserModify_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozUserModify_setterinfo }},
  { "MozUserSelect", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozUserSelect_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozUserSelect_setterinfo }},
  { "verticalAlign", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &verticalAlign_getterinfo }, { (JSStrictPropertyOp)genericSetter, &verticalAlign_setterinfo }},
  { "visibility", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &visibility_getterinfo }, { (JSStrictPropertyOp)genericSetter, &visibility_setterinfo }},
  { "whiteSpace", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &whiteSpace_getterinfo }, { (JSStrictPropertyOp)genericSetter, &whiteSpace_setterinfo }},
  { "widows", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &widows_getterinfo }, { (JSStrictPropertyOp)genericSetter, &widows_setterinfo }},
  { "width", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &width_getterinfo }, { (JSStrictPropertyOp)genericSetter, &width_setterinfo }},
  { "MozWindowShadow", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozWindowShadow_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozWindowShadow_setterinfo }},
  { "wordBreak", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &wordBreak_getterinfo }, { (JSStrictPropertyOp)genericSetter, &wordBreak_setterinfo }},
  { "wordSpacing", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &wordSpacing_getterinfo }, { (JSStrictPropertyOp)genericSetter, &wordSpacing_setterinfo }},
  { "wordWrap", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &wordWrap_getterinfo }, { (JSStrictPropertyOp)genericSetter, &wordWrap_setterinfo }},
  { "MozHyphens", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozHyphens_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozHyphens_setterinfo }},
  { "zIndex", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &zIndex_getterinfo }, { (JSStrictPropertyOp)genericSetter, &zIndex_setterinfo }},
  { "MozBoxAlign", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozBoxAlign_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozBoxAlign_setterinfo }},
  { "MozBoxDirection", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozBoxDirection_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozBoxDirection_setterinfo }},
  { "MozBoxFlex", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozBoxFlex_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozBoxFlex_setterinfo }},
  { "MozBoxOrient", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozBoxOrient_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozBoxOrient_setterinfo }},
  { "MozBoxPack", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozBoxPack_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozBoxPack_setterinfo }},
  { "MozBoxOrdinalGroup", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozBoxOrdinalGroup_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozBoxOrdinalGroup_setterinfo }},
  { "MozStackSizing", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozStackSizing_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozStackSizing_setterinfo }},
  { "clipPath", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &clipPath_getterinfo }, { (JSStrictPropertyOp)genericSetter, &clipPath_setterinfo }},
  { "clipRule", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &clipRule_getterinfo }, { (JSStrictPropertyOp)genericSetter, &clipRule_setterinfo }},
  { "colorInterpolation", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &colorInterpolation_getterinfo }, { (JSStrictPropertyOp)genericSetter, &colorInterpolation_setterinfo }},
  { "colorInterpolationFilters", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &colorInterpolationFilters_getterinfo }, { (JSStrictPropertyOp)genericSetter, &colorInterpolationFilters_setterinfo }},
  { "dominantBaseline", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &dominantBaseline_getterinfo }, { (JSStrictPropertyOp)genericSetter, &dominantBaseline_setterinfo }},
  { "fill", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &fill_getterinfo }, { (JSStrictPropertyOp)genericSetter, &fill_setterinfo }},
  { "fillOpacity", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &fillOpacity_getterinfo }, { (JSStrictPropertyOp)genericSetter, &fillOpacity_setterinfo }},
  { "fillRule", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &fillRule_getterinfo }, { (JSStrictPropertyOp)genericSetter, &fillRule_setterinfo }},
  { "filter", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &filter_getterinfo }, { (JSStrictPropertyOp)genericSetter, &filter_setterinfo }},
  { "floodColor", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &floodColor_getterinfo }, { (JSStrictPropertyOp)genericSetter, &floodColor_setterinfo }},
  { "floodOpacity", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &floodOpacity_getterinfo }, { (JSStrictPropertyOp)genericSetter, &floodOpacity_setterinfo }},
  { "imageRendering", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &imageRendering_getterinfo }, { (JSStrictPropertyOp)genericSetter, &imageRendering_setterinfo }},
  { "lightingColor", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &lightingColor_getterinfo }, { (JSStrictPropertyOp)genericSetter, &lightingColor_setterinfo }},
  { "marker", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &marker_getterinfo }, { (JSStrictPropertyOp)genericSetter, &marker_setterinfo }},
  { "markerEnd", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &markerEnd_getterinfo }, { (JSStrictPropertyOp)genericSetter, &markerEnd_setterinfo }},
  { "markerMid", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &markerMid_getterinfo }, { (JSStrictPropertyOp)genericSetter, &markerMid_setterinfo }},
  { "markerStart", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &markerStart_getterinfo }, { (JSStrictPropertyOp)genericSetter, &markerStart_setterinfo }},
  { "mask", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &mask_getterinfo }, { (JSStrictPropertyOp)genericSetter, &mask_setterinfo }},
  { 0, 0, 0, JSOP_NULLWRAPPER, JSOP_NULLWRAPPER },
  { "maskType", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &maskType_getterinfo }, { (JSStrictPropertyOp)genericSetter, &maskType_setterinfo }},
  { 0, 0, 0, JSOP_NULLWRAPPER, JSOP_NULLWRAPPER },
  { "shapeRendering", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &shapeRendering_getterinfo }, { (JSStrictPropertyOp)genericSetter, &shapeRendering_setterinfo }},
  { "stopColor", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &stopColor_getterinfo }, { (JSStrictPropertyOp)genericSetter, &stopColor_setterinfo }},
  { "stopOpacity", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &stopOpacity_getterinfo }, { (JSStrictPropertyOp)genericSetter, &stopOpacity_setterinfo }},
  { "stroke", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &stroke_getterinfo }, { (JSStrictPropertyOp)genericSetter, &stroke_setterinfo }},
  { "strokeDasharray", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &strokeDasharray_getterinfo }, { (JSStrictPropertyOp)genericSetter, &strokeDasharray_setterinfo }},
  { "strokeDashoffset", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &strokeDashoffset_getterinfo }, { (JSStrictPropertyOp)genericSetter, &strokeDashoffset_setterinfo }},
  { "strokeLinecap", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &strokeLinecap_getterinfo }, { (JSStrictPropertyOp)genericSetter, &strokeLinecap_setterinfo }},
  { "strokeLinejoin", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &strokeLinejoin_getterinfo }, { (JSStrictPropertyOp)genericSetter, &strokeLinejoin_setterinfo }},
  { "strokeMiterlimit", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &strokeMiterlimit_getterinfo }, { (JSStrictPropertyOp)genericSetter, &strokeMiterlimit_setterinfo }},
  { "strokeOpacity", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &strokeOpacity_getterinfo }, { (JSStrictPropertyOp)genericSetter, &strokeOpacity_setterinfo }},
  { "strokeWidth", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &strokeWidth_getterinfo }, { (JSStrictPropertyOp)genericSetter, &strokeWidth_setterinfo }},
  { "textAnchor", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &textAnchor_getterinfo }, { (JSStrictPropertyOp)genericSetter, &textAnchor_setterinfo }},
  { "textRendering", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &textRendering_getterinfo }, { (JSStrictPropertyOp)genericSetter, &textRendering_setterinfo }},
  { "vectorEffect", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &vectorEffect_getterinfo }, { (JSStrictPropertyOp)genericSetter, &vectorEffect_setterinfo }},
  { 0, 0, 0, JSOP_NULLWRAPPER, JSOP_NULLWRAPPER },
  { "MozTransform", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozTransform_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozTransform_setterinfo }},
  { "MozTransformOrigin", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozTransformOrigin_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozTransformOrigin_setterinfo }},
  { "MozPerspectiveOrigin", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozPerspectiveOrigin_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozPerspectiveOrigin_setterinfo }},
  { "MozPerspective", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozPerspective_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozPerspective_setterinfo }},
  { "MozTransformStyle", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozTransformStyle_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozTransformStyle_setterinfo }},
  { "MozBackfaceVisibility", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozBackfaceVisibility_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozBackfaceVisibility_setterinfo }},
  { 0, 0, 0, JSOP_NULLWRAPPER, JSOP_NULLWRAPPER },
  { "MozBorderImage", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozBorderImage_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozBorderImage_setterinfo }},
  { 0, 0, 0, JSOP_NULLWRAPPER, JSOP_NULLWRAPPER },
  { "MozTransition", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozTransition_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozTransition_setterinfo }},
  { "MozTransitionDelay", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozTransitionDelay_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozTransitionDelay_setterinfo }},
  { "MozTransitionDuration", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozTransitionDuration_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozTransitionDuration_setterinfo }},
  { "MozTransitionProperty", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozTransitionProperty_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozTransitionProperty_setterinfo }},
  { "MozTransitionTimingFunction", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozTransitionTimingFunction_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozTransitionTimingFunction_setterinfo }},
  { 0, 0, 0, JSOP_NULLWRAPPER, JSOP_NULLWRAPPER },
  { "MozAnimation", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozAnimation_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozAnimation_setterinfo }},
  { "MozAnimationDelay", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozAnimationDelay_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozAnimationDelay_setterinfo }},
  { "MozAnimationDirection", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozAnimationDirection_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozAnimationDirection_setterinfo }},
  { "MozAnimationDuration", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozAnimationDuration_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozAnimationDuration_setterinfo }},
  { "MozAnimationFillMode", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozAnimationFillMode_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozAnimationFillMode_setterinfo }},
  { "MozAnimationIterationCount", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozAnimationIterationCount_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozAnimationIterationCount_setterinfo }},
  { "MozAnimationName", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozAnimationName_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozAnimationName_setterinfo }},
  { "MozAnimationPlayState", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozAnimationPlayState_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozAnimationPlayState_setterinfo }},
  { "MozAnimationTimingFunction", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &MozAnimationTimingFunction_getterinfo }, { (JSStrictPropertyOp)genericSetter, &MozAnimationTimingFunction_setterinfo }},
  { 0, 0, 0, JSOP_NULLWRAPPER, JSOP_NULLWRAPPER }
};

static Prefable<JSPropertySpec> sAttributes[] = {
  { true, &sAttributes_specs[0] },
  { true, &sAttributes_specs[95] },
  { true, &sAttributes_specs[105] },
  { true, &sAttributes_specs[236] },
  { true, &sAttributes_specs[238] },
  { true, &sAttributes_specs[253] },
  { true, &sAttributes_specs[260] },
  { true, &sAttributes_specs[262] },
  { true, &sAttributes_specs[268] },
  { false, NULL }
};

static jsid sAttributes_ids[278] = { JSID_VOID };


static const NativeProperties sNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sAttributes, sAttributes_ids, sAttributes_specs,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr
};
const NativePropertyHooks sNativePropertyHooks = {
  ResolveOwnProperty,
  EnumerateOwnProperties,
  { &sNativeProperties, nullptr },
  prototypes::id::CSS2Properties,
  constructors::id::CSS2Properties,
  &CSSStyleDeclarationBinding::sNativePropertyHooks
};

JSNativeHolder _constructor_holder = {
  ThrowingConstructor,
  &sNativePropertyHooks
};

static DOMIfaceAndProtoJSClass PrototypeClass = {
  {
    "CSS2PropertiesPrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(2),
    JS_PropertyStub,       /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    nullptr,               /* finalize */
    nullptr,               /* checkAccess */
    nullptr,               /* call */
    nullptr,               /* hasInstance */
    nullptr,               /* construct */
    nullptr,               /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  eInterfacePrototype,
  &sNativePropertyHooks
};

void
CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray)
{
  JSObject* parentProto = CSSStyleDeclarationBinding::GetProtoObject(aCx, aGlobal);
  if (!parentProto) {
    return;
  }


  if (sAttributes_ids[0] == JSID_VOID &&
      !InitIds(aCx, sAttributes, sAttributes_ids)) {
    sAttributes_ids[0] = JSID_VOID;
    return;
  }

  static bool sPrefCachesInited = false;
  if (!sPrefCachesInited) {
    sPrefCachesInited = true;
    Preferences::AddBoolVarCache(&sAttributes[1].enabled, "layout.css.flexbox.enabled");
    Preferences::AddBoolVarCache(&sAttributes[3].enabled, "layout.css.masking.enabled");
    Preferences::AddBoolVarCache(&sAttributes[5].enabled, "layout.css.prefixes.transforms");
    Preferences::AddBoolVarCache(&sAttributes[6].enabled, "layout.css.prefixes.border-image");
    Preferences::AddBoolVarCache(&sAttributes[7].enabled, "layout.css.prefixes.transitions");
    Preferences::AddBoolVarCache(&sAttributes[8].enabled, "layout.css.prefixes.animations");
  }

  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &PrototypeClass.mBase, &protoAndIfaceArray[prototypes::id::CSS2Properties],
                              nullptr, &_constructor_holder, 0, &protoAndIfaceArray[constructors::id::CSS2Properties],
                              &Class,
                              &sNativeProperties,
                              nullptr,
                              "CSS2Properties");
}

bool
ResolveOwnProperty(JSContext* cx, JSObject* wrapper, JSObject* obj, jsid id, JSPropertyDescriptor* desc, unsigned flags)
{
  // We rely on getOwnPropertyDescriptor not shadowing prototype properties by named
  // properties. If that changes we'll need to filter here.
  return js::GetProxyHandler(obj)->getOwnPropertyDescriptor(cx, wrapper, id, desc, flags);

}

bool
EnumerateOwnProperties(JSContext* cx, JSObject* wrapper, JSObject* obj, JS::AutoIdVector& props)
{
  // We rely on getOwnPropertyNames not shadowing prototype properties by named
  // properties. If that changes we'll need to filter here.
  return js::GetProxyHandler(obj)->getOwnPropertyNames(cx, wrapper, props);

}

JSObject*
DefineDOMInterface(JSContext* aCx, JSObject* aGlobal, bool* aEnabled)
{

  *aEnabled = true;
  return GetConstructorObject(aCx, aGlobal);
}

MOZ_ALWAYS_INLINE bool
IsProxy(JSObject* obj)
{
  return js::IsProxy(obj) && js::GetProxyHandler(obj) == DOMProxyHandler::getInstance();
}

MOZ_ALWAYS_INLINE nsDOMCSSDeclaration*
UnwrapProxy(JSObject* obj)
{
  if (xpc::WrapperFactory::IsXrayWrapper(obj)) {
    obj = js::UnwrapObject(obj);
  }
  MOZ_ASSERT(IsProxy(obj));
  return static_cast<nsDOMCSSDeclaration*>(js::GetProxyPrivate(obj).toPrivate());
}


const DOMClass Class = {
  { prototypes::id::CSSStyleDeclaration, prototypes::id::CSS2Properties, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
  true,
  &sNativePropertyHooks,
  GetParentObject<nsDOMCSSDeclaration>::Get,
  GetProtoObject,
  nullptr
};



DOMProxyHandler::DOMProxyHandler()
  : mozilla::dom::DOMProxyHandler(Class)
{

}


bool
DOMProxyHandler::getOwnPropertyDescriptor(JSContext* cx, JSObject* proxy, jsid id, JSPropertyDescriptor* desc, unsigned flags)
{
  int32_t index = GetArrayIndexFromId(cx, id);
  if (!(flags & JSRESOLVE_ASSIGNING)) {
    if (IsArrayIndex(index)) {
      nsDOMCSSDeclaration* self = UnwrapProxy(proxy);
      bool found;
      nsString result;
      self->IndexedGetter(index, found, result);

      if (found) {
        if (!xpc::NonVoidStringToJsval(cx, result, &desc->value)) {
          return false;
        }
        FillPropertyDescriptor(desc, proxy, true);
        return true;
      }
    }
  }

  JSObject* expando;
  if (!xpc::WrapperFactory::IsXrayWrapper(proxy) && (expando = GetExpandoObject(proxy))) {
    if (!JS_GetPropertyDescriptorById(cx, expando, id, flags, desc)) {
      return false;
    }
    if (desc->obj) {
      // Pretend the property lives on the wrapper.
      desc->obj = proxy;
      return true;
    }
  }

  desc->obj = NULL;
  return true;
}


bool
DOMProxyHandler::getOwnPropertyNames(JSContext* cx, JSObject* proxy, JS::AutoIdVector& props)
{
  uint32_t length = UnwrapProxy(proxy)->Length();
  MOZ_ASSERT(int32_t(length) >= 0);
  for (int32_t i = 0; i < int32_t(length); ++i) {
    if (!props.append(INT_TO_JSID(i))) {
      return false;
    }
  }

  JSObject* expando;
  if (!xpc::WrapperFactory::IsXrayWrapper(proxy) && (expando = DOMProxyHandler::GetExpandoObject(proxy)) &&
      !js::GetPropertyNames(cx, expando, JSITER_OWNONLY | JSITER_HIDDEN, &props)) {
    return false;
  }

  return true;
}


bool
DOMProxyHandler::hasOwn(JSContext* cx, JSObject* proxy, jsid id, bool* bp)
{
  int32_t index = GetArrayIndexFromId(cx, id);
  if (IsArrayIndex(index)) {
    nsDOMCSSDeclaration* self = UnwrapProxy(proxy);
    bool found;
    nsString result;
    self->IndexedGetter(index, found, result);
    (void)result;

    *bp = found;
    return true;
  }

  JSObject* expando = GetExpandoObject(proxy);
  if (expando) {
    JSBool b = true;
    JSBool ok = JS_HasPropertyById(cx, expando, id, &b);
    *bp = !!b;
    if (!ok || *bp) {
      return ok;
    }
  }

  *bp = false;
  return true;
}


bool
DOMProxyHandler::get(JSContext* cx, JSObject* proxy, JSObject* receiver, jsid id, JS::Value* vp)
{
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
              "Should not have a XrayWrapper here");

  int32_t index = GetArrayIndexFromId(cx, id);
  if (IsArrayIndex(index)) {
    nsDOMCSSDeclaration* self = UnwrapProxy(proxy);
    bool found;
    nsString result;
    self->IndexedGetter(index, found, result);

    if (found) {
      if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
        return false;
      }
      return true;
    }
    // Even if we don't have this index, we don't forward the
    // get on to our expando object.
  } else {
    JSObject* expando = DOMProxyHandler::GetExpandoObject(proxy);
    if (expando) {
      JSBool hasProp;
      if (!JS_HasPropertyById(cx, expando, id, &hasProp)) {
        return false;
      }

      if (hasProp) {
        return JS_GetPropertyById(cx, expando, id, vp);
      }
    }
  }

  {  // Scope for this "found" so it doesn't leak to things below
    bool found;
    if (!GetPropertyOnPrototype(cx, proxy, id, &found, vp)) {
      return false;
    }

    if (found) {
      return true;
    }
  }

  vp->setUndefined();
  return true;
}


JSString*
DOMProxyHandler::obj_toString(JSContext* cx, JSObject* proxy)
{
  return mozilla::dom::DOMProxyHandler::obj_toString(cx, "CSS2Properties");
}


void
DOMProxyHandler::finalize(JSFreeOp* fop, JSObject* proxy)
{
  nsDOMCSSDeclaration* self = UnwrapProxy(proxy);

  if (self) {
    ClearWrapper(self, self);
    XPCJSRuntime *rt = nsXPConnect::GetRuntimeInstance();
    if (rt) {
      rt->DeferredRelease(reinterpret_cast<nsISupports*>(self));
    } else {
      NS_RELEASE(self);
    }
  }
}


bool
DOMProxyHandler::getElementIfPresent(JSContext* cx, JSObject* proxy, JSObject* receiver, uint32_t index, JS::Value* vp, bool* present)
{
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
               "Should not have a XrayWrapper here");

  nsDOMCSSDeclaration* self = UnwrapProxy(proxy);
  bool found;
  nsString result;
  self->IndexedGetter(index, found, result);

  if (found) {
    if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
      return false;
    }
    *present = found;
    return true;
  }
  // We skip the expando object and any named getters if
  // there is an indexed getter.


  JSObject *proto;
  if (!js::GetObjectProto(cx, proxy, &proto)) {
    return false;
  }
  if (proto) {
    JSBool isPresent;
    if (!JS_GetElementIfPresent(cx, proto, index, proxy, vp, &isPresent)) {
      return false;
    }
    *present = isPresent;
    return true;
  }

  *present = false;
  // Can't Debug_SetValueRangeToCrashOnTouch because it's not public
  return true;
}


DOMProxyHandler*
DOMProxyHandler::getInstance()
{
  static DOMProxyHandler instance;
  return &instance;
}


bool
DOMProxyHandler::delete_(JSContext* cx, JSObject* proxy, jsid id, bool* bp)
{
  int32_t index = GetArrayIndexFromId(cx, id);
  if (IsArrayIndex(index)) {
    nsDOMCSSDeclaration* self = UnwrapProxy(proxy);
    bool found;
    nsString result;
    self->IndexedGetter(index, found, result);
    (void)result;
    if (found) {
      // XXXbz we should throw if Throw is true!
      *bp = false;
    } else {
      *bp = true;
    }
    // We always return here, even if the property was not found
    return true;
  }
  return dom::DOMProxyHandler::delete_(cx, proxy, id, bp);
}


bool
Is(JSObject* obj)
{
  return IsProxy(obj);
}

JSObject*
Wrap(JSContext* aCx, JSObject* aScope, nsDOMCSSDeclaration* aObject, nsWrapperCache* aCache, bool* aTriedToWrap)
{
  MOZ_ASSERT(static_cast<nsDOMCSSDeclaration*>(aObject) ==
             reinterpret_cast<nsDOMCSSDeclaration*>(aObject));
  MOZ_ASSERT(static_cast<nsICSSDeclaration*>(aObject) ==
             reinterpret_cast<nsICSSDeclaration*>(aObject));

  *aTriedToWrap = true;

  JSObject* parent = WrapNativeParent(aCx, aScope, aObject->GetParentObject());
  if (!parent) {
    return NULL;
  }

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.  Scope so we don't
  // collide with the "obj" we declare in CreateBindingJSObject.
  {
    JSObject* obj = aCache->GetWrapper();
    if (obj) {
      return obj;
    }
  }

  JSAutoCompartment ac(aCx, parent);
  JSObject* global = JS_GetGlobalForObject(aCx, parent);

  JSObject* proto = GetProtoObject(aCx, global);
  if (!proto) {
    return NULL;
  }

  JSObject *obj = NewProxyObject(aCx, DOMProxyHandler::getInstance(),
                                 JS::PrivateValue(aObject), proto, parent);
  if (!obj) {
    return NULL;
  }

  NS_ADDREF(aObject);


  aCache->SetWrapper(obj);

  return obj;
}

} // namespace CSS2PropertiesBinding



} // namespace dom
} // namespace mozilla
