/* THIS FILE IS AUTOGENERATED - DO NOT EDIT */

#include "AccessCheck.h"
#include "PrimitiveConversions.h"
#include "TestBindingHeader.h"
#include "TestCodeGenBinding.h"
#include "TestDictionaryBinding.h"
#include "TestExampleGenBinding.h"
#include "TestExampleInterface-example.h"
#include "TestExampleProxyInterface-example.h"
#include "WorkerPrivate.h"
#include "XPCQuickStubs.h"
#include "XPCWrapper.h"
#include "jsfriendapi.h"
#include "mozilla/FloatingPoint.h"
#include "mozilla/Preferences.h"
#include "mozilla/dom/BindingUtils.h"
#include "mozilla/dom/NonRefcountedDOMObject.h"
#include "mozilla/dom/Nullable.h"
#include "mozilla/dom/TypedArray.h"
#include "mozilla/dom/UnionConversions.h"
#include "nsContentUtils.h"
#include "nsDOMQS.h"

using namespace mozilla::dom;
namespace mozilla {
namespace dom {

namespace TestExampleInterfaceBinding {

static bool
get_readonlyByte(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* vp)
{
  int8_t result;
  result = self->ReadonlyByte();
  *vp = INT_TO_JSVAL(int32_t(result));
  return true;
}


const JSJitInfo readonlyByte_getterinfo = {
  (JSJitPropertyOp)get_readonlyByte,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_writableByte(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* vp)
{
  int8_t result;
  result = self->WritableByte();
  *vp = INT_TO_JSVAL(int32_t(result));
  return true;
}

static bool
set_writableByte(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* argv)
{
  int8_t arg0;
  if (!ValueToPrimitive<int8_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  self->SetWritableByte(arg0);

  return true;
}


const JSJitInfo writableByte_getterinfo = {
  (JSJitPropertyOp)get_writableByte,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo writableByte_setterinfo = {
  (JSJitPropertyOp)set_writableByte,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passByte(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.passByte");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  int8_t arg0;
  if (!ValueToPrimitive<int8_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  self->PassByte(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passByte_methodinfo = {
  (JSJitPropertyOp)passByte,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveByte(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{
  int8_t result;
  result = self->ReceiveByte();
  *vp = INT_TO_JSVAL(int32_t(result));
  return true;
}


const JSJitInfo receiveByte_methodinfo = {
  (JSJitPropertyOp)receiveByte,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalByte(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  const Optional< int8_t > arg0;
  if (0 < argc) {
    const_cast< Optional< int8_t > &>(arg0).Construct();
    if (!ValueToPrimitive<int8_t, eDefault>(cx, argv[0], &const_cast< int8_t & >(arg0.Value()))) {
      return false;
    }
  }
  self->PassOptionalByte(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalByte_methodinfo = {
  (JSJitPropertyOp)passOptionalByte,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalByteWithDefault(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  int8_t arg0;
  if (0 < argc) {
    if (!ValueToPrimitive<int8_t, eDefault>(cx, argv[0], &arg0)) {
      return false;
    }
  } else {
    arg0 = 0;
  }
  self->PassOptionalByteWithDefault(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalByteWithDefault_methodinfo = {
  (JSJitPropertyOp)passOptionalByteWithDefault,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passNullableByte(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.passNullableByte");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  const Nullable<int8_t> arg0;
  if (argv[0].isNullOrUndefined()) {
    const_cast< Nullable<int8_t>& >(arg0).SetNull();
  } else if (!ValueToPrimitive<int8_t, eDefault>(cx, argv[0], &const_cast< Nullable<int8_t>& >(arg0).SetValue())) {
    return false;
  }
  self->PassNullableByte(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passNullableByte_methodinfo = {
  (JSJitPropertyOp)passNullableByte,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalNullableByte(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  const Optional< Nullable<int8_t> > arg0;
  if (0 < argc) {
    const_cast< Optional< Nullable<int8_t> > &>(arg0).Construct();
    if (argv[0].isNullOrUndefined()) {
      const_cast< Nullable<int8_t>& >(const_cast< Nullable<int8_t> & >(arg0.Value())).SetNull();
    } else if (!ValueToPrimitive<int8_t, eDefault>(cx, argv[0], &const_cast< Nullable<int8_t>& >(const_cast< Nullable<int8_t> & >(arg0.Value())).SetValue())) {
      return false;
    }
  }
  self->PassOptionalNullableByte(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalNullableByte_methodinfo = {
  (JSJitPropertyOp)passOptionalNullableByte,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passVariadicByte(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  const Sequence< int8_t > arg0;
  if (argc > 0) {
    Sequence< int8_t >& arr = const_cast< Sequence< int8_t >& >(arg0);
    if (!arr.SetCapacity(argc - 0)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t variadicArg = 0; variadicArg < argc; ++variadicArg) {
      int8_t& slot = *arr.AppendElement();
      if (!ValueToPrimitive<int8_t, eDefault>(cx, argv[variadicArg], &slot)) {
        return false;
      }
    }
  }
  self->PassVariadicByte(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passVariadicByte_methodinfo = {
  (JSJitPropertyOp)passVariadicByte,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_readonlyShort(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* vp)
{
  int16_t result;
  result = self->ReadonlyShort();
  *vp = INT_TO_JSVAL(int32_t(result));
  return true;
}


const JSJitInfo readonlyShort_getterinfo = {
  (JSJitPropertyOp)get_readonlyShort,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_writableShort(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* vp)
{
  int16_t result;
  result = self->WritableShort();
  *vp = INT_TO_JSVAL(int32_t(result));
  return true;
}

static bool
set_writableShort(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* argv)
{
  int16_t arg0;
  if (!ValueToPrimitive<int16_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  self->SetWritableShort(arg0);

  return true;
}


const JSJitInfo writableShort_getterinfo = {
  (JSJitPropertyOp)get_writableShort,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo writableShort_setterinfo = {
  (JSJitPropertyOp)set_writableShort,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passShort(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.passShort");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  int16_t arg0;
  if (!ValueToPrimitive<int16_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  self->PassShort(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passShort_methodinfo = {
  (JSJitPropertyOp)passShort,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveShort(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{
  int16_t result;
  result = self->ReceiveShort();
  *vp = INT_TO_JSVAL(int32_t(result));
  return true;
}


const JSJitInfo receiveShort_methodinfo = {
  (JSJitPropertyOp)receiveShort,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalShort(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  const Optional< int16_t > arg0;
  if (0 < argc) {
    const_cast< Optional< int16_t > &>(arg0).Construct();
    if (!ValueToPrimitive<int16_t, eDefault>(cx, argv[0], &const_cast< int16_t & >(arg0.Value()))) {
      return false;
    }
  }
  self->PassOptionalShort(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalShort_methodinfo = {
  (JSJitPropertyOp)passOptionalShort,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalShortWithDefault(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  int16_t arg0;
  if (0 < argc) {
    if (!ValueToPrimitive<int16_t, eDefault>(cx, argv[0], &arg0)) {
      return false;
    }
  } else {
    arg0 = 5;
  }
  self->PassOptionalShortWithDefault(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalShortWithDefault_methodinfo = {
  (JSJitPropertyOp)passOptionalShortWithDefault,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_readonlyLong(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* vp)
{
  int32_t result;
  result = self->ReadonlyLong();
  *vp = INT_TO_JSVAL(int32_t(result));
  return true;
}


const JSJitInfo readonlyLong_getterinfo = {
  (JSJitPropertyOp)get_readonlyLong,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_writableLong(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* vp)
{
  int32_t result;
  result = self->WritableLong();
  *vp = INT_TO_JSVAL(int32_t(result));
  return true;
}

static bool
set_writableLong(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* argv)
{
  int32_t arg0;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  self->SetWritableLong(arg0);

  return true;
}


const JSJitInfo writableLong_getterinfo = {
  (JSJitPropertyOp)get_writableLong,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo writableLong_setterinfo = {
  (JSJitPropertyOp)set_writableLong,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passLong(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.passLong");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  int32_t arg0;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  self->PassLong(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passLong_methodinfo = {
  (JSJitPropertyOp)passLong,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveLong(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{
  int32_t result;
  result = self->ReceiveLong();
  *vp = INT_TO_JSVAL(int32_t(result));
  return true;
}


const JSJitInfo receiveLong_methodinfo = {
  (JSJitPropertyOp)receiveLong,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalLong(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  const Optional< int32_t > arg0;
  if (0 < argc) {
    const_cast< Optional< int32_t > &>(arg0).Construct();
    if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[0], &const_cast< int32_t & >(arg0.Value()))) {
      return false;
    }
  }
  self->PassOptionalLong(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalLong_methodinfo = {
  (JSJitPropertyOp)passOptionalLong,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalLongWithDefault(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  int32_t arg0;
  if (0 < argc) {
    if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[0], &arg0)) {
      return false;
    }
  } else {
    arg0 = 7;
  }
  self->PassOptionalLongWithDefault(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalLongWithDefault_methodinfo = {
  (JSJitPropertyOp)passOptionalLongWithDefault,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_readonlyLongLong(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* vp)
{
  int64_t result;
  result = self->ReadonlyLongLong();
  *vp = JS_NumberValue(double(result));
  return true;
}


const JSJitInfo readonlyLongLong_getterinfo = {
  (JSJitPropertyOp)get_readonlyLongLong,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_writableLongLong(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* vp)
{
  int64_t result;
  result = self->WritableLongLong();
  *vp = JS_NumberValue(double(result));
  return true;
}

static bool
set_writableLongLong(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* argv)
{
  int64_t arg0;
  if (!ValueToPrimitive<int64_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  self->SetWritableLongLong(arg0);

  return true;
}


const JSJitInfo writableLongLong_getterinfo = {
  (JSJitPropertyOp)get_writableLongLong,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo writableLongLong_setterinfo = {
  (JSJitPropertyOp)set_writableLongLong,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passLongLong(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.passLongLong");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  int64_t arg0;
  if (!ValueToPrimitive<int64_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  self->PassLongLong(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passLongLong_methodinfo = {
  (JSJitPropertyOp)passLongLong,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveLongLong(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{
  int64_t result;
  result = self->ReceiveLongLong();
  *vp = JS_NumberValue(double(result));
  return true;
}


const JSJitInfo receiveLongLong_methodinfo = {
  (JSJitPropertyOp)receiveLongLong,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalLongLong(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  const Optional< int64_t > arg0;
  if (0 < argc) {
    const_cast< Optional< int64_t > &>(arg0).Construct();
    if (!ValueToPrimitive<int64_t, eDefault>(cx, argv[0], &const_cast< int64_t & >(arg0.Value()))) {
      return false;
    }
  }
  self->PassOptionalLongLong(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalLongLong_methodinfo = {
  (JSJitPropertyOp)passOptionalLongLong,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalLongLongWithDefault(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  int64_t arg0;
  if (0 < argc) {
    if (!ValueToPrimitive<int64_t, eDefault>(cx, argv[0], &arg0)) {
      return false;
    }
  } else {
    arg0 = -12;
  }
  self->PassOptionalLongLongWithDefault(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalLongLongWithDefault_methodinfo = {
  (JSJitPropertyOp)passOptionalLongLongWithDefault,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_readonlyOctet(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* vp)
{
  uint8_t result;
  result = self->ReadonlyOctet();
  *vp = INT_TO_JSVAL(int32_t(result));
  return true;
}


const JSJitInfo readonlyOctet_getterinfo = {
  (JSJitPropertyOp)get_readonlyOctet,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_writableOctet(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* vp)
{
  uint8_t result;
  result = self->WritableOctet();
  *vp = INT_TO_JSVAL(int32_t(result));
  return true;
}

static bool
set_writableOctet(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* argv)
{
  uint8_t arg0;
  if (!ValueToPrimitive<uint8_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  self->SetWritableOctet(arg0);

  return true;
}


const JSJitInfo writableOctet_getterinfo = {
  (JSJitPropertyOp)get_writableOctet,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo writableOctet_setterinfo = {
  (JSJitPropertyOp)set_writableOctet,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOctet(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.passOctet");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  uint8_t arg0;
  if (!ValueToPrimitive<uint8_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  self->PassOctet(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOctet_methodinfo = {
  (JSJitPropertyOp)passOctet,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveOctet(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{
  uint8_t result;
  result = self->ReceiveOctet();
  *vp = INT_TO_JSVAL(int32_t(result));
  return true;
}


const JSJitInfo receiveOctet_methodinfo = {
  (JSJitPropertyOp)receiveOctet,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalOctet(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  const Optional< uint8_t > arg0;
  if (0 < argc) {
    const_cast< Optional< uint8_t > &>(arg0).Construct();
    if (!ValueToPrimitive<uint8_t, eDefault>(cx, argv[0], &const_cast< uint8_t & >(arg0.Value()))) {
      return false;
    }
  }
  self->PassOptionalOctet(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalOctet_methodinfo = {
  (JSJitPropertyOp)passOptionalOctet,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalOctetWithDefault(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  uint8_t arg0;
  if (0 < argc) {
    if (!ValueToPrimitive<uint8_t, eDefault>(cx, argv[0], &arg0)) {
      return false;
    }
  } else {
    arg0 = 19;
  }
  self->PassOptionalOctetWithDefault(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalOctetWithDefault_methodinfo = {
  (JSJitPropertyOp)passOptionalOctetWithDefault,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_readonlyUnsignedShort(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* vp)
{
  uint16_t result;
  result = self->ReadonlyUnsignedShort();
  *vp = INT_TO_JSVAL(int32_t(result));
  return true;
}


const JSJitInfo readonlyUnsignedShort_getterinfo = {
  (JSJitPropertyOp)get_readonlyUnsignedShort,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_writableUnsignedShort(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* vp)
{
  uint16_t result;
  result = self->WritableUnsignedShort();
  *vp = INT_TO_JSVAL(int32_t(result));
  return true;
}

static bool
set_writableUnsignedShort(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* argv)
{
  uint16_t arg0;
  if (!ValueToPrimitive<uint16_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  self->SetWritableUnsignedShort(arg0);

  return true;
}


const JSJitInfo writableUnsignedShort_getterinfo = {
  (JSJitPropertyOp)get_writableUnsignedShort,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo writableUnsignedShort_setterinfo = {
  (JSJitPropertyOp)set_writableUnsignedShort,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passUnsignedShort(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.passUnsignedShort");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  uint16_t arg0;
  if (!ValueToPrimitive<uint16_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  self->PassUnsignedShort(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passUnsignedShort_methodinfo = {
  (JSJitPropertyOp)passUnsignedShort,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveUnsignedShort(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{
  uint16_t result;
  result = self->ReceiveUnsignedShort();
  *vp = INT_TO_JSVAL(int32_t(result));
  return true;
}


const JSJitInfo receiveUnsignedShort_methodinfo = {
  (JSJitPropertyOp)receiveUnsignedShort,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalUnsignedShort(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  const Optional< uint16_t > arg0;
  if (0 < argc) {
    const_cast< Optional< uint16_t > &>(arg0).Construct();
    if (!ValueToPrimitive<uint16_t, eDefault>(cx, argv[0], &const_cast< uint16_t & >(arg0.Value()))) {
      return false;
    }
  }
  self->PassOptionalUnsignedShort(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalUnsignedShort_methodinfo = {
  (JSJitPropertyOp)passOptionalUnsignedShort,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalUnsignedShortWithDefault(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  uint16_t arg0;
  if (0 < argc) {
    if (!ValueToPrimitive<uint16_t, eDefault>(cx, argv[0], &arg0)) {
      return false;
    }
  } else {
    arg0 = 2;
  }
  self->PassOptionalUnsignedShortWithDefault(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalUnsignedShortWithDefault_methodinfo = {
  (JSJitPropertyOp)passOptionalUnsignedShortWithDefault,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_readonlyUnsignedLong(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* vp)
{
  uint32_t result;
  result = self->ReadonlyUnsignedLong();
  *vp = UINT_TO_JSVAL(result);
  return true;
}


const JSJitInfo readonlyUnsignedLong_getterinfo = {
  (JSJitPropertyOp)get_readonlyUnsignedLong,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_writableUnsignedLong(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* vp)
{
  uint32_t result;
  result = self->WritableUnsignedLong();
  *vp = UINT_TO_JSVAL(result);
  return true;
}

static bool
set_writableUnsignedLong(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* argv)
{
  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  self->SetWritableUnsignedLong(arg0);

  return true;
}


const JSJitInfo writableUnsignedLong_getterinfo = {
  (JSJitPropertyOp)get_writableUnsignedLong,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo writableUnsignedLong_setterinfo = {
  (JSJitPropertyOp)set_writableUnsignedLong,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passUnsignedLong(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.passUnsignedLong");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  self->PassUnsignedLong(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passUnsignedLong_methodinfo = {
  (JSJitPropertyOp)passUnsignedLong,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveUnsignedLong(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{
  uint32_t result;
  result = self->ReceiveUnsignedLong();
  *vp = UINT_TO_JSVAL(result);
  return true;
}


const JSJitInfo receiveUnsignedLong_methodinfo = {
  (JSJitPropertyOp)receiveUnsignedLong,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalUnsignedLong(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  const Optional< uint32_t > arg0;
  if (0 < argc) {
    const_cast< Optional< uint32_t > &>(arg0).Construct();
    if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[0], &const_cast< uint32_t & >(arg0.Value()))) {
      return false;
    }
  }
  self->PassOptionalUnsignedLong(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalUnsignedLong_methodinfo = {
  (JSJitPropertyOp)passOptionalUnsignedLong,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalUnsignedLongWithDefault(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  uint32_t arg0;
  if (0 < argc) {
    if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[0], &arg0)) {
      return false;
    }
  } else {
    arg0 = 6;
  }
  self->PassOptionalUnsignedLongWithDefault(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalUnsignedLongWithDefault_methodinfo = {
  (JSJitPropertyOp)passOptionalUnsignedLongWithDefault,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_readonlyUnsignedLongLong(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* vp)
{
  uint64_t result;
  result = self->ReadonlyUnsignedLongLong();
  *vp = JS_NumberValue(double(result));
  return true;
}


const JSJitInfo readonlyUnsignedLongLong_getterinfo = {
  (JSJitPropertyOp)get_readonlyUnsignedLongLong,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_writableUnsignedLongLong(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* vp)
{
  uint64_t result;
  result = self->WritableUnsignedLongLong();
  *vp = JS_NumberValue(double(result));
  return true;
}

static bool
set_writableUnsignedLongLong(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* argv)
{
  uint64_t arg0;
  if (!ValueToPrimitive<uint64_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  self->SetWritableUnsignedLongLong(arg0);

  return true;
}


const JSJitInfo writableUnsignedLongLong_getterinfo = {
  (JSJitPropertyOp)get_writableUnsignedLongLong,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo writableUnsignedLongLong_setterinfo = {
  (JSJitPropertyOp)set_writableUnsignedLongLong,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passUnsignedLongLong(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.passUnsignedLongLong");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  uint64_t arg0;
  if (!ValueToPrimitive<uint64_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  self->PassUnsignedLongLong(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passUnsignedLongLong_methodinfo = {
  (JSJitPropertyOp)passUnsignedLongLong,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveUnsignedLongLong(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{
  uint64_t result;
  result = self->ReceiveUnsignedLongLong();
  *vp = JS_NumberValue(double(result));
  return true;
}


const JSJitInfo receiveUnsignedLongLong_methodinfo = {
  (JSJitPropertyOp)receiveUnsignedLongLong,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalUnsignedLongLong(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  const Optional< uint64_t > arg0;
  if (0 < argc) {
    const_cast< Optional< uint64_t > &>(arg0).Construct();
    if (!ValueToPrimitive<uint64_t, eDefault>(cx, argv[0], &const_cast< uint64_t & >(arg0.Value()))) {
      return false;
    }
  }
  self->PassOptionalUnsignedLongLong(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalUnsignedLongLong_methodinfo = {
  (JSJitPropertyOp)passOptionalUnsignedLongLong,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalUnsignedLongLongWithDefault(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  uint64_t arg0;
  if (0 < argc) {
    if (!ValueToPrimitive<uint64_t, eDefault>(cx, argv[0], &arg0)) {
      return false;
    }
  } else {
    arg0 = 17;
  }
  self->PassOptionalUnsignedLongLongWithDefault(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalUnsignedLongLongWithDefault_methodinfo = {
  (JSJitPropertyOp)passOptionalUnsignedLongLongWithDefault,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_writableFloat(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* vp)
{
  float result;
  result = self->WritableFloat();
  *vp = JS_NumberValue(double(result));
  return true;
}

static bool
set_writableFloat(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* argv)
{
  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[0], &arg0)) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg0)) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    ThrowErrorMessage(cx, MSG_NOT_FINITE);
    return false;
  }
  self->SetWritableFloat(arg0);

  return true;
}


const JSJitInfo writableFloat_getterinfo = {
  (JSJitPropertyOp)get_writableFloat,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo writableFloat_setterinfo = {
  (JSJitPropertyOp)set_writableFloat,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_writableUnrestrictedFloat(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* vp)
{
  float result;
  result = self->WritableUnrestrictedFloat();
  *vp = JS_NumberValue(double(result));
  return true;
}

static bool
set_writableUnrestrictedFloat(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* argv)
{
  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  self->SetWritableUnrestrictedFloat(arg0);

  return true;
}


const JSJitInfo writableUnrestrictedFloat_getterinfo = {
  (JSJitPropertyOp)get_writableUnrestrictedFloat,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo writableUnrestrictedFloat_setterinfo = {
  (JSJitPropertyOp)set_writableUnrestrictedFloat,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_writableNullableFloat(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* vp)
{
  Nullable<float> result;
  result = self->GetWritableNullableFloat();
  if (result.IsNull()) {
    *vp = JSVAL_NULL;
    return true;
  }
  *vp = JS_NumberValue(double(result.Value()));
  return true;
}

static bool
set_writableNullableFloat(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* argv)
{
  const Nullable<float> arg0;
  if (argv[0].isNullOrUndefined()) {
    const_cast< Nullable<float>& >(arg0).SetNull();
  } else if (!ValueToPrimitive<float, eDefault>(cx, argv[0], &const_cast< Nullable<float>& >(arg0).SetValue())) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg0.Value())) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    ThrowErrorMessage(cx, MSG_NOT_FINITE);
    return false;
  }
  self->SetWritableNullableFloat(arg0);

  return true;
}


const JSJitInfo writableNullableFloat_getterinfo = {
  (JSJitPropertyOp)get_writableNullableFloat,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo writableNullableFloat_setterinfo = {
  (JSJitPropertyOp)set_writableNullableFloat,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_writableNullableUnrestrictedFloat(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* vp)
{
  Nullable<float> result;
  result = self->GetWritableNullableUnrestrictedFloat();
  if (result.IsNull()) {
    *vp = JSVAL_NULL;
    return true;
  }
  *vp = JS_NumberValue(double(result.Value()));
  return true;
}

static bool
set_writableNullableUnrestrictedFloat(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* argv)
{
  const Nullable<float> arg0;
  if (argv[0].isNullOrUndefined()) {
    const_cast< Nullable<float>& >(arg0).SetNull();
  } else if (!ValueToPrimitive<float, eDefault>(cx, argv[0], &const_cast< Nullable<float>& >(arg0).SetValue())) {
    return false;
  }
  self->SetWritableNullableUnrestrictedFloat(arg0);

  return true;
}


const JSJitInfo writableNullableUnrestrictedFloat_getterinfo = {
  (JSJitPropertyOp)get_writableNullableUnrestrictedFloat,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo writableNullableUnrestrictedFloat_setterinfo = {
  (JSJitPropertyOp)set_writableNullableUnrestrictedFloat,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_writableDouble(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* vp)
{
  double result;
  result = self->WritableDouble();
  *vp = JS_NumberValue(double(result));
  return true;
}

static bool
set_writableDouble(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* argv)
{
  double arg0;
  if (!ValueToPrimitive<double, eDefault>(cx, argv[0], &arg0)) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg0)) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    ThrowErrorMessage(cx, MSG_NOT_FINITE);
    return false;
  }
  self->SetWritableDouble(arg0);

  return true;
}


const JSJitInfo writableDouble_getterinfo = {
  (JSJitPropertyOp)get_writableDouble,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo writableDouble_setterinfo = {
  (JSJitPropertyOp)set_writableDouble,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_writableUnrestrictedDouble(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* vp)
{
  double result;
  result = self->WritableUnrestrictedDouble();
  *vp = JS_NumberValue(double(result));
  return true;
}

static bool
set_writableUnrestrictedDouble(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* argv)
{
  double arg0;
  if (!ValueToPrimitive<double, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  self->SetWritableUnrestrictedDouble(arg0);

  return true;
}


const JSJitInfo writableUnrestrictedDouble_getterinfo = {
  (JSJitPropertyOp)get_writableUnrestrictedDouble,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo writableUnrestrictedDouble_setterinfo = {
  (JSJitPropertyOp)set_writableUnrestrictedDouble,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_writableNullableDouble(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* vp)
{
  Nullable<double> result;
  result = self->GetWritableNullableDouble();
  if (result.IsNull()) {
    *vp = JSVAL_NULL;
    return true;
  }
  *vp = JS_NumberValue(double(result.Value()));
  return true;
}

static bool
set_writableNullableDouble(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* argv)
{
  const Nullable<double> arg0;
  if (argv[0].isNullOrUndefined()) {
    const_cast< Nullable<double>& >(arg0).SetNull();
  } else if (!ValueToPrimitive<double, eDefault>(cx, argv[0], &const_cast< Nullable<double>& >(arg0).SetValue())) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg0.Value())) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    ThrowErrorMessage(cx, MSG_NOT_FINITE);
    return false;
  }
  self->SetWritableNullableDouble(arg0);

  return true;
}


const JSJitInfo writableNullableDouble_getterinfo = {
  (JSJitPropertyOp)get_writableNullableDouble,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo writableNullableDouble_setterinfo = {
  (JSJitPropertyOp)set_writableNullableDouble,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_writableNullableUnrestrictedDouble(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* vp)
{
  Nullable<double> result;
  result = self->GetWritableNullableUnrestrictedDouble();
  if (result.IsNull()) {
    *vp = JSVAL_NULL;
    return true;
  }
  *vp = JS_NumberValue(double(result.Value()));
  return true;
}

static bool
set_writableNullableUnrestrictedDouble(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* argv)
{
  const Nullable<double> arg0;
  if (argv[0].isNullOrUndefined()) {
    const_cast< Nullable<double>& >(arg0).SetNull();
  } else if (!ValueToPrimitive<double, eDefault>(cx, argv[0], &const_cast< Nullable<double>& >(arg0).SetValue())) {
    return false;
  }
  self->SetWritableNullableUnrestrictedDouble(arg0);

  return true;
}


const JSJitInfo writableNullableUnrestrictedDouble_getterinfo = {
  (JSJitPropertyOp)get_writableNullableUnrestrictedDouble,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo writableNullableUnrestrictedDouble_setterinfo = {
  (JSJitPropertyOp)set_writableNullableUnrestrictedDouble,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passFloat(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 16) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.passFloat");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[0], &arg0)) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg0)) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    ThrowErrorMessage(cx, MSG_NOT_FINITE);
    return false;
  }
  float arg1;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[1], &arg1)) {
    return false;
  }
  const Nullable<float> arg2;
  if (argv[2].isNullOrUndefined()) {
    const_cast< Nullable<float>& >(arg2).SetNull();
  } else if (!ValueToPrimitive<float, eDefault>(cx, argv[2], &const_cast< Nullable<float>& >(arg2).SetValue())) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg2.Value())) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    ThrowErrorMessage(cx, MSG_NOT_FINITE);
    return false;
  }
  const Nullable<float> arg3;
  if (argv[3].isNullOrUndefined()) {
    const_cast< Nullable<float>& >(arg3).SetNull();
  } else if (!ValueToPrimitive<float, eDefault>(cx, argv[3], &const_cast< Nullable<float>& >(arg3).SetValue())) {
    return false;
  }
  double arg4;
  if (!ValueToPrimitive<double, eDefault>(cx, argv[4], &arg4)) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg4)) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    ThrowErrorMessage(cx, MSG_NOT_FINITE);
    return false;
  }
  double arg5;
  if (!ValueToPrimitive<double, eDefault>(cx, argv[5], &arg5)) {
    return false;
  }
  const Nullable<double> arg6;
  if (argv[6].isNullOrUndefined()) {
    const_cast< Nullable<double>& >(arg6).SetNull();
  } else if (!ValueToPrimitive<double, eDefault>(cx, argv[6], &const_cast< Nullable<double>& >(arg6).SetValue())) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg6.Value())) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    ThrowErrorMessage(cx, MSG_NOT_FINITE);
    return false;
  }
  const Nullable<double> arg7;
  if (argv[7].isNullOrUndefined()) {
    const_cast< Nullable<double>& >(arg7).SetNull();
  } else if (!ValueToPrimitive<double, eDefault>(cx, argv[7], &const_cast< Nullable<double>& >(arg7).SetValue())) {
    return false;
  }
  const Sequence< float > arg8;
  if (argv[8].isObject()) {
    JSObject* seq = &argv[8].toObject();

    if (!IsArrayLike(cx, seq)) {
      ThrowErrorMessage(cx, MSG_NOT_SEQUENCE);
      return false;
    }
    uint32_t length;
    // JS_GetArrayLength actually works on all objects
    if (!JS_GetArrayLength(cx, seq, &length)) {
      return false;
    }
    Sequence< float > &arr = const_cast< Sequence< float >& >(arg8);
    if (!arr.SetCapacity(length)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t i = 0; i < length; ++i) {
      jsval temp;
      if (!JS_GetElement(cx, seq, i, &temp)) {
        return false;
      }
      float& slot = *arr.AppendElement();
      if (!ValueToPrimitive<float, eDefault>(cx, temp, &slot)) {
        return false;
      } else if (!MOZ_DOUBLE_IS_FINITE(slot)) {
        // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
        //       when passed a non-finite float too.
        ThrowErrorMessage(cx, MSG_NOT_FINITE);
        return false;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  const Sequence< float > arg9;
  if (argv[9].isObject()) {
    JSObject* seq = &argv[9].toObject();

    if (!IsArrayLike(cx, seq)) {
      ThrowErrorMessage(cx, MSG_NOT_SEQUENCE);
      return false;
    }
    uint32_t length;
    // JS_GetArrayLength actually works on all objects
    if (!JS_GetArrayLength(cx, seq, &length)) {
      return false;
    }
    Sequence< float > &arr = const_cast< Sequence< float >& >(arg9);
    if (!arr.SetCapacity(length)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t i = 0; i < length; ++i) {
      jsval temp;
      if (!JS_GetElement(cx, seq, i, &temp)) {
        return false;
      }
      float& slot = *arr.AppendElement();
      if (!ValueToPrimitive<float, eDefault>(cx, temp, &slot)) {
        return false;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  const Sequence< Nullable<float> > arg10;
  if (argv[10].isObject()) {
    JSObject* seq = &argv[10].toObject();

    if (!IsArrayLike(cx, seq)) {
      ThrowErrorMessage(cx, MSG_NOT_SEQUENCE);
      return false;
    }
    uint32_t length;
    // JS_GetArrayLength actually works on all objects
    if (!JS_GetArrayLength(cx, seq, &length)) {
      return false;
    }
    Sequence< Nullable<float> > &arr = const_cast< Sequence< Nullable<float> >& >(arg10);
    if (!arr.SetCapacity(length)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t i = 0; i < length; ++i) {
      jsval temp;
      if (!JS_GetElement(cx, seq, i, &temp)) {
        return false;
      }
      Nullable<float>& slot = *arr.AppendElement();
      if (temp.isNullOrUndefined()) {
        const_cast< Nullable<float>& >(slot).SetNull();
      } else if (!ValueToPrimitive<float, eDefault>(cx, temp, &const_cast< Nullable<float>& >(slot).SetValue())) {
        return false;
      } else if (!MOZ_DOUBLE_IS_FINITE(slot.Value())) {
        // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
        //       when passed a non-finite float too.
        ThrowErrorMessage(cx, MSG_NOT_FINITE);
        return false;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  const Sequence< Nullable<float> > arg11;
  if (argv[11].isObject()) {
    JSObject* seq = &argv[11].toObject();

    if (!IsArrayLike(cx, seq)) {
      ThrowErrorMessage(cx, MSG_NOT_SEQUENCE);
      return false;
    }
    uint32_t length;
    // JS_GetArrayLength actually works on all objects
    if (!JS_GetArrayLength(cx, seq, &length)) {
      return false;
    }
    Sequence< Nullable<float> > &arr = const_cast< Sequence< Nullable<float> >& >(arg11);
    if (!arr.SetCapacity(length)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t i = 0; i < length; ++i) {
      jsval temp;
      if (!JS_GetElement(cx, seq, i, &temp)) {
        return false;
      }
      Nullable<float>& slot = *arr.AppendElement();
      if (temp.isNullOrUndefined()) {
        const_cast< Nullable<float>& >(slot).SetNull();
      } else if (!ValueToPrimitive<float, eDefault>(cx, temp, &const_cast< Nullable<float>& >(slot).SetValue())) {
        return false;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  const Sequence< double > arg12;
  if (argv[12].isObject()) {
    JSObject* seq = &argv[12].toObject();

    if (!IsArrayLike(cx, seq)) {
      ThrowErrorMessage(cx, MSG_NOT_SEQUENCE);
      return false;
    }
    uint32_t length;
    // JS_GetArrayLength actually works on all objects
    if (!JS_GetArrayLength(cx, seq, &length)) {
      return false;
    }
    Sequence< double > &arr = const_cast< Sequence< double >& >(arg12);
    if (!arr.SetCapacity(length)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t i = 0; i < length; ++i) {
      jsval temp;
      if (!JS_GetElement(cx, seq, i, &temp)) {
        return false;
      }
      double& slot = *arr.AppendElement();
      if (!ValueToPrimitive<double, eDefault>(cx, temp, &slot)) {
        return false;
      } else if (!MOZ_DOUBLE_IS_FINITE(slot)) {
        // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
        //       when passed a non-finite float too.
        ThrowErrorMessage(cx, MSG_NOT_FINITE);
        return false;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  const Sequence< double > arg13;
  if (argv[13].isObject()) {
    JSObject* seq = &argv[13].toObject();

    if (!IsArrayLike(cx, seq)) {
      ThrowErrorMessage(cx, MSG_NOT_SEQUENCE);
      return false;
    }
    uint32_t length;
    // JS_GetArrayLength actually works on all objects
    if (!JS_GetArrayLength(cx, seq, &length)) {
      return false;
    }
    Sequence< double > &arr = const_cast< Sequence< double >& >(arg13);
    if (!arr.SetCapacity(length)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t i = 0; i < length; ++i) {
      jsval temp;
      if (!JS_GetElement(cx, seq, i, &temp)) {
        return false;
      }
      double& slot = *arr.AppendElement();
      if (!ValueToPrimitive<double, eDefault>(cx, temp, &slot)) {
        return false;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  const Sequence< Nullable<double> > arg14;
  if (argv[14].isObject()) {
    JSObject* seq = &argv[14].toObject();

    if (!IsArrayLike(cx, seq)) {
      ThrowErrorMessage(cx, MSG_NOT_SEQUENCE);
      return false;
    }
    uint32_t length;
    // JS_GetArrayLength actually works on all objects
    if (!JS_GetArrayLength(cx, seq, &length)) {
      return false;
    }
    Sequence< Nullable<double> > &arr = const_cast< Sequence< Nullable<double> >& >(arg14);
    if (!arr.SetCapacity(length)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t i = 0; i < length; ++i) {
      jsval temp;
      if (!JS_GetElement(cx, seq, i, &temp)) {
        return false;
      }
      Nullable<double>& slot = *arr.AppendElement();
      if (temp.isNullOrUndefined()) {
        const_cast< Nullable<double>& >(slot).SetNull();
      } else if (!ValueToPrimitive<double, eDefault>(cx, temp, &const_cast< Nullable<double>& >(slot).SetValue())) {
        return false;
      } else if (!MOZ_DOUBLE_IS_FINITE(slot.Value())) {
        // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
        //       when passed a non-finite float too.
        ThrowErrorMessage(cx, MSG_NOT_FINITE);
        return false;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  const Sequence< Nullable<double> > arg15;
  if (argv[15].isObject()) {
    JSObject* seq = &argv[15].toObject();

    if (!IsArrayLike(cx, seq)) {
      ThrowErrorMessage(cx, MSG_NOT_SEQUENCE);
      return false;
    }
    uint32_t length;
    // JS_GetArrayLength actually works on all objects
    if (!JS_GetArrayLength(cx, seq, &length)) {
      return false;
    }
    Sequence< Nullable<double> > &arr = const_cast< Sequence< Nullable<double> >& >(arg15);
    if (!arr.SetCapacity(length)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t i = 0; i < length; ++i) {
      jsval temp;
      if (!JS_GetElement(cx, seq, i, &temp)) {
        return false;
      }
      Nullable<double>& slot = *arr.AppendElement();
      if (temp.isNullOrUndefined()) {
        const_cast< Nullable<double>& >(slot).SetNull();
      } else if (!ValueToPrimitive<double, eDefault>(cx, temp, &const_cast< Nullable<double>& >(slot).SetValue())) {
        return false;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassFloat(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passFloat_methodinfo = {
  (JSJitPropertyOp)passFloat,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passLenientFloat(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 16) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.passLenientFloat");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[0], &arg0)) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg0)) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    *vp = JSVAL_VOID;
    return true;
  }
  float arg1;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[1], &arg1)) {
    return false;
  }
  const Nullable<float> arg2;
  if (argv[2].isNullOrUndefined()) {
    const_cast< Nullable<float>& >(arg2).SetNull();
  } else if (!ValueToPrimitive<float, eDefault>(cx, argv[2], &const_cast< Nullable<float>& >(arg2).SetValue())) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg2.Value())) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    *vp = JSVAL_VOID;
    return true;
  }
  const Nullable<float> arg3;
  if (argv[3].isNullOrUndefined()) {
    const_cast< Nullable<float>& >(arg3).SetNull();
  } else if (!ValueToPrimitive<float, eDefault>(cx, argv[3], &const_cast< Nullable<float>& >(arg3).SetValue())) {
    return false;
  }
  double arg4;
  if (!ValueToPrimitive<double, eDefault>(cx, argv[4], &arg4)) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg4)) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    *vp = JSVAL_VOID;
    return true;
  }
  double arg5;
  if (!ValueToPrimitive<double, eDefault>(cx, argv[5], &arg5)) {
    return false;
  }
  const Nullable<double> arg6;
  if (argv[6].isNullOrUndefined()) {
    const_cast< Nullable<double>& >(arg6).SetNull();
  } else if (!ValueToPrimitive<double, eDefault>(cx, argv[6], &const_cast< Nullable<double>& >(arg6).SetValue())) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg6.Value())) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    *vp = JSVAL_VOID;
    return true;
  }
  const Nullable<double> arg7;
  if (argv[7].isNullOrUndefined()) {
    const_cast< Nullable<double>& >(arg7).SetNull();
  } else if (!ValueToPrimitive<double, eDefault>(cx, argv[7], &const_cast< Nullable<double>& >(arg7).SetValue())) {
    return false;
  }
  const Sequence< float > arg8;
  if (argv[8].isObject()) {
    JSObject* seq = &argv[8].toObject();

    if (!IsArrayLike(cx, seq)) {
      ThrowErrorMessage(cx, MSG_NOT_SEQUENCE);
      return false;
    }
    uint32_t length;
    // JS_GetArrayLength actually works on all objects
    if (!JS_GetArrayLength(cx, seq, &length)) {
      return false;
    }
    Sequence< float > &arr = const_cast< Sequence< float >& >(arg8);
    if (!arr.SetCapacity(length)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t i = 0; i < length; ++i) {
      jsval temp;
      if (!JS_GetElement(cx, seq, i, &temp)) {
        return false;
      }
      float& slot = *arr.AppendElement();
      if (!ValueToPrimitive<float, eDefault>(cx, temp, &slot)) {
        return false;
      } else if (!MOZ_DOUBLE_IS_FINITE(slot)) {
        // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
        //       when passed a non-finite float too.
        *vp = JSVAL_VOID;
        return true;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  const Sequence< float > arg9;
  if (argv[9].isObject()) {
    JSObject* seq = &argv[9].toObject();

    if (!IsArrayLike(cx, seq)) {
      ThrowErrorMessage(cx, MSG_NOT_SEQUENCE);
      return false;
    }
    uint32_t length;
    // JS_GetArrayLength actually works on all objects
    if (!JS_GetArrayLength(cx, seq, &length)) {
      return false;
    }
    Sequence< float > &arr = const_cast< Sequence< float >& >(arg9);
    if (!arr.SetCapacity(length)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t i = 0; i < length; ++i) {
      jsval temp;
      if (!JS_GetElement(cx, seq, i, &temp)) {
        return false;
      }
      float& slot = *arr.AppendElement();
      if (!ValueToPrimitive<float, eDefault>(cx, temp, &slot)) {
        return false;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  const Sequence< Nullable<float> > arg10;
  if (argv[10].isObject()) {
    JSObject* seq = &argv[10].toObject();

    if (!IsArrayLike(cx, seq)) {
      ThrowErrorMessage(cx, MSG_NOT_SEQUENCE);
      return false;
    }
    uint32_t length;
    // JS_GetArrayLength actually works on all objects
    if (!JS_GetArrayLength(cx, seq, &length)) {
      return false;
    }
    Sequence< Nullable<float> > &arr = const_cast< Sequence< Nullable<float> >& >(arg10);
    if (!arr.SetCapacity(length)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t i = 0; i < length; ++i) {
      jsval temp;
      if (!JS_GetElement(cx, seq, i, &temp)) {
        return false;
      }
      Nullable<float>& slot = *arr.AppendElement();
      if (temp.isNullOrUndefined()) {
        const_cast< Nullable<float>& >(slot).SetNull();
      } else if (!ValueToPrimitive<float, eDefault>(cx, temp, &const_cast< Nullable<float>& >(slot).SetValue())) {
        return false;
      } else if (!MOZ_DOUBLE_IS_FINITE(slot.Value())) {
        // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
        //       when passed a non-finite float too.
        *vp = JSVAL_VOID;
        return true;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  const Sequence< Nullable<float> > arg11;
  if (argv[11].isObject()) {
    JSObject* seq = &argv[11].toObject();

    if (!IsArrayLike(cx, seq)) {
      ThrowErrorMessage(cx, MSG_NOT_SEQUENCE);
      return false;
    }
    uint32_t length;
    // JS_GetArrayLength actually works on all objects
    if (!JS_GetArrayLength(cx, seq, &length)) {
      return false;
    }
    Sequence< Nullable<float> > &arr = const_cast< Sequence< Nullable<float> >& >(arg11);
    if (!arr.SetCapacity(length)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t i = 0; i < length; ++i) {
      jsval temp;
      if (!JS_GetElement(cx, seq, i, &temp)) {
        return false;
      }
      Nullable<float>& slot = *arr.AppendElement();
      if (temp.isNullOrUndefined()) {
        const_cast< Nullable<float>& >(slot).SetNull();
      } else if (!ValueToPrimitive<float, eDefault>(cx, temp, &const_cast< Nullable<float>& >(slot).SetValue())) {
        return false;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  const Sequence< double > arg12;
  if (argv[12].isObject()) {
    JSObject* seq = &argv[12].toObject();

    if (!IsArrayLike(cx, seq)) {
      ThrowErrorMessage(cx, MSG_NOT_SEQUENCE);
      return false;
    }
    uint32_t length;
    // JS_GetArrayLength actually works on all objects
    if (!JS_GetArrayLength(cx, seq, &length)) {
      return false;
    }
    Sequence< double > &arr = const_cast< Sequence< double >& >(arg12);
    if (!arr.SetCapacity(length)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t i = 0; i < length; ++i) {
      jsval temp;
      if (!JS_GetElement(cx, seq, i, &temp)) {
        return false;
      }
      double& slot = *arr.AppendElement();
      if (!ValueToPrimitive<double, eDefault>(cx, temp, &slot)) {
        return false;
      } else if (!MOZ_DOUBLE_IS_FINITE(slot)) {
        // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
        //       when passed a non-finite float too.
        *vp = JSVAL_VOID;
        return true;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  const Sequence< double > arg13;
  if (argv[13].isObject()) {
    JSObject* seq = &argv[13].toObject();

    if (!IsArrayLike(cx, seq)) {
      ThrowErrorMessage(cx, MSG_NOT_SEQUENCE);
      return false;
    }
    uint32_t length;
    // JS_GetArrayLength actually works on all objects
    if (!JS_GetArrayLength(cx, seq, &length)) {
      return false;
    }
    Sequence< double > &arr = const_cast< Sequence< double >& >(arg13);
    if (!arr.SetCapacity(length)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t i = 0; i < length; ++i) {
      jsval temp;
      if (!JS_GetElement(cx, seq, i, &temp)) {
        return false;
      }
      double& slot = *arr.AppendElement();
      if (!ValueToPrimitive<double, eDefault>(cx, temp, &slot)) {
        return false;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  const Sequence< Nullable<double> > arg14;
  if (argv[14].isObject()) {
    JSObject* seq = &argv[14].toObject();

    if (!IsArrayLike(cx, seq)) {
      ThrowErrorMessage(cx, MSG_NOT_SEQUENCE);
      return false;
    }
    uint32_t length;
    // JS_GetArrayLength actually works on all objects
    if (!JS_GetArrayLength(cx, seq, &length)) {
      return false;
    }
    Sequence< Nullable<double> > &arr = const_cast< Sequence< Nullable<double> >& >(arg14);
    if (!arr.SetCapacity(length)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t i = 0; i < length; ++i) {
      jsval temp;
      if (!JS_GetElement(cx, seq, i, &temp)) {
        return false;
      }
      Nullable<double>& slot = *arr.AppendElement();
      if (temp.isNullOrUndefined()) {
        const_cast< Nullable<double>& >(slot).SetNull();
      } else if (!ValueToPrimitive<double, eDefault>(cx, temp, &const_cast< Nullable<double>& >(slot).SetValue())) {
        return false;
      } else if (!MOZ_DOUBLE_IS_FINITE(slot.Value())) {
        // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
        //       when passed a non-finite float too.
        *vp = JSVAL_VOID;
        return true;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  const Sequence< Nullable<double> > arg15;
  if (argv[15].isObject()) {
    JSObject* seq = &argv[15].toObject();

    if (!IsArrayLike(cx, seq)) {
      ThrowErrorMessage(cx, MSG_NOT_SEQUENCE);
      return false;
    }
    uint32_t length;
    // JS_GetArrayLength actually works on all objects
    if (!JS_GetArrayLength(cx, seq, &length)) {
      return false;
    }
    Sequence< Nullable<double> > &arr = const_cast< Sequence< Nullable<double> >& >(arg15);
    if (!arr.SetCapacity(length)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t i = 0; i < length; ++i) {
      jsval temp;
      if (!JS_GetElement(cx, seq, i, &temp)) {
        return false;
      }
      Nullable<double>& slot = *arr.AppendElement();
      if (temp.isNullOrUndefined()) {
        const_cast< Nullable<double>& >(slot).SetNull();
      } else if (!ValueToPrimitive<double, eDefault>(cx, temp, &const_cast< Nullable<double>& >(slot).SetValue())) {
        return false;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassLenientFloat(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passLenientFloat_methodinfo = {
  (JSJitPropertyOp)passLenientFloat,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_lenientFloatAttr(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* vp)
{
  float result;
  result = self->LenientFloatAttr();
  *vp = JS_NumberValue(double(result));
  return true;
}

static bool
set_lenientFloatAttr(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* argv)
{
  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[0], &arg0)) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg0)) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    return true;
  }
  self->SetLenientFloatAttr(arg0);

  return true;
}


const JSJitInfo lenientFloatAttr_getterinfo = {
  (JSJitPropertyOp)get_lenientFloatAttr,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo lenientFloatAttr_setterinfo = {
  (JSJitPropertyOp)set_lenientFloatAttr,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_lenientDoubleAttr(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* vp)
{
  double result;
  result = self->LenientDoubleAttr();
  *vp = JS_NumberValue(double(result));
  return true;
}

static bool
set_lenientDoubleAttr(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* argv)
{
  double arg0;
  if (!ValueToPrimitive<double, eDefault>(cx, argv[0], &arg0)) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg0)) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    return true;
  }
  self->SetLenientDoubleAttr(arg0);

  return true;
}


const JSJitInfo lenientDoubleAttr_getterinfo = {
  (JSJitPropertyOp)get_lenientDoubleAttr,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_DOUBLE   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo lenientDoubleAttr_setterinfo = {
  (JSJitPropertyOp)set_lenientDoubleAttr,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveSelf(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{
  nsRefPtr<mozilla::dom::TestInterface> result;
  result = self->ReceiveSelf();
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}


const JSJitInfo receiveSelf_methodinfo = {
  (JSJitPropertyOp)receiveSelf,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveNullableSelf(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{
  nsRefPtr<mozilla::dom::TestInterface> result;
  result = self->ReceiveNullableSelf();
  if (!result) {
    *vp = JSVAL_NULL;
    return true;
  }
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}


const JSJitInfo receiveNullableSelf_methodinfo = {
  (JSJitPropertyOp)receiveNullableSelf,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveWeakSelf(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{
  mozilla::dom::TestInterface* result;
  result = self->ReceiveWeakSelf();
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}


const JSJitInfo receiveWeakSelf_methodinfo = {
  (JSJitPropertyOp)receiveWeakSelf,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveWeakNullableSelf(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{
  mozilla::dom::TestInterface* result;
  result = self->ReceiveWeakNullableSelf();
  if (!result) {
    *vp = JSVAL_NULL;
    return true;
  }
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}


const JSJitInfo receiveWeakNullableSelf_methodinfo = {
  (JSJitPropertyOp)receiveWeakNullableSelf,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
passSelf(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.passSelf");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  NonNull<mozilla::dom::TestInterface> arg0;
  if (argv[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(cx, &argv[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestInterface");
        return false;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassSelf(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passSelf_methodinfo = {
  (JSJitPropertyOp)passSelf,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passSelf2(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.passSelf2");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  NonNull<mozilla::dom::TestInterface> arg0;
  if (argv[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(cx, &argv[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestInterface");
        return false;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassSelf2(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passSelf2_methodinfo = {
  (JSJitPropertyOp)passSelf2,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passNullableSelf(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.passNullableSelf");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  mozilla::dom::TestInterface* arg0;
  if (argv[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(cx, &argv[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestInterface");
        return false;
      }
    }
  } else if (argv[0].isNullOrUndefined()) {
    arg0 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassNullableSelf(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passNullableSelf_methodinfo = {
  (JSJitPropertyOp)passNullableSelf,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_nonNullSelf(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* vp)
{
  nsRefPtr<mozilla::dom::TestInterface> result;
  result = self->NonNullSelf();
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static bool
set_nonNullSelf(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* argv)
{
  NonNull<mozilla::dom::TestInterface> arg0;
  if (argv[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(cx, &argv[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestInterface");
        return false;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->SetNonNullSelf(arg0);

  return true;
}


const JSJitInfo nonNullSelf_getterinfo = {
  (JSJitPropertyOp)get_nonNullSelf,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo nonNullSelf_setterinfo = {
  (JSJitPropertyOp)set_nonNullSelf,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_nullableSelf(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* vp)
{
  nsRefPtr<mozilla::dom::TestInterface> result;
  result = self->GetNullableSelf();
  if (!result) {
    *vp = JSVAL_NULL;
    return true;
  }
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static bool
set_nullableSelf(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* argv)
{
  mozilla::dom::TestInterface* arg0;
  if (argv[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(cx, &argv[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestInterface");
        return false;
      }
    }
  } else if (argv[0].isNullOrUndefined()) {
    arg0 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->SetNullableSelf(arg0);

  return true;
}


const JSJitInfo nullableSelf_getterinfo = {
  (JSJitPropertyOp)get_nullableSelf,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo nullableSelf_setterinfo = {
  (JSJitPropertyOp)set_nullableSelf,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalSelf(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  const Optional< mozilla::dom::TestInterface* > arg0;
  if (0 < argc) {
    const_cast< Optional< mozilla::dom::TestInterface* > &>(arg0).Construct();
    if (argv[0].isObject()) {
      {
        nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(cx, &argv[0].toObject(), const_cast< mozilla::dom::TestInterface* & >(arg0.Value()));
        if (NS_FAILED(rv)) {
          ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestInterface");
          return false;
        }
      }
    } else if (argv[0].isNullOrUndefined()) {
      const_cast< mozilla::dom::TestInterface* & >(arg0.Value()) = NULL;
    } else {
      ThrowErrorMessage(cx, MSG_NOT_OBJECT);
      return false;
    }
  }
  self->PassOptionalSelf(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalSelf_methodinfo = {
  (JSJitPropertyOp)passOptionalSelf,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalNonNullSelf(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  const Optional< NonNull<mozilla::dom::TestInterface> > arg0;
  if (0 < argc) {
    const_cast< Optional< NonNull<mozilla::dom::TestInterface> > &>(arg0).Construct();
    if (argv[0].isObject()) {
      {
        nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(cx, &argv[0].toObject(), const_cast< NonNull<mozilla::dom::TestInterface> & >(arg0.Value()));
        if (NS_FAILED(rv)) {
          ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestInterface");
          return false;
        }
      }
    } else {
      ThrowErrorMessage(cx, MSG_NOT_OBJECT);
      return false;
    }
  }
  self->PassOptionalNonNullSelf(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalNonNullSelf_methodinfo = {
  (JSJitPropertyOp)passOptionalNonNullSelf,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalSelfWithDefault(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  mozilla::dom::TestInterface* arg0;
  if (0 < argc) {
    if (argv[0].isObject()) {
      {
        nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(cx, &argv[0].toObject(), arg0);
        if (NS_FAILED(rv)) {
          ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestInterface");
          return false;
        }
      }
    } else if (argv[0].isNullOrUndefined()) {
      arg0 = NULL;
    } else {
      ThrowErrorMessage(cx, MSG_NOT_OBJECT);
      return false;
    }
  } else {
    arg0 = NULL;
  }
  self->PassOptionalSelfWithDefault(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalSelfWithDefault_methodinfo = {
  (JSJitPropertyOp)passOptionalSelfWithDefault,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveNonWrapperCacheInterface(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{
  nsRefPtr<mozilla::dom::TestNonWrapperCacheInterface> result;
  result = self->ReceiveNonWrapperCacheInterface();
  if (!WrapNewBindingNonWrapperCachedObject(cx, obj, result, vp)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}


const JSJitInfo receiveNonWrapperCacheInterface_methodinfo = {
  (JSJitPropertyOp)receiveNonWrapperCacheInterface,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveNullableNonWrapperCacheInterface(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{
  nsRefPtr<mozilla::dom::TestNonWrapperCacheInterface> result;
  result = self->ReceiveNullableNonWrapperCacheInterface();
  if (!result) {
    *vp = JSVAL_NULL;
    return true;
  }
  if (!WrapNewBindingNonWrapperCachedObject(cx, obj, result, vp)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}


const JSJitInfo receiveNullableNonWrapperCacheInterface_methodinfo = {
  (JSJitPropertyOp)receiveNullableNonWrapperCacheInterface,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveNonWrapperCacheInterfaceSequence(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{
  nsTArray< nsRefPtr<mozilla::dom::TestNonWrapperCacheInterface> > result;
  self->ReceiveNonWrapperCacheInterfaceSequence(result);

  uint32_t length = result.Length();
  JSObject *returnArray = JS_NewArrayObject(cx, length, NULL);
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    jsval tmp;
    for (uint32_t i = 0; i < length; ++i) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!WrapNewBindingNonWrapperCachedObject(cx, returnArray, result[i], &tmp)) {
          MOZ_ASSERT(JS_IsExceptionPending(cx));
          return false;
        }
        break;
      } while (0);
      if (!JS_DefineElement(cx, returnArray, i, tmp,
                            nullptr, nullptr, JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  *vp = JS::ObjectValue(*returnArray);
  return true;
}


const JSJitInfo receiveNonWrapperCacheInterfaceSequence_methodinfo = {
  (JSJitPropertyOp)receiveNonWrapperCacheInterfaceSequence,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveNullableNonWrapperCacheInterfaceSequence(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{
  nsTArray< nsRefPtr<mozilla::dom::TestNonWrapperCacheInterface> > result;
  self->ReceiveNullableNonWrapperCacheInterfaceSequence(result);

  uint32_t length = result.Length();
  JSObject *returnArray = JS_NewArrayObject(cx, length, NULL);
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    jsval tmp;
    for (uint32_t i = 0; i < length; ++i) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!result[i]) {
          tmp = JSVAL_NULL;
          break;
        }
        if (!WrapNewBindingNonWrapperCachedObject(cx, returnArray, result[i], &tmp)) {
          MOZ_ASSERT(JS_IsExceptionPending(cx));
          return false;
        }
        break;
      } while (0);
      if (!JS_DefineElement(cx, returnArray, i, tmp,
                            nullptr, nullptr, JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  *vp = JS::ObjectValue(*returnArray);
  return true;
}


const JSJitInfo receiveNullableNonWrapperCacheInterfaceSequence_methodinfo = {
  (JSJitPropertyOp)receiveNullableNonWrapperCacheInterfaceSequence,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveNonWrapperCacheInterfaceNullableSequence(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{
  Nullable< nsTArray< nsRefPtr<mozilla::dom::TestNonWrapperCacheInterface> > > result;
  self->ReceiveNonWrapperCacheInterfaceNullableSequence(result);

  if (result.IsNull()) {
    *vp = JSVAL_NULL;
    return true;
  }

  uint32_t length = result.Value().Length();
  JSObject *returnArray = JS_NewArrayObject(cx, length, NULL);
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    jsval tmp;
    for (uint32_t i = 0; i < length; ++i) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!WrapNewBindingNonWrapperCachedObject(cx, returnArray, result.Value()[i], &tmp)) {
          MOZ_ASSERT(JS_IsExceptionPending(cx));
          return false;
        }
        break;
      } while (0);
      if (!JS_DefineElement(cx, returnArray, i, tmp,
                            nullptr, nullptr, JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  *vp = JS::ObjectValue(*returnArray);
  return true;
}


const JSJitInfo receiveNonWrapperCacheInterfaceNullableSequence_methodinfo = {
  (JSJitPropertyOp)receiveNonWrapperCacheInterfaceNullableSequence,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveNullableNonWrapperCacheInterfaceNullableSequence(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{
  Nullable< nsTArray< nsRefPtr<mozilla::dom::TestNonWrapperCacheInterface> > > result;
  self->ReceiveNullableNonWrapperCacheInterfaceNullableSequence(result);

  if (result.IsNull()) {
    *vp = JSVAL_NULL;
    return true;
  }

  uint32_t length = result.Value().Length();
  JSObject *returnArray = JS_NewArrayObject(cx, length, NULL);
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    jsval tmp;
    for (uint32_t i = 0; i < length; ++i) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!result.Value()[i]) {
          tmp = JSVAL_NULL;
          break;
        }
        if (!WrapNewBindingNonWrapperCachedObject(cx, returnArray, result.Value()[i], &tmp)) {
          MOZ_ASSERT(JS_IsExceptionPending(cx));
          return false;
        }
        break;
      } while (0);
      if (!JS_DefineElement(cx, returnArray, i, tmp,
                            nullptr, nullptr, JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  *vp = JS::ObjectValue(*returnArray);
  return true;
}


const JSJitInfo receiveNullableNonWrapperCacheInterfaceNullableSequence_methodinfo = {
  (JSJitPropertyOp)receiveNullableNonWrapperCacheInterfaceNullableSequence,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveOther(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{
  nsRefPtr<mozilla::dom::TestNonCastableInterface> result;
  result = self->ReceiveOther();
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}


const JSJitInfo receiveOther_methodinfo = {
  (JSJitPropertyOp)receiveOther,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveNullableOther(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{
  nsRefPtr<mozilla::dom::TestNonCastableInterface> result;
  result = self->ReceiveNullableOther();
  if (!result) {
    *vp = JSVAL_NULL;
    return true;
  }
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}


const JSJitInfo receiveNullableOther_methodinfo = {
  (JSJitPropertyOp)receiveNullableOther,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveWeakOther(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{
  mozilla::dom::TestNonCastableInterface* result;
  result = self->ReceiveWeakOther();
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}


const JSJitInfo receiveWeakOther_methodinfo = {
  (JSJitPropertyOp)receiveWeakOther,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveWeakNullableOther(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{
  mozilla::dom::TestNonCastableInterface* result;
  result = self->ReceiveWeakNullableOther();
  if (!result) {
    *vp = JSVAL_NULL;
    return true;
  }
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}


const JSJitInfo receiveWeakNullableOther_methodinfo = {
  (JSJitPropertyOp)receiveWeakNullableOther,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOther(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.passOther");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  nsRefPtr<mozilla::dom::TestNonCastableInterface> arg0_holder;
  NonNull<mozilla::dom::TestNonCastableInterface> arg0;
  if (argv[0].isObject()) {
    jsval tmpVal = argv[0];
    mozilla::dom::TestNonCastableInterface* tmp;
    if (NS_FAILED(xpc_qsUnwrapArg<mozilla::dom::TestNonCastableInterface>(cx, argv[0], &tmp, static_cast<mozilla::dom::TestNonCastableInterface**>(getter_AddRefs(arg0_holder)), &tmpVal))) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestNonCastableInterface");return false;
    }
    MOZ_ASSERT(tmp);
    if (tmpVal != argv[0] && !arg0_holder) {
      // We have to have a strong ref, because we got this off
      // some random object that might get GCed
      arg0_holder = tmp;
    }
    arg0 = tmp;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassOther(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOther_methodinfo = {
  (JSJitPropertyOp)passOther,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOther2(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.passOther2");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  nsRefPtr<mozilla::dom::TestNonCastableInterface> arg0_holder;
  NonNull<mozilla::dom::TestNonCastableInterface> arg0;
  if (argv[0].isObject()) {
    jsval tmpVal = argv[0];
    mozilla::dom::TestNonCastableInterface* tmp;
    if (NS_FAILED(xpc_qsUnwrapArg<mozilla::dom::TestNonCastableInterface>(cx, argv[0], &tmp, static_cast<mozilla::dom::TestNonCastableInterface**>(getter_AddRefs(arg0_holder)), &tmpVal))) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestNonCastableInterface");return false;
    }
    MOZ_ASSERT(tmp);
    if (tmpVal != argv[0] && !arg0_holder) {
      // We have to have a strong ref, because we got this off
      // some random object that might get GCed
      arg0_holder = tmp;
    }
    arg0 = tmp;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassOther2(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOther2_methodinfo = {
  (JSJitPropertyOp)passOther2,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passNullableOther(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.passNullableOther");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  nsRefPtr<mozilla::dom::TestNonCastableInterface> arg0_holder;
  mozilla::dom::TestNonCastableInterface* arg0;
  if (argv[0].isObject()) {
    jsval tmpVal = argv[0];
    mozilla::dom::TestNonCastableInterface* tmp;
    if (NS_FAILED(xpc_qsUnwrapArg<mozilla::dom::TestNonCastableInterface>(cx, argv[0], &tmp, static_cast<mozilla::dom::TestNonCastableInterface**>(getter_AddRefs(arg0_holder)), &tmpVal))) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestNonCastableInterface");return false;
    }
    MOZ_ASSERT(tmp);
    if (tmpVal != argv[0] && !arg0_holder) {
      // We have to have a strong ref, because we got this off
      // some random object that might get GCed
      arg0_holder = tmp;
    }
    arg0 = tmp;
  } else if (argv[0].isNullOrUndefined()) {
    arg0 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassNullableOther(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passNullableOther_methodinfo = {
  (JSJitPropertyOp)passNullableOther,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_nonNullOther(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* vp)
{
  nsRefPtr<mozilla::dom::TestNonCastableInterface> result;
  result = self->NonNullOther();
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static bool
set_nonNullOther(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* argv)
{
  nsRefPtr<mozilla::dom::TestNonCastableInterface> arg0_holder;
  NonNull<mozilla::dom::TestNonCastableInterface> arg0;
  if (argv[0].isObject()) {
    jsval tmpVal = argv[0];
    mozilla::dom::TestNonCastableInterface* tmp;
    if (NS_FAILED(xpc_qsUnwrapArg<mozilla::dom::TestNonCastableInterface>(cx, argv[0], &tmp, static_cast<mozilla::dom::TestNonCastableInterface**>(getter_AddRefs(arg0_holder)), &tmpVal))) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestNonCastableInterface");return false;
    }
    MOZ_ASSERT(tmp);
    if (tmpVal != argv[0] && !arg0_holder) {
      // We have to have a strong ref, because we got this off
      // some random object that might get GCed
      arg0_holder = tmp;
    }
    arg0 = tmp;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->SetNonNullOther(arg0);

  return true;
}


const JSJitInfo nonNullOther_getterinfo = {
  (JSJitPropertyOp)get_nonNullOther,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo nonNullOther_setterinfo = {
  (JSJitPropertyOp)set_nonNullOther,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_nullableOther(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* vp)
{
  nsRefPtr<mozilla::dom::TestNonCastableInterface> result;
  result = self->GetNullableOther();
  if (!result) {
    *vp = JSVAL_NULL;
    return true;
  }
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static bool
set_nullableOther(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* argv)
{
  nsRefPtr<mozilla::dom::TestNonCastableInterface> arg0_holder;
  mozilla::dom::TestNonCastableInterface* arg0;
  if (argv[0].isObject()) {
    jsval tmpVal = argv[0];
    mozilla::dom::TestNonCastableInterface* tmp;
    if (NS_FAILED(xpc_qsUnwrapArg<mozilla::dom::TestNonCastableInterface>(cx, argv[0], &tmp, static_cast<mozilla::dom::TestNonCastableInterface**>(getter_AddRefs(arg0_holder)), &tmpVal))) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestNonCastableInterface");return false;
    }
    MOZ_ASSERT(tmp);
    if (tmpVal != argv[0] && !arg0_holder) {
      // We have to have a strong ref, because we got this off
      // some random object that might get GCed
      arg0_holder = tmp;
    }
    arg0 = tmp;
  } else if (argv[0].isNullOrUndefined()) {
    arg0 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->SetNullableOther(arg0);

  return true;
}


const JSJitInfo nullableOther_getterinfo = {
  (JSJitPropertyOp)get_nullableOther,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo nullableOther_setterinfo = {
  (JSJitPropertyOp)set_nullableOther,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalOther(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  const Optional< nsRefPtr<mozilla::dom::TestNonCastableInterface> > arg0_holder;
  const Optional< mozilla::dom::TestNonCastableInterface* > arg0;
  if (0 < argc) {
    const_cast< Optional< mozilla::dom::TestNonCastableInterface* > &>(arg0).Construct();
    const_cast< Optional< nsRefPtr<mozilla::dom::TestNonCastableInterface> > &>(arg0_holder).Construct();
    if (argv[0].isObject()) {
      jsval tmpVal = argv[0];
      mozilla::dom::TestNonCastableInterface* tmp;
      if (NS_FAILED(xpc_qsUnwrapArg<mozilla::dom::TestNonCastableInterface>(cx, argv[0], &tmp, static_cast<mozilla::dom::TestNonCastableInterface**>(getter_AddRefs(const_cast< nsRefPtr<mozilla::dom::TestNonCastableInterface> & >(arg0_holder.Value()))), &tmpVal))) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestNonCastableInterface");return false;
      }
      MOZ_ASSERT(tmp);
      if (tmpVal != argv[0] && !const_cast< nsRefPtr<mozilla::dom::TestNonCastableInterface> & >(arg0_holder.Value())) {
        // We have to have a strong ref, because we got this off
        // some random object that might get GCed
        const_cast< nsRefPtr<mozilla::dom::TestNonCastableInterface> & >(arg0_holder.Value()) = tmp;
      }
      const_cast< mozilla::dom::TestNonCastableInterface* & >(arg0.Value()) = tmp;
    } else if (argv[0].isNullOrUndefined()) {
      const_cast< mozilla::dom::TestNonCastableInterface* & >(arg0.Value()) = NULL;
    } else {
      ThrowErrorMessage(cx, MSG_NOT_OBJECT);
      return false;
    }
  }
  self->PassOptionalOther(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalOther_methodinfo = {
  (JSJitPropertyOp)passOptionalOther,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalNonNullOther(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  const Optional< nsRefPtr<mozilla::dom::TestNonCastableInterface> > arg0_holder;
  const Optional< NonNull<mozilla::dom::TestNonCastableInterface> > arg0;
  if (0 < argc) {
    const_cast< Optional< NonNull<mozilla::dom::TestNonCastableInterface> > &>(arg0).Construct();
    const_cast< Optional< nsRefPtr<mozilla::dom::TestNonCastableInterface> > &>(arg0_holder).Construct();
    if (argv[0].isObject()) {
      jsval tmpVal = argv[0];
      mozilla::dom::TestNonCastableInterface* tmp;
      if (NS_FAILED(xpc_qsUnwrapArg<mozilla::dom::TestNonCastableInterface>(cx, argv[0], &tmp, static_cast<mozilla::dom::TestNonCastableInterface**>(getter_AddRefs(const_cast< nsRefPtr<mozilla::dom::TestNonCastableInterface> & >(arg0_holder.Value()))), &tmpVal))) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestNonCastableInterface");return false;
      }
      MOZ_ASSERT(tmp);
      if (tmpVal != argv[0] && !const_cast< nsRefPtr<mozilla::dom::TestNonCastableInterface> & >(arg0_holder.Value())) {
        // We have to have a strong ref, because we got this off
        // some random object that might get GCed
        const_cast< nsRefPtr<mozilla::dom::TestNonCastableInterface> & >(arg0_holder.Value()) = tmp;
      }
      const_cast< NonNull<mozilla::dom::TestNonCastableInterface> & >(arg0.Value()) = tmp;
    } else {
      ThrowErrorMessage(cx, MSG_NOT_OBJECT);
      return false;
    }
  }
  self->PassOptionalNonNullOther(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalNonNullOther_methodinfo = {
  (JSJitPropertyOp)passOptionalNonNullOther,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalOtherWithDefault(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  nsRefPtr<mozilla::dom::TestNonCastableInterface> arg0_holder;
  mozilla::dom::TestNonCastableInterface* arg0;
  if (0 < argc) {
    if (argv[0].isObject()) {
      jsval tmpVal = argv[0];
      mozilla::dom::TestNonCastableInterface* tmp;
      if (NS_FAILED(xpc_qsUnwrapArg<mozilla::dom::TestNonCastableInterface>(cx, argv[0], &tmp, static_cast<mozilla::dom::TestNonCastableInterface**>(getter_AddRefs(arg0_holder)), &tmpVal))) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestNonCastableInterface");return false;
      }
      MOZ_ASSERT(tmp);
      if (tmpVal != argv[0] && !arg0_holder) {
        // We have to have a strong ref, because we got this off
        // some random object that might get GCed
        arg0_holder = tmp;
      }
      arg0 = tmp;
    } else if (argv[0].isNullOrUndefined()) {
      arg0 = NULL;
    } else {
      ThrowErrorMessage(cx, MSG_NOT_OBJECT);
      return false;
    }
  } else {
    arg0 = NULL;
  }
  self->PassOptionalOtherWithDefault(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalOtherWithDefault_methodinfo = {
  (JSJitPropertyOp)passOptionalOtherWithDefault,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveExternal(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{
  nsRefPtr<mozilla::dom::TestExternalInterface> result;
  result = self->ReceiveExternal();
  if (!WrapObject(cx, obj, result, vp)) {
    return false;
  }
  return true;
}


const JSJitInfo receiveExternal_methodinfo = {
  (JSJitPropertyOp)receiveExternal,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveNullableExternal(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{
  nsRefPtr<mozilla::dom::TestExternalInterface> result;
  result = self->ReceiveNullableExternal();
  if (!result) {
    *vp = JSVAL_NULL;
    return true;
  }
  if (!WrapObject(cx, obj, result, vp)) {
    return false;
  }
  return true;
}


const JSJitInfo receiveNullableExternal_methodinfo = {
  (JSJitPropertyOp)receiveNullableExternal,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveWeakExternal(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{
  mozilla::dom::TestExternalInterface* result;
  result = self->ReceiveWeakExternal();
  if (!WrapObject(cx, obj, result, vp)) {
    return false;
  }
  return true;
}


const JSJitInfo receiveWeakExternal_methodinfo = {
  (JSJitPropertyOp)receiveWeakExternal,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveWeakNullableExternal(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{
  mozilla::dom::TestExternalInterface* result;
  result = self->ReceiveWeakNullableExternal();
  if (!result) {
    *vp = JSVAL_NULL;
    return true;
  }
  if (!WrapObject(cx, obj, result, vp)) {
    return false;
  }
  return true;
}


const JSJitInfo receiveWeakNullableExternal_methodinfo = {
  (JSJitPropertyOp)receiveWeakNullableExternal,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
passExternal(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.passExternal");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  nsRefPtr<mozilla::dom::TestExternalInterface> arg0_holder;
  mozilla::dom::TestExternalInterface* arg0;
  if (argv[0].isObject()) {
    jsval tmpVal = argv[0];
    mozilla::dom::TestExternalInterface* tmp;
    if (NS_FAILED(xpc_qsUnwrapArg<mozilla::dom::TestExternalInterface>(cx, argv[0], &tmp, static_cast<mozilla::dom::TestExternalInterface**>(getter_AddRefs(arg0_holder)), &tmpVal))) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestExternalInterface");return false;
    }
    MOZ_ASSERT(tmp);
    if (tmpVal != argv[0] && !arg0_holder) {
      // We have to have a strong ref, because we got this off
      // some random object that might get GCed
      arg0_holder = tmp;
    }
    arg0 = tmp;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassExternal(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passExternal_methodinfo = {
  (JSJitPropertyOp)passExternal,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passExternal2(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.passExternal2");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  nsRefPtr<mozilla::dom::TestExternalInterface> arg0_holder;
  mozilla::dom::TestExternalInterface* arg0;
  if (argv[0].isObject()) {
    jsval tmpVal = argv[0];
    mozilla::dom::TestExternalInterface* tmp;
    if (NS_FAILED(xpc_qsUnwrapArg<mozilla::dom::TestExternalInterface>(cx, argv[0], &tmp, static_cast<mozilla::dom::TestExternalInterface**>(getter_AddRefs(arg0_holder)), &tmpVal))) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestExternalInterface");return false;
    }
    MOZ_ASSERT(tmp);
    if (tmpVal != argv[0] && !arg0_holder) {
      // We have to have a strong ref, because we got this off
      // some random object that might get GCed
      arg0_holder = tmp;
    }
    arg0 = tmp;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassExternal2(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passExternal2_methodinfo = {
  (JSJitPropertyOp)passExternal2,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passNullableExternal(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.passNullableExternal");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  nsRefPtr<mozilla::dom::TestExternalInterface> arg0_holder;
  mozilla::dom::TestExternalInterface* arg0;
  if (argv[0].isObject()) {
    jsval tmpVal = argv[0];
    mozilla::dom::TestExternalInterface* tmp;
    if (NS_FAILED(xpc_qsUnwrapArg<mozilla::dom::TestExternalInterface>(cx, argv[0], &tmp, static_cast<mozilla::dom::TestExternalInterface**>(getter_AddRefs(arg0_holder)), &tmpVal))) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestExternalInterface");return false;
    }
    MOZ_ASSERT(tmp);
    if (tmpVal != argv[0] && !arg0_holder) {
      // We have to have a strong ref, because we got this off
      // some random object that might get GCed
      arg0_holder = tmp;
    }
    arg0 = tmp;
  } else if (argv[0].isNullOrUndefined()) {
    arg0 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassNullableExternal(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passNullableExternal_methodinfo = {
  (JSJitPropertyOp)passNullableExternal,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_nonNullExternal(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* vp)
{
  nsRefPtr<mozilla::dom::TestExternalInterface> result;
  result = self->NonNullExternal();
  if (!WrapObject(cx, obj, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_nonNullExternal(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* argv)
{
  nsRefPtr<mozilla::dom::TestExternalInterface> arg0_holder;
  mozilla::dom::TestExternalInterface* arg0;
  if (argv[0].isObject()) {
    jsval tmpVal = argv[0];
    mozilla::dom::TestExternalInterface* tmp;
    if (NS_FAILED(xpc_qsUnwrapArg<mozilla::dom::TestExternalInterface>(cx, argv[0], &tmp, static_cast<mozilla::dom::TestExternalInterface**>(getter_AddRefs(arg0_holder)), &tmpVal))) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestExternalInterface");return false;
    }
    MOZ_ASSERT(tmp);
    if (tmpVal != argv[0] && !arg0_holder) {
      // We have to have a strong ref, because we got this off
      // some random object that might get GCed
      arg0_holder = tmp;
    }
    arg0 = tmp;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->SetNonNullExternal(arg0);

  return true;
}


const JSJitInfo nonNullExternal_getterinfo = {
  (JSJitPropertyOp)get_nonNullExternal,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo nonNullExternal_setterinfo = {
  (JSJitPropertyOp)set_nonNullExternal,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_nullableExternal(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* vp)
{
  nsRefPtr<mozilla::dom::TestExternalInterface> result;
  result = self->GetNullableExternal();
  if (!result) {
    *vp = JSVAL_NULL;
    return true;
  }
  if (!WrapObject(cx, obj, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_nullableExternal(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* argv)
{
  nsRefPtr<mozilla::dom::TestExternalInterface> arg0_holder;
  mozilla::dom::TestExternalInterface* arg0;
  if (argv[0].isObject()) {
    jsval tmpVal = argv[0];
    mozilla::dom::TestExternalInterface* tmp;
    if (NS_FAILED(xpc_qsUnwrapArg<mozilla::dom::TestExternalInterface>(cx, argv[0], &tmp, static_cast<mozilla::dom::TestExternalInterface**>(getter_AddRefs(arg0_holder)), &tmpVal))) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestExternalInterface");return false;
    }
    MOZ_ASSERT(tmp);
    if (tmpVal != argv[0] && !arg0_holder) {
      // We have to have a strong ref, because we got this off
      // some random object that might get GCed
      arg0_holder = tmp;
    }
    arg0 = tmp;
  } else if (argv[0].isNullOrUndefined()) {
    arg0 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->SetNullableExternal(arg0);

  return true;
}


const JSJitInfo nullableExternal_getterinfo = {
  (JSJitPropertyOp)get_nullableExternal,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo nullableExternal_setterinfo = {
  (JSJitPropertyOp)set_nullableExternal,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalExternal(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  const Optional< nsRefPtr<mozilla::dom::TestExternalInterface> > arg0_holder;
  const Optional< mozilla::dom::TestExternalInterface* > arg0;
  if (0 < argc) {
    const_cast< Optional< mozilla::dom::TestExternalInterface* > &>(arg0).Construct();
    const_cast< Optional< nsRefPtr<mozilla::dom::TestExternalInterface> > &>(arg0_holder).Construct();
    if (argv[0].isObject()) {
      jsval tmpVal = argv[0];
      mozilla::dom::TestExternalInterface* tmp;
      if (NS_FAILED(xpc_qsUnwrapArg<mozilla::dom::TestExternalInterface>(cx, argv[0], &tmp, static_cast<mozilla::dom::TestExternalInterface**>(getter_AddRefs(const_cast< nsRefPtr<mozilla::dom::TestExternalInterface> & >(arg0_holder.Value()))), &tmpVal))) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestExternalInterface");return false;
      }
      MOZ_ASSERT(tmp);
      if (tmpVal != argv[0] && !const_cast< nsRefPtr<mozilla::dom::TestExternalInterface> & >(arg0_holder.Value())) {
        // We have to have a strong ref, because we got this off
        // some random object that might get GCed
        const_cast< nsRefPtr<mozilla::dom::TestExternalInterface> & >(arg0_holder.Value()) = tmp;
      }
      const_cast< mozilla::dom::TestExternalInterface* & >(arg0.Value()) = tmp;
    } else if (argv[0].isNullOrUndefined()) {
      const_cast< mozilla::dom::TestExternalInterface* & >(arg0.Value()) = NULL;
    } else {
      ThrowErrorMessage(cx, MSG_NOT_OBJECT);
      return false;
    }
  }
  self->PassOptionalExternal(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalExternal_methodinfo = {
  (JSJitPropertyOp)passOptionalExternal,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalNonNullExternal(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  const Optional< nsRefPtr<mozilla::dom::TestExternalInterface> > arg0_holder;
  const Optional< mozilla::dom::TestExternalInterface* > arg0;
  if (0 < argc) {
    const_cast< Optional< mozilla::dom::TestExternalInterface* > &>(arg0).Construct();
    const_cast< Optional< nsRefPtr<mozilla::dom::TestExternalInterface> > &>(arg0_holder).Construct();
    if (argv[0].isObject()) {
      jsval tmpVal = argv[0];
      mozilla::dom::TestExternalInterface* tmp;
      if (NS_FAILED(xpc_qsUnwrapArg<mozilla::dom::TestExternalInterface>(cx, argv[0], &tmp, static_cast<mozilla::dom::TestExternalInterface**>(getter_AddRefs(const_cast< nsRefPtr<mozilla::dom::TestExternalInterface> & >(arg0_holder.Value()))), &tmpVal))) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestExternalInterface");return false;
      }
      MOZ_ASSERT(tmp);
      if (tmpVal != argv[0] && !const_cast< nsRefPtr<mozilla::dom::TestExternalInterface> & >(arg0_holder.Value())) {
        // We have to have a strong ref, because we got this off
        // some random object that might get GCed
        const_cast< nsRefPtr<mozilla::dom::TestExternalInterface> & >(arg0_holder.Value()) = tmp;
      }
      const_cast< mozilla::dom::TestExternalInterface* & >(arg0.Value()) = tmp;
    } else {
      ThrowErrorMessage(cx, MSG_NOT_OBJECT);
      return false;
    }
  }
  self->PassOptionalNonNullExternal(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalNonNullExternal_methodinfo = {
  (JSJitPropertyOp)passOptionalNonNullExternal,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalExternalWithDefault(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  nsRefPtr<mozilla::dom::TestExternalInterface> arg0_holder;
  mozilla::dom::TestExternalInterface* arg0;
  if (0 < argc) {
    if (argv[0].isObject()) {
      jsval tmpVal = argv[0];
      mozilla::dom::TestExternalInterface* tmp;
      if (NS_FAILED(xpc_qsUnwrapArg<mozilla::dom::TestExternalInterface>(cx, argv[0], &tmp, static_cast<mozilla::dom::TestExternalInterface**>(getter_AddRefs(arg0_holder)), &tmpVal))) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestExternalInterface");return false;
      }
      MOZ_ASSERT(tmp);
      if (tmpVal != argv[0] && !arg0_holder) {
        // We have to have a strong ref, because we got this off
        // some random object that might get GCed
        arg0_holder = tmp;
      }
      arg0 = tmp;
    } else if (argv[0].isNullOrUndefined()) {
      arg0 = NULL;
    } else {
      ThrowErrorMessage(cx, MSG_NOT_OBJECT);
      return false;
    }
  } else {
    arg0 = NULL;
  }
  self->PassOptionalExternalWithDefault(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalExternalWithDefault_methodinfo = {
  (JSJitPropertyOp)passOptionalExternalWithDefault,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveCallbackInterface(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{
  nsRefPtr<mozilla::dom::TestCallbackInterface> result;
  result = self->ReceiveCallbackInterface();
  if (!WrapCallbackInterface(cx, obj, result, vp)) {
    return false;
  }
  return true;
}


const JSJitInfo receiveCallbackInterface_methodinfo = {
  (JSJitPropertyOp)receiveCallbackInterface,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveNullableCallbackInterface(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{
  nsRefPtr<mozilla::dom::TestCallbackInterface> result;
  result = self->ReceiveNullableCallbackInterface();
  if (!result) {
    *vp = JSVAL_NULL;
    return true;
  }
  if (!WrapCallbackInterface(cx, obj, result, vp)) {
    return false;
  }
  return true;
}


const JSJitInfo receiveNullableCallbackInterface_methodinfo = {
  (JSJitPropertyOp)receiveNullableCallbackInterface,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveWeakCallbackInterface(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{
  nsRefPtr<mozilla::dom::TestCallbackInterface> result;
  result = self->ReceiveWeakCallbackInterface();
  if (!WrapCallbackInterface(cx, obj, result, vp)) {
    return false;
  }
  return true;
}


const JSJitInfo receiveWeakCallbackInterface_methodinfo = {
  (JSJitPropertyOp)receiveWeakCallbackInterface,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveWeakNullableCallbackInterface(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{
  nsRefPtr<mozilla::dom::TestCallbackInterface> result;
  result = self->ReceiveWeakNullableCallbackInterface();
  if (!result) {
    *vp = JSVAL_NULL;
    return true;
  }
  if (!WrapCallbackInterface(cx, obj, result, vp)) {
    return false;
  }
  return true;
}


const JSJitInfo receiveWeakNullableCallbackInterface_methodinfo = {
  (JSJitPropertyOp)receiveWeakNullableCallbackInterface,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
passCallbackInterface(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.passCallbackInterface");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  OwningNonNull<mozilla::dom::TestCallbackInterface> arg0;
  if (argv[0].isObject()) {
    if (!IsConvertibleToCallbackInterface(cx, &argv[0].toObject())) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestCallbackInterface");
        return false;
    }

    nsresult rv;
    XPCCallContext ccx(JS_CALLER, cx);
    if (!ccx.IsValid()) {
      rv = NS_ERROR_XPC_BAD_CONVERT_JS;
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestCallbackInterface");
      return false;
    }

    const nsIID& iid = NS_GET_IID(mozilla::dom::TestCallbackInterface);
    nsRefPtr<nsXPCWrappedJS> wrappedJS;
    rv = nsXPCWrappedJS::GetNewOrUsed(ccx, &argv[0].toObject(), iid,
                                      NULL, getter_AddRefs(wrappedJS));
    if (NS_FAILED(rv) || !wrappedJS) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestCallbackInterface");
      return false;
    }

    // Use a temp nsCOMPtr for the null-check, because arg0 might be
    // OwningNonNull, not an nsCOMPtr.
    nsCOMPtr<mozilla::dom::TestCallbackInterface> tmp = do_QueryObject(wrappedJS.get());
    if (!tmp) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestCallbackInterface");
      return false;
    }
    arg0 = tmp.forget();
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassCallbackInterface(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passCallbackInterface_methodinfo = {
  (JSJitPropertyOp)passCallbackInterface,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passCallbackInterface2(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.passCallbackInterface2");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  OwningNonNull<mozilla::dom::TestCallbackInterface> arg0;
  if (argv[0].isObject()) {
    if (!IsConvertibleToCallbackInterface(cx, &argv[0].toObject())) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestCallbackInterface");
        return false;
    }

    nsresult rv;
    XPCCallContext ccx(JS_CALLER, cx);
    if (!ccx.IsValid()) {
      rv = NS_ERROR_XPC_BAD_CONVERT_JS;
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestCallbackInterface");
      return false;
    }

    const nsIID& iid = NS_GET_IID(mozilla::dom::TestCallbackInterface);
    nsRefPtr<nsXPCWrappedJS> wrappedJS;
    rv = nsXPCWrappedJS::GetNewOrUsed(ccx, &argv[0].toObject(), iid,
                                      NULL, getter_AddRefs(wrappedJS));
    if (NS_FAILED(rv) || !wrappedJS) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestCallbackInterface");
      return false;
    }

    // Use a temp nsCOMPtr for the null-check, because arg0 might be
    // OwningNonNull, not an nsCOMPtr.
    nsCOMPtr<mozilla::dom::TestCallbackInterface> tmp = do_QueryObject(wrappedJS.get());
    if (!tmp) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestCallbackInterface");
      return false;
    }
    arg0 = tmp.forget();
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassCallbackInterface2(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passCallbackInterface2_methodinfo = {
  (JSJitPropertyOp)passCallbackInterface2,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passNullableCallbackInterface(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.passNullableCallbackInterface");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  nsRefPtr<mozilla::dom::TestCallbackInterface> arg0;
  if (argv[0].isObject()) {
    if (!IsConvertibleToCallbackInterface(cx, &argv[0].toObject())) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestCallbackInterface");
        return false;
    }

    nsresult rv;
    XPCCallContext ccx(JS_CALLER, cx);
    if (!ccx.IsValid()) {
      rv = NS_ERROR_XPC_BAD_CONVERT_JS;
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestCallbackInterface");
      return false;
    }

    const nsIID& iid = NS_GET_IID(mozilla::dom::TestCallbackInterface);
    nsRefPtr<nsXPCWrappedJS> wrappedJS;
    rv = nsXPCWrappedJS::GetNewOrUsed(ccx, &argv[0].toObject(), iid,
                                      NULL, getter_AddRefs(wrappedJS));
    if (NS_FAILED(rv) || !wrappedJS) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestCallbackInterface");
      return false;
    }

    // Use a temp nsCOMPtr for the null-check, because arg0 might be
    // OwningNonNull, not an nsCOMPtr.
    nsCOMPtr<mozilla::dom::TestCallbackInterface> tmp = do_QueryObject(wrappedJS.get());
    if (!tmp) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestCallbackInterface");
      return false;
    }
    arg0 = tmp.forget();
  } else if (argv[0].isNullOrUndefined()) {
    arg0 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassNullableCallbackInterface(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passNullableCallbackInterface_methodinfo = {
  (JSJitPropertyOp)passNullableCallbackInterface,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_nonNullCallbackInterface(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* vp)
{
  nsRefPtr<mozilla::dom::TestCallbackInterface> result;
  result = self->NonNullCallbackInterface();
  if (!WrapCallbackInterface(cx, obj, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_nonNullCallbackInterface(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* argv)
{
  OwningNonNull<mozilla::dom::TestCallbackInterface> arg0;
  if (argv[0].isObject()) {
    if (!IsConvertibleToCallbackInterface(cx, &argv[0].toObject())) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestCallbackInterface");
        return false;
    }

    nsresult rv;
    XPCCallContext ccx(JS_CALLER, cx);
    if (!ccx.IsValid()) {
      rv = NS_ERROR_XPC_BAD_CONVERT_JS;
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestCallbackInterface");
      return false;
    }

    const nsIID& iid = NS_GET_IID(mozilla::dom::TestCallbackInterface);
    nsRefPtr<nsXPCWrappedJS> wrappedJS;
    rv = nsXPCWrappedJS::GetNewOrUsed(ccx, &argv[0].toObject(), iid,
                                      NULL, getter_AddRefs(wrappedJS));
    if (NS_FAILED(rv) || !wrappedJS) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestCallbackInterface");
      return false;
    }

    // Use a temp nsCOMPtr for the null-check, because arg0 might be
    // OwningNonNull, not an nsCOMPtr.
    nsCOMPtr<mozilla::dom::TestCallbackInterface> tmp = do_QueryObject(wrappedJS.get());
    if (!tmp) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestCallbackInterface");
      return false;
    }
    arg0 = tmp.forget();
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->SetNonNullCallbackInterface(arg0);

  return true;
}


const JSJitInfo nonNullCallbackInterface_getterinfo = {
  (JSJitPropertyOp)get_nonNullCallbackInterface,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo nonNullCallbackInterface_setterinfo = {
  (JSJitPropertyOp)set_nonNullCallbackInterface,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_nullableCallbackInterface(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* vp)
{
  nsRefPtr<mozilla::dom::TestCallbackInterface> result;
  result = self->GetNullableCallbackInterface();
  if (!result) {
    *vp = JSVAL_NULL;
    return true;
  }
  if (!WrapCallbackInterface(cx, obj, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_nullableCallbackInterface(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* argv)
{
  nsRefPtr<mozilla::dom::TestCallbackInterface> arg0;
  if (argv[0].isObject()) {
    if (!IsConvertibleToCallbackInterface(cx, &argv[0].toObject())) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestCallbackInterface");
        return false;
    }

    nsresult rv;
    XPCCallContext ccx(JS_CALLER, cx);
    if (!ccx.IsValid()) {
      rv = NS_ERROR_XPC_BAD_CONVERT_JS;
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestCallbackInterface");
      return false;
    }

    const nsIID& iid = NS_GET_IID(mozilla::dom::TestCallbackInterface);
    nsRefPtr<nsXPCWrappedJS> wrappedJS;
    rv = nsXPCWrappedJS::GetNewOrUsed(ccx, &argv[0].toObject(), iid,
                                      NULL, getter_AddRefs(wrappedJS));
    if (NS_FAILED(rv) || !wrappedJS) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestCallbackInterface");
      return false;
    }

    // Use a temp nsCOMPtr for the null-check, because arg0 might be
    // OwningNonNull, not an nsCOMPtr.
    nsCOMPtr<mozilla::dom::TestCallbackInterface> tmp = do_QueryObject(wrappedJS.get());
    if (!tmp) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestCallbackInterface");
      return false;
    }
    arg0 = tmp.forget();
  } else if (argv[0].isNullOrUndefined()) {
    arg0 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->SetNullableCallbackInterface(arg0);

  return true;
}


const JSJitInfo nullableCallbackInterface_getterinfo = {
  (JSJitPropertyOp)get_nullableCallbackInterface,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo nullableCallbackInterface_setterinfo = {
  (JSJitPropertyOp)set_nullableCallbackInterface,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalCallbackInterface(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  const Optional< nsRefPtr<mozilla::dom::TestCallbackInterface> > arg0;
  if (0 < argc) {
    const_cast< Optional< nsRefPtr<mozilla::dom::TestCallbackInterface> > &>(arg0).Construct();
    if (argv[0].isObject()) {
      if (!IsConvertibleToCallbackInterface(cx, &argv[0].toObject())) {
          ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestCallbackInterface");
          return false;
      }

      nsresult rv;
      XPCCallContext ccx(JS_CALLER, cx);
      if (!ccx.IsValid()) {
        rv = NS_ERROR_XPC_BAD_CONVERT_JS;
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestCallbackInterface");
        return false;
      }

      const nsIID& iid = NS_GET_IID(mozilla::dom::TestCallbackInterface);
      nsRefPtr<nsXPCWrappedJS> wrappedJS;
      rv = nsXPCWrappedJS::GetNewOrUsed(ccx, &argv[0].toObject(), iid,
                                        NULL, getter_AddRefs(wrappedJS));
      if (NS_FAILED(rv) || !wrappedJS) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestCallbackInterface");
        return false;
      }

      // Use a temp nsCOMPtr for the null-check, because const_cast< nsRefPtr<mozilla::dom::TestCallbackInterface> & >(arg0.Value()) might be
      // OwningNonNull, not an nsCOMPtr.
      nsCOMPtr<mozilla::dom::TestCallbackInterface> tmp = do_QueryObject(wrappedJS.get());
      if (!tmp) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestCallbackInterface");
        return false;
      }
      const_cast< nsRefPtr<mozilla::dom::TestCallbackInterface> & >(arg0.Value()) = tmp.forget();
    } else if (argv[0].isNullOrUndefined()) {
      const_cast< nsRefPtr<mozilla::dom::TestCallbackInterface> & >(arg0.Value()) = NULL;
    } else {
      ThrowErrorMessage(cx, MSG_NOT_OBJECT);
      return false;
    }
  }
  self->PassOptionalCallbackInterface(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalCallbackInterface_methodinfo = {
  (JSJitPropertyOp)passOptionalCallbackInterface,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalNonNullCallbackInterface(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  const Optional< OwningNonNull<mozilla::dom::TestCallbackInterface> > arg0;
  if (0 < argc) {
    const_cast< Optional< OwningNonNull<mozilla::dom::TestCallbackInterface> > &>(arg0).Construct();
    if (argv[0].isObject()) {
      if (!IsConvertibleToCallbackInterface(cx, &argv[0].toObject())) {
          ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestCallbackInterface");
          return false;
      }

      nsresult rv;
      XPCCallContext ccx(JS_CALLER, cx);
      if (!ccx.IsValid()) {
        rv = NS_ERROR_XPC_BAD_CONVERT_JS;
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestCallbackInterface");
        return false;
      }

      const nsIID& iid = NS_GET_IID(mozilla::dom::TestCallbackInterface);
      nsRefPtr<nsXPCWrappedJS> wrappedJS;
      rv = nsXPCWrappedJS::GetNewOrUsed(ccx, &argv[0].toObject(), iid,
                                        NULL, getter_AddRefs(wrappedJS));
      if (NS_FAILED(rv) || !wrappedJS) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestCallbackInterface");
        return false;
      }

      // Use a temp nsCOMPtr for the null-check, because const_cast< OwningNonNull<mozilla::dom::TestCallbackInterface> & >(arg0.Value()) might be
      // OwningNonNull, not an nsCOMPtr.
      nsCOMPtr<mozilla::dom::TestCallbackInterface> tmp = do_QueryObject(wrappedJS.get());
      if (!tmp) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestCallbackInterface");
        return false;
      }
      const_cast< OwningNonNull<mozilla::dom::TestCallbackInterface> & >(arg0.Value()) = tmp.forget();
    } else {
      ThrowErrorMessage(cx, MSG_NOT_OBJECT);
      return false;
    }
  }
  self->PassOptionalNonNullCallbackInterface(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalNonNullCallbackInterface_methodinfo = {
  (JSJitPropertyOp)passOptionalNonNullCallbackInterface,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalCallbackInterfaceWithDefault(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  nsRefPtr<mozilla::dom::TestCallbackInterface> arg0;
  if (0 < argc) {
    if (argv[0].isObject()) {
      if (!IsConvertibleToCallbackInterface(cx, &argv[0].toObject())) {
          ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestCallbackInterface");
          return false;
      }

      nsresult rv;
      XPCCallContext ccx(JS_CALLER, cx);
      if (!ccx.IsValid()) {
        rv = NS_ERROR_XPC_BAD_CONVERT_JS;
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestCallbackInterface");
        return false;
      }

      const nsIID& iid = NS_GET_IID(mozilla::dom::TestCallbackInterface);
      nsRefPtr<nsXPCWrappedJS> wrappedJS;
      rv = nsXPCWrappedJS::GetNewOrUsed(ccx, &argv[0].toObject(), iid,
                                        NULL, getter_AddRefs(wrappedJS));
      if (NS_FAILED(rv) || !wrappedJS) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestCallbackInterface");
        return false;
      }

      // Use a temp nsCOMPtr for the null-check, because arg0 might be
      // OwningNonNull, not an nsCOMPtr.
      nsCOMPtr<mozilla::dom::TestCallbackInterface> tmp = do_QueryObject(wrappedJS.get());
      if (!tmp) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestCallbackInterface");
        return false;
      }
      arg0 = tmp.forget();
    } else if (argv[0].isNullOrUndefined()) {
      arg0 = NULL;
    } else {
      ThrowErrorMessage(cx, MSG_NOT_OBJECT);
      return false;
    }
  } else {
    arg0 = NULL;
  }
  self->PassOptionalCallbackInterfaceWithDefault(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalCallbackInterfaceWithDefault_methodinfo = {
  (JSJitPropertyOp)passOptionalCallbackInterfaceWithDefault,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveConsequentialInterface(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{
  nsRefPtr<mozilla::dom::IndirectlyImplementedInterface> result;
  result = self->ReceiveConsequentialInterface();
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}


const JSJitInfo receiveConsequentialInterface_methodinfo = {
  (JSJitPropertyOp)receiveConsequentialInterface,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
passConsequentialInterface(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.passConsequentialInterface");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  nsRefPtr<mozilla::dom::IndirectlyImplementedInterface> arg0_holder;
  NonNull<mozilla::dom::IndirectlyImplementedInterface> arg0;
  if (argv[0].isObject()) {
    jsval tmpVal = argv[0];
    mozilla::dom::IndirectlyImplementedInterface* tmp;
    if (NS_FAILED(xpc_qsUnwrapArg<mozilla::dom::IndirectlyImplementedInterface>(cx, argv[0], &tmp, static_cast<mozilla::dom::IndirectlyImplementedInterface**>(getter_AddRefs(arg0_holder)), &tmpVal))) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "IndirectlyImplementedInterface");return false;
    }
    MOZ_ASSERT(tmp);
    if (tmpVal != argv[0] && !arg0_holder) {
      // We have to have a strong ref, because we got this off
      // some random object that might get GCed
      arg0_holder = tmp;
    }
    arg0 = tmp;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassConsequentialInterface(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passConsequentialInterface_methodinfo = {
  (JSJitPropertyOp)passConsequentialInterface,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveSequence(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{
  nsTArray< int32_t > result;
  self->ReceiveSequence(result);

  uint32_t length = result.Length();
  JSObject *returnArray = JS_NewArrayObject(cx, length, NULL);
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    jsval tmp;
    for (uint32_t i = 0; i < length; ++i) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        tmp = INT_TO_JSVAL(int32_t(result[i]));
        break;
      } while (0);
      if (!JS_DefineElement(cx, returnArray, i, tmp,
                            nullptr, nullptr, JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  *vp = JS::ObjectValue(*returnArray);
  return true;
}


const JSJitInfo receiveSequence_methodinfo = {
  (JSJitPropertyOp)receiveSequence,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveNullableSequence(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{
  Nullable< nsTArray< int32_t > > result;
  self->ReceiveNullableSequence(result);

  if (result.IsNull()) {
    *vp = JSVAL_NULL;
    return true;
  }

  uint32_t length = result.Value().Length();
  JSObject *returnArray = JS_NewArrayObject(cx, length, NULL);
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    jsval tmp;
    for (uint32_t i = 0; i < length; ++i) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        tmp = INT_TO_JSVAL(int32_t(result.Value()[i]));
        break;
      } while (0);
      if (!JS_DefineElement(cx, returnArray, i, tmp,
                            nullptr, nullptr, JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  *vp = JS::ObjectValue(*returnArray);
  return true;
}


const JSJitInfo receiveNullableSequence_methodinfo = {
  (JSJitPropertyOp)receiveNullableSequence,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveSequenceOfNullableInts(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{
  nsTArray< Nullable<int32_t> > result;
  self->ReceiveSequenceOfNullableInts(result);

  uint32_t length = result.Length();
  JSObject *returnArray = JS_NewArrayObject(cx, length, NULL);
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    jsval tmp;
    for (uint32_t i = 0; i < length; ++i) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (result[i].IsNull()) {
          tmp = JSVAL_NULL;
          break;
        }
        tmp = INT_TO_JSVAL(int32_t(result[i].Value()));
        break;
      } while (0);
      if (!JS_DefineElement(cx, returnArray, i, tmp,
                            nullptr, nullptr, JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  *vp = JS::ObjectValue(*returnArray);
  return true;
}


const JSJitInfo receiveSequenceOfNullableInts_methodinfo = {
  (JSJitPropertyOp)receiveSequenceOfNullableInts,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveNullableSequenceOfNullableInts(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{
  Nullable< nsTArray< Nullable<int32_t> > > result;
  self->ReceiveNullableSequenceOfNullableInts(result);

  if (result.IsNull()) {
    *vp = JSVAL_NULL;
    return true;
  }

  uint32_t length = result.Value().Length();
  JSObject *returnArray = JS_NewArrayObject(cx, length, NULL);
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    jsval tmp;
    for (uint32_t i = 0; i < length; ++i) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (result.Value()[i].IsNull()) {
          tmp = JSVAL_NULL;
          break;
        }
        tmp = INT_TO_JSVAL(int32_t(result.Value()[i].Value()));
        break;
      } while (0);
      if (!JS_DefineElement(cx, returnArray, i, tmp,
                            nullptr, nullptr, JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  *vp = JS::ObjectValue(*returnArray);
  return true;
}


const JSJitInfo receiveNullableSequenceOfNullableInts_methodinfo = {
  (JSJitPropertyOp)receiveNullableSequenceOfNullableInts,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
passSequence(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.passSequence");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  const Sequence< int32_t > arg0;
  if (argv[0].isObject()) {
    JSObject* seq = &argv[0].toObject();

    if (!IsArrayLike(cx, seq)) {
      ThrowErrorMessage(cx, MSG_NOT_SEQUENCE);
      return false;
    }
    uint32_t length;
    // JS_GetArrayLength actually works on all objects
    if (!JS_GetArrayLength(cx, seq, &length)) {
      return false;
    }
    Sequence< int32_t > &arr = const_cast< Sequence< int32_t >& >(arg0);
    if (!arr.SetCapacity(length)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t i = 0; i < length; ++i) {
      jsval temp;
      if (!JS_GetElement(cx, seq, i, &temp)) {
        return false;
      }
      int32_t& slot = *arr.AppendElement();
      if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, &slot)) {
        return false;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassSequence(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passSequence_methodinfo = {
  (JSJitPropertyOp)passSequence,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passNullableSequence(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.passNullableSequence");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  const Nullable< Sequence< int32_t > > arg0;
  if (argv[0].isObject()) {
    JSObject* seq = &argv[0].toObject();

    if (!IsArrayLike(cx, seq)) {
      ThrowErrorMessage(cx, MSG_NOT_SEQUENCE);
      return false;
    }
    uint32_t length;
    // JS_GetArrayLength actually works on all objects
    if (!JS_GetArrayLength(cx, seq, &length)) {
      return false;
    }
    Sequence< int32_t > &arr = const_cast< Sequence< int32_t >& >(arg0.Value());
    if (!arr.SetCapacity(length)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t i = 0; i < length; ++i) {
      jsval temp;
      if (!JS_GetElement(cx, seq, i, &temp)) {
        return false;
      }
      int32_t& slot = *arr.AppendElement();
      if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, &slot)) {
        return false;
      }
    }
  } else if (argv[0].isNullOrUndefined()) {
    const_cast< Nullable< Sequence< int32_t > > & >(arg0).SetNull();
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassNullableSequence(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passNullableSequence_methodinfo = {
  (JSJitPropertyOp)passNullableSequence,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passSequenceOfNullableInts(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.passSequenceOfNullableInts");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  const Sequence< Nullable<int32_t> > arg0;
  if (argv[0].isObject()) {
    JSObject* seq = &argv[0].toObject();

    if (!IsArrayLike(cx, seq)) {
      ThrowErrorMessage(cx, MSG_NOT_SEQUENCE);
      return false;
    }
    uint32_t length;
    // JS_GetArrayLength actually works on all objects
    if (!JS_GetArrayLength(cx, seq, &length)) {
      return false;
    }
    Sequence< Nullable<int32_t> > &arr = const_cast< Sequence< Nullable<int32_t> >& >(arg0);
    if (!arr.SetCapacity(length)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t i = 0; i < length; ++i) {
      jsval temp;
      if (!JS_GetElement(cx, seq, i, &temp)) {
        return false;
      }
      Nullable<int32_t>& slot = *arr.AppendElement();
      if (temp.isNullOrUndefined()) {
        const_cast< Nullable<int32_t>& >(slot).SetNull();
      } else if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, &const_cast< Nullable<int32_t>& >(slot).SetValue())) {
        return false;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassSequenceOfNullableInts(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passSequenceOfNullableInts_methodinfo = {
  (JSJitPropertyOp)passSequenceOfNullableInts,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalSequenceOfNullableInts(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  const Optional< Sequence< Nullable<int32_t> > > arg0;
  if (0 < argc) {
    const_cast< Optional< Sequence< Nullable<int32_t> > > &>(arg0).Construct();
    if (argv[0].isObject()) {
      JSObject* seq = &argv[0].toObject();

      if (!IsArrayLike(cx, seq)) {
        ThrowErrorMessage(cx, MSG_NOT_SEQUENCE);
        return false;
      }
      uint32_t length;
      // JS_GetArrayLength actually works on all objects
      if (!JS_GetArrayLength(cx, seq, &length)) {
        return false;
      }
      Sequence< Nullable<int32_t> > &arr = const_cast< Sequence< Nullable<int32_t> >& >(const_cast< Sequence< Nullable<int32_t> > & >(arg0.Value()));
      if (!arr.SetCapacity(length)) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      for (uint32_t i = 0; i < length; ++i) {
        jsval temp;
        if (!JS_GetElement(cx, seq, i, &temp)) {
          return false;
        }
        Nullable<int32_t>& slot = *arr.AppendElement();
        if (temp.isNullOrUndefined()) {
          const_cast< Nullable<int32_t>& >(slot).SetNull();
        } else if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, &const_cast< Nullable<int32_t>& >(slot).SetValue())) {
          return false;
        }
      }
    } else {
      ThrowErrorMessage(cx, MSG_NOT_OBJECT);
      return false;
    }
  }
  self->PassOptionalSequenceOfNullableInts(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalSequenceOfNullableInts_methodinfo = {
  (JSJitPropertyOp)passOptionalSequenceOfNullableInts,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalNullableSequenceOfNullableInts(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  const Optional< Nullable< Sequence< Nullable<int32_t> > > > arg0;
  if (0 < argc) {
    const_cast< Optional< Nullable< Sequence< Nullable<int32_t> > > > &>(arg0).Construct();
    if (argv[0].isObject()) {
      JSObject* seq = &argv[0].toObject();

      if (!IsArrayLike(cx, seq)) {
        ThrowErrorMessage(cx, MSG_NOT_SEQUENCE);
        return false;
      }
      uint32_t length;
      // JS_GetArrayLength actually works on all objects
      if (!JS_GetArrayLength(cx, seq, &length)) {
        return false;
      }
      Sequence< Nullable<int32_t> > &arr = const_cast< Sequence< Nullable<int32_t> >& >(const_cast< Nullable< Sequence< Nullable<int32_t> > > & >(arg0.Value()).Value());
      if (!arr.SetCapacity(length)) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      for (uint32_t i = 0; i < length; ++i) {
        jsval temp;
        if (!JS_GetElement(cx, seq, i, &temp)) {
          return false;
        }
        Nullable<int32_t>& slot = *arr.AppendElement();
        if (temp.isNullOrUndefined()) {
          const_cast< Nullable<int32_t>& >(slot).SetNull();
        } else if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, &const_cast< Nullable<int32_t>& >(slot).SetValue())) {
          return false;
        }
      }
    } else if (argv[0].isNullOrUndefined()) {
      const_cast< Nullable< Sequence< Nullable<int32_t> > > & >(const_cast< Nullable< Sequence< Nullable<int32_t> > > & >(arg0.Value())).SetNull();
    } else {
      ThrowErrorMessage(cx, MSG_NOT_OBJECT);
      return false;
    }
  }
  self->PassOptionalNullableSequenceOfNullableInts(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalNullableSequenceOfNullableInts_methodinfo = {
  (JSJitPropertyOp)passOptionalNullableSequenceOfNullableInts,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveCastableObjectSequence(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{
  nsTArray< nsRefPtr<mozilla::dom::TestInterface> > result;
  self->ReceiveCastableObjectSequence(result);

  uint32_t length = result.Length();
  JSObject *returnArray = JS_NewArrayObject(cx, length, NULL);
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    jsval tmp;
    for (uint32_t i = 0; i < length; ++i) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!WrapNewBindingObject(cx, returnArray, result[i], &tmp)) {
          MOZ_ASSERT(JS_IsExceptionPending(cx));
          return false;
        }
        break;
      } while (0);
      if (!JS_DefineElement(cx, returnArray, i, tmp,
                            nullptr, nullptr, JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  *vp = JS::ObjectValue(*returnArray);
  return true;
}


const JSJitInfo receiveCastableObjectSequence_methodinfo = {
  (JSJitPropertyOp)receiveCastableObjectSequence,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveCallbackObjectSequence(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{
  nsTArray< nsRefPtr<mozilla::dom::TestCallbackInterface> > result;
  self->ReceiveCallbackObjectSequence(result);

  uint32_t length = result.Length();
  JSObject *returnArray = JS_NewArrayObject(cx, length, NULL);
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    jsval tmp;
    for (uint32_t i = 0; i < length; ++i) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!WrapCallbackInterface(cx, returnArray, result[i], &tmp)) {
          return false;
        }
        break;
      } while (0);
      if (!JS_DefineElement(cx, returnArray, i, tmp,
                            nullptr, nullptr, JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  *vp = JS::ObjectValue(*returnArray);
  return true;
}


const JSJitInfo receiveCallbackObjectSequence_methodinfo = {
  (JSJitPropertyOp)receiveCallbackObjectSequence,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveNullableCastableObjectSequence(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{
  nsTArray< nsRefPtr<mozilla::dom::TestInterface> > result;
  self->ReceiveNullableCastableObjectSequence(result);

  uint32_t length = result.Length();
  JSObject *returnArray = JS_NewArrayObject(cx, length, NULL);
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    jsval tmp;
    for (uint32_t i = 0; i < length; ++i) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!result[i]) {
          tmp = JSVAL_NULL;
          break;
        }
        if (!WrapNewBindingObject(cx, returnArray, result[i], &tmp)) {
          MOZ_ASSERT(JS_IsExceptionPending(cx));
          return false;
        }
        break;
      } while (0);
      if (!JS_DefineElement(cx, returnArray, i, tmp,
                            nullptr, nullptr, JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  *vp = JS::ObjectValue(*returnArray);
  return true;
}


const JSJitInfo receiveNullableCastableObjectSequence_methodinfo = {
  (JSJitPropertyOp)receiveNullableCastableObjectSequence,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveNullableCallbackObjectSequence(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{
  nsTArray< nsRefPtr<mozilla::dom::TestCallbackInterface> > result;
  self->ReceiveNullableCallbackObjectSequence(result);

  uint32_t length = result.Length();
  JSObject *returnArray = JS_NewArrayObject(cx, length, NULL);
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    jsval tmp;
    for (uint32_t i = 0; i < length; ++i) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!result[i]) {
          tmp = JSVAL_NULL;
          break;
        }
        if (!WrapCallbackInterface(cx, returnArray, result[i], &tmp)) {
          return false;
        }
        break;
      } while (0);
      if (!JS_DefineElement(cx, returnArray, i, tmp,
                            nullptr, nullptr, JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  *vp = JS::ObjectValue(*returnArray);
  return true;
}


const JSJitInfo receiveNullableCallbackObjectSequence_methodinfo = {
  (JSJitPropertyOp)receiveNullableCallbackObjectSequence,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveCastableObjectNullableSequence(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{
  Nullable< nsTArray< nsRefPtr<mozilla::dom::TestInterface> > > result;
  self->ReceiveCastableObjectNullableSequence(result);

  if (result.IsNull()) {
    *vp = JSVAL_NULL;
    return true;
  }

  uint32_t length = result.Value().Length();
  JSObject *returnArray = JS_NewArrayObject(cx, length, NULL);
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    jsval tmp;
    for (uint32_t i = 0; i < length; ++i) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!WrapNewBindingObject(cx, returnArray, result.Value()[i], &tmp)) {
          MOZ_ASSERT(JS_IsExceptionPending(cx));
          return false;
        }
        break;
      } while (0);
      if (!JS_DefineElement(cx, returnArray, i, tmp,
                            nullptr, nullptr, JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  *vp = JS::ObjectValue(*returnArray);
  return true;
}


const JSJitInfo receiveCastableObjectNullableSequence_methodinfo = {
  (JSJitPropertyOp)receiveCastableObjectNullableSequence,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveNullableCastableObjectNullableSequence(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{
  Nullable< nsTArray< nsRefPtr<mozilla::dom::TestInterface> > > result;
  self->ReceiveNullableCastableObjectNullableSequence(result);

  if (result.IsNull()) {
    *vp = JSVAL_NULL;
    return true;
  }

  uint32_t length = result.Value().Length();
  JSObject *returnArray = JS_NewArrayObject(cx, length, NULL);
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    jsval tmp;
    for (uint32_t i = 0; i < length; ++i) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!result.Value()[i]) {
          tmp = JSVAL_NULL;
          break;
        }
        if (!WrapNewBindingObject(cx, returnArray, result.Value()[i], &tmp)) {
          MOZ_ASSERT(JS_IsExceptionPending(cx));
          return false;
        }
        break;
      } while (0);
      if (!JS_DefineElement(cx, returnArray, i, tmp,
                            nullptr, nullptr, JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  *vp = JS::ObjectValue(*returnArray);
  return true;
}


const JSJitInfo receiveNullableCastableObjectNullableSequence_methodinfo = {
  (JSJitPropertyOp)receiveNullableCastableObjectNullableSequence,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveWeakCastableObjectSequence(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{
  nsTArray< mozilla::dom::TestInterface* > result;
  self->ReceiveWeakCastableObjectSequence(result);

  uint32_t length = result.Length();
  JSObject *returnArray = JS_NewArrayObject(cx, length, NULL);
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    jsval tmp;
    for (uint32_t i = 0; i < length; ++i) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!WrapNewBindingObject(cx, returnArray, result[i], &tmp)) {
          MOZ_ASSERT(JS_IsExceptionPending(cx));
          return false;
        }
        break;
      } while (0);
      if (!JS_DefineElement(cx, returnArray, i, tmp,
                            nullptr, nullptr, JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  *vp = JS::ObjectValue(*returnArray);
  return true;
}


const JSJitInfo receiveWeakCastableObjectSequence_methodinfo = {
  (JSJitPropertyOp)receiveWeakCastableObjectSequence,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveWeakNullableCastableObjectSequence(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{
  nsTArray< mozilla::dom::TestInterface* > result;
  self->ReceiveWeakNullableCastableObjectSequence(result);

  uint32_t length = result.Length();
  JSObject *returnArray = JS_NewArrayObject(cx, length, NULL);
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    jsval tmp;
    for (uint32_t i = 0; i < length; ++i) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!result[i]) {
          tmp = JSVAL_NULL;
          break;
        }
        if (!WrapNewBindingObject(cx, returnArray, result[i], &tmp)) {
          MOZ_ASSERT(JS_IsExceptionPending(cx));
          return false;
        }
        break;
      } while (0);
      if (!JS_DefineElement(cx, returnArray, i, tmp,
                            nullptr, nullptr, JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  *vp = JS::ObjectValue(*returnArray);
  return true;
}


const JSJitInfo receiveWeakNullableCastableObjectSequence_methodinfo = {
  (JSJitPropertyOp)receiveWeakNullableCastableObjectSequence,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveWeakCastableObjectNullableSequence(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{
  Nullable< nsTArray< mozilla::dom::TestInterface* > > result;
  self->ReceiveWeakCastableObjectNullableSequence(result);

  if (result.IsNull()) {
    *vp = JSVAL_NULL;
    return true;
  }

  uint32_t length = result.Value().Length();
  JSObject *returnArray = JS_NewArrayObject(cx, length, NULL);
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    jsval tmp;
    for (uint32_t i = 0; i < length; ++i) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!WrapNewBindingObject(cx, returnArray, result.Value()[i], &tmp)) {
          MOZ_ASSERT(JS_IsExceptionPending(cx));
          return false;
        }
        break;
      } while (0);
      if (!JS_DefineElement(cx, returnArray, i, tmp,
                            nullptr, nullptr, JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  *vp = JS::ObjectValue(*returnArray);
  return true;
}


const JSJitInfo receiveWeakCastableObjectNullableSequence_methodinfo = {
  (JSJitPropertyOp)receiveWeakCastableObjectNullableSequence,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveWeakNullableCastableObjectNullableSequence(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{
  Nullable< nsTArray< mozilla::dom::TestInterface* > > result;
  self->ReceiveWeakNullableCastableObjectNullableSequence(result);

  if (result.IsNull()) {
    *vp = JSVAL_NULL;
    return true;
  }

  uint32_t length = result.Value().Length();
  JSObject *returnArray = JS_NewArrayObject(cx, length, NULL);
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    jsval tmp;
    for (uint32_t i = 0; i < length; ++i) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!result.Value()[i]) {
          tmp = JSVAL_NULL;
          break;
        }
        if (!WrapNewBindingObject(cx, returnArray, result.Value()[i], &tmp)) {
          MOZ_ASSERT(JS_IsExceptionPending(cx));
          return false;
        }
        break;
      } while (0);
      if (!JS_DefineElement(cx, returnArray, i, tmp,
                            nullptr, nullptr, JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  *vp = JS::ObjectValue(*returnArray);
  return true;
}


const JSJitInfo receiveWeakNullableCastableObjectNullableSequence_methodinfo = {
  (JSJitPropertyOp)receiveWeakNullableCastableObjectNullableSequence,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
passCastableObjectSequence(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.passCastableObjectSequence");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  const Sequence< OwningNonNull<mozilla::dom::TestInterface> > arg0;
  if (argv[0].isObject()) {
    JSObject* seq = &argv[0].toObject();

    if (!IsArrayLike(cx, seq)) {
      ThrowErrorMessage(cx, MSG_NOT_SEQUENCE);
      return false;
    }
    uint32_t length;
    // JS_GetArrayLength actually works on all objects
    if (!JS_GetArrayLength(cx, seq, &length)) {
      return false;
    }
    Sequence< OwningNonNull<mozilla::dom::TestInterface> > &arr = const_cast< Sequence< OwningNonNull<mozilla::dom::TestInterface> >& >(arg0);
    if (!arr.SetCapacity(length)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t i = 0; i < length; ++i) {
      jsval temp;
      if (!JS_GetElement(cx, seq, i, &temp)) {
        return false;
      }
      OwningNonNull<mozilla::dom::TestInterface>& slot = *arr.AppendElement();
      if (temp.isObject()) {
        {
          nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(cx, &temp.toObject(), slot);
          if (NS_FAILED(rv)) {
            ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestInterface");
            return false;
          }
        }
      } else {
        ThrowErrorMessage(cx, MSG_NOT_OBJECT);
        return false;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassCastableObjectSequence(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passCastableObjectSequence_methodinfo = {
  (JSJitPropertyOp)passCastableObjectSequence,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passNullableCastableObjectSequence(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.passNullableCastableObjectSequence");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  const Sequence< nsRefPtr<mozilla::dom::TestInterface> > arg0;
  if (argv[0].isObject()) {
    JSObject* seq = &argv[0].toObject();

    if (!IsArrayLike(cx, seq)) {
      ThrowErrorMessage(cx, MSG_NOT_SEQUENCE);
      return false;
    }
    uint32_t length;
    // JS_GetArrayLength actually works on all objects
    if (!JS_GetArrayLength(cx, seq, &length)) {
      return false;
    }
    Sequence< nsRefPtr<mozilla::dom::TestInterface> > &arr = const_cast< Sequence< nsRefPtr<mozilla::dom::TestInterface> >& >(arg0);
    if (!arr.SetCapacity(length)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t i = 0; i < length; ++i) {
      jsval temp;
      if (!JS_GetElement(cx, seq, i, &temp)) {
        return false;
      }
      nsRefPtr<mozilla::dom::TestInterface>& slot = *arr.AppendElement();
      if (temp.isObject()) {
        {
          nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(cx, &temp.toObject(), slot);
          if (NS_FAILED(rv)) {
            ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestInterface");
            return false;
          }
        }
      } else if (temp.isNullOrUndefined()) {
        slot = NULL;
      } else {
        ThrowErrorMessage(cx, MSG_NOT_OBJECT);
        return false;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassNullableCastableObjectSequence(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passNullableCastableObjectSequence_methodinfo = {
  (JSJitPropertyOp)passNullableCastableObjectSequence,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passCastableObjectNullableSequence(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.passCastableObjectNullableSequence");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  const Nullable< Sequence< OwningNonNull<mozilla::dom::TestInterface> > > arg0;
  if (argv[0].isObject()) {
    JSObject* seq = &argv[0].toObject();

    if (!IsArrayLike(cx, seq)) {
      ThrowErrorMessage(cx, MSG_NOT_SEQUENCE);
      return false;
    }
    uint32_t length;
    // JS_GetArrayLength actually works on all objects
    if (!JS_GetArrayLength(cx, seq, &length)) {
      return false;
    }
    Sequence< OwningNonNull<mozilla::dom::TestInterface> > &arr = const_cast< Sequence< OwningNonNull<mozilla::dom::TestInterface> >& >(arg0.Value());
    if (!arr.SetCapacity(length)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t i = 0; i < length; ++i) {
      jsval temp;
      if (!JS_GetElement(cx, seq, i, &temp)) {
        return false;
      }
      OwningNonNull<mozilla::dom::TestInterface>& slot = *arr.AppendElement();
      if (temp.isObject()) {
        {
          nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(cx, &temp.toObject(), slot);
          if (NS_FAILED(rv)) {
            ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestInterface");
            return false;
          }
        }
      } else {
        ThrowErrorMessage(cx, MSG_NOT_OBJECT);
        return false;
      }
    }
  } else if (argv[0].isNullOrUndefined()) {
    const_cast< Nullable< Sequence< OwningNonNull<mozilla::dom::TestInterface> > > & >(arg0).SetNull();
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassCastableObjectNullableSequence(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passCastableObjectNullableSequence_methodinfo = {
  (JSJitPropertyOp)passCastableObjectNullableSequence,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passNullableCastableObjectNullableSequence(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.passNullableCastableObjectNullableSequence");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  const Nullable< Sequence< nsRefPtr<mozilla::dom::TestInterface> > > arg0;
  if (argv[0].isObject()) {
    JSObject* seq = &argv[0].toObject();

    if (!IsArrayLike(cx, seq)) {
      ThrowErrorMessage(cx, MSG_NOT_SEQUENCE);
      return false;
    }
    uint32_t length;
    // JS_GetArrayLength actually works on all objects
    if (!JS_GetArrayLength(cx, seq, &length)) {
      return false;
    }
    Sequence< nsRefPtr<mozilla::dom::TestInterface> > &arr = const_cast< Sequence< nsRefPtr<mozilla::dom::TestInterface> >& >(arg0.Value());
    if (!arr.SetCapacity(length)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t i = 0; i < length; ++i) {
      jsval temp;
      if (!JS_GetElement(cx, seq, i, &temp)) {
        return false;
      }
      nsRefPtr<mozilla::dom::TestInterface>& slot = *arr.AppendElement();
      if (temp.isObject()) {
        {
          nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(cx, &temp.toObject(), slot);
          if (NS_FAILED(rv)) {
            ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestInterface");
            return false;
          }
        }
      } else if (temp.isNullOrUndefined()) {
        slot = NULL;
      } else {
        ThrowErrorMessage(cx, MSG_NOT_OBJECT);
        return false;
      }
    }
  } else if (argv[0].isNullOrUndefined()) {
    const_cast< Nullable< Sequence< nsRefPtr<mozilla::dom::TestInterface> > > & >(arg0).SetNull();
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassNullableCastableObjectNullableSequence(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passNullableCastableObjectNullableSequence_methodinfo = {
  (JSJitPropertyOp)passNullableCastableObjectNullableSequence,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalSequence(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  const Optional< Sequence< int32_t > > arg0;
  if (0 < argc) {
    const_cast< Optional< Sequence< int32_t > > &>(arg0).Construct();
    if (argv[0].isObject()) {
      JSObject* seq = &argv[0].toObject();

      if (!IsArrayLike(cx, seq)) {
        ThrowErrorMessage(cx, MSG_NOT_SEQUENCE);
        return false;
      }
      uint32_t length;
      // JS_GetArrayLength actually works on all objects
      if (!JS_GetArrayLength(cx, seq, &length)) {
        return false;
      }
      Sequence< int32_t > &arr = const_cast< Sequence< int32_t >& >(const_cast< Sequence< int32_t > & >(arg0.Value()));
      if (!arr.SetCapacity(length)) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      for (uint32_t i = 0; i < length; ++i) {
        jsval temp;
        if (!JS_GetElement(cx, seq, i, &temp)) {
          return false;
        }
        int32_t& slot = *arr.AppendElement();
        if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, &slot)) {
          return false;
        }
      }
    } else {
      ThrowErrorMessage(cx, MSG_NOT_OBJECT);
      return false;
    }
  }
  self->PassOptionalSequence(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalSequence_methodinfo = {
  (JSJitPropertyOp)passOptionalSequence,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalNullableSequence(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  const Optional< Nullable< Sequence< int32_t > > > arg0;
  if (0 < argc) {
    const_cast< Optional< Nullable< Sequence< int32_t > > > &>(arg0).Construct();
    if (argv[0].isObject()) {
      JSObject* seq = &argv[0].toObject();

      if (!IsArrayLike(cx, seq)) {
        ThrowErrorMessage(cx, MSG_NOT_SEQUENCE);
        return false;
      }
      uint32_t length;
      // JS_GetArrayLength actually works on all objects
      if (!JS_GetArrayLength(cx, seq, &length)) {
        return false;
      }
      Sequence< int32_t > &arr = const_cast< Sequence< int32_t >& >(const_cast< Nullable< Sequence< int32_t > > & >(arg0.Value()).Value());
      if (!arr.SetCapacity(length)) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      for (uint32_t i = 0; i < length; ++i) {
        jsval temp;
        if (!JS_GetElement(cx, seq, i, &temp)) {
          return false;
        }
        int32_t& slot = *arr.AppendElement();
        if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, &slot)) {
          return false;
        }
      }
    } else if (argv[0].isNullOrUndefined()) {
      const_cast< Nullable< Sequence< int32_t > > & >(const_cast< Nullable< Sequence< int32_t > > & >(arg0.Value())).SetNull();
    } else {
      ThrowErrorMessage(cx, MSG_NOT_OBJECT);
      return false;
    }
  }
  self->PassOptionalNullableSequence(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalNullableSequence_methodinfo = {
  (JSJitPropertyOp)passOptionalNullableSequence,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalNullableSequenceWithDefaultValue(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  const Nullable< Sequence< int32_t > > arg0;
  if (0 < argc) {
    if (argv[0].isObject()) {
      JSObject* seq = &argv[0].toObject();

      if (!IsArrayLike(cx, seq)) {
        ThrowErrorMessage(cx, MSG_NOT_SEQUENCE);
        return false;
      }
      uint32_t length;
      // JS_GetArrayLength actually works on all objects
      if (!JS_GetArrayLength(cx, seq, &length)) {
        return false;
      }
      Sequence< int32_t > &arr = const_cast< Sequence< int32_t >& >(arg0.Value());
      if (!arr.SetCapacity(length)) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      for (uint32_t i = 0; i < length; ++i) {
        jsval temp;
        if (!JS_GetElement(cx, seq, i, &temp)) {
          return false;
        }
        int32_t& slot = *arr.AppendElement();
        if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, &slot)) {
          return false;
        }
      }
    } else if (argv[0].isNullOrUndefined()) {
      const_cast< Nullable< Sequence< int32_t > > & >(arg0).SetNull();
    } else {
      ThrowErrorMessage(cx, MSG_NOT_OBJECT);
      return false;
    }
  } else {
    const_cast< Nullable< Sequence< int32_t > > & >(arg0).SetNull();
  }
  self->PassOptionalNullableSequenceWithDefaultValue(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalNullableSequenceWithDefaultValue_methodinfo = {
  (JSJitPropertyOp)passOptionalNullableSequenceWithDefaultValue,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalObjectSequence(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  const Optional< Sequence< OwningNonNull<mozilla::dom::TestInterface> > > arg0;
  if (0 < argc) {
    const_cast< Optional< Sequence< OwningNonNull<mozilla::dom::TestInterface> > > &>(arg0).Construct();
    if (argv[0].isObject()) {
      JSObject* seq = &argv[0].toObject();

      if (!IsArrayLike(cx, seq)) {
        ThrowErrorMessage(cx, MSG_NOT_SEQUENCE);
        return false;
      }
      uint32_t length;
      // JS_GetArrayLength actually works on all objects
      if (!JS_GetArrayLength(cx, seq, &length)) {
        return false;
      }
      Sequence< OwningNonNull<mozilla::dom::TestInterface> > &arr = const_cast< Sequence< OwningNonNull<mozilla::dom::TestInterface> >& >(const_cast< Sequence< OwningNonNull<mozilla::dom::TestInterface> > & >(arg0.Value()));
      if (!arr.SetCapacity(length)) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      for (uint32_t i = 0; i < length; ++i) {
        jsval temp;
        if (!JS_GetElement(cx, seq, i, &temp)) {
          return false;
        }
        OwningNonNull<mozilla::dom::TestInterface>& slot = *arr.AppendElement();
        if (temp.isObject()) {
          {
            nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(cx, &temp.toObject(), slot);
            if (NS_FAILED(rv)) {
              ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestInterface");
              return false;
            }
          }
        } else {
          ThrowErrorMessage(cx, MSG_NOT_OBJECT);
          return false;
        }
      }
    } else {
      ThrowErrorMessage(cx, MSG_NOT_OBJECT);
      return false;
    }
  }
  self->PassOptionalObjectSequence(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalObjectSequence_methodinfo = {
  (JSJitPropertyOp)passOptionalObjectSequence,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passExternalInterfaceSequence(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.passExternalInterfaceSequence");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  const Sequence< nsRefPtr<mozilla::dom::TestExternalInterface> > arg0;
  if (argv[0].isObject()) {
    JSObject* seq = &argv[0].toObject();

    if (!IsArrayLike(cx, seq)) {
      ThrowErrorMessage(cx, MSG_NOT_SEQUENCE);
      return false;
    }
    uint32_t length;
    // JS_GetArrayLength actually works on all objects
    if (!JS_GetArrayLength(cx, seq, &length)) {
      return false;
    }
    Sequence< nsRefPtr<mozilla::dom::TestExternalInterface> > &arr = const_cast< Sequence< nsRefPtr<mozilla::dom::TestExternalInterface> >& >(arg0);
    if (!arr.SetCapacity(length)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t i = 0; i < length; ++i) {
      jsval temp;
      if (!JS_GetElement(cx, seq, i, &temp)) {
        return false;
      }
      nsRefPtr<mozilla::dom::TestExternalInterface>& slot = *arr.AppendElement();
      if (temp.isObject()) {
        nsRefPtr<mozilla::dom::TestExternalInterface> tempHolder;
        jsval tmpVal = temp;
        mozilla::dom::TestExternalInterface* tmp;
        if (NS_FAILED(xpc_qsUnwrapArg<mozilla::dom::TestExternalInterface>(cx, temp, &tmp, static_cast<mozilla::dom::TestExternalInterface**>(getter_AddRefs(tempHolder)), &tmpVal))) {
          ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestExternalInterface");return false;
        }
        MOZ_ASSERT(tmp);
        slot = tmp;
      } else {
        ThrowErrorMessage(cx, MSG_NOT_OBJECT);
        return false;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassExternalInterfaceSequence(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passExternalInterfaceSequence_methodinfo = {
  (JSJitPropertyOp)passExternalInterfaceSequence,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passNullableExternalInterfaceSequence(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.passNullableExternalInterfaceSequence");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  const Sequence< nsRefPtr<mozilla::dom::TestExternalInterface> > arg0;
  if (argv[0].isObject()) {
    JSObject* seq = &argv[0].toObject();

    if (!IsArrayLike(cx, seq)) {
      ThrowErrorMessage(cx, MSG_NOT_SEQUENCE);
      return false;
    }
    uint32_t length;
    // JS_GetArrayLength actually works on all objects
    if (!JS_GetArrayLength(cx, seq, &length)) {
      return false;
    }
    Sequence< nsRefPtr<mozilla::dom::TestExternalInterface> > &arr = const_cast< Sequence< nsRefPtr<mozilla::dom::TestExternalInterface> >& >(arg0);
    if (!arr.SetCapacity(length)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t i = 0; i < length; ++i) {
      jsval temp;
      if (!JS_GetElement(cx, seq, i, &temp)) {
        return false;
      }
      nsRefPtr<mozilla::dom::TestExternalInterface>& slot = *arr.AppendElement();
      if (temp.isObject()) {
        nsRefPtr<mozilla::dom::TestExternalInterface> tempHolder;
        jsval tmpVal = temp;
        mozilla::dom::TestExternalInterface* tmp;
        if (NS_FAILED(xpc_qsUnwrapArg<mozilla::dom::TestExternalInterface>(cx, temp, &tmp, static_cast<mozilla::dom::TestExternalInterface**>(getter_AddRefs(tempHolder)), &tmpVal))) {
          ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestExternalInterface");return false;
        }
        MOZ_ASSERT(tmp);
        slot = tmp;
      } else if (temp.isNullOrUndefined()) {
        slot = NULL;
      } else {
        ThrowErrorMessage(cx, MSG_NOT_OBJECT);
        return false;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassNullableExternalInterfaceSequence(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passNullableExternalInterfaceSequence_methodinfo = {
  (JSJitPropertyOp)passNullableExternalInterfaceSequence,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveStringSequence(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{
  nsTArray< nsString > result;
  self->ReceiveStringSequence(result);

  uint32_t length = result.Length();
  JSObject *returnArray = JS_NewArrayObject(cx, length, NULL);
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    jsval tmp;
    for (uint32_t i = 0; i < length; ++i) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!xpc::NonVoidStringToJsval(cx, result[i], &tmp)) {
          return false;
        }
        break;
      } while (0);
      if (!JS_DefineElement(cx, returnArray, i, tmp,
                            nullptr, nullptr, JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  *vp = JS::ObjectValue(*returnArray);
  return true;
}


const JSJitInfo receiveStringSequence_methodinfo = {
  (JSJitPropertyOp)receiveStringSequence,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
passStringSequence(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.passStringSequence");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  const Sequence< nsString > arg0;
  if (argv[0].isObject()) {
    JSObject* seq = &argv[0].toObject();

    if (!IsArrayLike(cx, seq)) {
      ThrowErrorMessage(cx, MSG_NOT_SEQUENCE);
      return false;
    }
    uint32_t length;
    // JS_GetArrayLength actually works on all objects
    if (!JS_GetArrayLength(cx, seq, &length)) {
      return false;
    }
    Sequence< nsString > &arr = const_cast< Sequence< nsString >& >(arg0);
    if (!arr.SetCapacity(length)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t i = 0; i < length; ++i) {
      jsval temp;
      if (!JS_GetElement(cx, seq, i, &temp)) {
        return false;
      }
      nsString& slot = *arr.AppendElement();
      {
        FakeDependentString str;
        if (!ConvertJSValueToString(cx, temp, &temp, eStringify, eStringify, str)) {
          return false;
        }
        slot = str;
      }

    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassStringSequence(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passStringSequence_methodinfo = {
  (JSJitPropertyOp)passStringSequence,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveAnySequence(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{
  nsTArray< JS::Value > result;
  self->ReceiveAnySequence(cx, result);

  uint32_t length = result.Length();
  JSObject *returnArray = JS_NewArrayObject(cx, length, NULL);
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    jsval tmp;
    for (uint32_t i = 0; i < length; ++i) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        tmp = result[i];
        if (!MaybeWrapValue(cx, &tmp)) {
          return false;
        }
        break;
      } while (0);
      if (!JS_DefineElement(cx, returnArray, i, tmp,
                            nullptr, nullptr, JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  *vp = JS::ObjectValue(*returnArray);
  return true;
}


const JSJitInfo receiveAnySequence_methodinfo = {
  (JSJitPropertyOp)receiveAnySequence,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveNullableAnySequence(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{
  Nullable< nsTArray< JS::Value > > result;
  self->ReceiveNullableAnySequence(cx, result);

  if (result.IsNull()) {
    *vp = JSVAL_NULL;
    return true;
  }

  uint32_t length = result.Value().Length();
  JSObject *returnArray = JS_NewArrayObject(cx, length, NULL);
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    jsval tmp;
    for (uint32_t i = 0; i < length; ++i) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        tmp = result.Value()[i];
        if (!MaybeWrapValue(cx, &tmp)) {
          return false;
        }
        break;
      } while (0);
      if (!JS_DefineElement(cx, returnArray, i, tmp,
                            nullptr, nullptr, JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  *vp = JS::ObjectValue(*returnArray);
  return true;
}


const JSJitInfo receiveNullableAnySequence_methodinfo = {
  (JSJitPropertyOp)receiveNullableAnySequence,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
passArrayBuffer(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.passArrayBuffer");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  Maybe<ArrayBuffer> arg0_holder;
  NonNull<ArrayBuffer> arg0;
  if (argv[0].isObject()) {
    arg0_holder.construct(&argv[0].toObject());
    if (!arg0_holder.ref().inited()) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "ArrayBuffer");return false;
    }
    arg0 = arg0_holder.addr();
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassArrayBuffer(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passArrayBuffer_methodinfo = {
  (JSJitPropertyOp)passArrayBuffer,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passNullableArrayBuffer(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.passNullableArrayBuffer");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  Maybe<ArrayBuffer> arg0_holder;
  ArrayBuffer* arg0;
  if (argv[0].isObject()) {
    arg0_holder.construct(&argv[0].toObject());
    if (!arg0_holder.ref().inited()) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "ArrayBuffer");return false;
    }
    arg0 = arg0_holder.addr();
  } else if (argv[0].isNullOrUndefined()) {
    arg0 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassNullableArrayBuffer(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passNullableArrayBuffer_methodinfo = {
  (JSJitPropertyOp)passNullableArrayBuffer,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalArrayBuffer(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  const Optional<ArrayBuffer> arg0;
  if (0 < argc) {
    if (argv[0].isObject()) {
      (const_cast<Optional<ArrayBuffer>& >(arg0)).Construct(&argv[0].toObject());
      if (!(const_cast<Optional<ArrayBuffer>& >(arg0)).Value().inited()) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "ArrayBuffer");return false;
      }

    } else {
      ThrowErrorMessage(cx, MSG_NOT_OBJECT);
      return false;
    }
  }
  self->PassOptionalArrayBuffer(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalArrayBuffer_methodinfo = {
  (JSJitPropertyOp)passOptionalArrayBuffer,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalNullableArrayBuffer(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  Maybe<ArrayBuffer> arg0_holder;
  const Optional<ArrayBuffer*> arg0;
  if (0 < argc) {
    if (argv[0].isObject()) {
      arg0_holder.construct(&argv[0].toObject());
      if (!arg0_holder.ref().inited()) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "ArrayBuffer");return false;
      }
      (const_cast<Optional<ArrayBuffer*>& >(arg0)).Construct();
      (const_cast<Optional<ArrayBuffer*>& >(arg0)).Value() = arg0_holder.addr();
    } else if (argv[0].isNullOrUndefined()) {
      (const_cast<Optional<ArrayBuffer*>& >(arg0)).Value() = NULL;
    } else {
      ThrowErrorMessage(cx, MSG_NOT_OBJECT);
      return false;
    }
  }
  self->PassOptionalNullableArrayBuffer(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalNullableArrayBuffer_methodinfo = {
  (JSJitPropertyOp)passOptionalNullableArrayBuffer,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalNullableArrayBufferWithDefaultValue(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  Maybe<ArrayBuffer> arg0_holder;
  ArrayBuffer* arg0;
  if (0 < argc) {
    if (argv[0].isObject()) {
      arg0_holder.construct(&argv[0].toObject());
      if (!arg0_holder.ref().inited()) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "ArrayBuffer");return false;
      }
      arg0 = arg0_holder.addr();
    } else if (argv[0].isNullOrUndefined()) {
      arg0 = NULL;
    } else {
      ThrowErrorMessage(cx, MSG_NOT_OBJECT);
      return false;
    }
  } else {
    arg0 = NULL;
  }
  self->PassOptionalNullableArrayBufferWithDefaultValue(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalNullableArrayBufferWithDefaultValue_methodinfo = {
  (JSJitPropertyOp)passOptionalNullableArrayBufferWithDefaultValue,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passArrayBufferView(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.passArrayBufferView");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  Maybe<ArrayBufferView> arg0_holder;
  NonNull<ArrayBufferView> arg0;
  if (argv[0].isObject()) {
    arg0_holder.construct(&argv[0].toObject());
    if (!arg0_holder.ref().inited()) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "ArrayBufferView");return false;
    }
    arg0 = arg0_holder.addr();
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassArrayBufferView(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passArrayBufferView_methodinfo = {
  (JSJitPropertyOp)passArrayBufferView,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passInt8Array(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.passInt8Array");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  Maybe<Int8Array> arg0_holder;
  NonNull<Int8Array> arg0;
  if (argv[0].isObject()) {
    arg0_holder.construct(&argv[0].toObject());
    if (!arg0_holder.ref().inited()) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "Int8Array");return false;
    }
    arg0 = arg0_holder.addr();
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassInt8Array(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passInt8Array_methodinfo = {
  (JSJitPropertyOp)passInt8Array,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passInt16Array(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.passInt16Array");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  Maybe<Int16Array> arg0_holder;
  NonNull<Int16Array> arg0;
  if (argv[0].isObject()) {
    arg0_holder.construct(&argv[0].toObject());
    if (!arg0_holder.ref().inited()) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "Int16Array");return false;
    }
    arg0 = arg0_holder.addr();
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassInt16Array(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passInt16Array_methodinfo = {
  (JSJitPropertyOp)passInt16Array,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passInt32Array(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.passInt32Array");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  Maybe<Int32Array> arg0_holder;
  NonNull<Int32Array> arg0;
  if (argv[0].isObject()) {
    arg0_holder.construct(&argv[0].toObject());
    if (!arg0_holder.ref().inited()) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "Int32Array");return false;
    }
    arg0 = arg0_holder.addr();
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassInt32Array(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passInt32Array_methodinfo = {
  (JSJitPropertyOp)passInt32Array,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passUint8Array(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.passUint8Array");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  Maybe<Uint8Array> arg0_holder;
  NonNull<Uint8Array> arg0;
  if (argv[0].isObject()) {
    arg0_holder.construct(&argv[0].toObject());
    if (!arg0_holder.ref().inited()) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "Uint8Array");return false;
    }
    arg0 = arg0_holder.addr();
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassUint8Array(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passUint8Array_methodinfo = {
  (JSJitPropertyOp)passUint8Array,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passUint16Array(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.passUint16Array");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  Maybe<Uint16Array> arg0_holder;
  NonNull<Uint16Array> arg0;
  if (argv[0].isObject()) {
    arg0_holder.construct(&argv[0].toObject());
    if (!arg0_holder.ref().inited()) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "Uint16Array");return false;
    }
    arg0 = arg0_holder.addr();
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassUint16Array(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passUint16Array_methodinfo = {
  (JSJitPropertyOp)passUint16Array,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passUint32Array(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.passUint32Array");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  Maybe<Uint32Array> arg0_holder;
  NonNull<Uint32Array> arg0;
  if (argv[0].isObject()) {
    arg0_holder.construct(&argv[0].toObject());
    if (!arg0_holder.ref().inited()) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "Uint32Array");return false;
    }
    arg0 = arg0_holder.addr();
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassUint32Array(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passUint32Array_methodinfo = {
  (JSJitPropertyOp)passUint32Array,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passUint8ClampedArray(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.passUint8ClampedArray");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  Maybe<Uint8ClampedArray> arg0_holder;
  NonNull<Uint8ClampedArray> arg0;
  if (argv[0].isObject()) {
    arg0_holder.construct(&argv[0].toObject());
    if (!arg0_holder.ref().inited()) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "Uint8ClampedArray");return false;
    }
    arg0 = arg0_holder.addr();
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassUint8ClampedArray(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passUint8ClampedArray_methodinfo = {
  (JSJitPropertyOp)passUint8ClampedArray,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passFloat32Array(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.passFloat32Array");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  Maybe<Float32Array> arg0_holder;
  NonNull<Float32Array> arg0;
  if (argv[0].isObject()) {
    arg0_holder.construct(&argv[0].toObject());
    if (!arg0_holder.ref().inited()) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "Float32Array");return false;
    }
    arg0 = arg0_holder.addr();
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassFloat32Array(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passFloat32Array_methodinfo = {
  (JSJitPropertyOp)passFloat32Array,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passFloat64Array(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.passFloat64Array");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  Maybe<Float64Array> arg0_holder;
  NonNull<Float64Array> arg0;
  if (argv[0].isObject()) {
    arg0_holder.construct(&argv[0].toObject());
    if (!arg0_holder.ref().inited()) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "Float64Array");return false;
    }
    arg0 = arg0_holder.addr();
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassFloat64Array(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passFloat64Array_methodinfo = {
  (JSJitPropertyOp)passFloat64Array,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveUint8Array(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{
  JSObject* result;
  result = self->ReceiveUint8Array(cx);
  *vp = JS::ObjectValue(*result);
  if (!MaybeWrapValue(cx, vp)) {
    return false;
  }
  return true;
}


const JSJitInfo receiveUint8Array_methodinfo = {
  (JSJitPropertyOp)receiveUint8Array,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
passString(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.passString");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eStringify, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  self->PassString(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passString_methodinfo = {
  (JSJitPropertyOp)passString,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passNullableString(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.passNullableString");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eNull, eNull, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  self->PassNullableString(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passNullableString_methodinfo = {
  (JSJitPropertyOp)passNullableString,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalString(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  FakeDependentString arg0_holder;
  const Optional<nsAString> arg0;
  if (0 < argc) {
    if (!ConvertJSValueToString(cx, argv[0], &argv[0], eStringify, eStringify, arg0_holder)) {
      return false;
    }
    const_cast<Optional<nsAString>&>(arg0) = &arg0_holder;
  }
  self->PassOptionalString(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalString_methodinfo = {
  (JSJitPropertyOp)passOptionalString,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalStringWithDefaultValue(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (0 < argc) {
    if (!ConvertJSValueToString(cx, argv[0], &argv[0], eStringify, eStringify, arg0_holder)) {
      return false;
    }
  } else {
    static const PRUnichar data[] = { 'a', 'b', 'c', 0 };
    arg0_holder.SetData(data, ArrayLength(data) - 1);
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  self->PassOptionalStringWithDefaultValue(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalStringWithDefaultValue_methodinfo = {
  (JSJitPropertyOp)passOptionalStringWithDefaultValue,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalNullableString(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  FakeDependentString arg0_holder;
  const Optional<nsAString> arg0;
  if (0 < argc) {
    if (!ConvertJSValueToString(cx, argv[0], &argv[0], eNull, eNull, arg0_holder)) {
      return false;
    }
    const_cast<Optional<nsAString>&>(arg0) = &arg0_holder;
  }
  self->PassOptionalNullableString(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalNullableString_methodinfo = {
  (JSJitPropertyOp)passOptionalNullableString,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalNullableStringWithDefaultValue(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (0 < argc) {
    if (!ConvertJSValueToString(cx, argv[0], &argv[0], eNull, eNull, arg0_holder)) {
      return false;
    }
  } else {
    arg0_holder.SetNull();
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  self->PassOptionalNullableStringWithDefaultValue(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalNullableStringWithDefaultValue_methodinfo = {
  (JSJitPropertyOp)passOptionalNullableStringWithDefaultValue,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passVariadicString(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  const Sequence< nsString > arg0;
  if (argc > 0) {
    Sequence< nsString >& arr = const_cast< Sequence< nsString >& >(arg0);
    if (!arr.SetCapacity(argc - 0)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t variadicArg = 0; variadicArg < argc; ++variadicArg) {
      nsString& slot = *arr.AppendElement();
      {
        FakeDependentString str;
        if (!ConvertJSValueToString(cx, argv[variadicArg], &argv[variadicArg], eStringify, eStringify, str)) {
          return false;
        }
        slot = str;
      }

    }
  }
  self->PassVariadicString(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passVariadicString_methodinfo = {
  (JSJitPropertyOp)passVariadicString,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passEnum(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.passEnum");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  TestEnum arg0;
  {
    bool ok;
    int index = FindEnumStringIndex<true>(cx, argv[0], TestEnumValues::strings, "TestEnum", &ok);
    if (!ok) {
      return false;
    }
    MOZ_ASSERT(index >= 0);
    arg0 = static_cast<TestEnum>(index);
  }
  self->PassEnum(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passEnum_methodinfo = {
  (JSJitPropertyOp)passEnum,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalEnum(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  const Optional< TestEnum > arg0;
  if (0 < argc) {
    const_cast< Optional< TestEnum > &>(arg0).Construct();
    {
      bool ok;
      int index = FindEnumStringIndex<true>(cx, argv[0], TestEnumValues::strings, "TestEnum", &ok);
      if (!ok) {
        return false;
      }
      MOZ_ASSERT(index >= 0);
      const_cast< TestEnum & >(arg0.Value()) = static_cast<TestEnum>(index);
    }
  }
  self->PassOptionalEnum(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalEnum_methodinfo = {
  (JSJitPropertyOp)passOptionalEnum,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passEnumWithDefault(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  TestEnum arg0;
  if (0 < argc) {
    {
      bool ok;
      int index = FindEnumStringIndex<true>(cx, argv[0], TestEnumValues::strings, "TestEnum", &ok);
      if (!ok) {
        return false;
      }
      MOZ_ASSERT(index >= 0);
      arg0 = static_cast<TestEnum>(index);
    }
  } else {
    arg0 = TestEnumValues::A;
  }
  self->PassEnumWithDefault(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passEnumWithDefault_methodinfo = {
  (JSJitPropertyOp)passEnumWithDefault,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveEnum(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{
  TestEnum result;
  result = self->ReceiveEnum();
  MOZ_ASSERT(uint32_t(result) < ArrayLength(TestEnumValues::strings));
  JSString* result_str = JS_NewStringCopyN(cx, TestEnumValues::strings[uint32_t(result)].value, TestEnumValues::strings[uint32_t(result)].length);
  if (!result_str) {
  return false;
  }
  *vp = JS::StringValue(result_str);
  return true;
}


const JSJitInfo receiveEnum_methodinfo = {
  (JSJitPropertyOp)receiveEnum,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_enumAttribute(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* vp)
{
  TestEnum result;
  result = self->EnumAttribute();
  MOZ_ASSERT(uint32_t(result) < ArrayLength(TestEnumValues::strings));
  JSString* result_str = JS_NewStringCopyN(cx, TestEnumValues::strings[uint32_t(result)].value, TestEnumValues::strings[uint32_t(result)].length);
  if (!result_str) {
  return false;
  }
  *vp = JS::StringValue(result_str);
  return true;
}

static bool
set_enumAttribute(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* argv)
{
  TestEnum arg0;
  {
    bool ok;
    int index = FindEnumStringIndex<false>(cx, argv[0], TestEnumValues::strings, "TestEnum", &ok);
    if (!ok) {
      return false;
    }
    if (index < 0) {
      return true;
    }
    arg0 = static_cast<TestEnum>(index);
  }
  self->SetEnumAttribute(arg0);

  return true;
}


const JSJitInfo enumAttribute_getterinfo = {
  (JSJitPropertyOp)get_enumAttribute,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo enumAttribute_setterinfo = {
  (JSJitPropertyOp)set_enumAttribute,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_readonlyEnumAttribute(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* vp)
{
  TestEnum result;
  result = self->ReadonlyEnumAttribute();
  MOZ_ASSERT(uint32_t(result) < ArrayLength(TestEnumValues::strings));
  JSString* result_str = JS_NewStringCopyN(cx, TestEnumValues::strings[uint32_t(result)].value, TestEnumValues::strings[uint32_t(result)].length);
  if (!result_str) {
  return false;
  }
  *vp = JS::StringValue(result_str);
  return true;
}


const JSJitInfo readonlyEnumAttribute_getterinfo = {
  (JSJitPropertyOp)get_readonlyEnumAttribute,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

static bool
passCallback(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.passCallback");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  OwningNonNull<TestCallback> arg0;
  if (argv[0].isObject()) {
    if (JS_ObjectIsCallable(cx, &argv[0].toObject())) {
      bool inited;
      arg0 = new TestCallback(cx, obj, &argv[0].toObject(), &inited);
      if (!inited) {
        return false;
      }
    } else {
      ThrowErrorMessage(cx, MSG_NOT_CALLABLE);
      return false;
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassCallback(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passCallback_methodinfo = {
  (JSJitPropertyOp)passCallback,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passNullableCallback(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.passNullableCallback");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  nsRefPtr<TestCallback> arg0;
  if (argv[0].isObject()) {
    if (JS_ObjectIsCallable(cx, &argv[0].toObject())) {
      bool inited;
      arg0 = new TestCallback(cx, obj, &argv[0].toObject(), &inited);
      if (!inited) {
        return false;
      }
    } else {
      ThrowErrorMessage(cx, MSG_NOT_CALLABLE);
      return false;
    }
  } else if (argv[0].isNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassNullableCallback(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passNullableCallback_methodinfo = {
  (JSJitPropertyOp)passNullableCallback,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalCallback(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  const Optional< OwningNonNull<TestCallback> > arg0;
  if (0 < argc) {
    const_cast< Optional< OwningNonNull<TestCallback> > &>(arg0).Construct();
    if (argv[0].isObject()) {
      if (JS_ObjectIsCallable(cx, &argv[0].toObject())) {
        bool inited;
        const_cast< OwningNonNull<TestCallback> & >(arg0.Value()) = new TestCallback(cx, obj, &argv[0].toObject(), &inited);
        if (!inited) {
          return false;
        }
      } else {
        ThrowErrorMessage(cx, MSG_NOT_CALLABLE);
        return false;
      }
    } else {
      ThrowErrorMessage(cx, MSG_NOT_OBJECT);
      return false;
    }
  }
  self->PassOptionalCallback(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalCallback_methodinfo = {
  (JSJitPropertyOp)passOptionalCallback,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalNullableCallback(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  const Optional< nsRefPtr<TestCallback> > arg0;
  if (0 < argc) {
    const_cast< Optional< nsRefPtr<TestCallback> > &>(arg0).Construct();
    if (argv[0].isObject()) {
      if (JS_ObjectIsCallable(cx, &argv[0].toObject())) {
        bool inited;
        const_cast< nsRefPtr<TestCallback> & >(arg0.Value()) = new TestCallback(cx, obj, &argv[0].toObject(), &inited);
        if (!inited) {
          return false;
        }
      } else {
        ThrowErrorMessage(cx, MSG_NOT_CALLABLE);
        return false;
      }
    } else if (argv[0].isNullOrUndefined()) {
      const_cast< nsRefPtr<TestCallback> & >(arg0.Value()) = nullptr;
    } else {
      ThrowErrorMessage(cx, MSG_NOT_OBJECT);
      return false;
    }
  }
  self->PassOptionalNullableCallback(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalNullableCallback_methodinfo = {
  (JSJitPropertyOp)passOptionalNullableCallback,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalNullableCallbackWithDefaultValue(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  nsRefPtr<TestCallback> arg0;
  if (0 < argc) {
    if (argv[0].isObject()) {
      if (JS_ObjectIsCallable(cx, &argv[0].toObject())) {
        bool inited;
        arg0 = new TestCallback(cx, obj, &argv[0].toObject(), &inited);
        if (!inited) {
          return false;
        }
      } else {
        ThrowErrorMessage(cx, MSG_NOT_CALLABLE);
        return false;
      }
    } else if (argv[0].isNullOrUndefined()) {
      arg0 = nullptr;
    } else {
      ThrowErrorMessage(cx, MSG_NOT_OBJECT);
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  self->PassOptionalNullableCallbackWithDefaultValue(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalNullableCallbackWithDefaultValue_methodinfo = {
  (JSJitPropertyOp)passOptionalNullableCallbackWithDefaultValue,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveCallback(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{
  nsRefPtr<TestCallback> result;
  result = self->ReceiveCallback();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}


const JSJitInfo receiveCallback_methodinfo = {
  (JSJitPropertyOp)receiveCallback,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveNullableCallback(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{
  nsRefPtr<TestCallback> result;
  result = self->ReceiveNullableCallback();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}


const JSJitInfo receiveNullableCallback_methodinfo = {
  (JSJitPropertyOp)receiveNullableCallback,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
passNullableTreatAsNullCallback(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.passNullableTreatAsNullCallback");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  nsRefPtr<TestTreatAsNullCallback> arg0;
  if (argv[0].isObject()) {
    if (JS_ObjectIsCallable(cx, &argv[0].toObject())) {
      bool inited;
      arg0 = new TestTreatAsNullCallback(cx, obj, &argv[0].toObject(), &inited);
      if (!inited) {
        return false;
      }
    } else {
      ThrowErrorMessage(cx, MSG_NOT_CALLABLE);
      return false;
    }
  } else if (argv[0].isNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassNullableTreatAsNullCallback(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passNullableTreatAsNullCallback_methodinfo = {
  (JSJitPropertyOp)passNullableTreatAsNullCallback,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalNullableTreatAsNullCallback(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  const Optional< nsRefPtr<TestTreatAsNullCallback> > arg0;
  if (0 < argc) {
    const_cast< Optional< nsRefPtr<TestTreatAsNullCallback> > &>(arg0).Construct();
    if (argv[0].isObject()) {
      if (JS_ObjectIsCallable(cx, &argv[0].toObject())) {
        bool inited;
        const_cast< nsRefPtr<TestTreatAsNullCallback> & >(arg0.Value()) = new TestTreatAsNullCallback(cx, obj, &argv[0].toObject(), &inited);
        if (!inited) {
          return false;
        }
      } else {
        ThrowErrorMessage(cx, MSG_NOT_CALLABLE);
        return false;
      }
    } else if (argv[0].isNullOrUndefined()) {
      const_cast< nsRefPtr<TestTreatAsNullCallback> & >(arg0.Value()) = nullptr;
    } else {
      ThrowErrorMessage(cx, MSG_NOT_OBJECT);
      return false;
    }
  }
  self->PassOptionalNullableTreatAsNullCallback(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalNullableTreatAsNullCallback_methodinfo = {
  (JSJitPropertyOp)passOptionalNullableTreatAsNullCallback,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalNullableTreatAsNullCallbackWithDefaultValue(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  nsRefPtr<TestTreatAsNullCallback> arg0;
  if (0 < argc) {
    if (argv[0].isObject()) {
      if (JS_ObjectIsCallable(cx, &argv[0].toObject())) {
        bool inited;
        arg0 = new TestTreatAsNullCallback(cx, obj, &argv[0].toObject(), &inited);
        if (!inited) {
          return false;
        }
      } else {
        ThrowErrorMessage(cx, MSG_NOT_CALLABLE);
        return false;
      }
    } else if (argv[0].isNullOrUndefined()) {
      arg0 = nullptr;
    } else {
      ThrowErrorMessage(cx, MSG_NOT_OBJECT);
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  self->PassOptionalNullableTreatAsNullCallbackWithDefaultValue(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalNullableTreatAsNullCallbackWithDefaultValue_methodinfo = {
  (JSJitPropertyOp)passOptionalNullableTreatAsNullCallbackWithDefaultValue,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passAny(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.passAny");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  JS::Value arg0;
  arg0 = argv[0];
  self->PassAny(cx, arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passAny_methodinfo = {
  (JSJitPropertyOp)passAny,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalAny(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  const Optional< JS::Value > arg0;
  if (0 < argc) {
    const_cast< Optional< JS::Value > &>(arg0).Construct();
    const_cast< JS::Value & >(arg0.Value()) = argv[0];
  }
  self->PassOptionalAny(cx, arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalAny_methodinfo = {
  (JSJitPropertyOp)passOptionalAny,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passAnyDefaultNull(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  JS::Value arg0;
  if (0 < argc) {
    arg0 = argv[0];
  } else {
    arg0 = JS::NullValue();
  }
  self->PassAnyDefaultNull(cx, arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passAnyDefaultNull_methodinfo = {
  (JSJitPropertyOp)passAnyDefaultNull,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveAny(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{
  JS::Value result;
  result = self->ReceiveAny(cx);
  *vp = result;
  if (!MaybeWrapValue(cx, vp)) {
    return false;
  }
  return true;
}


const JSJitInfo receiveAny_methodinfo = {
  (JSJitPropertyOp)receiveAny,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
passObject(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.passObject");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  NonNull<JSObject> arg0;
  if (argv[0].isObject()) {
    arg0 = &argv[0].toObject();
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassObject(cx, (JSObject&)arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passObject_methodinfo = {
  (JSJitPropertyOp)passObject,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passNullableObject(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.passNullableObject");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  JSObject* arg0;
  if (argv[0].isObject()) {
    arg0 = &argv[0].toObject();
  } else if (argv[0].isNullOrUndefined()) {
    arg0 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassNullableObject(cx, arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passNullableObject_methodinfo = {
  (JSJitPropertyOp)passNullableObject,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalObject(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  const Optional< NonNull<JSObject> > arg0;
  if (0 < argc) {
    const_cast< Optional< NonNull<JSObject> > &>(arg0).Construct();
    if (argv[0].isObject()) {
      const_cast< NonNull<JSObject> & >(arg0.Value()) = &argv[0].toObject();
    } else {
      ThrowErrorMessage(cx, MSG_NOT_OBJECT);
      return false;
    }
  }
  self->PassOptionalObject(cx, arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalObject_methodinfo = {
  (JSJitPropertyOp)passOptionalObject,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalNullableObject(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  const Optional< JSObject* > arg0;
  if (0 < argc) {
    const_cast< Optional< JSObject* > &>(arg0).Construct();
    if (argv[0].isObject()) {
      const_cast< JSObject* & >(arg0.Value()) = &argv[0].toObject();
    } else if (argv[0].isNullOrUndefined()) {
      const_cast< JSObject* & >(arg0.Value()) = NULL;
    } else {
      ThrowErrorMessage(cx, MSG_NOT_OBJECT);
      return false;
    }
  }
  self->PassOptionalNullableObject(cx, arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalNullableObject_methodinfo = {
  (JSJitPropertyOp)passOptionalNullableObject,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalNullableObjectWithDefaultValue(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  JSObject* arg0;
  if (0 < argc) {
    if (argv[0].isObject()) {
      arg0 = &argv[0].toObject();
    } else if (argv[0].isNullOrUndefined()) {
      arg0 = NULL;
    } else {
      ThrowErrorMessage(cx, MSG_NOT_OBJECT);
      return false;
    }
  } else {
    arg0 = NULL;
  }
  self->PassOptionalNullableObjectWithDefaultValue(cx, arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalNullableObjectWithDefaultValue_methodinfo = {
  (JSJitPropertyOp)passOptionalNullableObjectWithDefaultValue,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveObject(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{
  JSObject* result;
  result = self->ReceiveObject(cx);
  *vp = JS::ObjectValue(*result);
  if (!MaybeWrapValue(cx, vp)) {
    return false;
  }
  return true;
}


const JSJitInfo receiveObject_methodinfo = {
  (JSJitPropertyOp)receiveObject,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
receiveNullableObject(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{
  JSObject* result;
  result = self->ReceiveNullableObject(cx);
  *vp = JS::ObjectOrNullValue(result);
  if (!MaybeWrapValue(cx, vp)) {
    return false;
  }
  return true;
}


const JSJitInfo receiveNullableObject_methodinfo = {
  (JSJitPropertyOp)receiveNullableObject,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
passUnion(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.passUnion");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  const ObjectOrLong arg0;
  ObjectOrLongArgument arg0_holder(arg0);
  {
    bool done = false, failed = false, tryNext;
    if (argv[0].isObject()) {
      JSObject& argObj = argv[0].toObject();
      arg0_holder.SetToObject(&argObj);
      done = true;
    } else {
      done = (failed = !arg0_holder.TrySetToLong(cx, obj, argv[0], &argv[0], tryNext)) || !tryNext;
    }
    if (failed) {
      return false;
    }
    if (!done) {
      ThrowErrorMessage(cx, MSG_NOT_IN_UNION, "Long");
      return false;
    }
  }
  self->PassUnion(cx, arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passUnion_methodinfo = {
  (JSJitPropertyOp)passUnion,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passUnionWithNullable(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.passUnionWithNullable");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  const ObjectOrNullOrLong arg0;
  ObjectOrNullOrLongArgument arg0_holder(arg0);
  if (argv[0].isNullOrUndefined()) {
    arg0_holder.SetNull();
  } else {
    {
      bool done = false, failed = false, tryNext;
      if (argv[0].isObject()) {
        JSObject& argObj = argv[0].toObject();
        arg0_holder.SetToObject(&argObj);
        done = true;
      } else {
        done = (failed = !arg0_holder.TrySetToLong(cx, obj, argv[0], &argv[0], tryNext)) || !tryNext;
      }
      if (failed) {
        return false;
      }
      if (!done) {
        ThrowErrorMessage(cx, MSG_NOT_IN_UNION, "Long");
        return false;
      }
    }
  }
  self->PassUnionWithNullable(cx, arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passUnionWithNullable_methodinfo = {
  (JSJitPropertyOp)passUnionWithNullable,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passNullableUnion(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.passNullableUnion");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  Maybe<ObjectOrLongArgument > arg0_holder;
  const Nullable<ObjectOrLong > arg0;
  if (argv[0].isNullOrUndefined()) {
    const_cast<Nullable<ObjectOrLong >& >(arg0).SetNull();
  } else {
    arg0_holder.construct(const_cast<Nullable<ObjectOrLong >& >(arg0).SetValue());
    {
      bool done = false, failed = false, tryNext;
      if (argv[0].isObject()) {
        JSObject& argObj = argv[0].toObject();
        arg0_holder.ref().SetToObject(&argObj);
        done = true;
      } else {
        done = (failed = !arg0_holder.ref().TrySetToLong(cx, obj, argv[0], &argv[0], tryNext)) || !tryNext;
      }
      if (failed) {
        return false;
      }
      if (!done) {
        ThrowErrorMessage(cx, MSG_NOT_IN_UNION, "Long");
        return false;
      }
    }
  }
  self->PassNullableUnion(cx, arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passNullableUnion_methodinfo = {
  (JSJitPropertyOp)passNullableUnion,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalUnion(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  Maybe<ObjectOrLongArgument > arg0_holder;
  const Optional<ObjectOrLong > arg0;
  if (0 < argc) {
    const_cast<Optional<ObjectOrLong >& >(arg0).Construct();
    arg0_holder.construct(arg0.Value());
    {
      bool done = false, failed = false, tryNext;
      if (argv[0].isObject()) {
        JSObject& argObj = argv[0].toObject();
        arg0_holder.ref().SetToObject(&argObj);
        done = true;
      } else {
        done = (failed = !arg0_holder.ref().TrySetToLong(cx, obj, argv[0], &argv[0], tryNext)) || !tryNext;
      }
      if (failed) {
        return false;
      }
      if (!done) {
        ThrowErrorMessage(cx, MSG_NOT_IN_UNION, "Long");
        return false;
      }
    }
  }
  self->PassOptionalUnion(cx, arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalUnion_methodinfo = {
  (JSJitPropertyOp)passOptionalUnion,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalNullableUnion(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  Maybe<ObjectOrLongArgument > arg0_holder;
  const Optional<Nullable<ObjectOrLong > > arg0;
  if (0 < argc) {
    const_cast<Optional<Nullable<ObjectOrLong > >& >(arg0).Construct();
    if (argv[0].isNullOrUndefined()) {
      const_cast<Optional<Nullable<ObjectOrLong > >& >(arg0).Value().SetNull();
    } else {
      arg0_holder.construct(const_cast<Optional<Nullable<ObjectOrLong > >& >(arg0).Value().SetValue());
      {
        bool done = false, failed = false, tryNext;
        if (argv[0].isObject()) {
          JSObject& argObj = argv[0].toObject();
          arg0_holder.ref().SetToObject(&argObj);
          done = true;
        } else {
          done = (failed = !arg0_holder.ref().TrySetToLong(cx, obj, argv[0], &argv[0], tryNext)) || !tryNext;
        }
        if (failed) {
          return false;
        }
        if (!done) {
          ThrowErrorMessage(cx, MSG_NOT_IN_UNION, "Long");
          return false;
        }
      }
    }
  }
  self->PassOptionalNullableUnion(cx, arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalNullableUnion_methodinfo = {
  (JSJitPropertyOp)passOptionalNullableUnion,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOptionalNullableUnionWithDefaultValue(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  Maybe<ObjectOrLongArgument > arg0_holder;
  const Nullable<ObjectOrLong > arg0;
  if (!(0 < argc) || argv[0].isNullOrUndefined()) {
    const_cast<Nullable<ObjectOrLong >& >(arg0).SetNull();
  } else {
    arg0_holder.construct(const_cast<Nullable<ObjectOrLong >& >(arg0).SetValue());
    {
      bool done = false, failed = false, tryNext;
      if (argv[0].isObject()) {
        JSObject& argObj = argv[0].toObject();
        arg0_holder.ref().SetToObject(&argObj);
        done = true;
      } else {
        done = (failed = !arg0_holder.ref().TrySetToLong(cx, obj, argv[0], &argv[0], tryNext)) || !tryNext;
      }
      if (failed) {
        return false;
      }
      if (!done) {
        ThrowErrorMessage(cx, MSG_NOT_IN_UNION, "Long");
        return false;
      }
    }
  }
  self->PassOptionalNullableUnionWithDefaultValue(cx, arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOptionalNullableUnionWithDefaultValue_methodinfo = {
  (JSJitPropertyOp)passOptionalNullableUnionWithDefaultValue,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passUnionWithArrayBuffer(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.passUnionWithArrayBuffer");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  const ArrayBufferOrLong arg0;
  ArrayBufferOrLongArgument arg0_holder(arg0);
  {
    bool done = false, failed = false, tryNext;
    if (argv[0].isObject()) {
      done = (failed = !arg0_holder.TrySetToArrayBuffer(cx, obj, argv[0], &argv[0], tryNext)) || !tryNext;

    }
    if (!done) {
      done = (failed = !arg0_holder.TrySetToLong(cx, obj, argv[0], &argv[0], tryNext)) || !tryNext;
    }
    if (failed) {
      return false;
    }
    if (!done) {
      ThrowErrorMessage(cx, MSG_NOT_IN_UNION, "ArrayBuffer, Long");
      return false;
    }
  }
  self->PassUnionWithArrayBuffer(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passUnionWithArrayBuffer_methodinfo = {
  (JSJitPropertyOp)passUnionWithArrayBuffer,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passUnionWithString(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.passUnionWithString");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  const StringOrObject arg0;
  StringOrObjectArgument arg0_holder(arg0);
  {
    bool done = false, failed = false, tryNext;
    if (argv[0].isObject()) {
      JSObject& argObj = argv[0].toObject();
      arg0_holder.SetToObject(&argObj);
      done = true;
    } else {
      done = (failed = !arg0_holder.TrySetToString(cx, obj, argv[0], &argv[0], tryNext)) || !tryNext;
    }
    if (failed) {
      return false;
    }
    if (!done) {
      ThrowErrorMessage(cx, MSG_NOT_IN_UNION, "String");
      return false;
    }
  }
  self->PassUnionWithString(cx, arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passUnionWithString_methodinfo = {
  (JSJitPropertyOp)passUnionWithString,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passUnionWithObject(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.passUnionWithObject");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  const ObjectOrLong arg0;
  ObjectOrLongArgument arg0_holder(arg0);
  {
    bool done = false, failed = false, tryNext;
    if (argv[0].isObject()) {
      JSObject& argObj = argv[0].toObject();
      arg0_holder.SetToObject(&argObj);
      done = true;
    } else {
      done = (failed = !arg0_holder.TrySetToLong(cx, obj, argv[0], &argv[0], tryNext)) || !tryNext;
    }
    if (failed) {
      return false;
    }
    if (!done) {
      ThrowErrorMessage(cx, MSG_NOT_IN_UNION, "Long");
      return false;
    }
  }
  self->PassUnionWithObject(cx, arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passUnionWithObject_methodinfo = {
  (JSJitPropertyOp)passUnionWithObject,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
methodRenamedFrom(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  unsigned argcount = NS_MIN(argc, 1u);
  switch (argcount) {
    case 0: {
      self->MethodRenamedTo();
      *vp = JSVAL_VOID;
      return true;
      break;
    }
    case 1: {

      JS::Value* argv = JS_ARGV(cx, vp);

      int8_t arg0;
      if (!ValueToPrimitive<int8_t, eDefault>(cx, argv[0], &arg0)) {
        return false;
      }
      self->MethodRenamedTo(arg0);
      *vp = JSVAL_VOID;
      return true;
      break;
    }
    default: {
      return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.methodRenamedFrom");

      break;
    }
  }
  MOZ_NOT_REACHED("We have an always-returning default case");
  return false;
}


const JSJitInfo methodRenamedFrom_methodinfo = {
  (JSJitPropertyOp)methodRenamedFrom,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_attributeGetterRenamedFrom(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* vp)
{
  int8_t result;
  result = self->AttributeGetterRenamedTo();
  *vp = INT_TO_JSVAL(int32_t(result));
  return true;
}


const JSJitInfo attributeGetterRenamedFrom_getterinfo = {
  (JSJitPropertyOp)get_attributeGetterRenamedFrom,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_attributeRenamedFrom(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* vp)
{
  int8_t result;
  result = self->AttributeRenamedTo();
  *vp = INT_TO_JSVAL(int32_t(result));
  return true;
}

static bool
set_attributeRenamedFrom(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* argv)
{
  int8_t arg0;
  if (!ValueToPrimitive<int8_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  self->SetAttributeRenamedTo(arg0);

  return true;
}


const JSJitInfo attributeRenamedFrom_getterinfo = {
  (JSJitPropertyOp)get_attributeRenamedFrom,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo attributeRenamedFrom_setterinfo = {
  (JSJitPropertyOp)set_attributeRenamedFrom,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passDictionary(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  const Dict arg0;
  if (!const_cast<Dict&>(arg0).Init(cx, obj, (0 < argc) ? argv[0] : JSVAL_NULL)) {
    return false;
  }
  self->PassDictionary(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passDictionary_methodinfo = {
  (JSJitPropertyOp)passDictionary,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passOtherDictionary(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  const GrandparentDict arg0;
  if (!const_cast<GrandparentDict&>(arg0).Init(cx, obj, (0 < argc) ? argv[0] : JSVAL_NULL)) {
    return false;
  }
  self->PassOtherDictionary(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passOtherDictionary_methodinfo = {
  (JSJitPropertyOp)passOtherDictionary,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passSequenceOfDictionaries(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.passSequenceOfDictionaries");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  const Sequence< Dict > arg0;
  if (argv[0].isObject()) {
    JSObject* seq = &argv[0].toObject();

    if (!IsArrayLike(cx, seq)) {
      ThrowErrorMessage(cx, MSG_NOT_SEQUENCE);
      return false;
    }
    uint32_t length;
    // JS_GetArrayLength actually works on all objects
    if (!JS_GetArrayLength(cx, seq, &length)) {
      return false;
    }
    Sequence< Dict > &arr = const_cast< Sequence< Dict >& >(arg0);
    if (!arr.SetCapacity(length)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t i = 0; i < length; ++i) {
      jsval temp;
      if (!JS_GetElement(cx, seq, i, &temp)) {
        return false;
      }
      Dict& slot = *arr.AppendElement();
      if (!slot.Init(cx, obj, temp)) {
        return false;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassSequenceOfDictionaries(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passSequenceOfDictionaries_methodinfo = {
  (JSJitPropertyOp)passSequenceOfDictionaries,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passDictionaryOrLong(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  unsigned argcount = NS_MIN(argc, 1u);
  switch (argcount) {
    case 0: {

      JS::Value* argv = JS_ARGV(cx, vp);

      const Dict arg0;
      if (!const_cast<Dict&>(arg0).Init(cx, obj, (0 < argc) ? argv[0] : JSVAL_NULL)) {
        return false;
      }
      self->PassDictionaryOrLong(arg0);
      *vp = JSVAL_VOID;
      return true;
      break;
    }
    case 1: {
      JS::Value* argv_start = JS_ARGV(cx, vp);
      if (argv_start[0].isNullOrUndefined()) {
        const Dict arg0;
        if (!const_cast<Dict&>(arg0).Init(cx, obj, argv_start[0])) {
          return false;
        }
        self->PassDictionaryOrLong(arg0);
        *vp = JSVAL_VOID;
        return true;
      }
      if (argv_start[0].isObject()) {
        do {
          const Dict arg0;
          if (!IsConvertibleToDictionary(cx, &argv_start[0].toObject())) {
            break;
          }

          if (!const_cast<Dict&>(arg0).Init(cx, obj, argv_start[0])) {
            return false;
          }
          self->PassDictionaryOrLong(arg0);
          *vp = JSVAL_VOID;
          return true;
        } while (0);
      }

      JS::Value* argv = JS_ARGV(cx, vp);

      int32_t arg0;
      if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[0], &arg0)) {
        return false;
      }
      self->PassDictionaryOrLong(arg0);
      *vp = JSVAL_VOID;
      return true;
      break;
    }
    default: {
      return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.passDictionaryOrLong");

      break;
    }
  }
  MOZ_NOT_REACHED("We have an always-returning default case");
  return false;
}


const JSJitInfo passDictionaryOrLong_methodinfo = {
  (JSJitPropertyOp)passDictionaryOrLong,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passDictContainingDict(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  const DictContainingDict arg0;
  if (!const_cast<DictContainingDict&>(arg0).Init(cx, obj, (0 < argc) ? argv[0] : JSVAL_NULL)) {
    return false;
  }
  self->PassDictContainingDict(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passDictContainingDict_methodinfo = {
  (JSJitPropertyOp)passDictContainingDict,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passDictContainingSequence(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  JS::Value* argv = JS_ARGV(cx, vp);

  const DictContainingSequence arg0;
  if (!const_cast<DictContainingSequence&>(arg0).Init(cx, obj, (0 < argc) ? argv[0] : JSVAL_NULL)) {
    return false;
  }
  self->PassDictContainingSequence(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passDictContainingSequence_methodinfo = {
  (JSJitPropertyOp)passDictContainingSequence,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
dontEnforceRangeOrClamp(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.dontEnforceRangeOrClamp");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  int8_t arg0;
  if (!ValueToPrimitive<int8_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  self->DontEnforceRangeOrClamp(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo dontEnforceRangeOrClamp_methodinfo = {
  (JSJitPropertyOp)dontEnforceRangeOrClamp,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
doEnforceRange(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.doEnforceRange");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  int8_t arg0;
  if (!ValueToPrimitive<int8_t, eEnforceRange>(cx, argv[0], &arg0)) {
    return false;
  }
  self->DoEnforceRange(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo doEnforceRange_methodinfo = {
  (JSJitPropertyOp)doEnforceRange,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
doClamp(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.doClamp");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  int8_t arg0;
  if (!ValueToPrimitive<int8_t, eClamp>(cx, argv[0], &arg0)) {
    return false;
  }
  self->DoClamp(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo doClamp_methodinfo = {
  (JSJitPropertyOp)doClamp,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
exerciseTypedefInterfaces1(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.exerciseTypedefInterfaces1");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  NonNull<mozilla::dom::TestInterface> arg0;
  if (argv[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(cx, &argv[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestInterface");
        return false;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->ExerciseTypedefInterfaces1(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo exerciseTypedefInterfaces1_methodinfo = {
  (JSJitPropertyOp)exerciseTypedefInterfaces1,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
exerciseTypedefInterfaces2(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.exerciseTypedefInterfaces2");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  mozilla::dom::TestInterface* arg0;
  if (argv[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(cx, &argv[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestInterface");
        return false;
      }
    }
  } else if (argv[0].isNullOrUndefined()) {
    arg0 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  nsRefPtr<mozilla::dom::TestInterface> result;
  result = self->ExerciseTypedefInterfaces2(arg0);
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}


const JSJitInfo exerciseTypedefInterfaces2_methodinfo = {
  (JSJitPropertyOp)exerciseTypedefInterfaces2,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
exerciseTypedefInterfaces3(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.exerciseTypedefInterfaces3");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  NonNull<mozilla::dom::TestInterface> arg0;
  if (argv[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(cx, &argv[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestInterface");
        return false;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->ExerciseTypedefInterfaces3(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo exerciseTypedefInterfaces3_methodinfo = {
  (JSJitPropertyOp)exerciseTypedefInterfaces3,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static JSBool
get_staticAttribute(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  // We have to be careful to leave "obj" in its existing compartment, even
  // while we grab our global from the real underlying object, because we
  // use it for unwrapping the other arguments later.
  nsISupports* global;
  xpc_qsSelfRef globalRef;
  {
    JS::Value val;
    Maybe<JSAutoCompartment> ac;
    if (js::IsWrapper(obj)) {
      JSObject* realObj = XPCWrapper::Unwrap(cx, obj, false);
      if (!realObj) {
        return Throw<true>(cx, NS_ERROR_XPC_SECURITY_MANAGER_VETO);
      }
      ac.construct(cx, realObj);
      val.setObject(*JS_GetGlobalForObject(cx, realObj));
    } else {
      val.setObject(*JS_GetGlobalForObject(cx, obj));
    }

    nsresult rv = xpc_qsUnwrapArg<nsISupports>(cx, val, &global, &globalRef.ptr,
                                               &val);
    if (NS_FAILED(rv)) {
      return Throw<true>(cx, NS_ERROR_XPC_BAD_CONVERT_JS);
    }
  }

  bool result;
  result = mozilla::dom::TestExampleInterface::StaticAttribute(global);
  *vp = BOOLEAN_TO_JSVAL(result);
  return true;
}

static JSBool
set_staticAttribute(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  // We have to be careful to leave "obj" in its existing compartment, even
  // while we grab our global from the real underlying object, because we
  // use it for unwrapping the other arguments later.
  nsISupports* global;
  xpc_qsSelfRef globalRef;
  {
    JS::Value val;
    Maybe<JSAutoCompartment> ac;
    if (js::IsWrapper(obj)) {
      JSObject* realObj = XPCWrapper::Unwrap(cx, obj, false);
      if (!realObj) {
        return Throw<true>(cx, NS_ERROR_XPC_SECURITY_MANAGER_VETO);
      }
      ac.construct(cx, realObj);
      val.setObject(*JS_GetGlobalForObject(cx, realObj));
    } else {
      val.setObject(*JS_GetGlobalForObject(cx, obj));
    }

    nsresult rv = xpc_qsUnwrapArg<nsISupports>(cx, val, &global, &globalRef.ptr,
                                               &val);
    if (NS_FAILED(rv)) {
      return Throw<true>(cx, NS_ERROR_XPC_BAD_CONVERT_JS);
    }
  }

  JS::Value* argv = JS_ARGV(cx, vp);
  JS::Value undef = JS::UndefinedValue();
  if (argc == 0) {
    argv = &undef;
  }
  bool arg0;
  if (!ValueToPrimitive<bool, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  mozilla::dom::TestExampleInterface::SetStaticAttribute(global, arg0);

  return true;
}

static JSBool
staticMethod(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  // We have to be careful to leave "obj" in its existing compartment, even
  // while we grab our global from the real underlying object, because we
  // use it for unwrapping the other arguments later.
  nsISupports* global;
  xpc_qsSelfRef globalRef;
  {
    JS::Value val;
    Maybe<JSAutoCompartment> ac;
    if (js::IsWrapper(obj)) {
      JSObject* realObj = XPCWrapper::Unwrap(cx, obj, false);
      if (!realObj) {
        return Throw<true>(cx, NS_ERROR_XPC_SECURITY_MANAGER_VETO);
      }
      ac.construct(cx, realObj);
      val.setObject(*JS_GetGlobalForObject(cx, realObj));
    } else {
      val.setObject(*JS_GetGlobalForObject(cx, obj));
    }

    nsresult rv = xpc_qsUnwrapArg<nsISupports>(cx, val, &global, &globalRef.ptr,
                                               &val);
    if (NS_FAILED(rv)) {
      return Throw<true>(cx, NS_ERROR_XPC_BAD_CONVERT_JS);
    }
  }


  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.staticMethod");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  bool arg0;
  if (!ValueToPrimitive<bool, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  mozilla::dom::TestExampleInterface::StaticMethod(global, arg0);
  *vp = JSVAL_VOID;
  return true;
}

static bool
overload1(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  unsigned argcount = NS_MIN(argc, 2u);
  switch (argcount) {
    case 1: {

      JS::Value* argv = JS_ARGV(cx, vp);

      NonNull<mozilla::dom::TestInterface> arg0;
      if (argv[0].isObject()) {
        {
          nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(cx, &argv[0].toObject(), arg0);
          if (NS_FAILED(rv)) {
            ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestInterface");
            return false;
          }
        }
      } else {
        ThrowErrorMessage(cx, MSG_NOT_OBJECT);
        return false;
      }
      bool result;
      result = self->Overload1(arg0);
      *vp = BOOLEAN_TO_JSVAL(result);
      return true;
      break;
    }
    case 2: {

      JS::Value* argv = JS_ARGV(cx, vp);

      FakeDependentString arg0_holder;
      const NonNull<nsAString> arg0;
      if (!ConvertJSValueToString(cx, argv[0], &argv[0], eStringify, eStringify, arg0_holder)) {
        return false;
      }
      const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
      NonNull<mozilla::dom::TestInterface> arg1;
      if (argv[1].isObject()) {
        {
          nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(cx, &argv[1].toObject(), arg1);
          if (NS_FAILED(rv)) {
            ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestInterface");
            return false;
          }
        }
      } else {
        ThrowErrorMessage(cx, MSG_NOT_OBJECT);
        return false;
      }
      nsRefPtr<mozilla::dom::TestInterface> result;
      result = self->Overload1(arg0, arg1);
      if (!WrapNewBindingObject(cx, obj, result, vp)) {
        MOZ_ASSERT(JS_IsExceptionPending(cx));
        return false;
      }
      return true;
      break;
    }
    default: {
      return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.overload1");

      break;
    }
  }
  MOZ_NOT_REACHED("We have an always-returning default case");
  return false;
}


const JSJitInfo overload1_methodinfo = {
  (JSJitPropertyOp)overload1,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
overload2(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  unsigned argcount = NS_MIN(argc, 1u);
  switch (argcount) {
    case 0: {

      JS::Value* argv = JS_ARGV(cx, vp);

      const Dict arg0;
      if (!const_cast<Dict&>(arg0).Init(cx, obj, (0 < argc) ? argv[0] : JSVAL_NULL)) {
        return false;
      }
      self->Overload2(arg0);
      *vp = JSVAL_VOID;
      return true;
      break;
    }
    case 1: {
      JS::Value* argv_start = JS_ARGV(cx, vp);
      if (argv_start[0].isNullOrUndefined()) {
        const Dict arg0;
        if (!const_cast<Dict&>(arg0).Init(cx, obj, argv_start[0])) {
          return false;
        }
        self->Overload2(arg0);
        *vp = JSVAL_VOID;
        return true;
      }
      if (argv_start[0].isObject()) {
        do {
          NonNull<mozilla::dom::TestInterface> arg0;
          {
            nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(cx, &argv_start[0].toObject(), arg0);
            if (NS_FAILED(rv)) {
              break;
            }
          }
          self->Overload2(arg0);
          *vp = JSVAL_VOID;
          return true;
        } while (0);
        do {
          const Dict arg0;
          if (!IsConvertibleToDictionary(cx, &argv_start[0].toObject())) {
            break;
          }

          if (!const_cast<Dict&>(arg0).Init(cx, obj, argv_start[0])) {
            return false;
          }
          self->Overload2(arg0);
          *vp = JSVAL_VOID;
          return true;
        } while (0);
      }

      JS::Value* argv = JS_ARGV(cx, vp);

      FakeDependentString arg0_holder;
      const NonNull<nsAString> arg0;
      if (!ConvertJSValueToString(cx, argv[0], &argv[0], eStringify, eStringify, arg0_holder)) {
        return false;
      }
      const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
      self->Overload2(arg0);
      *vp = JSVAL_VOID;
      return true;
      break;
    }
    default: {
      return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.overload2");

      break;
    }
  }
  MOZ_NOT_REACHED("We have an always-returning default case");
  return false;
}


const JSJitInfo overload2_methodinfo = {
  (JSJitPropertyOp)overload2,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
overload3(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  unsigned argcount = NS_MIN(argc, 1u);
  switch (argcount) {
    case 1: {
      JS::Value* argv_start = JS_ARGV(cx, vp);
      if (argv_start[0].isObject()) {
        do {
          NonNull<mozilla::dom::TestInterface> arg0;
          {
            nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(cx, &argv_start[0].toObject(), arg0);
            if (NS_FAILED(rv)) {
              break;
            }
          }
          self->Overload3(arg0);
          *vp = JSVAL_VOID;
          return true;
        } while (0);
        do {
          OwningNonNull<TestCallback> arg0;
          if (JS_ObjectIsCallable(cx, &argv_start[0].toObject())) {
            bool inited;
            arg0 = new TestCallback(cx, obj, &argv_start[0].toObject(), &inited);
            if (!inited) {
              return false;
            }
          } else {
            break;
          }
          self->Overload3(arg0);
          *vp = JSVAL_VOID;
          return true;
        } while (0);
      }

      JS::Value* argv = JS_ARGV(cx, vp);

      FakeDependentString arg0_holder;
      const NonNull<nsAString> arg0;
      if (!ConvertJSValueToString(cx, argv[0], &argv[0], eStringify, eStringify, arg0_holder)) {
        return false;
      }
      const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
      self->Overload3(arg0);
      *vp = JSVAL_VOID;
      return true;
      break;
    }
    default: {
      return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.overload3");

      break;
    }
  }
  MOZ_NOT_REACHED("We have an always-returning default case");
  return false;
}


const JSJitInfo overload3_methodinfo = {
  (JSJitPropertyOp)overload3,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
overload4(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  unsigned argcount = NS_MIN(argc, 1u);
  switch (argcount) {
    case 1: {
      JS::Value* argv_start = JS_ARGV(cx, vp);
      if (argv_start[0].isObject()) {
        do {
          NonNull<mozilla::dom::TestInterface> arg0;
          {
            nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(cx, &argv_start[0].toObject(), arg0);
            if (NS_FAILED(rv)) {
              break;
            }
          }
          self->Overload4(arg0);
          *vp = JSVAL_VOID;
          return true;
        } while (0);
        do {
          OwningNonNull<mozilla::dom::TestCallbackInterface> arg0;
          if (!IsConvertibleToCallbackInterface(cx, &argv_start[0].toObject())) {
              break;
          }

          nsresult rv;
          XPCCallContext ccx(JS_CALLER, cx);
          if (!ccx.IsValid()) {
            rv = NS_ERROR_XPC_BAD_CONVERT_JS;
            break;
          }

          const nsIID& iid = NS_GET_IID(mozilla::dom::TestCallbackInterface);
          nsRefPtr<nsXPCWrappedJS> wrappedJS;
          rv = nsXPCWrappedJS::GetNewOrUsed(ccx, &argv_start[0].toObject(), iid,
                                            NULL, getter_AddRefs(wrappedJS));
          if (NS_FAILED(rv) || !wrappedJS) {
            break;
          }

          // Use a temp nsCOMPtr for the null-check, because arg0 might be
          // OwningNonNull, not an nsCOMPtr.
          nsCOMPtr<mozilla::dom::TestCallbackInterface> tmp = do_QueryObject(wrappedJS.get());
          if (!tmp) {
            break;
          }
          arg0 = tmp.forget();
          self->Overload4(arg0);
          *vp = JSVAL_VOID;
          return true;
        } while (0);
      }

      JS::Value* argv = JS_ARGV(cx, vp);

      FakeDependentString arg0_holder;
      const NonNull<nsAString> arg0;
      if (!ConvertJSValueToString(cx, argv[0], &argv[0], eStringify, eStringify, arg0_holder)) {
        return false;
      }
      const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
      self->Overload4(arg0);
      *vp = JSVAL_VOID;
      return true;
      break;
    }
    default: {
      return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.overload4");

      break;
    }
  }
  MOZ_NOT_REACHED("We have an always-returning default case");
  return false;
}


const JSJitInfo overload4_methodinfo = {
  (JSJitPropertyOp)overload4,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
passVariadicThirdArg(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 2) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.passVariadicThirdArg");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eStringify, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  int32_t arg1;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[1], &arg1)) {
    return false;
  }
  const Sequence< OwningNonNull<mozilla::dom::TestInterface> > arg2;
  if (argc > 2) {
    Sequence< OwningNonNull<mozilla::dom::TestInterface> >& arr = const_cast< Sequence< OwningNonNull<mozilla::dom::TestInterface> >& >(arg2);
    if (!arr.SetCapacity(argc - 2)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t variadicArg = 2; variadicArg < argc; ++variadicArg) {
      OwningNonNull<mozilla::dom::TestInterface>& slot = *arr.AppendElement();
      if (argv[variadicArg].isObject()) {
        {
          nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(cx, &argv[variadicArg].toObject(), slot);
          if (NS_FAILED(rv)) {
            ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestInterface");
            return false;
          }
        }
      } else {
        ThrowErrorMessage(cx, MSG_NOT_OBJECT);
        return false;
      }
    }
  }
  self->PassVariadicThirdArg(arg0, arg1, arg2);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passVariadicThirdArg_methodinfo = {
  (JSJitPropertyOp)passVariadicThirdArg,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_attrWithLenientThis(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* vp)
{
  int32_t result;
  result = self->AttrWithLenientThis();
  *vp = INT_TO_JSVAL(int32_t(result));
  return true;
}

static bool
set_attrWithLenientThis(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* argv)
{
  int32_t arg0;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  self->SetAttrWithLenientThis(arg0);

  return true;
}


const JSJitInfo attrWithLenientThis_getterinfo = {
  (JSJitPropertyOp)get_attrWithLenientThis,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo attrWithLenientThis_setterinfo = {
  (JSJitPropertyOp)set_attrWithLenientThis,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_unforgeableAttr(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* vp)
{
  int32_t result;
  result = self->UnforgeableAttr();
  *vp = INT_TO_JSVAL(int32_t(result));
  return true;
}


const JSJitInfo unforgeableAttr_getterinfo = {
  (JSJitPropertyOp)get_unforgeableAttr,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_unforgeableAttr2(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* vp)
{
  int32_t result;
  result = self->UnforgeableAttr2();
  *vp = INT_TO_JSVAL(int32_t(result));
  return true;
}


const JSJitInfo unforgeableAttr2_getterinfo = {
  (JSJitPropertyOp)get_unforgeableAttr2,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

static bool
__stringifier(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{
  nsString result;
  self->__stringifier(result);
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}


const JSJitInfo __stringifier_methodinfo = {
  (JSJitPropertyOp)__stringifier,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

static bool
passRenamedInterface(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.passRenamedInterface");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  NonNull<nsRenamedInterface> arg0;
  if (argv[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::TestRenamedInterface, nsRenamedInterface>(cx, &argv[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestRenamedInterface");
        return false;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->PassRenamedInterface(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo passRenamedInterface_methodinfo = {
  (JSJitPropertyOp)passRenamedInterface,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_putForwardsAttr(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* vp)
{
  nsRefPtr<mozilla::dom::TestExampleInterface> result;
  result = self->PutForwardsAttr();
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static bool
set_putForwardsAttr(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* argv)
{
  js::RootedValue v(cx);
  if (!JS_GetProperty(cx, obj, "putForwardsAttr", v.address())) {
    return false;
  }

  if (!v.isObject()) {
    return ThrowErrorMessage(cx, MSG_NOT_OBJECT);
  }

  return JS_SetProperty(cx, &v.toObject(), "writableByte", argv);
}


const JSJitInfo putForwardsAttr_getterinfo = {
  (JSJitPropertyOp)get_putForwardsAttr,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo putForwardsAttr_setterinfo = {
  (JSJitPropertyOp)set_putForwardsAttr,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_putForwardsAttr2(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* vp)
{
  nsRefPtr<mozilla::dom::TestExampleInterface> result;
  result = self->PutForwardsAttr2();
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static bool
set_putForwardsAttr2(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* argv)
{
  js::RootedValue v(cx);
  if (!JS_GetProperty(cx, obj, "putForwardsAttr2", v.address())) {
    return false;
  }

  if (!v.isObject()) {
    return ThrowErrorMessage(cx, MSG_NOT_OBJECT);
  }

  return JS_SetProperty(cx, &v.toObject(), "writableByte", argv);
}


const JSJitInfo putForwardsAttr2_getterinfo = {
  (JSJitPropertyOp)get_putForwardsAttr2,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo putForwardsAttr2_setterinfo = {
  (JSJitPropertyOp)set_putForwardsAttr2,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_putForwardsAttr3(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* vp)
{
  nsRefPtr<mozilla::dom::TestExampleInterface> result;
  result = self->PutForwardsAttr3();
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static bool
set_putForwardsAttr3(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* argv)
{
  js::RootedValue v(cx);
  if (!JS_GetProperty(cx, obj, "putForwardsAttr3", v.address())) {
    return false;
  }

  if (!v.isObject()) {
    return ThrowErrorMessage(cx, MSG_NOT_OBJECT);
  }

  return JS_SetProperty(cx, &v.toObject(), "writableByte", argv);
}


const JSJitInfo putForwardsAttr3_getterinfo = {
  (JSJitPropertyOp)get_putForwardsAttr3,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo putForwardsAttr3_setterinfo = {
  (JSJitPropertyOp)set_putForwardsAttr3,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
throwingMethod(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, unsigned argc, JS::Value* vp)
{
  ErrorResult rv;
  self->ThrowingMethod(rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "TestExampleInterface", "throwingMethod");
  }
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo throwingMethod_methodinfo = {
  (JSJitPropertyOp)throwingMethod,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Method,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_throwingAttr(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* vp)
{
  ErrorResult rv;
  bool result;
  result = self->GetThrowingAttr(rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "TestExampleInterface", "throwingAttr");
  }
  *vp = BOOLEAN_TO_JSVAL(result);
  return true;
}

static bool
set_throwingAttr(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* argv)
{
  bool arg0;
  if (!ValueToPrimitive<bool, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  ErrorResult rv;
  self->SetThrowingAttr(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "TestExampleInterface", "throwingAttr");
  }

  return true;
}


const JSJitInfo throwingAttr_getterinfo = {
  (JSJitPropertyOp)get_throwingAttr,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo throwingAttr_setterinfo = {
  (JSJitPropertyOp)set_throwingAttr,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_throwingGetterAttr(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* vp)
{
  ErrorResult rv;
  bool result;
  result = self->GetThrowingGetterAttr(rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "TestExampleInterface", "throwingGetterAttr");
  }
  *vp = BOOLEAN_TO_JSVAL(result);
  return true;
}

static bool
set_throwingGetterAttr(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* argv)
{
  bool arg0;
  if (!ValueToPrimitive<bool, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  self->SetThrowingGetterAttr(arg0);

  return true;
}


const JSJitInfo throwingGetterAttr_getterinfo = {
  (JSJitPropertyOp)get_throwingGetterAttr,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo throwingGetterAttr_setterinfo = {
  (JSJitPropertyOp)set_throwingGetterAttr,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_throwingSetterAttr(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* vp)
{
  bool result;
  result = self->ThrowingSetterAttr();
  *vp = BOOLEAN_TO_JSVAL(result);
  return true;
}

static bool
set_throwingSetterAttr(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleInterface* self, JS::Value* argv)
{
  bool arg0;
  if (!ValueToPrimitive<bool, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  ErrorResult rv;
  self->SetThrowingSetterAttr(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "TestExampleInterface", "throwingSetterAttr");
  }

  return true;
}


const JSJitInfo throwingSetterAttr_getterinfo = {
  (JSJitPropertyOp)get_throwingSetterAttr,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo throwingSetterAttr_setterinfo = {
  (JSJitPropertyOp)set_throwingSetterAttr,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static JSBool
genericMethod(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  mozilla::dom::TestExampleInterface* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::TestExampleInterface, mozilla::dom::TestExampleInterface>(cx, obj, self);
    if (NS_FAILED(rv)) {
      return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestExampleInterface");
    }
  }
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Method);
  JSJitMethodOp method = (JSJitMethodOp)info->op;
  return method(cx, obj, self, argc, vp);
}

static JSBool
genericGetter(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  mozilla::dom::TestExampleInterface* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::TestExampleInterface, mozilla::dom::TestExampleInterface>(cx, obj, self);
    if (NS_FAILED(rv)) {
      return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestExampleInterface");
    }
  }
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Getter);
  JSJitPropertyOp getter = info->op;
  return getter(cx, obj, self, vp);
}

static JSBool
genericLenientGetter(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  mozilla::dom::TestExampleInterface* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::TestExampleInterface, mozilla::dom::TestExampleInterface>(cx, obj, self);
    if (NS_FAILED(rv)) {
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      JS_SET_RVAL(cx, vp, JS::UndefinedValue());
      return true;
    }
  }
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Getter);
  JSJitPropertyOp getter = info->op;
  return getter(cx, obj, self, vp);
}

static JSBool
genericSetter(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  mozilla::dom::TestExampleInterface* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::TestExampleInterface, mozilla::dom::TestExampleInterface>(cx, obj, self);
    if (NS_FAILED(rv)) {
      return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestExampleInterface");
    }
  }
  if (argc == 0) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface attribute setter");
  }
  JS::Value* argv = JS_ARGV(cx, vp);
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Setter);
  JSJitPropertyOp setter = info->op;
  if (!setter(cx, obj, self, argv)) {
    return false;
  }
  *vp = JSVAL_VOID;
  return true;
}

static JSBool
genericLenientSetter(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  mozilla::dom::TestExampleInterface* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::TestExampleInterface, mozilla::dom::TestExampleInterface>(cx, obj, self);
    if (NS_FAILED(rv)) {
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      return true;
    }
  }
  if (argc == 0) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface attribute setter");
  }
  JS::Value* argv = JS_ARGV(cx, vp);
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Setter);
  JSJitPropertyOp setter = info->op;
  if (!setter(cx, obj, self, argv)) {
    return false;
  }
  *vp = JSVAL_VOID;
  return true;
}

static JSBool
_addProperty(JSContext* cx, JSHandleObject obj, JSHandleId id, JSMutableHandleValue vp)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::dom::TestExampleInterface>::value), "Must be an nsISupports class");
  mozilla::dom::TestExampleInterface* self = UnwrapDOMObject<mozilla::dom::TestExampleInterface>(obj);
  nsContentUtils::PreserveWrapper(reinterpret_cast<nsISupports*>(self), self);
  return true;
}

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, mozilla::dom::TestExampleInterface>::value), "Must be an nsISupports class");
  mozilla::dom::TestExampleInterface* self = UnwrapDOMObject<mozilla::dom::TestExampleInterface>(obj);
  if (self) {
    ClearWrapper(self, self);
    XPCJSRuntime *rt = nsXPConnect::GetRuntimeInstance();
    if (rt) {
      rt->DeferredRelease(reinterpret_cast<nsISupports*>(self));
    } else {
      NS_RELEASE(self);
    }
  }
}

static JSFunctionSpec sStaticMethods_specs[] = {
  JS_FNINFO("staticMethod", staticMethod, nullptr, 1, JSPROP_ENUMERATE),
  JS_FS_END
};

static Prefable<JSFunctionSpec> sStaticMethods[] = {
  { true, &sStaticMethods_specs[0] },
  { false, NULL }
};

static jsid sStaticMethods_ids[2] = { JSID_VOID };

static JSPropertySpec sStaticAttributes_specs[] = {
  { "staticAttribute", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)get_staticAttribute, nullptr }, { (JSStrictPropertyOp)set_staticAttribute, nullptr }},
  { 0, 0, 0, JSOP_NULLWRAPPER, JSOP_NULLWRAPPER }
};

static Prefable<JSPropertySpec> sStaticAttributes[] = {
  { true, &sStaticAttributes_specs[0] },
  { false, NULL }
};

static jsid sStaticAttributes_ids[2] = { JSID_VOID };

static JSFunctionSpec sMethods_specs[] = {
  JS_FNINFO("passByte", genericMethod, &passByte_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("receiveByte", genericMethod, &receiveByte_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalByte", genericMethod, &passOptionalByte_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalByteWithDefault", genericMethod, &passOptionalByteWithDefault_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passNullableByte", genericMethod, &passNullableByte_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalNullableByte", genericMethod, &passOptionalNullableByte_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passVariadicByte", genericMethod, &passVariadicByte_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passShort", genericMethod, &passShort_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("receiveShort", genericMethod, &receiveShort_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalShort", genericMethod, &passOptionalShort_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalShortWithDefault", genericMethod, &passOptionalShortWithDefault_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passLong", genericMethod, &passLong_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("receiveLong", genericMethod, &receiveLong_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalLong", genericMethod, &passOptionalLong_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalLongWithDefault", genericMethod, &passOptionalLongWithDefault_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passLongLong", genericMethod, &passLongLong_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("receiveLongLong", genericMethod, &receiveLongLong_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalLongLong", genericMethod, &passOptionalLongLong_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalLongLongWithDefault", genericMethod, &passOptionalLongLongWithDefault_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOctet", genericMethod, &passOctet_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("receiveOctet", genericMethod, &receiveOctet_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalOctet", genericMethod, &passOptionalOctet_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalOctetWithDefault", genericMethod, &passOptionalOctetWithDefault_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passUnsignedShort", genericMethod, &passUnsignedShort_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("receiveUnsignedShort", genericMethod, &receiveUnsignedShort_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalUnsignedShort", genericMethod, &passOptionalUnsignedShort_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalUnsignedShortWithDefault", genericMethod, &passOptionalUnsignedShortWithDefault_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passUnsignedLong", genericMethod, &passUnsignedLong_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("receiveUnsignedLong", genericMethod, &receiveUnsignedLong_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalUnsignedLong", genericMethod, &passOptionalUnsignedLong_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalUnsignedLongWithDefault", genericMethod, &passOptionalUnsignedLongWithDefault_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passUnsignedLongLong", genericMethod, &passUnsignedLongLong_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("receiveUnsignedLongLong", genericMethod, &receiveUnsignedLongLong_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalUnsignedLongLong", genericMethod, &passOptionalUnsignedLongLong_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalUnsignedLongLongWithDefault", genericMethod, &passOptionalUnsignedLongLongWithDefault_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passFloat", genericMethod, &passFloat_methodinfo, 16, JSPROP_ENUMERATE),
  JS_FNINFO("passLenientFloat", genericMethod, &passLenientFloat_methodinfo, 16, JSPROP_ENUMERATE),
  JS_FNINFO("receiveSelf", genericMethod, &receiveSelf_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveNullableSelf", genericMethod, &receiveNullableSelf_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveWeakSelf", genericMethod, &receiveWeakSelf_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveWeakNullableSelf", genericMethod, &receiveWeakNullableSelf_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passSelf", genericMethod, &passSelf_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passSelf2", genericMethod, &passSelf2_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passNullableSelf", genericMethod, &passNullableSelf_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalSelf", genericMethod, &passOptionalSelf_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalNonNullSelf", genericMethod, &passOptionalNonNullSelf_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalSelfWithDefault", genericMethod, &passOptionalSelfWithDefault_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveNonWrapperCacheInterface", genericMethod, &receiveNonWrapperCacheInterface_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveNullableNonWrapperCacheInterface", genericMethod, &receiveNullableNonWrapperCacheInterface_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveNonWrapperCacheInterfaceSequence", genericMethod, &receiveNonWrapperCacheInterfaceSequence_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveNullableNonWrapperCacheInterfaceSequence", genericMethod, &receiveNullableNonWrapperCacheInterfaceSequence_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveNonWrapperCacheInterfaceNullableSequence", genericMethod, &receiveNonWrapperCacheInterfaceNullableSequence_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveNullableNonWrapperCacheInterfaceNullableSequence", genericMethod, &receiveNullableNonWrapperCacheInterfaceNullableSequence_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveOther", genericMethod, &receiveOther_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveNullableOther", genericMethod, &receiveNullableOther_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveWeakOther", genericMethod, &receiveWeakOther_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveWeakNullableOther", genericMethod, &receiveWeakNullableOther_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOther", genericMethod, &passOther_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passOther2", genericMethod, &passOther2_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passNullableOther", genericMethod, &passNullableOther_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalOther", genericMethod, &passOptionalOther_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalNonNullOther", genericMethod, &passOptionalNonNullOther_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalOtherWithDefault", genericMethod, &passOptionalOtherWithDefault_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveExternal", genericMethod, &receiveExternal_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveNullableExternal", genericMethod, &receiveNullableExternal_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveWeakExternal", genericMethod, &receiveWeakExternal_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveWeakNullableExternal", genericMethod, &receiveWeakNullableExternal_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passExternal", genericMethod, &passExternal_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passExternal2", genericMethod, &passExternal2_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passNullableExternal", genericMethod, &passNullableExternal_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalExternal", genericMethod, &passOptionalExternal_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalNonNullExternal", genericMethod, &passOptionalNonNullExternal_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalExternalWithDefault", genericMethod, &passOptionalExternalWithDefault_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveCallbackInterface", genericMethod, &receiveCallbackInterface_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveNullableCallbackInterface", genericMethod, &receiveNullableCallbackInterface_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveWeakCallbackInterface", genericMethod, &receiveWeakCallbackInterface_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveWeakNullableCallbackInterface", genericMethod, &receiveWeakNullableCallbackInterface_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passCallbackInterface", genericMethod, &passCallbackInterface_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passCallbackInterface2", genericMethod, &passCallbackInterface2_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passNullableCallbackInterface", genericMethod, &passNullableCallbackInterface_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalCallbackInterface", genericMethod, &passOptionalCallbackInterface_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalNonNullCallbackInterface", genericMethod, &passOptionalNonNullCallbackInterface_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalCallbackInterfaceWithDefault", genericMethod, &passOptionalCallbackInterfaceWithDefault_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveConsequentialInterface", genericMethod, &receiveConsequentialInterface_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passConsequentialInterface", genericMethod, &passConsequentialInterface_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("receiveSequence", genericMethod, &receiveSequence_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveNullableSequence", genericMethod, &receiveNullableSequence_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveSequenceOfNullableInts", genericMethod, &receiveSequenceOfNullableInts_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveNullableSequenceOfNullableInts", genericMethod, &receiveNullableSequenceOfNullableInts_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passSequence", genericMethod, &passSequence_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passNullableSequence", genericMethod, &passNullableSequence_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passSequenceOfNullableInts", genericMethod, &passSequenceOfNullableInts_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalSequenceOfNullableInts", genericMethod, &passOptionalSequenceOfNullableInts_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalNullableSequenceOfNullableInts", genericMethod, &passOptionalNullableSequenceOfNullableInts_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveCastableObjectSequence", genericMethod, &receiveCastableObjectSequence_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveCallbackObjectSequence", genericMethod, &receiveCallbackObjectSequence_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveNullableCastableObjectSequence", genericMethod, &receiveNullableCastableObjectSequence_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveNullableCallbackObjectSequence", genericMethod, &receiveNullableCallbackObjectSequence_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveCastableObjectNullableSequence", genericMethod, &receiveCastableObjectNullableSequence_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveNullableCastableObjectNullableSequence", genericMethod, &receiveNullableCastableObjectNullableSequence_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveWeakCastableObjectSequence", genericMethod, &receiveWeakCastableObjectSequence_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveWeakNullableCastableObjectSequence", genericMethod, &receiveWeakNullableCastableObjectSequence_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveWeakCastableObjectNullableSequence", genericMethod, &receiveWeakCastableObjectNullableSequence_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveWeakNullableCastableObjectNullableSequence", genericMethod, &receiveWeakNullableCastableObjectNullableSequence_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passCastableObjectSequence", genericMethod, &passCastableObjectSequence_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passNullableCastableObjectSequence", genericMethod, &passNullableCastableObjectSequence_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passCastableObjectNullableSequence", genericMethod, &passCastableObjectNullableSequence_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passNullableCastableObjectNullableSequence", genericMethod, &passNullableCastableObjectNullableSequence_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalSequence", genericMethod, &passOptionalSequence_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalNullableSequence", genericMethod, &passOptionalNullableSequence_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalNullableSequenceWithDefaultValue", genericMethod, &passOptionalNullableSequenceWithDefaultValue_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalObjectSequence", genericMethod, &passOptionalObjectSequence_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passExternalInterfaceSequence", genericMethod, &passExternalInterfaceSequence_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passNullableExternalInterfaceSequence", genericMethod, &passNullableExternalInterfaceSequence_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("receiveStringSequence", genericMethod, &receiveStringSequence_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passStringSequence", genericMethod, &passStringSequence_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("receiveAnySequence", genericMethod, &receiveAnySequence_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveNullableAnySequence", genericMethod, &receiveNullableAnySequence_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passArrayBuffer", genericMethod, &passArrayBuffer_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passNullableArrayBuffer", genericMethod, &passNullableArrayBuffer_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalArrayBuffer", genericMethod, &passOptionalArrayBuffer_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalNullableArrayBuffer", genericMethod, &passOptionalNullableArrayBuffer_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalNullableArrayBufferWithDefaultValue", genericMethod, &passOptionalNullableArrayBufferWithDefaultValue_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passArrayBufferView", genericMethod, &passArrayBufferView_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passInt8Array", genericMethod, &passInt8Array_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passInt16Array", genericMethod, &passInt16Array_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passInt32Array", genericMethod, &passInt32Array_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passUint8Array", genericMethod, &passUint8Array_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passUint16Array", genericMethod, &passUint16Array_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passUint32Array", genericMethod, &passUint32Array_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passUint8ClampedArray", genericMethod, &passUint8ClampedArray_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passFloat32Array", genericMethod, &passFloat32Array_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passFloat64Array", genericMethod, &passFloat64Array_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("receiveUint8Array", genericMethod, &receiveUint8Array_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passString", genericMethod, &passString_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passNullableString", genericMethod, &passNullableString_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalString", genericMethod, &passOptionalString_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalStringWithDefaultValue", genericMethod, &passOptionalStringWithDefaultValue_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalNullableString", genericMethod, &passOptionalNullableString_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalNullableStringWithDefaultValue", genericMethod, &passOptionalNullableStringWithDefaultValue_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passVariadicString", genericMethod, &passVariadicString_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passEnum", genericMethod, &passEnum_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalEnum", genericMethod, &passOptionalEnum_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passEnumWithDefault", genericMethod, &passEnumWithDefault_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveEnum", genericMethod, &receiveEnum_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passCallback", genericMethod, &passCallback_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passNullableCallback", genericMethod, &passNullableCallback_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalCallback", genericMethod, &passOptionalCallback_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalNullableCallback", genericMethod, &passOptionalNullableCallback_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalNullableCallbackWithDefaultValue", genericMethod, &passOptionalNullableCallbackWithDefaultValue_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveCallback", genericMethod, &receiveCallback_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveNullableCallback", genericMethod, &receiveNullableCallback_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passNullableTreatAsNullCallback", genericMethod, &passNullableTreatAsNullCallback_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalNullableTreatAsNullCallback", genericMethod, &passOptionalNullableTreatAsNullCallback_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalNullableTreatAsNullCallbackWithDefaultValue", genericMethod, &passOptionalNullableTreatAsNullCallbackWithDefaultValue_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passAny", genericMethod, &passAny_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalAny", genericMethod, &passOptionalAny_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passAnyDefaultNull", genericMethod, &passAnyDefaultNull_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveAny", genericMethod, &receiveAny_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passObject", genericMethod, &passObject_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passNullableObject", genericMethod, &passNullableObject_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalObject", genericMethod, &passOptionalObject_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalNullableObject", genericMethod, &passOptionalNullableObject_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalNullableObjectWithDefaultValue", genericMethod, &passOptionalNullableObjectWithDefaultValue_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveObject", genericMethod, &receiveObject_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("receiveNullableObject", genericMethod, &receiveNullableObject_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passUnion", genericMethod, &passUnion_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passUnionWithNullable", genericMethod, &passUnionWithNullable_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passNullableUnion", genericMethod, &passNullableUnion_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalUnion", genericMethod, &passOptionalUnion_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalNullableUnion", genericMethod, &passOptionalNullableUnion_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOptionalNullableUnionWithDefaultValue", genericMethod, &passOptionalNullableUnionWithDefaultValue_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passUnionWithArrayBuffer", genericMethod, &passUnionWithArrayBuffer_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passUnionWithString", genericMethod, &passUnionWithString_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passUnionWithObject", genericMethod, &passUnionWithObject_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("methodRenamedFrom", genericMethod, &methodRenamedFrom_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passDictionary", genericMethod, &passDictionary_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passOtherDictionary", genericMethod, &passOtherDictionary_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passSequenceOfDictionaries", genericMethod, &passSequenceOfDictionaries_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passDictionaryOrLong", genericMethod, &passDictionaryOrLong_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passDictContainingDict", genericMethod, &passDictContainingDict_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("passDictContainingSequence", genericMethod, &passDictContainingSequence_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("dontEnforceRangeOrClamp", genericMethod, &dontEnforceRangeOrClamp_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("doEnforceRange", genericMethod, &doEnforceRange_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("doClamp", genericMethod, &doClamp_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("exerciseTypedefInterfaces1", genericMethod, &exerciseTypedefInterfaces1_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("exerciseTypedefInterfaces2", genericMethod, &exerciseTypedefInterfaces2_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("exerciseTypedefInterfaces3", genericMethod, &exerciseTypedefInterfaces3_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("overload1", genericMethod, &overload1_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("overload2", genericMethod, &overload2_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("overload3", genericMethod, &overload3_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("overload4", genericMethod, &overload4_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("passVariadicThirdArg", genericMethod, &passVariadicThirdArg_methodinfo, 2, JSPROP_ENUMERATE),
  JS_FNINFO("passRenamedInterface", genericMethod, &passRenamedInterface_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("throwingMethod", genericMethod, &throwingMethod_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("toString", genericMethod, &__stringifier_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FS_END
};

static Prefable<JSFunctionSpec> sMethods[] = {
  { true, &sMethods_specs[0] },
  { false, NULL }
};

static jsid sMethods_ids[197] = { JSID_VOID };

static JSFunctionSpec sChromeMethods_specs[] = {
  JS_FNINFO("QueryInterface", QueryInterface, nullptr, 1, 0),
  JS_FS_END
};

static Prefable<JSFunctionSpec> sChromeMethods[] = {
  { true, &sChromeMethods_specs[0] },
  { false, NULL }
};

static jsid sChromeMethods_ids[2] = { JSID_VOID };

static JSPropertySpec sAttributes_specs[] = {
  { "readonlyByte", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &readonlyByte_getterinfo }, JSOP_NULLWRAPPER},
  { "writableByte", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &writableByte_getterinfo }, { (JSStrictPropertyOp)genericSetter, &writableByte_setterinfo }},
  { "readonlyShort", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &readonlyShort_getterinfo }, JSOP_NULLWRAPPER},
  { "writableShort", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &writableShort_getterinfo }, { (JSStrictPropertyOp)genericSetter, &writableShort_setterinfo }},
  { "readonlyLong", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &readonlyLong_getterinfo }, JSOP_NULLWRAPPER},
  { "writableLong", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &writableLong_getterinfo }, { (JSStrictPropertyOp)genericSetter, &writableLong_setterinfo }},
  { "readonlyLongLong", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &readonlyLongLong_getterinfo }, JSOP_NULLWRAPPER},
  { "writableLongLong", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &writableLongLong_getterinfo }, { (JSStrictPropertyOp)genericSetter, &writableLongLong_setterinfo }},
  { "readonlyOctet", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &readonlyOctet_getterinfo }, JSOP_NULLWRAPPER},
  { "writableOctet", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &writableOctet_getterinfo }, { (JSStrictPropertyOp)genericSetter, &writableOctet_setterinfo }},
  { "readonlyUnsignedShort", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &readonlyUnsignedShort_getterinfo }, JSOP_NULLWRAPPER},
  { "writableUnsignedShort", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &writableUnsignedShort_getterinfo }, { (JSStrictPropertyOp)genericSetter, &writableUnsignedShort_setterinfo }},
  { "readonlyUnsignedLong", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &readonlyUnsignedLong_getterinfo }, JSOP_NULLWRAPPER},
  { "writableUnsignedLong", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &writableUnsignedLong_getterinfo }, { (JSStrictPropertyOp)genericSetter, &writableUnsignedLong_setterinfo }},
  { "readonlyUnsignedLongLong", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &readonlyUnsignedLongLong_getterinfo }, JSOP_NULLWRAPPER},
  { "writableUnsignedLongLong", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &writableUnsignedLongLong_getterinfo }, { (JSStrictPropertyOp)genericSetter, &writableUnsignedLongLong_setterinfo }},
  { "writableFloat", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &writableFloat_getterinfo }, { (JSStrictPropertyOp)genericSetter, &writableFloat_setterinfo }},
  { "writableUnrestrictedFloat", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &writableUnrestrictedFloat_getterinfo }, { (JSStrictPropertyOp)genericSetter, &writableUnrestrictedFloat_setterinfo }},
  { "writableNullableFloat", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &writableNullableFloat_getterinfo }, { (JSStrictPropertyOp)genericSetter, &writableNullableFloat_setterinfo }},
  { "writableNullableUnrestrictedFloat", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &writableNullableUnrestrictedFloat_getterinfo }, { (JSStrictPropertyOp)genericSetter, &writableNullableUnrestrictedFloat_setterinfo }},
  { "writableDouble", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &writableDouble_getterinfo }, { (JSStrictPropertyOp)genericSetter, &writableDouble_setterinfo }},
  { "writableUnrestrictedDouble", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &writableUnrestrictedDouble_getterinfo }, { (JSStrictPropertyOp)genericSetter, &writableUnrestrictedDouble_setterinfo }},
  { "writableNullableDouble", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &writableNullableDouble_getterinfo }, { (JSStrictPropertyOp)genericSetter, &writableNullableDouble_setterinfo }},
  { "writableNullableUnrestrictedDouble", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &writableNullableUnrestrictedDouble_getterinfo }, { (JSStrictPropertyOp)genericSetter, &writableNullableUnrestrictedDouble_setterinfo }},
  { "lenientFloatAttr", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &lenientFloatAttr_getterinfo }, { (JSStrictPropertyOp)genericSetter, &lenientFloatAttr_setterinfo }},
  { "lenientDoubleAttr", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &lenientDoubleAttr_getterinfo }, { (JSStrictPropertyOp)genericSetter, &lenientDoubleAttr_setterinfo }},
  { "nonNullSelf", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &nonNullSelf_getterinfo }, { (JSStrictPropertyOp)genericSetter, &nonNullSelf_setterinfo }},
  { "nullableSelf", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &nullableSelf_getterinfo }, { (JSStrictPropertyOp)genericSetter, &nullableSelf_setterinfo }},
  { "nonNullOther", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &nonNullOther_getterinfo }, { (JSStrictPropertyOp)genericSetter, &nonNullOther_setterinfo }},
  { "nullableOther", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &nullableOther_getterinfo }, { (JSStrictPropertyOp)genericSetter, &nullableOther_setterinfo }},
  { "nonNullExternal", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &nonNullExternal_getterinfo }, { (JSStrictPropertyOp)genericSetter, &nonNullExternal_setterinfo }},
  { "nullableExternal", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &nullableExternal_getterinfo }, { (JSStrictPropertyOp)genericSetter, &nullableExternal_setterinfo }},
  { "nonNullCallbackInterface", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &nonNullCallbackInterface_getterinfo }, { (JSStrictPropertyOp)genericSetter, &nonNullCallbackInterface_setterinfo }},
  { "nullableCallbackInterface", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &nullableCallbackInterface_getterinfo }, { (JSStrictPropertyOp)genericSetter, &nullableCallbackInterface_setterinfo }},
  { "enumAttribute", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &enumAttribute_getterinfo }, { (JSStrictPropertyOp)genericSetter, &enumAttribute_setterinfo }},
  { "readonlyEnumAttribute", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &readonlyEnumAttribute_getterinfo }, JSOP_NULLWRAPPER},
  { "attributeGetterRenamedFrom", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &attributeGetterRenamedFrom_getterinfo }, JSOP_NULLWRAPPER},
  { "attributeRenamedFrom", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &attributeRenamedFrom_getterinfo }, { (JSStrictPropertyOp)genericSetter, &attributeRenamedFrom_setterinfo }},
  { "attrWithLenientThis", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericLenientGetter, &attrWithLenientThis_getterinfo }, { (JSStrictPropertyOp)genericLenientSetter, &attrWithLenientThis_setterinfo }},
  { "putForwardsAttr", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &putForwardsAttr_getterinfo }, { (JSStrictPropertyOp)genericSetter, &putForwardsAttr_setterinfo }},
  { "putForwardsAttr2", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericLenientGetter, &putForwardsAttr2_getterinfo }, { (JSStrictPropertyOp)genericLenientSetter, &putForwardsAttr2_setterinfo }},
  { "throwingAttr", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &throwingAttr_getterinfo }, { (JSStrictPropertyOp)genericSetter, &throwingAttr_setterinfo }},
  { "throwingGetterAttr", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &throwingGetterAttr_getterinfo }, { (JSStrictPropertyOp)genericSetter, &throwingGetterAttr_setterinfo }},
  { "throwingSetterAttr", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &throwingSetterAttr_getterinfo }, { (JSStrictPropertyOp)genericSetter, &throwingSetterAttr_setterinfo }},
  { 0, 0, 0, JSOP_NULLWRAPPER, JSOP_NULLWRAPPER }
};

static Prefable<JSPropertySpec> sAttributes[] = {
  { true, &sAttributes_specs[0] },
  { false, NULL }
};

static jsid sAttributes_ids[45] = { JSID_VOID };

static JSPropertySpec sChromeAttributes_specs[] = {
  { "putForwardsAttr3", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &putForwardsAttr3_getterinfo }, { (JSStrictPropertyOp)genericSetter, &putForwardsAttr3_setterinfo }},
  { 0, 0, 0, JSOP_NULLWRAPPER, JSOP_NULLWRAPPER }
};

static Prefable<JSPropertySpec> sChromeAttributes[] = {
  { true, &sChromeAttributes_specs[0] },
  { false, NULL }
};

static jsid sChromeAttributes_ids[2] = { JSID_VOID };

static JSPropertySpec sUnforgeableAttributes_specs[] = {
  { "unforgeableAttr", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS | JSPROP_PERMANENT, { (JSPropertyOp)genericGetter, &unforgeableAttr_getterinfo }, JSOP_NULLWRAPPER},
  { 0, 0, 0, JSOP_NULLWRAPPER, JSOP_NULLWRAPPER }
};

static Prefable<JSPropertySpec> sUnforgeableAttributes[] = {
  { true, &sUnforgeableAttributes_specs[0] },
  { false, NULL }
};

static jsid sUnforgeableAttributes_ids[2] = { JSID_VOID };

static JSPropertySpec sChromeUnforgeableAttributes_specs[] = {
  { "unforgeableAttr2", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS | JSPROP_PERMANENT, { (JSPropertyOp)genericGetter, &unforgeableAttr2_getterinfo }, JSOP_NULLWRAPPER},
  { 0, 0, 0, JSOP_NULLWRAPPER, JSOP_NULLWRAPPER }
};

static Prefable<JSPropertySpec> sChromeUnforgeableAttributes[] = {
  { true, &sChromeUnforgeableAttributes_specs[0] },
  { false, NULL }
};

static jsid sChromeUnforgeableAttributes_ids[2] = { JSID_VOID };

static ConstantSpec sConstants_specs[] = {
  { "myLongConstant", INT_TO_JSVAL(5) },
  { 0, JSVAL_VOID }
};

static Prefable<ConstantSpec> sConstants[] = {
  { true, &sConstants_specs[0] },
  { false, NULL }
};

static jsid sConstants_ids[2] = { JSID_VOID };


static const NativeProperties sNativeProperties = {
  sStaticMethods, sStaticMethods_ids, sStaticMethods_specs,
  sStaticAttributes, sStaticAttributes_ids, sStaticAttributes_specs,
  sMethods, sMethods_ids, sMethods_specs,
  sAttributes, sAttributes_ids, sAttributes_specs,
  sUnforgeableAttributes, sUnforgeableAttributes_ids, sUnforgeableAttributes_specs,
  sConstants, sConstants_ids, sConstants_specs
};

static const NativeProperties sChromeOnlyNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sChromeMethods, sChromeMethods_ids, sChromeMethods_specs,
  sChromeAttributes, sChromeAttributes_ids, sChromeAttributes_specs,
  sChromeUnforgeableAttributes, sChromeUnforgeableAttributes_ids, sChromeUnforgeableAttributes_specs,
  nullptr, nullptr, nullptr
};
const NativePropertyHooks sNativePropertyHooks = {
  nullptr,
  nullptr,
  { &sNativeProperties, &sChromeOnlyNativeProperties },
  prototypes::id::TestExampleInterface,
  constructors::id::TestExampleInterface,
  NULL
};

static JSBool
_constructor(JSContext* cx, unsigned argc, JS::Value* vp)
{

  JSObject* obj = JS_GetGlobalForObject(cx, JSVAL_TO_OBJECT(JS_CALLEE(cx, vp)));

  nsISupports* global;
  xpc_qsSelfRef globalRef;
  {
    nsresult rv;
    JS::Value val = OBJECT_TO_JSVAL(obj);
    rv = xpc_qsUnwrapArg<nsISupports>(cx, val, &global, &globalRef.ptr, &val);
    if (NS_FAILED(rv)) {
      return ThrowErrorMessage(cx, MSG_GLOBAL_NOT_NATIVE);
    }
  }

  unsigned argcount = NS_MIN(argc, 2u);
  switch (argcount) {
    case 0: {
      ErrorResult rv;
      nsRefPtr<mozilla::dom::TestExampleInterface> result;
      result = mozilla::dom::TestExampleInterface::Constructor(global, rv);
      if (rv.Failed()) {
        return ThrowMethodFailedWithDetails<true>(cx, rv, "TestExampleInterface", "constructor");
      }
      if (!WrapNewBindingObject(cx, obj, result, vp)) {
        MOZ_ASSERT(JS_IsExceptionPending(cx));
        return false;
      }
      return true;
      break;
    }
    case 1: {
      JS::Value* argv_start = JS_ARGV(cx, vp);
      if (argv_start[0].isNullOrUndefined()) {
        mozilla::dom::TestInterface* arg0;
        arg0 = NULL;
        ErrorResult rv;
        nsRefPtr<mozilla::dom::TestExampleInterface> result;
        result = mozilla::dom::TestExampleInterface::Constructor(global, arg0, rv);
        if (rv.Failed()) {
          return ThrowMethodFailedWithDetails<true>(cx, rv, "TestExampleInterface", "constructor");
        }
        if (!WrapNewBindingObject(cx, obj, result, vp)) {
          MOZ_ASSERT(JS_IsExceptionPending(cx));
          return false;
        }
        return true;
      }
      if (argv_start[0].isObject()) {
        do {
          mozilla::dom::TestInterface* arg0;
          {
            nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(cx, &argv_start[0].toObject(), arg0);
            if (NS_FAILED(rv)) {
              break;
            }
          }
          ErrorResult rv;
          nsRefPtr<mozilla::dom::TestExampleInterface> result;
          result = mozilla::dom::TestExampleInterface::Constructor(global, arg0, rv);
          if (rv.Failed()) {
            return ThrowMethodFailedWithDetails<true>(cx, rv, "TestExampleInterface", "constructor");
          }
          if (!WrapNewBindingObject(cx, obj, result, vp)) {
            MOZ_ASSERT(JS_IsExceptionPending(cx));
            return false;
          }
          return true;
        } while (0);
        do {
          nsRefPtr<mozilla::dom::TestNonCastableInterface> arg0_holder;
          NonNull<mozilla::dom::TestNonCastableInterface> arg0;
          jsval tmpVal = argv_start[0];
          mozilla::dom::TestNonCastableInterface* tmp;
          if (NS_FAILED(xpc_qsUnwrapArg<mozilla::dom::TestNonCastableInterface>(cx, argv_start[0], &tmp, static_cast<mozilla::dom::TestNonCastableInterface**>(getter_AddRefs(arg0_holder)), &tmpVal))) {
            break;
          }
          MOZ_ASSERT(tmp);
          arg0 = tmp;
          ErrorResult rv;
          nsRefPtr<mozilla::dom::TestExampleInterface> result;
          result = mozilla::dom::TestExampleInterface::Constructor(global, arg0, rv);
          if (rv.Failed()) {
            return ThrowMethodFailedWithDetails<true>(cx, rv, "TestExampleInterface", "constructor");
          }
          if (!WrapNewBindingObject(cx, obj, result, vp)) {
            MOZ_ASSERT(JS_IsExceptionPending(cx));
            return false;
          }
          return true;
        } while (0);
      }

      JS::Value* argv = JS_ARGV(cx, vp);

      FakeDependentString arg0_holder;
      const NonNull<nsAString> arg0;
      if (!ConvertJSValueToString(cx, argv[0], &argv[0], eStringify, eStringify, arg0_holder)) {
        return false;
      }
      const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
      ErrorResult rv;
      nsRefPtr<mozilla::dom::TestExampleInterface> result;
      result = mozilla::dom::TestExampleInterface::Constructor(global, arg0, rv);
      if (rv.Failed()) {
        return ThrowMethodFailedWithDetails<true>(cx, rv, "TestExampleInterface", "constructor");
      }
      if (!WrapNewBindingObject(cx, obj, result, vp)) {
        MOZ_ASSERT(JS_IsExceptionPending(cx));
        return false;
      }
      return true;
      break;
    }
    case 2: {

      JS::Value* argv = JS_ARGV(cx, vp);

      uint32_t arg0;
      if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[0], &arg0)) {
        return false;
      }
      const Nullable<bool> arg1;
      if (argv[1].isNullOrUndefined()) {
        const_cast< Nullable<bool>& >(arg1).SetNull();
      } else if (!ValueToPrimitive<bool, eDefault>(cx, argv[1], &const_cast< Nullable<bool>& >(arg1).SetValue())) {
        return false;
      }
      ErrorResult rv;
      nsRefPtr<mozilla::dom::TestExampleInterface> result;
      result = mozilla::dom::TestExampleInterface::Constructor(global, arg0, arg1, rv);
      if (rv.Failed()) {
        return ThrowMethodFailedWithDetails<true>(cx, rv, "TestExampleInterface", "constructor");
      }
      if (!WrapNewBindingObject(cx, obj, result, vp)) {
        MOZ_ASSERT(JS_IsExceptionPending(cx));
        return false;
      }
      return true;
      break;
    }
    default: {
      return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleInterface.constructor");

      break;
    }
  }
  MOZ_NOT_REACHED("We have an always-returning default case");
  return false;
}

JSNativeHolder _constructor_holder = {
  _constructor,
  &sNativePropertyHooks
};

static DOMIfaceAndProtoJSClass PrototypeClass = {
  {
    "TestExampleInterfacePrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(2),
    JS_PropertyStub,       /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    nullptr,               /* finalize */
    nullptr,               /* checkAccess */
    nullptr,               /* call */
    nullptr,               /* hasInstance */
    nullptr,               /* construct */
    nullptr,               /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  eInterfacePrototype,
  &sNativePropertyHooks
};

void
CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray)
{
  JSObject* parentProto = JS_GetObjectPrototype(aCx, aGlobal);
  if (!parentProto) {
    return;
  }


  if (sStaticMethods_ids[0] == JSID_VOID &&
      (!InitIds(aCx, sStaticMethods, sStaticMethods_ids) ||
       !InitIds(aCx, sStaticAttributes, sStaticAttributes_ids) ||
       !InitIds(aCx, sChromeMethods, sChromeMethods_ids) ||
       !InitIds(aCx, sMethods, sMethods_ids) ||
       !InitIds(aCx, sChromeAttributes, sChromeAttributes_ids) ||
       !InitIds(aCx, sAttributes, sAttributes_ids) ||
       !InitIds(aCx, sChromeUnforgeableAttributes, sChromeUnforgeableAttributes_ids) ||
       !InitIds(aCx, sUnforgeableAttributes, sUnforgeableAttributes_ids) ||
       !InitIds(aCx, sConstants, sConstants_ids))) {
    sStaticMethods_ids[0] = JSID_VOID;
    return;
  }

  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &PrototypeClass.mBase, &protoAndIfaceArray[prototypes::id::TestExampleInterface],
                              nullptr, &_constructor_holder, 0, &protoAndIfaceArray[constructors::id::TestExampleInterface],
                              &Class.mClass,
                              &sNativeProperties,
                              xpc::AccessCheck::isChrome(aGlobal) ? &sChromeOnlyNativeProperties : nullptr,
                              "TestExampleInterface");
}

JSObject*
DefineDOMInterface(JSContext* aCx, JSObject* aGlobal, bool* aEnabled)
{

  *aEnabled = true;
  return GetConstructorObject(aCx, aGlobal);
}


DOMJSClass Class = {
  { "TestExampleInterface",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(3),
    _addProperty, /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    _finalize, /* finalize */
    NULL,                  /* checkAccess */
    NULL,                  /* call */
    NULL,                  /* hasInstance */
    NULL,                  /* construct */
    NULL, /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  {
    { prototypes::id::TestExampleInterface, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
    true,
    &sNativePropertyHooks,
    GetParentObject<mozilla::dom::TestExampleInterface>::Get,
    GetProtoObject,
    nullptr
  }
};

JSObject*
Wrap(JSContext* aCx, JSObject* aScope, mozilla::dom::TestExampleInterface* aObject, nsWrapperCache* aCache, bool* aTriedToWrap)
{
  MOZ_ASSERT(static_cast<mozilla::dom::TestExampleInterface*>(aObject) ==
             reinterpret_cast<mozilla::dom::TestExampleInterface*>(aObject));

  *aTriedToWrap = true;

  JSObject* parent = WrapNativeParent(aCx, aScope, aObject->GetParentObject());
  if (!parent) {
    return NULL;
  }

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.  Scope so we don't
  // collide with the "obj" we declare in CreateBindingJSObject.
  {
    JSObject* obj = aCache->GetWrapper();
    if (obj) {
      return obj;
    }
  }

  JSAutoCompartment ac(aCx, parent);
  JSObject* global = JS_GetGlobalForObject(aCx, parent);

  JSObject* proto = GetProtoObject(aCx, global);
  if (!proto) {
    return NULL;
  }

  JSObject* obj = JS_NewObject(aCx, &Class.mBase, proto, parent);
  if (!obj) {
    return NULL;
  }

  js::SetReservedSlot(obj, DOM_OBJECT_SLOT, PRIVATE_TO_JSVAL(aObject));
  NS_ADDREF(aObject);


  // Important: do unforgeable property setup after we have handed
  // over ownership of the C++ object to obj as needed, so that if
  // we fail and it ends up GCed it won't have problems in the
  // finalizer trying to drop its ownership of the C++ object.
  if (!DefineUnforgeableAttributes(aCx, obj, sUnforgeableAttributes)) {
    return nullptr;
  }
  if (xpc::AccessCheck::isChrome(global)) {
    if (!DefineUnforgeableAttributes(aCx, obj, sChromeUnforgeableAttributes)) {
      return nullptr;
    }
  }

  aCache->SetWrapper(obj);

  return obj;
}

} // namespace TestExampleInterfaceBinding



namespace TestExampleProxyInterfaceBinding {

static bool
longIndexedGetter(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleProxyInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleProxyInterface.longIndexedGetter");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  int32_t result;
  result = self->LongIndexedGetter(arg0);
  *vp = INT_TO_JSVAL(int32_t(result));
  return true;
}


const JSJitInfo longIndexedGetter_methodinfo = {
  (JSJitPropertyOp)longIndexedGetter,
  prototypes::id::TestExampleProxyInterface,
  PrototypeTraits<prototypes::id::TestExampleProxyInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

static bool
longIndexedSetter(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleProxyInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 2) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleProxyInterface.longIndexedSetter");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[0], &arg0)) {
    return false;
  }
  int32_t arg1;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, argv[1], &arg1)) {
    return false;
  }
  self->LongIndexedSetter(arg0, arg1);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo longIndexedSetter_methodinfo = {
  (JSJitPropertyOp)longIndexedSetter,
  prototypes::id::TestExampleProxyInterface,
  PrototypeTraits<prototypes::id::TestExampleProxyInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
myStringifier(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleProxyInterface* self, unsigned argc, JS::Value* vp)
{
  nsString result;
  self->MyStringifier(result);
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}


const JSJitInfo myStringifier_methodinfo = {
  (JSJitPropertyOp)myStringifier,
  prototypes::id::TestExampleProxyInterface,
  PrototypeTraits<prototypes::id::TestExampleProxyInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

static bool
shortNameGetter(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleProxyInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleProxyInterface.shortNameGetter");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eStringify, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  int16_t result;
  result = self->ShortNameGetter(arg0);
  *vp = INT_TO_JSVAL(int32_t(result));
  return true;
}


const JSJitInfo shortNameGetter_methodinfo = {
  (JSJitPropertyOp)shortNameGetter,
  prototypes::id::TestExampleProxyInterface,
  PrototypeTraits<prototypes::id::TestExampleProxyInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

static bool
shortNamedSetter(JSContext* cx, JSHandleObject obj, mozilla::dom::TestExampleProxyInterface* self, unsigned argc, JS::Value* vp)
{

  if (argc < 2) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "TestExampleProxyInterface.shortNamedSetter");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eStringify, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  int16_t arg1;
  if (!ValueToPrimitive<int16_t, eDefault>(cx, argv[1], &arg1)) {
    return false;
  }
  self->ShortNamedSetter(arg0, arg1);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo shortNamedSetter_methodinfo = {
  (JSJitPropertyOp)shortNamedSetter,
  prototypes::id::TestExampleProxyInterface,
  PrototypeTraits<prototypes::id::TestExampleProxyInterface>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static JSBool
genericMethod(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  mozilla::dom::TestExampleProxyInterface* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::TestExampleProxyInterface, mozilla::dom::TestExampleProxyInterface>(cx, obj, self);
    if (NS_FAILED(rv)) {
      return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "TestExampleProxyInterface");
    }
  }
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Method);
  JSJitMethodOp method = (JSJitMethodOp)info->op;
  return method(cx, obj, self, argc, vp);
}

static JSFunctionSpec sMethods_specs[] = {
  JS_FNINFO("longIndexedGetter", genericMethod, &longIndexedGetter_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("longIndexedSetter", genericMethod, &longIndexedSetter_methodinfo, 2, JSPROP_ENUMERATE),
  JS_FNINFO("myStringifier", genericMethod, &myStringifier_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("shortNameGetter", genericMethod, &shortNameGetter_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("shortNamedSetter", genericMethod, &shortNamedSetter_methodinfo, 2, JSPROP_ENUMERATE),
  JS_FNINFO("iterator", JS_ArrayIterator, nullptr, 0, JSPROP_ENUMERATE),
  JS_FNINFO("toString", genericMethod, &myStringifier_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FS_END
};

static Prefable<JSFunctionSpec> sMethods[] = {
  { true, &sMethods_specs[0] },
  { false, NULL }
};

static jsid sMethods_ids[8] = { JSID_VOID };

static JSFunctionSpec sChromeMethods_specs[] = {
  JS_FNINFO("QueryInterface", QueryInterface, nullptr, 1, 0),
  JS_FS_END
};

static Prefable<JSFunctionSpec> sChromeMethods[] = {
  { true, &sChromeMethods_specs[0] },
  { false, NULL }
};

static jsid sChromeMethods_ids[2] = { JSID_VOID };


static const NativeProperties sNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sMethods, sMethods_ids, sMethods_specs,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr
};

static const NativeProperties sChromeOnlyNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sChromeMethods, sChromeMethods_ids, sChromeMethods_specs,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr
};
const NativePropertyHooks sNativePropertyHooks = {
  ResolveOwnProperty,
  EnumerateOwnProperties,
  { &sNativeProperties, &sChromeOnlyNativeProperties },
  prototypes::id::TestExampleProxyInterface,
  constructors::id::TestExampleProxyInterface,
  NULL
};

JSNativeHolder _constructor_holder = {
  ThrowingConstructor,
  &sNativePropertyHooks
};

static DOMIfaceAndProtoJSClass PrototypeClass = {
  {
    "TestExampleProxyInterfacePrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(2),
    JS_PropertyStub,       /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    nullptr,               /* finalize */
    nullptr,               /* checkAccess */
    nullptr,               /* call */
    nullptr,               /* hasInstance */
    nullptr,               /* construct */
    nullptr,               /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  eInterfacePrototype,
  &sNativePropertyHooks
};

void
CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray)
{
  JSObject* parentProto = JS_GetObjectPrototype(aCx, aGlobal);
  if (!parentProto) {
    return;
  }


  if (sChromeMethods_ids[0] == JSID_VOID &&
      (!InitIds(aCx, sChromeMethods, sChromeMethods_ids) ||
       !InitIds(aCx, sMethods, sMethods_ids))) {
    sChromeMethods_ids[0] = JSID_VOID;
    return;
  }

  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &PrototypeClass.mBase, &protoAndIfaceArray[prototypes::id::TestExampleProxyInterface],
                              nullptr, &_constructor_holder, 0, &protoAndIfaceArray[constructors::id::TestExampleProxyInterface],
                              &Class,
                              &sNativeProperties,
                              xpc::AccessCheck::isChrome(aGlobal) ? &sChromeOnlyNativeProperties : nullptr,
                              "TestExampleProxyInterface");
}

bool
ResolveOwnProperty(JSContext* cx, JSObject* wrapper, JSObject* obj, jsid id, JSPropertyDescriptor* desc, unsigned flags)
{
  // We rely on getOwnPropertyDescriptor not shadowing prototype properties by named
  // properties. If that changes we'll need to filter here.
  return js::GetProxyHandler(obj)->getOwnPropertyDescriptor(cx, wrapper, id, desc, flags);

}

bool
EnumerateOwnProperties(JSContext* cx, JSObject* wrapper, JSObject* obj, JS::AutoIdVector& props)
{
  // We rely on getOwnPropertyNames not shadowing prototype properties by named
  // properties. If that changes we'll need to filter here.
  return js::GetProxyHandler(obj)->getOwnPropertyNames(cx, wrapper, props);

}

JSObject*
DefineDOMInterface(JSContext* aCx, JSObject* aGlobal, bool* aEnabled)
{

  *aEnabled = true;
  return GetConstructorObject(aCx, aGlobal);
}

MOZ_ALWAYS_INLINE bool
IsProxy(JSObject* obj)
{
  return js::IsProxy(obj) && js::GetProxyHandler(obj) == DOMProxyHandler::getInstance();
}

MOZ_ALWAYS_INLINE mozilla::dom::TestExampleProxyInterface*
UnwrapProxy(JSObject* obj)
{
  if (xpc::WrapperFactory::IsXrayWrapper(obj)) {
    obj = js::UnwrapObject(obj);
  }
  MOZ_ASSERT(IsProxy(obj));
  return static_cast<mozilla::dom::TestExampleProxyInterface*>(js::GetProxyPrivate(obj).toPrivate());
}


const DOMClass Class = {
  { prototypes::id::TestExampleProxyInterface, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
  true,
  &sNativePropertyHooks,
  GetParentObject<mozilla::dom::TestExampleProxyInterface>::Get,
  GetProtoObject,
  nullptr
};



DOMProxyHandler::DOMProxyHandler()
  : mozilla::dom::DOMProxyHandler(Class)
{

}


bool
DOMProxyHandler::getOwnPropertyDescriptor(JSContext* cx, JSObject* proxy, jsid id, JSPropertyDescriptor* desc, unsigned flags)
{
  int32_t index = GetArrayIndexFromId(cx, id);
  if (flags & JSRESOLVE_ASSIGNING) {
    if (IsArrayIndex(index)) {
      FillPropertyDescriptor(desc, proxy, JSVAL_VOID, false);
      return true;
    }
    FillPropertyDescriptor(desc, proxy, JSVAL_VOID, false);
    return true;
  } else {
    if (IsArrayIndex(index)) {
      uint32_t ix = index;
      mozilla::dom::TestExampleProxyInterface* self = UnwrapProxy(proxy);
      bool found;
      int32_t result;
      result = self->IndexedGetter(ix, found);

      if (found) {
        desc->value = INT_TO_JSVAL(int32_t(result));
        FillPropertyDescriptor(desc, proxy, false);
        return true;
      }
    }
  }

  JSObject* expando;
  if (!xpc::WrapperFactory::IsXrayWrapper(proxy) && (expando = GetExpandoObject(proxy))) {
    if (!JS_GetPropertyDescriptorById(cx, expando, id, flags, desc)) {
      return false;
    }
    if (desc->obj) {
      // Pretend the property lives on the wrapper.
      desc->obj = proxy;
      return true;
    }
  }

  if (!IsArrayIndex(index) && !(flags & JSRESOLVE_ASSIGNING) && !HasPropertyOnPrototype(cx, proxy, this, id)) {
    JS::Value nameVal = js::IdToValue(id);
    FakeDependentString nom;
    if (!ConvertJSValueToString(cx, nameVal, &nameVal,
                                eStringify, eStringify, nom)) {
      return false;
    }

    mozilla::dom::TestExampleProxyInterface* self = UnwrapProxy(proxy);
    bool found;
    int16_t result;
    result = self->NamedGetter(nom, found);

    if (found) {
      desc->value = INT_TO_JSVAL(int32_t(result));
      FillPropertyDescriptor(desc, proxy, false);
      return true;
    }
  }

  desc->obj = NULL;
  return true;
}


bool
DOMProxyHandler::defineProperty(JSContext* cx, JSObject* proxy, jsid id, JSPropertyDescriptor* desc)
{
  int32_t index = GetArrayIndexFromId(cx, id);
  if (IsArrayIndex(index)) {
    uint32_t y = index;
    mozilla::dom::TestExampleProxyInterface* self = UnwrapProxy(proxy);
    int32_t z;
    if (!ValueToPrimitive<int32_t, eDefault>(cx, desc->value, &z)) {
      return false;
    }
    self->IndexedSetter(y, z);
    return true;
  }
  JS::Value nameVal = js::IdToValue(id);
  FakeDependentString me;
  if (!ConvertJSValueToString(cx, nameVal, &nameVal,
                              eStringify, eStringify, me)) {
    return false;
  }

  mozilla::dom::TestExampleProxyInterface* self = UnwrapProxy(proxy);
  int16_t value;
  if (!ValueToPrimitive<int16_t, eDefault>(cx, desc->value, &value)) {
    return false;
  }
  self->NamedSetter(me, value);

  return true;

}


bool
DOMProxyHandler::getOwnPropertyNames(JSContext* cx, JSObject* proxy, JS::AutoIdVector& props)
{
  uint32_t length = UnwrapProxy(proxy)->Length();
  MOZ_ASSERT(int32_t(length) >= 0);
  for (int32_t i = 0; i < int32_t(length); ++i) {
    if (!props.append(INT_TO_JSID(i))) {
      return false;
    }
  }

  nsTArray<nsString> names;
  UnwrapProxy(proxy)->GetSupportedNames(names);
  if (!AppendNamedPropertyIds(cx, proxy, names, props)) {
    return false;
  }

  JSObject* expando;
  if (!xpc::WrapperFactory::IsXrayWrapper(proxy) && (expando = DOMProxyHandler::GetExpandoObject(proxy)) &&
      !js::GetPropertyNames(cx, expando, JSITER_OWNONLY | JSITER_HIDDEN, &props)) {
    return false;
  }

  return true;
}


bool
DOMProxyHandler::hasOwn(JSContext* cx, JSObject* proxy, jsid id, bool* bp)
{
  int32_t index = GetArrayIndexFromId(cx, id);
  if (IsArrayIndex(index)) {
    uint32_t ix = index;
    mozilla::dom::TestExampleProxyInterface* self = UnwrapProxy(proxy);
    bool found;
    int32_t result;
    result = self->IndexedGetter(ix, found);
    (void)result;

    *bp = found;
    return true;
  }

  JSObject* expando = GetExpandoObject(proxy);
  if (expando) {
    JSBool b = true;
    JSBool ok = JS_HasPropertyById(cx, expando, id, &b);
    *bp = !!b;
    if (!ok || *bp) {
      return ok;
    }
  }

  if (!HasPropertyOnPrototype(cx, proxy, this, id)) {
    JS::Value nameVal = js::IdToValue(id);
    FakeDependentString nom;
    if (!ConvertJSValueToString(cx, nameVal, &nameVal,
                                eStringify, eStringify, nom)) {
      return false;
    }

    mozilla::dom::TestExampleProxyInterface* self = UnwrapProxy(proxy);
    bool found;
    int16_t result;
    result = self->NamedGetter(nom, found);
    (void)result;

    *bp = found;
    return true;
  }

  *bp = false;
  return true;
}


bool
DOMProxyHandler::get(JSContext* cx, JSObject* proxy, JSObject* receiver, jsid id, JS::Value* vp)
{
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
              "Should not have a XrayWrapper here");

  int32_t index = GetArrayIndexFromId(cx, id);
  if (IsArrayIndex(index)) {
    uint32_t ix = index;
    mozilla::dom::TestExampleProxyInterface* self = UnwrapProxy(proxy);
    bool found;
    int32_t result;
    result = self->IndexedGetter(ix, found);

    if (found) {
      *vp = INT_TO_JSVAL(int32_t(result));
      return true;
    }
    // Even if we don't have this index, we don't forward the
    // get on to our expando object.
  } else {
    JSObject* expando = DOMProxyHandler::GetExpandoObject(proxy);
    if (expando) {
      JSBool hasProp;
      if (!JS_HasPropertyById(cx, expando, id, &hasProp)) {
        return false;
      }

      if (hasProp) {
        return JS_GetPropertyById(cx, expando, id, vp);
      }
    }
  }

  {  // Scope for this "found" so it doesn't leak to things below
    bool found;
    if (!GetPropertyOnPrototype(cx, proxy, id, &found, vp)) {
      return false;
    }

    if (found) {
      return true;
    }
  }
  if (!IsArrayIndex(index)) {
    JS::Value nameVal = js::IdToValue(id);
    FakeDependentString nom;
    if (!ConvertJSValueToString(cx, nameVal, &nameVal,
                                eStringify, eStringify, nom)) {
      return false;
    }

    mozilla::dom::TestExampleProxyInterface* self = UnwrapProxy(proxy);
    bool found;
    int16_t result;
    result = self->NamedGetter(nom, found);

    if (found) {
      *vp = INT_TO_JSVAL(int32_t(result));
      return true;
    }
  }

  vp->setUndefined();
  return true;
}


JSString*
DOMProxyHandler::obj_toString(JSContext* cx, JSObject* proxy)
{
  return mozilla::dom::DOMProxyHandler::obj_toString(cx, "TestExampleProxyInterface");
}


void
DOMProxyHandler::finalize(JSFreeOp* fop, JSObject* proxy)
{
  mozilla::dom::TestExampleProxyInterface* self = UnwrapProxy(proxy);

  if (self) {
    ClearWrapper(self, self);
    XPCJSRuntime *rt = nsXPConnect::GetRuntimeInstance();
    if (rt) {
      rt->DeferredRelease(reinterpret_cast<nsISupports*>(self));
    } else {
      NS_RELEASE(self);
    }
  }
}


bool
DOMProxyHandler::getElementIfPresent(JSContext* cx, JSObject* proxy, JSObject* receiver, uint32_t index, JS::Value* vp, bool* present)
{
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
               "Should not have a XrayWrapper here");

  uint32_t ix = index;
  mozilla::dom::TestExampleProxyInterface* self = UnwrapProxy(proxy);
  bool found;
  int32_t result;
  result = self->IndexedGetter(ix, found);

  if (found) {
    *vp = INT_TO_JSVAL(int32_t(result));
    *present = found;
    return true;
  }
  // We skip the expando object and any named getters if
  // there is an indexed getter.


  JSObject *proto;
  if (!js::GetObjectProto(cx, proxy, &proto)) {
    return false;
  }
  if (proto) {
    JSBool isPresent;
    if (!JS_GetElementIfPresent(cx, proto, index, proxy, vp, &isPresent)) {
      return false;
    }
    *present = isPresent;
    return true;
  }

  *present = false;
  // Can't Debug_SetValueRangeToCrashOnTouch because it's not public
  return true;
}


DOMProxyHandler*
DOMProxyHandler::getInstance()
{
  static DOMProxyHandler instance;
  return &instance;
}


bool
DOMProxyHandler::delete_(JSContext* cx, JSObject* proxy, jsid id, bool* bp)
{
  int32_t index = GetArrayIndexFromId(cx, id);
  if (IsArrayIndex(index)) {
    uint32_t ix = index;
    mozilla::dom::TestExampleProxyInterface* self = UnwrapProxy(proxy);
    bool found;
    self->IndexedDeleter(ix, found);
    *bp = true;
    // We always return here, even if the property was not found
    return true;
  }
  if (!HasPropertyOnPrototype(cx, proxy, this, id)) {
    JS::Value nameVal = js::IdToValue(id);
    FakeDependentString nomnom;
    if (!ConvertJSValueToString(cx, nameVal, &nameVal,
                                eStringify, eStringify, nomnom)) {
      return false;
    }

    mozilla::dom::TestExampleProxyInterface* self = UnwrapProxy(proxy);
    bool found;
    self->NamedDeleter(nomnom, found);
    *bp = true;
    if (found) {
      return true;
    }
  }
  return dom::DOMProxyHandler::delete_(cx, proxy, id, bp);
}


bool
Is(JSObject* obj)
{
  return IsProxy(obj);
}

JSObject*
Wrap(JSContext* aCx, JSObject* aScope, mozilla::dom::TestExampleProxyInterface* aObject, nsWrapperCache* aCache, bool* aTriedToWrap)
{
  MOZ_ASSERT(static_cast<mozilla::dom::TestExampleProxyInterface*>(aObject) ==
             reinterpret_cast<mozilla::dom::TestExampleProxyInterface*>(aObject));

  *aTriedToWrap = true;

  JSObject* parent = WrapNativeParent(aCx, aScope, aObject->GetParentObject());
  if (!parent) {
    return NULL;
  }

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.  Scope so we don't
  // collide with the "obj" we declare in CreateBindingJSObject.
  {
    JSObject* obj = aCache->GetWrapper();
    if (obj) {
      return obj;
    }
  }

  JSAutoCompartment ac(aCx, parent);
  JSObject* global = JS_GetGlobalForObject(aCx, parent);

  JSObject* proto = GetProtoObject(aCx, global);
  if (!proto) {
    return NULL;
  }

  JSObject *obj = NewProxyObject(aCx, DOMProxyHandler::getInstance(),
                                 JS::PrivateValue(aObject), proto, parent);
  if (!obj) {
    return NULL;
  }

  NS_ADDREF(aObject);


  aCache->SetWrapper(obj);

  return obj;
}

} // namespace TestExampleProxyInterfaceBinding



} // namespace dom
} // namespace mozilla
