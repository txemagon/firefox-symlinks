/* THIS FILE IS AUTOGENERATED - DO NOT EDIT */

#include "AccessCheck.h"
#include "CDATASectionBinding.h"
#include "CommentBinding.h"
#include "DOMImplementationBinding.h"
#include "DocumentBinding.h"
#include "DocumentFragmentBinding.h"
#include "DocumentTypeBinding.h"
#include "ElementBinding.h"
#include "EventHandlerBinding.h"
#include "EventListenerBinding.h"
#include "EventTargetBinding.h"
#include "HTMLCollectionBinding.h"
#include "HTMLPropertiesCollectionBinding.h"
#include "LocationBinding.h"
#include "NodeBinding.h"
#include "NodeFilterBinding.h"
#include "NodeListBinding.h"
#include "PrimitiveConversions.h"
#include "ProcessingInstructionBinding.h"
#include "TextBinding.h"
#include "UndoManagerBinding.h"
#include "WorkerPrivate.h"
#include "XPCQuickStubs.h"
#include "XPCWrapper.h"
#include "XPathEvaluatorBinding.h"
#include "mozilla/FloatingPoint.h"
#include "mozilla/Preferences.h"
#include "mozilla/dom/BindingUtils.h"
#include "mozilla/dom/CDATASection.h"
#include "mozilla/dom/Comment.h"
#include "mozilla/dom/DOMImplementation.h"
#include "mozilla/dom/DocumentFragment.h"
#include "mozilla/dom/DocumentType.h"
#include "mozilla/dom/Element.h"
#include "mozilla/dom/NonRefcountedDOMObject.h"
#include "mozilla/dom/Nullable.h"
#include "mozilla/dom/ProcessingInstruction.h"
#include "mozilla/dom/UndoManager.h"
#include "nsContentUtils.h"
#include "nsDOMQS.h"
#include "nsIDOMAttr.h"
#include "nsIDOMDOMStringList.h"
#include "nsIDOMDocument.h"
#include "nsIDOMEvent.h"
#include "nsIDOMLocation.h"
#include "nsIDOMNodeFilter.h"
#include "nsIDOMNodeIterator.h"
#include "nsIDOMStyleSheetList.h"
#include "nsIDOMTreeWalker.h"
#include "nsIDOMWindow.h"
#include "nsIDOMXPathExpression.h"
#include "nsIDOMXPathNSResolver.h"
#include "nsIDocument.h"
#include "nsIHTMLCollection.h"
#include "nsINode.h"
#include "nsINodeList.h"
#include "nsISupports.h"
#include "nsRange.h"
#include "nsTextNode.h"

using namespace mozilla::dom;
namespace mozilla {
namespace dom {

namespace VisibilityStateValues {

  const EnumEntry strings[3] = {
    {"hidden", 6},
    {"visible", 7},
    { NULL, 0 }
  };
} // namespace VisibilityStateValues


namespace DocumentBinding {

static bool
get_implementation(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  ErrorResult rv;
  mozilla::dom::DOMImplementation* result;
  result = self->GetImplementation(rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "implementation");
  }
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}


const JSJitInfo implementation_getterinfo = {
  (JSJitPropertyOp)get_implementation,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  true,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_URL(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsString result;
  self->GetURL(result);
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}


const JSJitInfo URL_getterinfo = {
  (JSJitPropertyOp)get_URL,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_documentURI(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsString result;
  self->GetDocumentURI(result);
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}


const JSJitInfo documentURI_getterinfo = {
  (JSJitPropertyOp)get_documentURI,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_compatMode(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsString result;
  self->GetCompatMode(result);
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}


const JSJitInfo compatMode_getterinfo = {
  (JSJitPropertyOp)get_compatMode,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_characterSet(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsString result;
  self->GetCharacterSet(result);
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}


const JSJitInfo characterSet_getterinfo = {
  (JSJitPropertyOp)get_characterSet,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_contentType(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsString result;
  self->GetContentType(result);
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}


const JSJitInfo contentType_getterinfo = {
  (JSJitPropertyOp)get_contentType,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_doctype(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  mozilla::dom::DocumentType* result;
  result = self->GetDoctype();
  if (!result) {
    *vp = JSVAL_NULL;
    return true;
  }
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}


const JSJitInfo doctype_getterinfo = {
  (JSJitPropertyOp)get_doctype,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_documentElement(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  mozilla::dom::Element* result;
  result = self->GetDocumentElement();
  if (!result) {
    *vp = JSVAL_NULL;
    return true;
  }
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    if (!HandleNewBindingWrappingFailure(cx, obj, result, vp)) {
      return false;
    }
    return true;
  }
  return true;
}


const JSJitInfo documentElement_getterinfo = {
  (JSJitPropertyOp)get_documentElement,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
getElementsByTagName(JSContext* cx, JSHandleObject obj, nsIDocument* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Document.getElementsByTagName");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eStringify, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  nsRefPtr<nsIHTMLCollection> result;
  result = self->GetElementsByTagName(arg0);
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}


const JSJitInfo getElementsByTagName_methodinfo = {
  (JSJitPropertyOp)getElementsByTagName,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
getElementsByTagNameNS(JSContext* cx, JSHandleObject obj, nsIDocument* self, unsigned argc, JS::Value* vp)
{

  if (argc < 2) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Document.getElementsByTagNameNS");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eNull, eNull, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  FakeDependentString arg1_holder;
  const NonNull<nsAString> arg1;
  if (!ConvertJSValueToString(cx, argv[1], &argv[1], eStringify, eStringify, arg1_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg1) = &arg1_holder;
  nsRefPtr<nsIHTMLCollection> result;
  result = self->GetElementsByTagNameNS(arg0, arg1);
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}


const JSJitInfo getElementsByTagNameNS_methodinfo = {
  (JSJitPropertyOp)getElementsByTagNameNS,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
getElementsByClassName(JSContext* cx, JSHandleObject obj, nsIDocument* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Document.getElementsByClassName");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eStringify, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  nsRefPtr<nsIHTMLCollection> result;
  result = self->GetElementsByClassName(arg0);
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}


const JSJitInfo getElementsByClassName_methodinfo = {
  (JSJitPropertyOp)getElementsByClassName,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
getElementById(JSContext* cx, JSHandleObject obj, nsIDocument* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Document.getElementById");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eStringify, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  mozilla::dom::Element* result;
  result = self->GetElementById(arg0);
  if (!result) {
    *vp = JSVAL_NULL;
    return true;
  }
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    if (!HandleNewBindingWrappingFailure(cx, obj, result, vp)) {
      return false;
    }
    return true;
  }
  return true;
}


const JSJitInfo getElementById_methodinfo = {
  (JSJitPropertyOp)getElementById,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
createElement(JSContext* cx, JSHandleObject obj, nsIDocument* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Document.createElement");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eStringify, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  nsRefPtr<mozilla::dom::Element> result;
  result = self->CreateElement(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "createElement");
  }
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    if (!HandleNewBindingWrappingFailure(cx, obj, result, vp)) {
      return false;
    }
    return true;
  }
  return true;
}


const JSJitInfo createElement_methodinfo = {
  (JSJitPropertyOp)createElement,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
createElementNS(JSContext* cx, JSHandleObject obj, nsIDocument* self, unsigned argc, JS::Value* vp)
{

  if (argc < 2) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Document.createElementNS");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eNull, eNull, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  FakeDependentString arg1_holder;
  const NonNull<nsAString> arg1;
  if (!ConvertJSValueToString(cx, argv[1], &argv[1], eStringify, eStringify, arg1_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg1) = &arg1_holder;
  ErrorResult rv;
  nsRefPtr<mozilla::dom::Element> result;
  result = self->CreateElementNS(arg0, arg1, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "createElementNS");
  }
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    if (!HandleNewBindingWrappingFailure(cx, obj, result, vp)) {
      return false;
    }
    return true;
  }
  return true;
}


const JSJitInfo createElementNS_methodinfo = {
  (JSJitPropertyOp)createElementNS,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
createDocumentFragment(JSContext* cx, JSHandleObject obj, nsIDocument* self, unsigned argc, JS::Value* vp)
{
  ErrorResult rv;
  nsRefPtr<mozilla::dom::DocumentFragment> result;
  result = self->CreateDocumentFragment(rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "createDocumentFragment");
  }
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}


const JSJitInfo createDocumentFragment_methodinfo = {
  (JSJitPropertyOp)createDocumentFragment,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
createTextNode(JSContext* cx, JSHandleObject obj, nsIDocument* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Document.createTextNode");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eStringify, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  nsRefPtr<mozilla::dom::Text> result;
  result = self->CreateTextNode(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "createTextNode");
  }
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}


const JSJitInfo createTextNode_methodinfo = {
  (JSJitPropertyOp)createTextNode,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
createComment(JSContext* cx, JSHandleObject obj, nsIDocument* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Document.createComment");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eStringify, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  nsRefPtr<mozilla::dom::Comment> result;
  result = self->CreateComment(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "createComment");
  }
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}


const JSJitInfo createComment_methodinfo = {
  (JSJitPropertyOp)createComment,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
createProcessingInstruction(JSContext* cx, JSHandleObject obj, nsIDocument* self, unsigned argc, JS::Value* vp)
{

  if (argc < 2) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Document.createProcessingInstruction");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eStringify, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  FakeDependentString arg1_holder;
  const NonNull<nsAString> arg1;
  if (!ConvertJSValueToString(cx, argv[1], &argv[1], eStringify, eStringify, arg1_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg1) = &arg1_holder;
  ErrorResult rv;
  nsRefPtr<mozilla::dom::ProcessingInstruction> result;
  result = self->CreateProcessingInstruction(arg0, arg1, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "createProcessingInstruction");
  }
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}


const JSJitInfo createProcessingInstruction_methodinfo = {
  (JSJitPropertyOp)createProcessingInstruction,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
importNode(JSContext* cx, JSHandleObject obj, nsIDocument* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Document.importNode");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  NonNull<nsINode> arg0;
  if (argv[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::Node, nsINode>(cx, &argv[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        nsINode *objPtr;
        xpc_qsSelfRef objRef;
        JS::Value val = JS::ObjectValue(*&argv[0].toObject());
        nsresult rv = xpc_qsUnwrapArg<nsINode>(cx, val, &objPtr, &objRef.ptr, &val);
        if (NS_FAILED(rv)) {
            ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "Node");
            return false;
        }
        // We should be castable!
        MOZ_ASSERT(!objRef.ptr);
        // We should have an object, too!
        MOZ_ASSERT(objPtr);
        arg0 = objPtr;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  bool arg1;
  if (1 < argc) {
    if (!ValueToPrimitive<bool, eDefault>(cx, argv[1], &arg1)) {
      return false;
    }
  } else {
    arg1 = true;
  }
  ErrorResult rv;
  nsRefPtr<nsINode> result;
  result = self->ImportNode(arg0, arg1, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "importNode");
  }
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    if (!HandleNewBindingWrappingFailure(cx, obj, result, vp)) {
      return false;
    }
    return true;
  }
  return true;
}


const JSJitInfo importNode_methodinfo = {
  (JSJitPropertyOp)importNode,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
adoptNode(JSContext* cx, JSHandleObject obj, nsIDocument* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Document.adoptNode");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  NonNull<nsINode> arg0;
  if (argv[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::Node, nsINode>(cx, &argv[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        nsINode *objPtr;
        xpc_qsSelfRef objRef;
        JS::Value val = JS::ObjectValue(*&argv[0].toObject());
        nsresult rv = xpc_qsUnwrapArg<nsINode>(cx, val, &objPtr, &objRef.ptr, &val);
        if (NS_FAILED(rv)) {
            ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "Node");
            return false;
        }
        // We should be castable!
        MOZ_ASSERT(!objRef.ptr);
        // We should have an object, too!
        MOZ_ASSERT(objPtr);
        arg0 = objPtr;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  ErrorResult rv;
  nsINode* result;
  result = self->AdoptNode(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "adoptNode");
  }
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    if (!HandleNewBindingWrappingFailure(cx, obj, result, vp)) {
      return false;
    }
    return true;
  }
  return true;
}


const JSJitInfo adoptNode_methodinfo = {
  (JSJitPropertyOp)adoptNode,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
createEvent(JSContext* cx, JSHandleObject obj, nsIDocument* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Document.createEvent");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eStringify, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  nsRefPtr<nsIDOMEvent> result;
  result = self->CreateEvent(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "createEvent");
  }
  if (!WrapObject(cx, obj, result, vp)) {
    return false;
  }
  return true;
}


const JSJitInfo createEvent_methodinfo = {
  (JSJitPropertyOp)createEvent,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
createRange(JSContext* cx, JSHandleObject obj, nsIDocument* self, unsigned argc, JS::Value* vp)
{
  ErrorResult rv;
  nsRefPtr<nsRange> result;
  result = self->CreateRange(rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "createRange");
  }
  if (!WrapObject(cx, obj, result, vp)) {
    return false;
  }
  return true;
}


const JSJitInfo createRange_methodinfo = {
  (JSJitPropertyOp)createRange,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
createNodeIterator(JSContext* cx, JSHandleObject obj, nsIDocument* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Document.createNodeIterator");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  NonNull<nsINode> arg0;
  if (argv[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::Node, nsINode>(cx, &argv[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        nsINode *objPtr;
        xpc_qsSelfRef objRef;
        JS::Value val = JS::ObjectValue(*&argv[0].toObject());
        nsresult rv = xpc_qsUnwrapArg<nsINode>(cx, val, &objPtr, &objRef.ptr, &val);
        if (NS_FAILED(rv)) {
            ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "Node");
            return false;
        }
        // We should be castable!
        MOZ_ASSERT(!objRef.ptr);
        // We should have an object, too!
        MOZ_ASSERT(objPtr);
        arg0 = objPtr;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  uint32_t arg1;
  if (1 < argc) {
    if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[1], &arg1)) {
      return false;
    }
  } else {
    arg1 = 4294967295;
  }
  nsRefPtr<nsIDOMNodeFilter> arg2;
  if (2 < argc) {
    if (argv[2].isObject()) {
      if (!IsConvertibleToCallbackInterface(cx, &argv[2].toObject())) {
          ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "NodeFilter");
          return false;
      }

      nsresult rv;
      XPCCallContext ccx(JS_CALLER, cx);
      if (!ccx.IsValid()) {
        rv = NS_ERROR_XPC_BAD_CONVERT_JS;
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "NodeFilter");
        return false;
      }

      const nsIID& iid = NS_GET_IID(nsIDOMNodeFilter);
      nsRefPtr<nsXPCWrappedJS> wrappedJS;
      rv = nsXPCWrappedJS::GetNewOrUsed(ccx, &argv[2].toObject(), iid,
                                        NULL, getter_AddRefs(wrappedJS));
      if (NS_FAILED(rv) || !wrappedJS) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "NodeFilter");
        return false;
      }

      // Use a temp nsCOMPtr for the null-check, because arg2 might be
      // OwningNonNull, not an nsCOMPtr.
      nsCOMPtr<nsIDOMNodeFilter> tmp = do_QueryObject(wrappedJS.get());
      if (!tmp) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "NodeFilter");
        return false;
      }
      arg2 = tmp.forget();
    } else if (argv[2].isNullOrUndefined()) {
      arg2 = NULL;
    } else {
      ThrowErrorMessage(cx, MSG_NOT_OBJECT);
      return false;
    }
  } else {
    arg2 = NULL;
  }
  ErrorResult rv;
  nsRefPtr<nsIDOMNodeIterator> result;
  result = self->CreateNodeIterator(arg0, arg1, arg2, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "createNodeIterator");
  }
  if (!WrapObject(cx, obj, result, vp)) {
    return false;
  }
  return true;
}


const JSJitInfo createNodeIterator_methodinfo = {
  (JSJitPropertyOp)createNodeIterator,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
createTreeWalker(JSContext* cx, JSHandleObject obj, nsIDocument* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Document.createTreeWalker");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  NonNull<nsINode> arg0;
  if (argv[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::Node, nsINode>(cx, &argv[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        nsINode *objPtr;
        xpc_qsSelfRef objRef;
        JS::Value val = JS::ObjectValue(*&argv[0].toObject());
        nsresult rv = xpc_qsUnwrapArg<nsINode>(cx, val, &objPtr, &objRef.ptr, &val);
        if (NS_FAILED(rv)) {
            ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "Node");
            return false;
        }
        // We should be castable!
        MOZ_ASSERT(!objRef.ptr);
        // We should have an object, too!
        MOZ_ASSERT(objPtr);
        arg0 = objPtr;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  uint32_t arg1;
  if (1 < argc) {
    if (!ValueToPrimitive<uint32_t, eDefault>(cx, argv[1], &arg1)) {
      return false;
    }
  } else {
    arg1 = 4294967295;
  }
  nsRefPtr<nsIDOMNodeFilter> arg2;
  if (2 < argc) {
    if (argv[2].isObject()) {
      if (!IsConvertibleToCallbackInterface(cx, &argv[2].toObject())) {
          ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "NodeFilter");
          return false;
      }

      nsresult rv;
      XPCCallContext ccx(JS_CALLER, cx);
      if (!ccx.IsValid()) {
        rv = NS_ERROR_XPC_BAD_CONVERT_JS;
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "NodeFilter");
        return false;
      }

      const nsIID& iid = NS_GET_IID(nsIDOMNodeFilter);
      nsRefPtr<nsXPCWrappedJS> wrappedJS;
      rv = nsXPCWrappedJS::GetNewOrUsed(ccx, &argv[2].toObject(), iid,
                                        NULL, getter_AddRefs(wrappedJS));
      if (NS_FAILED(rv) || !wrappedJS) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "NodeFilter");
        return false;
      }

      // Use a temp nsCOMPtr for the null-check, because arg2 might be
      // OwningNonNull, not an nsCOMPtr.
      nsCOMPtr<nsIDOMNodeFilter> tmp = do_QueryObject(wrappedJS.get());
      if (!tmp) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "NodeFilter");
        return false;
      }
      arg2 = tmp.forget();
    } else if (argv[2].isNullOrUndefined()) {
      arg2 = NULL;
    } else {
      ThrowErrorMessage(cx, MSG_NOT_OBJECT);
      return false;
    }
  } else {
    arg2 = NULL;
  }
  ErrorResult rv;
  nsRefPtr<nsIDOMTreeWalker> result;
  result = self->CreateTreeWalker(arg0, arg1, arg2, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "createTreeWalker");
  }
  if (!WrapObject(cx, obj, result, vp)) {
    return false;
  }
  return true;
}


const JSJitInfo createTreeWalker_methodinfo = {
  (JSJitPropertyOp)createTreeWalker,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
createCDATASection(JSContext* cx, JSHandleObject obj, nsIDocument* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Document.createCDATASection");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eStringify, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  nsRefPtr<mozilla::dom::CDATASection> result;
  result = self->CreateCDATASection(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "createCDATASection");
  }
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}


const JSJitInfo createCDATASection_methodinfo = {
  (JSJitPropertyOp)createCDATASection,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
createAttribute(JSContext* cx, JSHandleObject obj, nsIDocument* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Document.createAttribute");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eStringify, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  nsRefPtr<nsIDOMAttr> result;
  result = self->CreateAttribute(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "createAttribute");
  }
  if (!WrapObject(cx, obj, result, vp)) {
    return false;
  }
  return true;
}


const JSJitInfo createAttribute_methodinfo = {
  (JSJitPropertyOp)createAttribute,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
createAttributeNS(JSContext* cx, JSHandleObject obj, nsIDocument* self, unsigned argc, JS::Value* vp)
{

  if (argc < 2) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Document.createAttributeNS");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eNull, eNull, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  FakeDependentString arg1_holder;
  const NonNull<nsAString> arg1;
  if (!ConvertJSValueToString(cx, argv[1], &argv[1], eStringify, eStringify, arg1_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg1) = &arg1_holder;
  ErrorResult rv;
  nsRefPtr<nsIDOMAttr> result;
  result = self->CreateAttributeNS(arg0, arg1, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "createAttributeNS");
  }
  if (!WrapObject(cx, obj, result, vp)) {
    return false;
  }
  return true;
}


const JSJitInfo createAttributeNS_methodinfo = {
  (JSJitPropertyOp)createAttributeNS,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_inputEncoding(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsString result;
  self->GetInputEncoding(result);
  if (!xpc::StringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}


const JSJitInfo inputEncoding_getterinfo = {
  (JSJitPropertyOp)get_inputEncoding,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_location(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsRefPtr<nsIDOMLocation> result;
  result = self->GetLocation();
  if (!result) {
    *vp = JSVAL_NULL;
    return true;
  }
  if (!WrapObject(cx, obj, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_location(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* argv)
{
  js::RootedValue v(cx);
  if (!JS_GetProperty(cx, obj, "location", v.address())) {
    return false;
  }

  if (!v.isObject()) {
    return ThrowErrorMessage(cx, MSG_NOT_OBJECT);
  }

  return JS_SetProperty(cx, &v.toObject(), "href", argv);
}


const JSJitInfo location_getterinfo = {
  (JSJitPropertyOp)get_location,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo location_setterinfo = {
  (JSJitPropertyOp)set_location,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_referrer(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsString result;
  self->GetReferrer(result);
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}


const JSJitInfo referrer_getterinfo = {
  (JSJitPropertyOp)get_referrer,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_lastModified(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsString result;
  self->GetLastModified(result);
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}


const JSJitInfo lastModified_getterinfo = {
  (JSJitPropertyOp)get_lastModified,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_readyState(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsString result;
  self->GetReadyState(result);
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}


const JSJitInfo readyState_getterinfo = {
  (JSJitPropertyOp)get_readyState,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_title(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsString result;
  self->GetTitle(result);
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_title(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eStringify, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetTitle(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "title");
  }

  return true;
}


const JSJitInfo title_getterinfo = {
  (JSJitPropertyOp)get_title,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo title_setterinfo = {
  (JSJitPropertyOp)set_title,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_dir(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsString result;
  self->GetDir(result);
  if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_dir(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eStringify, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->SetDir(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "dir");
  }

  return true;
}


const JSJitInfo dir_getterinfo = {
  (JSJitPropertyOp)get_dir,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo dir_setterinfo = {
  (JSJitPropertyOp)set_dir,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_defaultView(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsIDOMWindow* result;
  result = self->GetDefaultView();
  if (!result) {
    *vp = JSVAL_NULL;
    return true;
  }
  if (!WrapObject(cx, obj, result, vp)) {
    return false;
  }
  return true;
}


const JSJitInfo defaultView_getterinfo = {
  (JSJitPropertyOp)get_defaultView,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_activeElement(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  mozilla::dom::Element* result;
  result = self->GetActiveElement();
  if (!result) {
    *vp = JSVAL_NULL;
    return true;
  }
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    if (!HandleNewBindingWrappingFailure(cx, obj, result, vp)) {
      return false;
    }
    return true;
  }
  return true;
}


const JSJitInfo activeElement_getterinfo = {
  (JSJitPropertyOp)get_activeElement,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
hasFocus(JSContext* cx, JSHandleObject obj, nsIDocument* self, unsigned argc, JS::Value* vp)
{
  ErrorResult rv;
  bool result;
  result = self->HasFocus(rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "hasFocus");
  }
  *vp = BOOLEAN_TO_JSVAL(result);
  return true;
}


const JSJitInfo hasFocus_methodinfo = {
  (JSJitPropertyOp)hasFocus,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Method,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onabort(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnabort();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onabort(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnabort(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "onabort");
  }

  return true;
}


const JSJitInfo onabort_getterinfo = {
  (JSJitPropertyOp)get_onabort,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onabort_setterinfo = {
  (JSJitPropertyOp)set_onabort,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onblur(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnblur();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onblur(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnblur(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "onblur");
  }

  return true;
}


const JSJitInfo onblur_getterinfo = {
  (JSJitPropertyOp)get_onblur,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onblur_setterinfo = {
  (JSJitPropertyOp)set_onblur,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_oncanplay(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOncanplay();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_oncanplay(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOncanplay(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "oncanplay");
  }

  return true;
}


const JSJitInfo oncanplay_getterinfo = {
  (JSJitPropertyOp)get_oncanplay,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo oncanplay_setterinfo = {
  (JSJitPropertyOp)set_oncanplay,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_oncanplaythrough(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOncanplaythrough();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_oncanplaythrough(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOncanplaythrough(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "oncanplaythrough");
  }

  return true;
}


const JSJitInfo oncanplaythrough_getterinfo = {
  (JSJitPropertyOp)get_oncanplaythrough,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo oncanplaythrough_setterinfo = {
  (JSJitPropertyOp)set_oncanplaythrough,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onchange(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnchange();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onchange(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnchange(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "onchange");
  }

  return true;
}


const JSJitInfo onchange_getterinfo = {
  (JSJitPropertyOp)get_onchange,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onchange_setterinfo = {
  (JSJitPropertyOp)set_onchange,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onclick(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnclick();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onclick(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnclick(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "onclick");
  }

  return true;
}


const JSJitInfo onclick_getterinfo = {
  (JSJitPropertyOp)get_onclick,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onclick_setterinfo = {
  (JSJitPropertyOp)set_onclick,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_oncontextmenu(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOncontextmenu();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_oncontextmenu(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOncontextmenu(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "oncontextmenu");
  }

  return true;
}


const JSJitInfo oncontextmenu_getterinfo = {
  (JSJitPropertyOp)get_oncontextmenu,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo oncontextmenu_setterinfo = {
  (JSJitPropertyOp)set_oncontextmenu,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_ondblclick(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOndblclick();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_ondblclick(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOndblclick(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "ondblclick");
  }

  return true;
}


const JSJitInfo ondblclick_getterinfo = {
  (JSJitPropertyOp)get_ondblclick,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo ondblclick_setterinfo = {
  (JSJitPropertyOp)set_ondblclick,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_ondrag(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOndrag();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_ondrag(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOndrag(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "ondrag");
  }

  return true;
}


const JSJitInfo ondrag_getterinfo = {
  (JSJitPropertyOp)get_ondrag,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo ondrag_setterinfo = {
  (JSJitPropertyOp)set_ondrag,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_ondragend(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOndragend();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_ondragend(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOndragend(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "ondragend");
  }

  return true;
}


const JSJitInfo ondragend_getterinfo = {
  (JSJitPropertyOp)get_ondragend,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo ondragend_setterinfo = {
  (JSJitPropertyOp)set_ondragend,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_ondragenter(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOndragenter();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_ondragenter(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOndragenter(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "ondragenter");
  }

  return true;
}


const JSJitInfo ondragenter_getterinfo = {
  (JSJitPropertyOp)get_ondragenter,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo ondragenter_setterinfo = {
  (JSJitPropertyOp)set_ondragenter,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_ondragleave(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOndragleave();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_ondragleave(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOndragleave(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "ondragleave");
  }

  return true;
}


const JSJitInfo ondragleave_getterinfo = {
  (JSJitPropertyOp)get_ondragleave,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo ondragleave_setterinfo = {
  (JSJitPropertyOp)set_ondragleave,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_ondragover(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOndragover();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_ondragover(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOndragover(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "ondragover");
  }

  return true;
}


const JSJitInfo ondragover_getterinfo = {
  (JSJitPropertyOp)get_ondragover,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo ondragover_setterinfo = {
  (JSJitPropertyOp)set_ondragover,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_ondragstart(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOndragstart();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_ondragstart(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOndragstart(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "ondragstart");
  }

  return true;
}


const JSJitInfo ondragstart_getterinfo = {
  (JSJitPropertyOp)get_ondragstart,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo ondragstart_setterinfo = {
  (JSJitPropertyOp)set_ondragstart,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_ondrop(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOndrop();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_ondrop(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOndrop(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "ondrop");
  }

  return true;
}


const JSJitInfo ondrop_getterinfo = {
  (JSJitPropertyOp)get_ondrop,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo ondrop_setterinfo = {
  (JSJitPropertyOp)set_ondrop,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_ondurationchange(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOndurationchange();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_ondurationchange(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOndurationchange(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "ondurationchange");
  }

  return true;
}


const JSJitInfo ondurationchange_getterinfo = {
  (JSJitPropertyOp)get_ondurationchange,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo ondurationchange_setterinfo = {
  (JSJitPropertyOp)set_ondurationchange,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onemptied(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnemptied();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onemptied(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnemptied(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "onemptied");
  }

  return true;
}


const JSJitInfo onemptied_getterinfo = {
  (JSJitPropertyOp)get_onemptied,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onemptied_setterinfo = {
  (JSJitPropertyOp)set_onemptied,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onended(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnended();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onended(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnended(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "onended");
  }

  return true;
}


const JSJitInfo onended_getterinfo = {
  (JSJitPropertyOp)get_onended,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onended_setterinfo = {
  (JSJitPropertyOp)set_onended,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onerror(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnerror();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onerror(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnerror(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "onerror");
  }

  return true;
}


const JSJitInfo onerror_getterinfo = {
  (JSJitPropertyOp)get_onerror,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onerror_setterinfo = {
  (JSJitPropertyOp)set_onerror,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onfocus(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnfocus();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onfocus(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnfocus(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "onfocus");
  }

  return true;
}


const JSJitInfo onfocus_getterinfo = {
  (JSJitPropertyOp)get_onfocus,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onfocus_setterinfo = {
  (JSJitPropertyOp)set_onfocus,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_oninput(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOninput();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_oninput(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOninput(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "oninput");
  }

  return true;
}


const JSJitInfo oninput_getterinfo = {
  (JSJitPropertyOp)get_oninput,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo oninput_setterinfo = {
  (JSJitPropertyOp)set_oninput,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_oninvalid(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOninvalid();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_oninvalid(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOninvalid(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "oninvalid");
  }

  return true;
}


const JSJitInfo oninvalid_getterinfo = {
  (JSJitPropertyOp)get_oninvalid,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo oninvalid_setterinfo = {
  (JSJitPropertyOp)set_oninvalid,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onkeydown(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnkeydown();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onkeydown(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnkeydown(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "onkeydown");
  }

  return true;
}


const JSJitInfo onkeydown_getterinfo = {
  (JSJitPropertyOp)get_onkeydown,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onkeydown_setterinfo = {
  (JSJitPropertyOp)set_onkeydown,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onkeypress(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnkeypress();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onkeypress(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnkeypress(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "onkeypress");
  }

  return true;
}


const JSJitInfo onkeypress_getterinfo = {
  (JSJitPropertyOp)get_onkeypress,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onkeypress_setterinfo = {
  (JSJitPropertyOp)set_onkeypress,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onkeyup(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnkeyup();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onkeyup(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnkeyup(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "onkeyup");
  }

  return true;
}


const JSJitInfo onkeyup_getterinfo = {
  (JSJitPropertyOp)get_onkeyup,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onkeyup_setterinfo = {
  (JSJitPropertyOp)set_onkeyup,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onload(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnload();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onload(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnload(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "onload");
  }

  return true;
}


const JSJitInfo onload_getterinfo = {
  (JSJitPropertyOp)get_onload,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onload_setterinfo = {
  (JSJitPropertyOp)set_onload,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onloadeddata(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnloadeddata();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onloadeddata(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnloadeddata(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "onloadeddata");
  }

  return true;
}


const JSJitInfo onloadeddata_getterinfo = {
  (JSJitPropertyOp)get_onloadeddata,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onloadeddata_setterinfo = {
  (JSJitPropertyOp)set_onloadeddata,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onloadedmetadata(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnloadedmetadata();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onloadedmetadata(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnloadedmetadata(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "onloadedmetadata");
  }

  return true;
}


const JSJitInfo onloadedmetadata_getterinfo = {
  (JSJitPropertyOp)get_onloadedmetadata,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onloadedmetadata_setterinfo = {
  (JSJitPropertyOp)set_onloadedmetadata,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onloadstart(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnloadstart();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onloadstart(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnloadstart(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "onloadstart");
  }

  return true;
}


const JSJitInfo onloadstart_getterinfo = {
  (JSJitPropertyOp)get_onloadstart,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onloadstart_setterinfo = {
  (JSJitPropertyOp)set_onloadstart,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onmousedown(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnmousedown();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onmousedown(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnmousedown(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "onmousedown");
  }

  return true;
}


const JSJitInfo onmousedown_getterinfo = {
  (JSJitPropertyOp)get_onmousedown,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onmousedown_setterinfo = {
  (JSJitPropertyOp)set_onmousedown,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onmousemove(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnmousemove();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onmousemove(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnmousemove(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "onmousemove");
  }

  return true;
}


const JSJitInfo onmousemove_getterinfo = {
  (JSJitPropertyOp)get_onmousemove,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onmousemove_setterinfo = {
  (JSJitPropertyOp)set_onmousemove,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onmouseout(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnmouseout();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onmouseout(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnmouseout(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "onmouseout");
  }

  return true;
}


const JSJitInfo onmouseout_getterinfo = {
  (JSJitPropertyOp)get_onmouseout,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onmouseout_setterinfo = {
  (JSJitPropertyOp)set_onmouseout,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onmouseover(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnmouseover();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onmouseover(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnmouseover(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "onmouseover");
  }

  return true;
}


const JSJitInfo onmouseover_getterinfo = {
  (JSJitPropertyOp)get_onmouseover,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onmouseover_setterinfo = {
  (JSJitPropertyOp)set_onmouseover,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onmouseup(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnmouseup();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onmouseup(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnmouseup(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "onmouseup");
  }

  return true;
}


const JSJitInfo onmouseup_getterinfo = {
  (JSJitPropertyOp)get_onmouseup,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onmouseup_setterinfo = {
  (JSJitPropertyOp)set_onmouseup,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onpause(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnpause();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onpause(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnpause(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "onpause");
  }

  return true;
}


const JSJitInfo onpause_getterinfo = {
  (JSJitPropertyOp)get_onpause,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onpause_setterinfo = {
  (JSJitPropertyOp)set_onpause,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onplay(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnplay();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onplay(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnplay(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "onplay");
  }

  return true;
}


const JSJitInfo onplay_getterinfo = {
  (JSJitPropertyOp)get_onplay,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onplay_setterinfo = {
  (JSJitPropertyOp)set_onplay,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onplaying(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnplaying();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onplaying(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnplaying(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "onplaying");
  }

  return true;
}


const JSJitInfo onplaying_getterinfo = {
  (JSJitPropertyOp)get_onplaying,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onplaying_setterinfo = {
  (JSJitPropertyOp)set_onplaying,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onprogress(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnprogress();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onprogress(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnprogress(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "onprogress");
  }

  return true;
}


const JSJitInfo onprogress_getterinfo = {
  (JSJitPropertyOp)get_onprogress,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onprogress_setterinfo = {
  (JSJitPropertyOp)set_onprogress,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onratechange(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnratechange();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onratechange(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnratechange(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "onratechange");
  }

  return true;
}


const JSJitInfo onratechange_getterinfo = {
  (JSJitPropertyOp)get_onratechange,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onratechange_setterinfo = {
  (JSJitPropertyOp)set_onratechange,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onreset(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnreset();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onreset(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnreset(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "onreset");
  }

  return true;
}


const JSJitInfo onreset_getterinfo = {
  (JSJitPropertyOp)get_onreset,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onreset_setterinfo = {
  (JSJitPropertyOp)set_onreset,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onscroll(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnscroll();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onscroll(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnscroll(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "onscroll");
  }

  return true;
}


const JSJitInfo onscroll_getterinfo = {
  (JSJitPropertyOp)get_onscroll,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onscroll_setterinfo = {
  (JSJitPropertyOp)set_onscroll,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onseeked(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnseeked();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onseeked(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnseeked(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "onseeked");
  }

  return true;
}


const JSJitInfo onseeked_getterinfo = {
  (JSJitPropertyOp)get_onseeked,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onseeked_setterinfo = {
  (JSJitPropertyOp)set_onseeked,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onseeking(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnseeking();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onseeking(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnseeking(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "onseeking");
  }

  return true;
}


const JSJitInfo onseeking_getterinfo = {
  (JSJitPropertyOp)get_onseeking,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onseeking_setterinfo = {
  (JSJitPropertyOp)set_onseeking,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onselect(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnselect();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onselect(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnselect(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "onselect");
  }

  return true;
}


const JSJitInfo onselect_getterinfo = {
  (JSJitPropertyOp)get_onselect,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onselect_setterinfo = {
  (JSJitPropertyOp)set_onselect,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onshow(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnshow();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onshow(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnshow(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "onshow");
  }

  return true;
}


const JSJitInfo onshow_getterinfo = {
  (JSJitPropertyOp)get_onshow,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onshow_setterinfo = {
  (JSJitPropertyOp)set_onshow,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onstalled(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnstalled();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onstalled(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnstalled(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "onstalled");
  }

  return true;
}


const JSJitInfo onstalled_getterinfo = {
  (JSJitPropertyOp)get_onstalled,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onstalled_setterinfo = {
  (JSJitPropertyOp)set_onstalled,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onsubmit(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnsubmit();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onsubmit(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnsubmit(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "onsubmit");
  }

  return true;
}


const JSJitInfo onsubmit_getterinfo = {
  (JSJitPropertyOp)get_onsubmit,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onsubmit_setterinfo = {
  (JSJitPropertyOp)set_onsubmit,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onsuspend(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnsuspend();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onsuspend(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnsuspend(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "onsuspend");
  }

  return true;
}


const JSJitInfo onsuspend_getterinfo = {
  (JSJitPropertyOp)get_onsuspend,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onsuspend_setterinfo = {
  (JSJitPropertyOp)set_onsuspend,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_ontimeupdate(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOntimeupdate();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_ontimeupdate(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOntimeupdate(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "ontimeupdate");
  }

  return true;
}


const JSJitInfo ontimeupdate_getterinfo = {
  (JSJitPropertyOp)get_ontimeupdate,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo ontimeupdate_setterinfo = {
  (JSJitPropertyOp)set_ontimeupdate,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onvolumechange(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnvolumechange();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onvolumechange(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnvolumechange(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "onvolumechange");
  }

  return true;
}


const JSJitInfo onvolumechange_getterinfo = {
  (JSJitPropertyOp)get_onvolumechange,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onvolumechange_setterinfo = {
  (JSJitPropertyOp)set_onvolumechange,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onwaiting(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnwaiting();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onwaiting(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnwaiting(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "onwaiting");
  }

  return true;
}


const JSJitInfo onwaiting_getterinfo = {
  (JSJitPropertyOp)get_onwaiting,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onwaiting_setterinfo = {
  (JSJitPropertyOp)set_onwaiting,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onreadystatechange(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnreadystatechange();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onreadystatechange(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnreadystatechange(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "onreadystatechange");
  }

  return true;
}


const JSJitInfo onreadystatechange_getterinfo = {
  (JSJitPropertyOp)get_onreadystatechange,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onreadystatechange_setterinfo = {
  (JSJitPropertyOp)set_onreadystatechange,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onmouseenter(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnmouseenter();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onmouseenter(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnmouseenter(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "onmouseenter");
  }

  return true;
}


const JSJitInfo onmouseenter_getterinfo = {
  (JSJitPropertyOp)get_onmouseenter,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onmouseenter_setterinfo = {
  (JSJitPropertyOp)set_onmouseenter,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onmouseleave(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnmouseleave();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onmouseleave(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnmouseleave(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "onmouseleave");
  }

  return true;
}


const JSJitInfo onmouseleave_getterinfo = {
  (JSJitPropertyOp)get_onmouseleave,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onmouseleave_setterinfo = {
  (JSJitPropertyOp)set_onmouseleave,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onmozfullscreenchange(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnmozfullscreenchange();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onmozfullscreenchange(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnmozfullscreenchange(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "onmozfullscreenchange");
  }

  return true;
}


const JSJitInfo onmozfullscreenchange_getterinfo = {
  (JSJitPropertyOp)get_onmozfullscreenchange,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onmozfullscreenchange_setterinfo = {
  (JSJitPropertyOp)set_onmozfullscreenchange,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onmozfullscreenerror(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnmozfullscreenerror();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onmozfullscreenerror(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnmozfullscreenerror(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "onmozfullscreenerror");
  }

  return true;
}


const JSJitInfo onmozfullscreenerror_getterinfo = {
  (JSJitPropertyOp)get_onmozfullscreenerror,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onmozfullscreenerror_setterinfo = {
  (JSJitPropertyOp)set_onmozfullscreenerror,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onmozpointerlockchange(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnmozpointerlockchange();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onmozpointerlockchange(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnmozpointerlockchange(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "onmozpointerlockchange");
  }

  return true;
}


const JSJitInfo onmozpointerlockchange_getterinfo = {
  (JSJitPropertyOp)get_onmozpointerlockchange,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onmozpointerlockchange_setterinfo = {
  (JSJitPropertyOp)set_onmozpointerlockchange,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onmozpointerlockerror(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnmozpointerlockerror();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onmozpointerlockerror(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnmozpointerlockerror(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "onmozpointerlockerror");
  }

  return true;
}


const JSJitInfo onmozpointerlockerror_getterinfo = {
  (JSJitPropertyOp)get_onmozpointerlockerror,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onmozpointerlockerror_setterinfo = {
  (JSJitPropertyOp)set_onmozpointerlockerror,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onwheel(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnwheel();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onwheel(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnwheel(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "onwheel");
  }

  return true;
}


const JSJitInfo onwheel_getterinfo = {
  (JSJitPropertyOp)get_onwheel,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onwheel_setterinfo = {
  (JSJitPropertyOp)set_onwheel,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_oncopy(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOncopy();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_oncopy(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOncopy(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "oncopy");
  }

  return true;
}


const JSJitInfo oncopy_getterinfo = {
  (JSJitPropertyOp)get_oncopy,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo oncopy_setterinfo = {
  (JSJitPropertyOp)set_oncopy,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_oncut(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOncut();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_oncut(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOncut(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "oncut");
  }

  return true;
}


const JSJitInfo oncut_getterinfo = {
  (JSJitPropertyOp)get_oncut,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo oncut_setterinfo = {
  (JSJitPropertyOp)set_oncut,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onpaste(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnpaste();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onpaste(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnpaste(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "onpaste");
  }

  return true;
}


const JSJitInfo onpaste_getterinfo = {
  (JSJitPropertyOp)get_onpaste,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onpaste_setterinfo = {
  (JSJitPropertyOp)set_onpaste,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onbeforescriptexecute(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnbeforescriptexecute();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onbeforescriptexecute(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnbeforescriptexecute(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "onbeforescriptexecute");
  }

  return true;
}


const JSJitInfo onbeforescriptexecute_getterinfo = {
  (JSJitPropertyOp)get_onbeforescriptexecute,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onbeforescriptexecute_setterinfo = {
  (JSJitPropertyOp)set_onbeforescriptexecute,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_onafterscriptexecute(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsRefPtr<EventHandlerNonNull> result;
  result = self->GetOnafterscriptexecute();
  if (result) {
    *vp = JS::ObjectValue(*result->Callable());
    if (!MaybeWrapValue(cx, vp)) {
      return false;
    }
    return true;
  } else {
    *vp = JS::NullValue();
    return true;
  }
}

static bool
set_onafterscriptexecute(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* argv)
{
  nsRefPtr<EventHandlerNonNull> arg0;
  if (argv[0].isObject() && JS_ObjectIsCallable(cx, &argv[0].toObject())) {
    bool inited;
    arg0 = new EventHandlerNonNull(cx, obj, &argv[0].toObject(), &inited);
    if (!inited) {
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  ErrorResult rv;
  self->SetOnafterscriptexecute(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "onafterscriptexecute");
  }

  return true;
}


const JSJitInfo onafterscriptexecute_getterinfo = {
  (JSJitPropertyOp)get_onafterscriptexecute,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo onafterscriptexecute_setterinfo = {
  (JSJitPropertyOp)set_onafterscriptexecute,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_mozSyntheticDocument(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  bool result;
  result = self->MozSyntheticDocument();
  *vp = BOOLEAN_TO_JSVAL(result);
  return true;
}


const JSJitInfo mozSyntheticDocument_getterinfo = {
  (JSJitPropertyOp)get_mozSyntheticDocument,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_currentScript(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  mozilla::dom::Element* result;
  result = self->GetCurrentScript();
  if (!result) {
    *vp = JSVAL_NULL;
    return true;
  }
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    if (!HandleNewBindingWrappingFailure(cx, obj, result, vp)) {
      return false;
    }
    return true;
  }
  return true;
}


const JSJitInfo currentScript_getterinfo = {
  (JSJitPropertyOp)get_currentScript,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
releaseCapture(JSContext* cx, JSHandleObject obj, nsIDocument* self, unsigned argc, JS::Value* vp)
{
  self->ReleaseCapture();
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo releaseCapture_methodinfo = {
  (JSJitPropertyOp)releaseCapture,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Method,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
mozSetImageElement(JSContext* cx, JSHandleObject obj, nsIDocument* self, unsigned argc, JS::Value* vp)
{

  if (argc < 2) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Document.mozSetImageElement");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eStringify, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  mozilla::dom::Element* arg1;
  if (argv[1].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::Element, mozilla::dom::Element>(cx, &argv[1].toObject(), arg1);
      if (NS_FAILED(rv)) {
        mozilla::dom::Element *objPtr;
        xpc_qsSelfRef objRef;
        JS::Value val = JS::ObjectValue(*&argv[1].toObject());
        nsresult rv = xpc_qsUnwrapArg<mozilla::dom::Element>(cx, val, &objPtr, &objRef.ptr, &val);
        if (NS_FAILED(rv)) {
            ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "Element");
            return false;
        }
        // We should be castable!
        MOZ_ASSERT(!objRef.ptr);
        // We should have an object, too!
        MOZ_ASSERT(objPtr);
        arg1 = objPtr;
      }
    }
  } else if (argv[1].isNullOrUndefined()) {
    arg1 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  self->MozSetImageElement(arg0, arg1);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo mozSetImageElement_methodinfo = {
  (JSJitPropertyOp)mozSetImageElement,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_mozFullScreenEnabled(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  bool result;
  result = self->MozFullScreenEnabled();
  *vp = BOOLEAN_TO_JSVAL(result);
  return true;
}


const JSJitInfo mozFullScreenEnabled_getterinfo = {
  (JSJitPropertyOp)get_mozFullScreenEnabled,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_mozFullScreenElement(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  ErrorResult rv;
  mozilla::dom::Element* result;
  result = self->GetMozFullScreenElement(rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "mozFullScreenElement");
  }
  if (!result) {
    *vp = JSVAL_NULL;
    return true;
  }
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    if (!HandleNewBindingWrappingFailure(cx, obj, result, vp)) {
      return false;
    }
    return true;
  }
  return true;
}


const JSJitInfo mozFullScreenElement_getterinfo = {
  (JSJitPropertyOp)get_mozFullScreenElement,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_mozFullScreen(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  bool result;
  result = self->MozFullScreen();
  *vp = BOOLEAN_TO_JSVAL(result);
  return true;
}


const JSJitInfo mozFullScreen_getterinfo = {
  (JSJitPropertyOp)get_mozFullScreen,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

static bool
mozCancelFullScreen(JSContext* cx, JSHandleObject obj, nsIDocument* self, unsigned argc, JS::Value* vp)
{
  self->MozCancelFullScreen();
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo mozCancelFullScreen_methodinfo = {
  (JSJitPropertyOp)mozCancelFullScreen,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Method,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_mozPointerLockElement(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  mozilla::dom::Element* result;
  result = self->GetMozPointerLockElement();
  if (!result) {
    *vp = JSVAL_NULL;
    return true;
  }
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    if (!HandleNewBindingWrappingFailure(cx, obj, result, vp)) {
      return false;
    }
    return true;
  }
  return true;
}


const JSJitInfo mozPointerLockElement_getterinfo = {
  (JSJitPropertyOp)get_mozPointerLockElement,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
mozExitPointerLock(JSContext* cx, JSHandleObject obj, nsIDocument* self, unsigned argc, JS::Value* vp)
{
  self->MozExitPointerLock();
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo mozExitPointerLock_methodinfo = {
  (JSJitPropertyOp)mozExitPointerLock,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Method,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_hidden(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  bool result;
  result = self->Hidden();
  *vp = BOOLEAN_TO_JSVAL(result);
  return true;
}


const JSJitInfo hidden_getterinfo = {
  (JSJitPropertyOp)get_hidden,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_mozHidden(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  bool result;
  result = self->MozHidden();
  *vp = BOOLEAN_TO_JSVAL(result);
  return true;
}


const JSJitInfo mozHidden_getterinfo = {
  (JSJitPropertyOp)get_mozHidden,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  true,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_INT32   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_visibilityState(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  VisibilityState result;
  result = self->VisibilityState();
  MOZ_ASSERT(uint32_t(result) < ArrayLength(VisibilityStateValues::strings));
  JSString* result_str = JS_NewStringCopyN(cx, VisibilityStateValues::strings[uint32_t(result)].value, VisibilityStateValues::strings[uint32_t(result)].length);
  if (!result_str) {
  return false;
  }
  *vp = JS::StringValue(result_str);
  return true;
}


const JSJitInfo visibilityState_getterinfo = {
  (JSJitPropertyOp)get_visibilityState,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_mozVisibilityState(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  VisibilityState result;
  result = self->MozVisibilityState();
  MOZ_ASSERT(uint32_t(result) < ArrayLength(VisibilityStateValues::strings));
  JSString* result_str = JS_NewStringCopyN(cx, VisibilityStateValues::strings[uint32_t(result)].value, VisibilityStateValues::strings[uint32_t(result)].length);
  if (!result_str) {
  return false;
  }
  *vp = JS::StringValue(result_str);
  return true;
}


const JSJitInfo mozVisibilityState_getterinfo = {
  (JSJitPropertyOp)get_mozVisibilityState,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_STRING   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_styleSheets(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsIDOMStyleSheetList* result;
  result = self->StyleSheets();
  if (!WrapObject(cx, obj, result, vp)) {
    return false;
  }
  return true;
}


const JSJitInfo styleSheets_getterinfo = {
  (JSJitPropertyOp)get_styleSheets,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  true,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_selectedStyleSheetSet(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsString result;
  self->GetSelectedStyleSheetSet(result);
  if (!xpc::StringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}

static bool
set_selectedStyleSheetSet(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* argv)
{
  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eNull, eNull, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  self->SetSelectedStyleSheetSet(arg0);

  return true;
}


const JSJitInfo selectedStyleSheetSet_getterinfo = {
  (JSJitPropertyOp)get_selectedStyleSheetSet,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

const JSJitInfo selectedStyleSheetSet_setterinfo = {
  (JSJitPropertyOp)set_selectedStyleSheetSet,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Setter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_lastStyleSheetSet(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsString result;
  self->GetLastStyleSheetSet(result);
  if (!xpc::StringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}


const JSJitInfo lastStyleSheetSet_getterinfo = {
  (JSJitPropertyOp)get_lastStyleSheetSet,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_preferredStyleSheetSet(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsString result;
  self->GetPreferredStyleSheetSet(result);
  if (!xpc::StringToJsval(cx, result, vp)) {
    return false;
  }
  return true;
}


const JSJitInfo preferredStyleSheetSet_getterinfo = {
  (JSJitPropertyOp)get_preferredStyleSheetSet,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_styleSheetSets(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsIDOMDOMStringList* result;
  result = self->StyleSheetSets();
  if (!WrapObject(cx, obj, result, vp)) {
    return false;
  }
  return true;
}


const JSJitInfo styleSheetSets_getterinfo = {
  (JSJitPropertyOp)get_styleSheetSets,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  true,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
enableStyleSheetsForSet(JSContext* cx, JSHandleObject obj, nsIDocument* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Document.enableStyleSheetsForSet");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eNull, eNull, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  self->EnableStyleSheetsForSet(arg0);
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo enableStyleSheetsForSet_methodinfo = {
  (JSJitPropertyOp)enableStyleSheetsForSet,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
elementFromPoint(JSContext* cx, JSHandleObject obj, nsIDocument* self, unsigned argc, JS::Value* vp)
{

  if (argc < 2) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Document.elementFromPoint");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[0], &arg0)) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg0)) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    ThrowErrorMessage(cx, MSG_NOT_FINITE);
    return false;
  }
  float arg1;
  if (!ValueToPrimitive<float, eDefault>(cx, argv[1], &arg1)) {
    return false;
  } else if (!MOZ_DOUBLE_IS_FINITE(arg1)) {
    // Note: MOZ_DOUBLE_IS_FINITE will do the right thing
    //       when passed a non-finite float too.
    ThrowErrorMessage(cx, MSG_NOT_FINITE);
    return false;
  }
  mozilla::dom::Element* result;
  result = self->ElementFromPoint(arg0, arg1);
  if (!result) {
    *vp = JSVAL_NULL;
    return true;
  }
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    if (!HandleNewBindingWrappingFailure(cx, obj, result, vp)) {
      return false;
    }
    return true;
  }
  return true;
}


const JSJitInfo elementFromPoint_methodinfo = {
  (JSJitPropertyOp)elementFromPoint,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
get_undoManager(JSContext* cx, JSHandleObject obj, nsIDocument* self, JS::Value* vp)
{
  nsRefPtr<mozilla::dom::UndoManager> result;
  result = self->GetUndoManager();
  if (!result) {
    *vp = JSVAL_NULL;
    return true;
  }
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}


const JSJitInfo undoManager_getterinfo = {
  (JSJitPropertyOp)get_undoManager,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Getter,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
querySelector(JSContext* cx, JSHandleObject obj, nsIDocument* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Document.querySelector");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eStringify, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  mozilla::dom::Element* result;
  result = self->QuerySelector(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "querySelector");
  }
  if (!result) {
    *vp = JSVAL_NULL;
    return true;
  }
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    if (!HandleNewBindingWrappingFailure(cx, obj, result, vp)) {
      return false;
    }
    return true;
  }
  return true;
}


const JSJitInfo querySelector_methodinfo = {
  (JSJitPropertyOp)querySelector,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
querySelectorAll(JSContext* cx, JSHandleObject obj, nsIDocument* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Document.querySelectorAll");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eStringify, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  nsRefPtr<nsINodeList> result;
  result = self->QuerySelectorAll(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "querySelectorAll");
  }
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}


const JSJitInfo querySelectorAll_methodinfo = {
  (JSJitPropertyOp)querySelectorAll,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
getAnonymousNodes(JSContext* cx, JSHandleObject obj, nsIDocument* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Document.getAnonymousNodes");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  NonNull<mozilla::dom::Element> arg0;
  if (argv[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::Element, mozilla::dom::Element>(cx, &argv[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        mozilla::dom::Element *objPtr;
        xpc_qsSelfRef objRef;
        JS::Value val = JS::ObjectValue(*&argv[0].toObject());
        nsresult rv = xpc_qsUnwrapArg<mozilla::dom::Element>(cx, val, &objPtr, &objRef.ptr, &val);
        if (NS_FAILED(rv)) {
            ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "Element");
            return false;
        }
        // We should be castable!
        MOZ_ASSERT(!objRef.ptr);
        // We should have an object, too!
        MOZ_ASSERT(objPtr);
        arg0 = objPtr;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  nsINodeList* result;
  result = self->GetAnonymousNodes(arg0);
  if (!result) {
    *vp = JSVAL_NULL;
    return true;
  }
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}


const JSJitInfo getAnonymousNodes_methodinfo = {
  (JSJitPropertyOp)getAnonymousNodes,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
getAnonymousElementByAttribute(JSContext* cx, JSHandleObject obj, nsIDocument* self, unsigned argc, JS::Value* vp)
{

  if (argc < 3) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Document.getAnonymousElementByAttribute");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  NonNull<mozilla::dom::Element> arg0;
  if (argv[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::Element, mozilla::dom::Element>(cx, &argv[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        mozilla::dom::Element *objPtr;
        xpc_qsSelfRef objRef;
        JS::Value val = JS::ObjectValue(*&argv[0].toObject());
        nsresult rv = xpc_qsUnwrapArg<mozilla::dom::Element>(cx, val, &objPtr, &objRef.ptr, &val);
        if (NS_FAILED(rv)) {
            ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "Element");
            return false;
        }
        // We should be castable!
        MOZ_ASSERT(!objRef.ptr);
        // We should have an object, too!
        MOZ_ASSERT(objPtr);
        arg0 = objPtr;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  FakeDependentString arg1_holder;
  const NonNull<nsAString> arg1;
  if (!ConvertJSValueToString(cx, argv[1], &argv[1], eStringify, eStringify, arg1_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg1) = &arg1_holder;
  FakeDependentString arg2_holder;
  const NonNull<nsAString> arg2;
  if (!ConvertJSValueToString(cx, argv[2], &argv[2], eStringify, eStringify, arg2_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg2) = &arg2_holder;
  nsRefPtr<mozilla::dom::Element> result;
  result = self->GetAnonymousElementByAttribute(arg0, arg1, arg2);
  if (!result) {
    *vp = JSVAL_NULL;
    return true;
  }
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    if (!HandleNewBindingWrappingFailure(cx, obj, result, vp)) {
      return false;
    }
    return true;
  }
  return true;
}


const JSJitInfo getAnonymousElementByAttribute_methodinfo = {
  (JSJitPropertyOp)getAnonymousElementByAttribute,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
addBinding(JSContext* cx, JSHandleObject obj, nsIDocument* self, unsigned argc, JS::Value* vp)
{

  if (argc < 2) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Document.addBinding");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  NonNull<mozilla::dom::Element> arg0;
  if (argv[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::Element, mozilla::dom::Element>(cx, &argv[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        mozilla::dom::Element *objPtr;
        xpc_qsSelfRef objRef;
        JS::Value val = JS::ObjectValue(*&argv[0].toObject());
        nsresult rv = xpc_qsUnwrapArg<mozilla::dom::Element>(cx, val, &objPtr, &objRef.ptr, &val);
        if (NS_FAILED(rv)) {
            ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "Element");
            return false;
        }
        // We should be castable!
        MOZ_ASSERT(!objRef.ptr);
        // We should have an object, too!
        MOZ_ASSERT(objPtr);
        arg0 = objPtr;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  FakeDependentString arg1_holder;
  const NonNull<nsAString> arg1;
  if (!ConvertJSValueToString(cx, argv[1], &argv[1], eStringify, eStringify, arg1_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg1) = &arg1_holder;
  ErrorResult rv;
  self->AddBinding(arg0, arg1, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "addBinding");
  }
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo addBinding_methodinfo = {
  (JSJitPropertyOp)addBinding,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
removeBinding(JSContext* cx, JSHandleObject obj, nsIDocument* self, unsigned argc, JS::Value* vp)
{

  if (argc < 2) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Document.removeBinding");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  NonNull<mozilla::dom::Element> arg0;
  if (argv[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::Element, mozilla::dom::Element>(cx, &argv[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        mozilla::dom::Element *objPtr;
        xpc_qsSelfRef objRef;
        JS::Value val = JS::ObjectValue(*&argv[0].toObject());
        nsresult rv = xpc_qsUnwrapArg<mozilla::dom::Element>(cx, val, &objPtr, &objRef.ptr, &val);
        if (NS_FAILED(rv)) {
            ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "Element");
            return false;
        }
        // We should be castable!
        MOZ_ASSERT(!objRef.ptr);
        // We should have an object, too!
        MOZ_ASSERT(objPtr);
        arg0 = objPtr;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  FakeDependentString arg1_holder;
  const NonNull<nsAString> arg1;
  if (!ConvertJSValueToString(cx, argv[1], &argv[1], eStringify, eStringify, arg1_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg1) = &arg1_holder;
  ErrorResult rv;
  self->RemoveBinding(arg0, arg1, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "removeBinding");
  }
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo removeBinding_methodinfo = {
  (JSJitPropertyOp)removeBinding,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
getBindingParent(JSContext* cx, JSHandleObject obj, nsIDocument* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Document.getBindingParent");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  NonNull<nsINode> arg0;
  if (argv[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::Node, nsINode>(cx, &argv[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        nsINode *objPtr;
        xpc_qsSelfRef objRef;
        JS::Value val = JS::ObjectValue(*&argv[0].toObject());
        nsresult rv = xpc_qsUnwrapArg<nsINode>(cx, val, &objPtr, &objRef.ptr, &val);
        if (NS_FAILED(rv)) {
            ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "Node");
            return false;
        }
        // We should be castable!
        MOZ_ASSERT(!objRef.ptr);
        // We should have an object, too!
        MOZ_ASSERT(objPtr);
        arg0 = objPtr;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  mozilla::dom::Element* result;
  result = self->GetBindingParent(arg0);
  if (!result) {
    *vp = JSVAL_NULL;
    return true;
  }
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    if (!HandleNewBindingWrappingFailure(cx, obj, result, vp)) {
      return false;
    }
    return true;
  }
  return true;
}


const JSJitInfo getBindingParent_methodinfo = {
  (JSJitPropertyOp)getBindingParent,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNKNOWN   /* returnType.  Only relevant for getters/methods. */
};

static bool
loadBindingDocument(JSContext* cx, JSHandleObject obj, nsIDocument* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Document.loadBindingDocument");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eStringify, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  ErrorResult rv;
  self->LoadBindingDocument(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "loadBindingDocument");
  }
  *vp = JSVAL_VOID;
  return true;
}


const JSJitInfo loadBindingDocument_methodinfo = {
  (JSJitPropertyOp)loadBindingDocument,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_UNDEFINED   /* returnType.  Only relevant for getters/methods. */
};

static bool
createExpression(JSContext* cx, JSHandleObject obj, nsIDocument* self, unsigned argc, JS::Value* vp)
{

  if (argc < 2) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Document.createExpression");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eStringify, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  nsRefPtr<nsIDOMXPathNSResolver> arg1_holder;
  nsIDOMXPathNSResolver* arg1;
  if (argv[1].isObject()) {
    jsval tmpVal = argv[1];
    nsIDOMXPathNSResolver* tmp;
    if (NS_FAILED(xpc_qsUnwrapArg<nsIDOMXPathNSResolver>(cx, argv[1], &tmp, static_cast<nsIDOMXPathNSResolver**>(getter_AddRefs(arg1_holder)), &tmpVal))) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "XPathNSResolver");return false;
    }
    MOZ_ASSERT(tmp);
    if (tmpVal != argv[1] && !arg1_holder) {
      // We have to have a strong ref, because we got this off
      // some random object that might get GCed
      arg1_holder = tmp;
    }
    arg1 = tmp;
  } else if (argv[1].isNullOrUndefined()) {
    arg1 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  ErrorResult rv;
  nsRefPtr<nsIDOMXPathExpression> result;
  result = self->CreateExpression(arg0, arg1, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "createExpression");
  }
  if (!WrapObject(cx, obj, result, vp)) {
    return false;
  }
  return true;
}


const JSJitInfo createExpression_methodinfo = {
  (JSJitPropertyOp)createExpression,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
createNSResolver(JSContext* cx, JSHandleObject obj, nsIDocument* self, unsigned argc, JS::Value* vp)
{

  if (argc < 1) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Document.createNSResolver");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  nsINode* arg0;
  if (argv[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::Node, nsINode>(cx, &argv[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        nsINode *objPtr;
        xpc_qsSelfRef objRef;
        JS::Value val = JS::ObjectValue(*&argv[0].toObject());
        nsresult rv = xpc_qsUnwrapArg<nsINode>(cx, val, &objPtr, &objRef.ptr, &val);
        if (NS_FAILED(rv)) {
            ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "Node");
            return false;
        }
        // We should be castable!
        MOZ_ASSERT(!objRef.ptr);
        // We should have an object, too!
        MOZ_ASSERT(objPtr);
        arg0 = objPtr;
      }
    }
  } else if (argv[0].isNullOrUndefined()) {
    arg0 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  ErrorResult rv;
  nsRefPtr<nsIDOMXPathNSResolver> result;
  result = self->CreateNSResolver(arg0, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "createNSResolver");
  }
  if (!WrapObject(cx, obj, result, vp)) {
    return false;
  }
  return true;
}


const JSJitInfo createNSResolver_methodinfo = {
  (JSJitPropertyOp)createNSResolver,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static bool
evaluate(JSContext* cx, JSHandleObject obj, nsIDocument* self, unsigned argc, JS::Value* vp)
{

  if (argc < 5) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Document.evaluate");
  }

  JS::Value* argv = JS_ARGV(cx, vp);

  FakeDependentString arg0_holder;
  const NonNull<nsAString> arg0;
  if (!ConvertJSValueToString(cx, argv[0], &argv[0], eStringify, eStringify, arg0_holder)) {
    return false;
  }
  const_cast<NonNull<nsAString>&>(arg0) = &arg0_holder;
  nsINode* arg1;
  if (argv[1].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::Node, nsINode>(cx, &argv[1].toObject(), arg1);
      if (NS_FAILED(rv)) {
        nsINode *objPtr;
        xpc_qsSelfRef objRef;
        JS::Value val = JS::ObjectValue(*&argv[1].toObject());
        nsresult rv = xpc_qsUnwrapArg<nsINode>(cx, val, &objPtr, &objRef.ptr, &val);
        if (NS_FAILED(rv)) {
            ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "Node");
            return false;
        }
        // We should be castable!
        MOZ_ASSERT(!objRef.ptr);
        // We should have an object, too!
        MOZ_ASSERT(objPtr);
        arg1 = objPtr;
      }
    }
  } else if (argv[1].isNullOrUndefined()) {
    arg1 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  nsRefPtr<nsIDOMXPathNSResolver> arg2_holder;
  nsIDOMXPathNSResolver* arg2;
  if (argv[2].isObject()) {
    jsval tmpVal = argv[2];
    nsIDOMXPathNSResolver* tmp;
    if (NS_FAILED(xpc_qsUnwrapArg<nsIDOMXPathNSResolver>(cx, argv[2], &tmp, static_cast<nsIDOMXPathNSResolver**>(getter_AddRefs(arg2_holder)), &tmpVal))) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "XPathNSResolver");return false;
    }
    MOZ_ASSERT(tmp);
    if (tmpVal != argv[2] && !arg2_holder) {
      // We have to have a strong ref, because we got this off
      // some random object that might get GCed
      arg2_holder = tmp;
    }
    arg2 = tmp;
  } else if (argv[2].isNullOrUndefined()) {
    arg2 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  uint16_t arg3;
  if (!ValueToPrimitive<uint16_t, eDefault>(cx, argv[3], &arg3)) {
    return false;
  }
  nsRefPtr<nsISupports> arg4_holder;
  nsISupports* arg4;
  if (argv[4].isObject()) {
    jsval tmpVal = argv[4];
    nsISupports* tmp;
    if (NS_FAILED(xpc_qsUnwrapArg<nsISupports>(cx, argv[4], &tmp, static_cast<nsISupports**>(getter_AddRefs(arg4_holder)), &tmpVal))) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "XPathResult");return false;
    }
    MOZ_ASSERT(tmp);
    if (tmpVal != argv[4] && !arg4_holder) {
      // We have to have a strong ref, because we got this off
      // some random object that might get GCed
      arg4_holder = tmp;
    }
    arg4 = tmp;
  } else if (argv[4].isNullOrUndefined()) {
    arg4 = NULL;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT);
    return false;
  }
  ErrorResult rv;
  nsRefPtr<nsISupports> result;
  result = self->Evaluate(arg0, arg1, arg2, arg3, arg4, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "evaluate");
  }
  if (!WrapObject(cx, obj, result, vp)) {
    return false;
  }
  return true;
}


const JSJitInfo evaluate_methodinfo = {
  (JSJitPropertyOp)evaluate,
  prototypes::id::Document,
  PrototypeTraits<prototypes::id::Document>::Depth,
  JSJitInfo::Method,
  false,  /* isInfallible. False in setters. */
  false,  /* isConstant. Only relevant for getters. */
  JSVAL_TYPE_OBJECT   /* returnType.  Only relevant for getters/methods. */
};

static JSBool
genericMethod(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  nsIDocument* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::Document, nsIDocument>(cx, obj, self);
    if (NS_FAILED(rv)) {
      nsIDocument *objPtr;
      xpc_qsSelfRef objRef;
      JS::Value val = JS::ObjectValue(*obj);
      nsresult rv = xpc_qsUnwrapArg<nsIDocument>(cx, val, &objPtr, &objRef.ptr, &val);
      if (NS_FAILED(rv)) {
          return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "Document");
      }
      // We should be castable!
      MOZ_ASSERT(!objRef.ptr);
      // We should have an object, too!
      MOZ_ASSERT(objPtr);
      self = objPtr;
    }
  }
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Method);
  JSJitMethodOp method = (JSJitMethodOp)info->op;
  return method(cx, obj, self, argc, vp);
}

static JSBool
genericGetter(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  nsIDocument* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::Document, nsIDocument>(cx, obj, self);
    if (NS_FAILED(rv)) {
      nsIDocument *objPtr;
      xpc_qsSelfRef objRef;
      JS::Value val = JS::ObjectValue(*obj);
      nsresult rv = xpc_qsUnwrapArg<nsIDocument>(cx, val, &objPtr, &objRef.ptr, &val);
      if (NS_FAILED(rv)) {
          return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "Document");
      }
      // We should be castable!
      MOZ_ASSERT(!objRef.ptr);
      // We should have an object, too!
      MOZ_ASSERT(objPtr);
      self = objPtr;
    }
  }
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Getter);
  JSJitPropertyOp getter = info->op;
  return getter(cx, obj, self, vp);
}

static JSBool
genericLenientGetter(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  nsIDocument* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::Document, nsIDocument>(cx, obj, self);
    if (NS_FAILED(rv)) {
      nsIDocument *objPtr;
      xpc_qsSelfRef objRef;
      JS::Value val = JS::ObjectValue(*obj);
      nsresult rv = xpc_qsUnwrapArg<nsIDocument>(cx, val, &objPtr, &objRef.ptr, &val);
      if (NS_FAILED(rv)) {
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          JS_SET_RVAL(cx, vp, JS::UndefinedValue());
          return true;
      }
      // We should be castable!
      MOZ_ASSERT(!objRef.ptr);
      // We should have an object, too!
      MOZ_ASSERT(objPtr);
      self = objPtr;
    }
  }
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Getter);
  JSJitPropertyOp getter = info->op;
  return getter(cx, obj, self, vp);
}

static JSBool
genericSetter(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  nsIDocument* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::Document, nsIDocument>(cx, obj, self);
    if (NS_FAILED(rv)) {
      nsIDocument *objPtr;
      xpc_qsSelfRef objRef;
      JS::Value val = JS::ObjectValue(*obj);
      nsresult rv = xpc_qsUnwrapArg<nsIDocument>(cx, val, &objPtr, &objRef.ptr, &val);
      if (NS_FAILED(rv)) {
          return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "Document");
      }
      // We should be castable!
      MOZ_ASSERT(!objRef.ptr);
      // We should have an object, too!
      MOZ_ASSERT(objPtr);
      self = objPtr;
    }
  }
  if (argc == 0) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Document attribute setter");
  }
  JS::Value* argv = JS_ARGV(cx, vp);
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Setter);
  JSJitPropertyOp setter = info->op;
  if (!setter(cx, obj, self, argv)) {
    return false;
  }
  *vp = JSVAL_VOID;
  return true;
}

static JSBool
genericLenientSetter(JSContext* cx, unsigned argc, JS::Value* vp)
{
  js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
  if (!obj) {
    return false;
  }

  nsIDocument* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::Document, nsIDocument>(cx, obj, self);
    if (NS_FAILED(rv)) {
      nsIDocument *objPtr;
      xpc_qsSelfRef objRef;
      JS::Value val = JS::ObjectValue(*obj);
      nsresult rv = xpc_qsUnwrapArg<nsIDocument>(cx, val, &objPtr, &objRef.ptr, &val);
      if (NS_FAILED(rv)) {
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          return true;
      }
      // We should be castable!
      MOZ_ASSERT(!objRef.ptr);
      // We should have an object, too!
      MOZ_ASSERT(objPtr);
      self = objPtr;
    }
  }
  if (argc == 0) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Document attribute setter");
  }
  JS::Value* argv = JS_ARGV(cx, vp);
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));
  MOZ_ASSERT(info->type == JSJitInfo::Setter);
  JSJitPropertyOp setter = info->op;
  if (!setter(cx, obj, self, argv)) {
    return false;
  }
  *vp = JSVAL_VOID;
  return true;
}

static JSBool
_addProperty(JSContext* cx, JSHandleObject obj, JSHandleId id, JSMutableHandleValue vp)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, nsIDocument>::value), "Must be an nsISupports class");
  nsIDocument* self = UnwrapDOMObject<nsIDocument>(obj);
  nsContentUtils::PreserveWrapper(reinterpret_cast<nsISupports*>(self), self);
  return true;
}

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  MOZ_STATIC_ASSERT((IsBaseOf<nsISupports, nsIDocument>::value), "Must be an nsISupports class");
  nsIDocument* self = UnwrapDOMObject<nsIDocument>(obj);
  if (self) {
    ClearWrapper(self, self);
    XPCJSRuntime *rt = nsXPConnect::GetRuntimeInstance();
    if (rt) {
      rt->DeferredRelease(reinterpret_cast<nsISupports*>(self));
    } else {
      NS_RELEASE(self);
    }
  }
}

static JSFunctionSpec sMethods_specs[] = {
  JS_FNINFO("getElementsByTagName", genericMethod, &getElementsByTagName_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("getElementsByTagNameNS", genericMethod, &getElementsByTagNameNS_methodinfo, 2, JSPROP_ENUMERATE),
  JS_FNINFO("getElementsByClassName", genericMethod, &getElementsByClassName_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("getElementById", genericMethod, &getElementById_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("createElement", genericMethod, &createElement_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("createElementNS", genericMethod, &createElementNS_methodinfo, 2, JSPROP_ENUMERATE),
  JS_FNINFO("createDocumentFragment", genericMethod, &createDocumentFragment_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("createTextNode", genericMethod, &createTextNode_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("createComment", genericMethod, &createComment_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("createProcessingInstruction", genericMethod, &createProcessingInstruction_methodinfo, 2, JSPROP_ENUMERATE),
  JS_FNINFO("importNode", genericMethod, &importNode_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("adoptNode", genericMethod, &adoptNode_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("createEvent", genericMethod, &createEvent_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("createRange", genericMethod, &createRange_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("createNodeIterator", genericMethod, &createNodeIterator_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("createTreeWalker", genericMethod, &createTreeWalker_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("createCDATASection", genericMethod, &createCDATASection_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("createAttribute", genericMethod, &createAttribute_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("createAttributeNS", genericMethod, &createAttributeNS_methodinfo, 2, JSPROP_ENUMERATE),
  JS_FNINFO("hasFocus", genericMethod, &hasFocus_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("releaseCapture", genericMethod, &releaseCapture_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("mozSetImageElement", genericMethod, &mozSetImageElement_methodinfo, 2, JSPROP_ENUMERATE),
  JS_FNINFO("mozCancelFullScreen", genericMethod, &mozCancelFullScreen_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("mozExitPointerLock", genericMethod, &mozExitPointerLock_methodinfo, 0, JSPROP_ENUMERATE),
  JS_FNINFO("enableStyleSheetsForSet", genericMethod, &enableStyleSheetsForSet_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("elementFromPoint", genericMethod, &elementFromPoint_methodinfo, 2, JSPROP_ENUMERATE),
  JS_FNINFO("querySelector", genericMethod, &querySelector_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("querySelectorAll", genericMethod, &querySelectorAll_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("getAnonymousNodes", genericMethod, &getAnonymousNodes_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("getAnonymousElementByAttribute", genericMethod, &getAnonymousElementByAttribute_methodinfo, 3, JSPROP_ENUMERATE),
  JS_FNINFO("addBinding", genericMethod, &addBinding_methodinfo, 2, JSPROP_ENUMERATE),
  JS_FNINFO("removeBinding", genericMethod, &removeBinding_methodinfo, 2, JSPROP_ENUMERATE),
  JS_FNINFO("getBindingParent", genericMethod, &getBindingParent_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("loadBindingDocument", genericMethod, &loadBindingDocument_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("createExpression", genericMethod, &createExpression_methodinfo, 2, JSPROP_ENUMERATE),
  JS_FNINFO("createNSResolver", genericMethod, &createNSResolver_methodinfo, 1, JSPROP_ENUMERATE),
  JS_FNINFO("evaluate", genericMethod, &evaluate_methodinfo, 5, JSPROP_ENUMERATE),
  JS_FS_END
};

static Prefable<JSFunctionSpec> sMethods[] = {
  { true, &sMethods_specs[0] },
  { false, NULL }
};

static jsid sMethods_ids[38] = { JSID_VOID };

static JSPropertySpec sAttributes_specs[] = {
  { "implementation", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &implementation_getterinfo }, JSOP_NULLWRAPPER},
  { "URL", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &URL_getterinfo }, JSOP_NULLWRAPPER},
  { "documentURI", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &documentURI_getterinfo }, JSOP_NULLWRAPPER},
  { "compatMode", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &compatMode_getterinfo }, JSOP_NULLWRAPPER},
  { "characterSet", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &characterSet_getterinfo }, JSOP_NULLWRAPPER},
  { "contentType", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &contentType_getterinfo }, JSOP_NULLWRAPPER},
  { "doctype", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &doctype_getterinfo }, JSOP_NULLWRAPPER},
  { "documentElement", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &documentElement_getterinfo }, JSOP_NULLWRAPPER},
  { "inputEncoding", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &inputEncoding_getterinfo }, JSOP_NULLWRAPPER},
  { "referrer", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &referrer_getterinfo }, JSOP_NULLWRAPPER},
  { "lastModified", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &lastModified_getterinfo }, JSOP_NULLWRAPPER},
  { "readyState", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &readyState_getterinfo }, JSOP_NULLWRAPPER},
  { "title", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &title_getterinfo }, { (JSStrictPropertyOp)genericSetter, &title_setterinfo }},
  { "dir", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &dir_getterinfo }, { (JSStrictPropertyOp)genericSetter, &dir_setterinfo }},
  { "defaultView", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &defaultView_getterinfo }, JSOP_NULLWRAPPER},
  { "activeElement", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &activeElement_getterinfo }, JSOP_NULLWRAPPER},
  { "onabort", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onabort_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onabort_setterinfo }},
  { "onblur", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onblur_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onblur_setterinfo }},
  { "oncanplay", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &oncanplay_getterinfo }, { (JSStrictPropertyOp)genericSetter, &oncanplay_setterinfo }},
  { "oncanplaythrough", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &oncanplaythrough_getterinfo }, { (JSStrictPropertyOp)genericSetter, &oncanplaythrough_setterinfo }},
  { "onchange", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onchange_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onchange_setterinfo }},
  { "onclick", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onclick_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onclick_setterinfo }},
  { "oncontextmenu", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &oncontextmenu_getterinfo }, { (JSStrictPropertyOp)genericSetter, &oncontextmenu_setterinfo }},
  { "ondblclick", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &ondblclick_getterinfo }, { (JSStrictPropertyOp)genericSetter, &ondblclick_setterinfo }},
  { "ondrag", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &ondrag_getterinfo }, { (JSStrictPropertyOp)genericSetter, &ondrag_setterinfo }},
  { "ondragend", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &ondragend_getterinfo }, { (JSStrictPropertyOp)genericSetter, &ondragend_setterinfo }},
  { "ondragenter", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &ondragenter_getterinfo }, { (JSStrictPropertyOp)genericSetter, &ondragenter_setterinfo }},
  { "ondragleave", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &ondragleave_getterinfo }, { (JSStrictPropertyOp)genericSetter, &ondragleave_setterinfo }},
  { "ondragover", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &ondragover_getterinfo }, { (JSStrictPropertyOp)genericSetter, &ondragover_setterinfo }},
  { "ondragstart", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &ondragstart_getterinfo }, { (JSStrictPropertyOp)genericSetter, &ondragstart_setterinfo }},
  { "ondrop", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &ondrop_getterinfo }, { (JSStrictPropertyOp)genericSetter, &ondrop_setterinfo }},
  { "ondurationchange", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &ondurationchange_getterinfo }, { (JSStrictPropertyOp)genericSetter, &ondurationchange_setterinfo }},
  { "onemptied", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onemptied_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onemptied_setterinfo }},
  { "onended", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onended_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onended_setterinfo }},
  { "onerror", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onerror_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onerror_setterinfo }},
  { "onfocus", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onfocus_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onfocus_setterinfo }},
  { "oninput", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &oninput_getterinfo }, { (JSStrictPropertyOp)genericSetter, &oninput_setterinfo }},
  { "oninvalid", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &oninvalid_getterinfo }, { (JSStrictPropertyOp)genericSetter, &oninvalid_setterinfo }},
  { "onkeydown", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onkeydown_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onkeydown_setterinfo }},
  { "onkeypress", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onkeypress_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onkeypress_setterinfo }},
  { "onkeyup", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onkeyup_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onkeyup_setterinfo }},
  { "onload", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onload_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onload_setterinfo }},
  { "onloadeddata", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onloadeddata_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onloadeddata_setterinfo }},
  { "onloadedmetadata", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onloadedmetadata_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onloadedmetadata_setterinfo }},
  { "onloadstart", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onloadstart_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onloadstart_setterinfo }},
  { "onmousedown", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onmousedown_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onmousedown_setterinfo }},
  { "onmousemove", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onmousemove_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onmousemove_setterinfo }},
  { "onmouseout", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onmouseout_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onmouseout_setterinfo }},
  { "onmouseover", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onmouseover_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onmouseover_setterinfo }},
  { "onmouseup", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onmouseup_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onmouseup_setterinfo }},
  { "onpause", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onpause_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onpause_setterinfo }},
  { "onplay", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onplay_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onplay_setterinfo }},
  { "onplaying", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onplaying_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onplaying_setterinfo }},
  { "onprogress", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onprogress_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onprogress_setterinfo }},
  { "onratechange", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onratechange_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onratechange_setterinfo }},
  { "onreset", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onreset_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onreset_setterinfo }},
  { "onscroll", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onscroll_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onscroll_setterinfo }},
  { "onseeked", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onseeked_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onseeked_setterinfo }},
  { "onseeking", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onseeking_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onseeking_setterinfo }},
  { "onselect", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onselect_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onselect_setterinfo }},
  { "onshow", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onshow_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onshow_setterinfo }},
  { "onstalled", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onstalled_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onstalled_setterinfo }},
  { "onsubmit", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onsubmit_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onsubmit_setterinfo }},
  { "onsuspend", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onsuspend_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onsuspend_setterinfo }},
  { "ontimeupdate", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &ontimeupdate_getterinfo }, { (JSStrictPropertyOp)genericSetter, &ontimeupdate_setterinfo }},
  { "onvolumechange", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onvolumechange_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onvolumechange_setterinfo }},
  { "onwaiting", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onwaiting_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onwaiting_setterinfo }},
  { "onreadystatechange", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericLenientGetter, &onreadystatechange_getterinfo }, { (JSStrictPropertyOp)genericLenientSetter, &onreadystatechange_setterinfo }},
  { "onmouseenter", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericLenientGetter, &onmouseenter_getterinfo }, { (JSStrictPropertyOp)genericLenientSetter, &onmouseenter_setterinfo }},
  { "onmouseleave", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericLenientGetter, &onmouseleave_getterinfo }, { (JSStrictPropertyOp)genericLenientSetter, &onmouseleave_setterinfo }},
  { "onmozfullscreenchange", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onmozfullscreenchange_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onmozfullscreenchange_setterinfo }},
  { "onmozfullscreenerror", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onmozfullscreenerror_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onmozfullscreenerror_setterinfo }},
  { "onmozpointerlockchange", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onmozpointerlockchange_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onmozpointerlockchange_setterinfo }},
  { "onmozpointerlockerror", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onmozpointerlockerror_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onmozpointerlockerror_setterinfo }},
  { "onwheel", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onwheel_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onwheel_setterinfo }},
  { "oncopy", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &oncopy_getterinfo }, { (JSStrictPropertyOp)genericSetter, &oncopy_setterinfo }},
  { "oncut", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &oncut_getterinfo }, { (JSStrictPropertyOp)genericSetter, &oncut_setterinfo }},
  { "onpaste", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onpaste_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onpaste_setterinfo }},
  { "onbeforescriptexecute", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onbeforescriptexecute_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onbeforescriptexecute_setterinfo }},
  { "onafterscriptexecute", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &onafterscriptexecute_getterinfo }, { (JSStrictPropertyOp)genericSetter, &onafterscriptexecute_setterinfo }},
  { "currentScript", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &currentScript_getterinfo }, JSOP_NULLWRAPPER},
  { "mozFullScreenEnabled", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &mozFullScreenEnabled_getterinfo }, JSOP_NULLWRAPPER},
  { "mozFullScreenElement", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &mozFullScreenElement_getterinfo }, JSOP_NULLWRAPPER},
  { "mozFullScreen", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &mozFullScreen_getterinfo }, JSOP_NULLWRAPPER},
  { "mozPointerLockElement", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &mozPointerLockElement_getterinfo }, JSOP_NULLWRAPPER},
  { "hidden", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &hidden_getterinfo }, JSOP_NULLWRAPPER},
  { "mozHidden", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &mozHidden_getterinfo }, JSOP_NULLWRAPPER},
  { "visibilityState", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &visibilityState_getterinfo }, JSOP_NULLWRAPPER},
  { "mozVisibilityState", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &mozVisibilityState_getterinfo }, JSOP_NULLWRAPPER},
  { "styleSheets", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &styleSheets_getterinfo }, JSOP_NULLWRAPPER},
  { "selectedStyleSheetSet", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &selectedStyleSheetSet_getterinfo }, { (JSStrictPropertyOp)genericSetter, &selectedStyleSheetSet_setterinfo }},
  { "lastStyleSheetSet", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &lastStyleSheetSet_getterinfo }, JSOP_NULLWRAPPER},
  { "preferredStyleSheetSet", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &preferredStyleSheetSet_getterinfo }, JSOP_NULLWRAPPER},
  { "styleSheetSets", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &styleSheetSets_getterinfo }, JSOP_NULLWRAPPER},
  { 0, 0, 0, JSOP_NULLWRAPPER, JSOP_NULLWRAPPER },
  { "undoManager", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &undoManager_getterinfo }, JSOP_NULLWRAPPER},
  { 0, 0, 0, JSOP_NULLWRAPPER, JSOP_NULLWRAPPER }
};

static Prefable<JSPropertySpec> sAttributes[] = {
  { true, &sAttributes_specs[0] },
  { true, &sAttributes_specs[95] },
  { false, NULL }
};

static jsid sAttributes_ids[97] = { JSID_VOID };

static JSPropertySpec sChromeAttributes_specs[] = {
  { "mozSyntheticDocument", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS, { (JSPropertyOp)genericGetter, &mozSyntheticDocument_getterinfo }, JSOP_NULLWRAPPER},
  { 0, 0, 0, JSOP_NULLWRAPPER, JSOP_NULLWRAPPER }
};

static Prefable<JSPropertySpec> sChromeAttributes[] = {
  { true, &sChromeAttributes_specs[0] },
  { false, NULL }
};

static jsid sChromeAttributes_ids[2] = { JSID_VOID };

static JSPropertySpec sUnforgeableAttributes_specs[] = {
  { "location", 0, JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS | JSPROP_PERMANENT, { (JSPropertyOp)genericGetter, &location_getterinfo }, { (JSStrictPropertyOp)genericSetter, &location_setterinfo }},
  { 0, 0, 0, JSOP_NULLWRAPPER, JSOP_NULLWRAPPER }
};

static Prefable<JSPropertySpec> sUnforgeableAttributes[] = {
  { true, &sUnforgeableAttributes_specs[0] },
  { false, NULL }
};

static jsid sUnforgeableAttributes_ids[2] = { JSID_VOID };


static const NativeProperties sNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sMethods, sMethods_ids, sMethods_specs,
  sAttributes, sAttributes_ids, sAttributes_specs,
  sUnforgeableAttributes, sUnforgeableAttributes_ids, sUnforgeableAttributes_specs,
  nullptr, nullptr, nullptr
};

static const NativeProperties sChromeOnlyNativeProperties = {
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr,
  sChromeAttributes, sChromeAttributes_ids, sChromeAttributes_specs,
  nullptr, nullptr, nullptr,
  nullptr, nullptr, nullptr
};
const NativePropertyHooks sNativePropertyHooks = {
  nullptr,
  nullptr,
  { &sNativeProperties, &sChromeOnlyNativeProperties },
  prototypes::id::Document,
  constructors::id::Document,
  &NodeBinding::sNativePropertyHooks
};

static JSBool
_constructor(JSContext* cx, unsigned argc, JS::Value* vp)
{

  JSObject* obj = JS_GetGlobalForObject(cx, JSVAL_TO_OBJECT(JS_CALLEE(cx, vp)));

  nsISupports* global;
  xpc_qsSelfRef globalRef;
  {
    nsresult rv;
    JS::Value val = OBJECT_TO_JSVAL(obj);
    rv = xpc_qsUnwrapArg<nsISupports>(cx, val, &global, &globalRef.ptr, &val);
    if (NS_FAILED(rv)) {
      return ThrowErrorMessage(cx, MSG_GLOBAL_NOT_NATIVE);
    }
  }
  ErrorResult rv;
  nsRefPtr<nsIDocument> result;
  result = nsIDocument::Constructor(global, rv);
  if (rv.Failed()) {
    return ThrowMethodFailedWithDetails<true>(cx, rv, "Document", "constructor");
  }
  if (!WrapNewBindingObject(cx, obj, result, vp)) {
    if (!HandleNewBindingWrappingFailure(cx, obj, result, vp)) {
      return false;
    }
    return true;
  }
  return true;
}

static JSBool
_hasInstance(JSContext* cx, JSHandleObject obj, JSMutableHandleValue vp, JSBool* bp)
{
  if (!vp.isObject()) {
    *bp = false;
    return true;
  }

  jsval protov;
  if (!JS_GetProperty(cx, obj, "prototype", &protov))
    return false;
  if (!protov.isObject()) {
    JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_BAD_PROTOTYPE,
                         "Document");
    return false;
  }
  JSObject *objProto = &protov.toObject();

  JSObject* instance = &vp.toObject();
  JSObject* proto;
  if (!JS_GetPrototype(cx, instance, &proto))
    return false;
  while (proto) {
    if (proto == objProto) {
      *bp = true;
      return true;
    }
    if (!JS_GetPrototype(cx, proto, &proto))
      return false;
  }

  // FIXME Limit this to chrome by checking xpc::AccessCheck::isChrome(obj).
  nsISupports* native =
    nsContentUtils::XPConnect()->GetNativeOfWrapper(cx, instance);
  nsCOMPtr<nsIDOMDocument> qiResult = do_QueryInterface(native);
  *bp = !!qiResult;
  return true;

}


static DOMIfaceAndProtoJSClass InterfaceObjectClass = {
  {
    "Function",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(2),
    JS_PropertyStub,       /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    nullptr,               /* finalize */
    nullptr,               /* checkAccess */
    _constructor, /* call */
    _hasInstance, /* hasInstance */
    _constructor, /* construct */
    nullptr,               /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  eInterface,
  &sNativePropertyHooks
};

static DOMIfaceAndProtoJSClass PrototypeClass = {
  {
    "DocumentPrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(2),
    JS_PropertyStub,       /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    nullptr,               /* finalize */
    nullptr,               /* checkAccess */
    nullptr,               /* call */
    nullptr,               /* hasInstance */
    nullptr,               /* construct */
    nullptr,               /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  eInterfacePrototype,
  &sNativePropertyHooks
};

void
CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray)
{
  JSObject* parentProto = NodeBinding::GetProtoObject(aCx, aGlobal);
  if (!parentProto) {
    return;
  }


  if (sMethods_ids[0] == JSID_VOID &&
      (!InitIds(aCx, sMethods, sMethods_ids) ||
       !InitIds(aCx, sChromeAttributes, sChromeAttributes_ids) ||
       !InitIds(aCx, sAttributes, sAttributes_ids) ||
       !InitIds(aCx, sUnforgeableAttributes, sUnforgeableAttributes_ids))) {
    sMethods_ids[0] = JSID_VOID;
    return;
  }

  static bool sPrefCachesInited = false;
  if (!sPrefCachesInited) {
    sPrefCachesInited = true;
    Preferences::AddBoolVarCache(&sAttributes[1].enabled, "dom.undo_manager.enabled");
  }

  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &PrototypeClass.mBase, &protoAndIfaceArray[prototypes::id::Document],
                              &InterfaceObjectClass.mBase, nullptr, 0, &protoAndIfaceArray[constructors::id::Document],
                              &Class.mClass,
                              &sNativeProperties,
                              xpc::AccessCheck::isChrome(aGlobal) ? &sChromeOnlyNativeProperties : nullptr,
                              "Document");
}

JSObject*
DefineDOMInterface(JSContext* aCx, JSObject* aGlobal, bool* aEnabled)
{

  *aEnabled = true;
  return GetConstructorObject(aCx, aGlobal);
}


DOMJSClass Class = {
  { "Document",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(3),
    _addProperty, /* addProperty */
    JS_PropertyStub,       /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    _finalize, /* finalize */
    NULL,                  /* checkAccess */
    NULL,                  /* call */
    NULL,                  /* hasInstance */
    NULL,                  /* construct */
    NULL, /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  {
    { prototypes::id::EventTarget, prototypes::id::Node, prototypes::id::Document, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
    true,
    &sNativePropertyHooks,
    GetParentObject<nsIDocument>::Get,
    GetProtoObject,
    nullptr
  }
};

JSObject*
Wrap(JSContext* aCx, JSObject* aScope, nsIDocument* aObject, nsWrapperCache* aCache, bool* aTriedToWrap)
{
  MOZ_ASSERT(static_cast<nsIDocument*>(aObject) ==
             reinterpret_cast<nsIDocument*>(aObject));
  MOZ_ASSERT(static_cast<nsINode*>(aObject) ==
             reinterpret_cast<nsINode*>(aObject));
  MOZ_ASSERT(static_cast<mozilla::dom::EventTarget*>(aObject) ==
             reinterpret_cast<mozilla::dom::EventTarget*>(aObject));

  *aTriedToWrap = true;

  JSObject* parent = WrapNativeParent(aCx, aScope, aObject->GetParentObject());
  if (!parent) {
    return NULL;
  }

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.  Scope so we don't
  // collide with the "obj" we declare in CreateBindingJSObject.
  {
    JSObject* obj = aCache->GetWrapper();
    if (obj) {
      return obj;
    }
  }

  JSAutoCompartment ac(aCx, parent);
  JSObject* global = JS_GetGlobalForObject(aCx, parent);

  JSObject* proto = GetProtoObject(aCx, global);
  if (!proto) {
    return NULL;
  }

  JSObject* obj = JS_NewObject(aCx, &Class.mBase, proto, parent);
  if (!obj) {
    return NULL;
  }

  js::SetReservedSlot(obj, DOM_OBJECT_SLOT, PRIVATE_TO_JSVAL(aObject));
  NS_ADDREF(aObject);


  // Important: do unforgeable property setup after we have handed
  // over ownership of the C++ object to obj as needed, so that if
  // we fail and it ends up GCed it won't have problems in the
  // finalizer trying to drop its ownership of the C++ object.
  if (!DefineUnforgeableAttributes(aCx, obj, sUnforgeableAttributes)) {
    return nullptr;
  }

  aCache->SetWrapper(obj);

  return obj;
}

} // namespace DocumentBinding



} // namespace dom
} // namespace mozilla
