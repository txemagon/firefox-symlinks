/* THIS FILE IS AUTOGENERATED - DO NOT EDIT */

#ifndef mozilla_dom_TestCodeGenBinding_h__
#define mozilla_dom_TestCodeGenBinding_h__

#include "TestCodeGenBinding.h"
#include "TestDictionaryBinding.h"
#include "mozilla/ErrorResult.h"
#include "mozilla/dom/BindingDeclarations.h"
#include "mozilla/dom/BindingUtils.h"
#include "mozilla/dom/CallbackFunction.h"
#include "mozilla/dom/DOMJSClass.h"
#include "mozilla/dom/DOMJSProxyHandler.h"

class XPCWrappedNativeScope;
namespace mozilla {
namespace dom {

class OnlyForUseInConstructor;

} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace dom {

class TestChildInterface;

} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace dom {

class TestCppKeywordNamedMethodsInterface;

} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace dom {

class TestIndexedAndNamedDeleterInterface;

} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace dom {

class TestIndexedAndNamedGetterAndSetterInterface;

} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace dom {

class TestIndexedAndNamedGetterInterface;

} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace dom {

class TestIndexedAndNamedSetterInterface;

} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace dom {

class TestIndexedDeleterInterface;

} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace dom {

class TestIndexedDeleterWithRetvalInterface;

} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace dom {

class TestIndexedGetterAndSetterAndNamedGetterInterface;

} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace dom {

class TestIndexedGetterInterface;

} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace dom {

class TestIndexedSetterInterface;

} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace dom {

class TestInterface;

} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace dom {

class TestNamedDeleterInterface;

} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace dom {

class TestNamedDeleterWithRetvalInterface;

} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace dom {

class TestNamedGetterInterface;

} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace dom {

class TestNamedSetterInterface;

} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace dom {

class TestNonCastableInterface;

} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace dom {

class TestNonWrapperCacheInterface;

} // namespace dom
} // namespace mozilla

class nsRenamedInterface;

namespace mozilla {
namespace dom {

class TestExternalInterface;

} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace dom {

class TestInterface;

} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace dom {

class TestExternalInterface;

} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace dom {

class TestInterface;

} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace dom {

class TestInterface;

} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace dom {

class TestInterface;

} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace dom {

class TestInterface;

} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace dom {

class TestExternalInterface;

} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace dom {

class TestExternalInterface;

} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace dom {

class TestCallbackInterface;

} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace dom {

class TestCallbackInterface;

} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace dom {

class TestInterface;

} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace dom {

class TestInterface;

} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace dom {

class TestExternalInterface;

} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace dom {

class TestExternalInterface;

} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace dom {

class TestCallbackInterface;

} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace dom {

class TestCallbackInterface;

} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace dom {

class TestInterface;

} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace dom {

class TestInterface;

} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace dom {

class TestExternalInterface;

} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace dom {

class TestExternalInterface;

} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace dom {

class TestCallbackInterface;

} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace dom {

class TestCallbackInterface;

} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace dom {

class TestInterface;

} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace dom {

class TestInterface;

} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace dom {

class TestInterface;

} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace dom {

class TestCallback;

} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace dom {

class TestCallback;

} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace dom {

class TestCallback;

} // namespace dom
} // namespace mozilla


namespace mozilla {
namespace dom {

template <>
struct PrototypeTraits<prototypes::id::OnlyForUseInConstructor>
{
  enum
  {
    Depth = 0
  };
  typedef mozilla::dom::OnlyForUseInConstructor NativeType;
};
template <>
struct PrototypeTraits<prototypes::id::TestChildInterface>
{
  enum
  {
    Depth = 1
  };
  typedef mozilla::dom::TestChildInterface NativeType;
};
template <>
struct PrototypeTraits<prototypes::id::TestCppKeywordNamedMethodsInterface>
{
  enum
  {
    Depth = 0
  };
  typedef mozilla::dom::TestCppKeywordNamedMethodsInterface NativeType;
};
template <>
struct PrototypeTraits<prototypes::id::TestIndexedAndNamedDeleterInterface>
{
  enum
  {
    Depth = 0
  };
  typedef mozilla::dom::TestIndexedAndNamedDeleterInterface NativeType;
};
template <>
struct PrototypeTraits<prototypes::id::TestIndexedAndNamedGetterAndSetterInterface>
{
  enum
  {
    Depth = 1
  };
  typedef mozilla::dom::TestIndexedAndNamedGetterAndSetterInterface NativeType;
};
template <>
struct PrototypeTraits<prototypes::id::TestIndexedAndNamedGetterInterface>
{
  enum
  {
    Depth = 0
  };
  typedef mozilla::dom::TestIndexedAndNamedGetterInterface NativeType;
};
template <>
struct PrototypeTraits<prototypes::id::TestIndexedAndNamedSetterInterface>
{
  enum
  {
    Depth = 0
  };
  typedef mozilla::dom::TestIndexedAndNamedSetterInterface NativeType;
};
template <>
struct PrototypeTraits<prototypes::id::TestIndexedDeleterInterface>
{
  enum
  {
    Depth = 0
  };
  typedef mozilla::dom::TestIndexedDeleterInterface NativeType;
};
template <>
struct PrototypeTraits<prototypes::id::TestIndexedDeleterWithRetvalInterface>
{
  enum
  {
    Depth = 0
  };
  typedef mozilla::dom::TestIndexedDeleterWithRetvalInterface NativeType;
};
template <>
struct PrototypeTraits<prototypes::id::TestIndexedGetterAndSetterAndNamedGetterInterface>
{
  enum
  {
    Depth = 0
  };
  typedef mozilla::dom::TestIndexedGetterAndSetterAndNamedGetterInterface NativeType;
};
template <>
struct PrototypeTraits<prototypes::id::TestIndexedGetterInterface>
{
  enum
  {
    Depth = 0
  };
  typedef mozilla::dom::TestIndexedGetterInterface NativeType;
};
template <>
struct PrototypeTraits<prototypes::id::TestIndexedSetterInterface>
{
  enum
  {
    Depth = 0
  };
  typedef mozilla::dom::TestIndexedSetterInterface NativeType;
};
template <>
struct PrototypeTraits<prototypes::id::TestInterface>
{
  enum
  {
    Depth = 0
  };
  typedef mozilla::dom::TestInterface NativeType;
};
template <>
struct PrototypeTraits<prototypes::id::TestNamedDeleterInterface>
{
  enum
  {
    Depth = 0
  };
  typedef mozilla::dom::TestNamedDeleterInterface NativeType;
};
template <>
struct PrototypeTraits<prototypes::id::TestNamedDeleterWithRetvalInterface>
{
  enum
  {
    Depth = 0
  };
  typedef mozilla::dom::TestNamedDeleterWithRetvalInterface NativeType;
};
template <>
struct PrototypeTraits<prototypes::id::TestNamedGetterInterface>
{
  enum
  {
    Depth = 0
  };
  typedef mozilla::dom::TestNamedGetterInterface NativeType;
};
template <>
struct PrototypeTraits<prototypes::id::TestNamedSetterInterface>
{
  enum
  {
    Depth = 0
  };
  typedef mozilla::dom::TestNamedSetterInterface NativeType;
};
template <>
struct PrototypeTraits<prototypes::id::TestNonCastableInterface>
{
  enum
  {
    Depth = 0
  };
  typedef mozilla::dom::TestNonCastableInterface NativeType;
};
template <>
struct PrototypeTraits<prototypes::id::TestNonWrapperCacheInterface>
{
  enum
  {
    Depth = 0
  };
  typedef mozilla::dom::TestNonWrapperCacheInterface NativeType;
};
template <>
struct PrototypeTraits<prototypes::id::TestRenamedInterface>
{
  enum
  {
    Depth = 0
  };
  typedef nsRenamedInterface NativeType;
};
template <>
struct PrototypeIDMap<mozilla::dom::OnlyForUseInConstructor>
{
  enum
  {
    PrototypeID = prototypes::id::OnlyForUseInConstructor
  };
};
template <>
struct PrototypeIDMap<mozilla::dom::TestChildInterface>
{
  enum
  {
    PrototypeID = prototypes::id::TestChildInterface
  };
};
template <>
struct PrototypeIDMap<mozilla::dom::TestCppKeywordNamedMethodsInterface>
{
  enum
  {
    PrototypeID = prototypes::id::TestCppKeywordNamedMethodsInterface
  };
};
template <>
struct PrototypeIDMap<mozilla::dom::TestIndexedAndNamedDeleterInterface>
{
  enum
  {
    PrototypeID = prototypes::id::TestIndexedAndNamedDeleterInterface
  };
};
template <>
struct PrototypeIDMap<mozilla::dom::TestIndexedAndNamedGetterAndSetterInterface>
{
  enum
  {
    PrototypeID = prototypes::id::TestIndexedAndNamedGetterAndSetterInterface
  };
};
template <>
struct PrototypeIDMap<mozilla::dom::TestIndexedAndNamedGetterInterface>
{
  enum
  {
    PrototypeID = prototypes::id::TestIndexedAndNamedGetterInterface
  };
};
template <>
struct PrototypeIDMap<mozilla::dom::TestIndexedAndNamedSetterInterface>
{
  enum
  {
    PrototypeID = prototypes::id::TestIndexedAndNamedSetterInterface
  };
};
template <>
struct PrototypeIDMap<mozilla::dom::TestIndexedDeleterInterface>
{
  enum
  {
    PrototypeID = prototypes::id::TestIndexedDeleterInterface
  };
};
template <>
struct PrototypeIDMap<mozilla::dom::TestIndexedDeleterWithRetvalInterface>
{
  enum
  {
    PrototypeID = prototypes::id::TestIndexedDeleterWithRetvalInterface
  };
};
template <>
struct PrototypeIDMap<mozilla::dom::TestIndexedGetterAndSetterAndNamedGetterInterface>
{
  enum
  {
    PrototypeID = prototypes::id::TestIndexedGetterAndSetterAndNamedGetterInterface
  };
};
template <>
struct PrototypeIDMap<mozilla::dom::TestIndexedGetterInterface>
{
  enum
  {
    PrototypeID = prototypes::id::TestIndexedGetterInterface
  };
};
template <>
struct PrototypeIDMap<mozilla::dom::TestIndexedSetterInterface>
{
  enum
  {
    PrototypeID = prototypes::id::TestIndexedSetterInterface
  };
};
template <>
struct PrototypeIDMap<mozilla::dom::TestInterface>
{
  enum
  {
    PrototypeID = prototypes::id::TestInterface
  };
};
template <>
struct PrototypeIDMap<mozilla::dom::TestNamedDeleterInterface>
{
  enum
  {
    PrototypeID = prototypes::id::TestNamedDeleterInterface
  };
};
template <>
struct PrototypeIDMap<mozilla::dom::TestNamedDeleterWithRetvalInterface>
{
  enum
  {
    PrototypeID = prototypes::id::TestNamedDeleterWithRetvalInterface
  };
};
template <>
struct PrototypeIDMap<mozilla::dom::TestNamedGetterInterface>
{
  enum
  {
    PrototypeID = prototypes::id::TestNamedGetterInterface
  };
};
template <>
struct PrototypeIDMap<mozilla::dom::TestNamedSetterInterface>
{
  enum
  {
    PrototypeID = prototypes::id::TestNamedSetterInterface
  };
};
template <>
struct PrototypeIDMap<mozilla::dom::TestNonCastableInterface>
{
  enum
  {
    PrototypeID = prototypes::id::TestNonCastableInterface
  };
};
template <>
struct PrototypeIDMap<mozilla::dom::TestNonWrapperCacheInterface>
{
  enum
  {
    PrototypeID = prototypes::id::TestNonWrapperCacheInterface
  };
};
template <>
struct PrototypeIDMap<nsRenamedInterface>
{
  enum
  {
    PrototypeID = prototypes::id::TestRenamedInterface
  };
};
} // namespace dom
} // namespace mozilla


namespace mozilla {
namespace dom {

namespace TestEnumValues {

  enum valuelist {
    A,
    B
  };

  extern const EnumEntry strings[3];
} // namespace TestEnumValues


typedef TestEnumValues::valuelist TestEnum;


struct DictContainingSequence : public MainThreadDictionaryBase {
  DictContainingSequence() {}
  bool Init(JSContext* cx, JSObject* scopeObj, const JS::Value& val);
  bool ToObject(JSContext* cx, JSObject* parentObject, JS::Value *vp);

  bool Init(const nsAString& aJSON)
  {
    mozilla::Maybe<JSAutoRequest> ar;
    mozilla::Maybe<JSAutoCompartment> ac;
    jsval json = JSVAL_VOID;
    JSContext* cx = ParseJSON(aJSON, ar, ac, json);
    NS_ENSURE_TRUE(cx, false);
    return Init(cx, nullptr, json);
  }

  Optional< Sequence< int32_t > > mOurSequence;
  Optional< Sequence< OwningNonNull<mozilla::dom::TestInterface> > > mOurSequence2;
private:
  // Disallow copy-construction
  DictContainingSequence(const DictContainingSequence&) MOZ_DELETE;
  static bool InitIds(JSContext* cx);
  static bool initedIds;
  static jsid ourSequence_id;
  static jsid ourSequence2_id;
};
struct DictContainingSequenceInitializer : public DictContainingSequence {
  DictContainingSequenceInitializer() {
    // Safe to pass a null context if we pass a null value
    Init(nullptr, nullptr, JS::NullValue());
  }
};

struct ParentDict : public GrandparentDict {
  ParentDict() {}
  bool Init(JSContext* cx, JSObject* scopeObj, const JS::Value& val);
  bool ToObject(JSContext* cx, JSObject* parentObject, JS::Value *vp);

  bool Init(const nsAString& aJSON)
  {
    mozilla::Maybe<JSAutoRequest> ar;
    mozilla::Maybe<JSAutoCompartment> ac;
    jsval json = JSVAL_VOID;
    JSContext* cx = ParseJSON(aJSON, ar, ac, json);
    NS_ENSURE_TRUE(cx, false);
    return Init(cx, nullptr, json);
  }

  int32_t mC;
  Optional< nsRefPtr<mozilla::dom::TestExternalInterface> > mSomeExternalInterface;
  Optional< OwningNonNull<mozilla::dom::TestInterface> > mSomeInterface;
private:
  // Disallow copy-construction
  ParentDict(const ParentDict&) MOZ_DELETE;
  static bool InitIds(JSContext* cx);
  static bool initedIds;
  static jsid c_id;
  static jsid someExternalInterface_id;
  static jsid someInterface_id;
};
struct ParentDictInitializer : public ParentDict {
  ParentDictInitializer() {
    // Safe to pass a null context if we pass a null value
    Init(nullptr, nullptr, JS::NullValue());
  }
};

struct Dict : public ParentDict {
  Dict() {}
  bool Init(JSContext* cx, JSObject* scopeObj, const JS::Value& val);
  bool ToObject(JSContext* cx, JSObject* parentObject, JS::Value *vp);

  bool Init(const nsAString& aJSON)
  {
    mozilla::Maybe<JSAutoRequest> ar;
    mozilla::Maybe<JSAutoCompartment> ac;
    jsval json = JSVAL_VOID;
    JSContext* cx = ParseJSON(aJSON, ar, ac, json);
    NS_ENSURE_TRUE(cx, false);
    return Init(cx, nullptr, json);
  }

  Optional< int32_t > mA;
  LazyRootedObject mAnotherObj;
  int32_t mB;
  nsString mEmpty;
  TestEnum mOtherEnum;
  nsString mOtherStr;
  nsRefPtr<TestCallback> mSomeCallback;
  Optional< TestEnum > mSomeEnum;
  Optional< NonNullLazyRootedObject > mSomeObj;
  Optional< nsString > mStr;
  Optional< nsString > mTemplate;
  Optional< int32_t > mX;
  nsString mYetAnotherStr;
  int32_t mZ;
private:
  // Disallow copy-construction
  Dict(const Dict&) MOZ_DELETE;
  static bool InitIds(JSContext* cx);
  static bool initedIds;
  static jsid a_id;
  static jsid anotherObj_id;
  static jsid b_id;
  static jsid empty_id;
  static jsid otherEnum_id;
  static jsid otherStr_id;
  static jsid someCallback_id;
  static jsid someEnum_id;
  static jsid someObj_id;
  static jsid str_id;
  static jsid template_id;
  static jsid x_id;
  static jsid yetAnotherStr_id;
  static jsid z_id;
};
struct DictInitializer : public Dict {
  DictInitializer() {
    // Safe to pass a null context if we pass a null value
    Init(nullptr, nullptr, JS::NullValue());
  }
};

struct DictContainingDict : public MainThreadDictionaryBase {
  DictContainingDict() {}
  bool Init(JSContext* cx, JSObject* scopeObj, const JS::Value& val);
  bool ToObject(JSContext* cx, JSObject* parentObject, JS::Value *vp);

  bool Init(const nsAString& aJSON)
  {
    mozilla::Maybe<JSAutoRequest> ar;
    mozilla::Maybe<JSAutoCompartment> ac;
    jsval json = JSVAL_VOID;
    JSContext* cx = ParseJSON(aJSON, ar, ac, json);
    NS_ENSURE_TRUE(cx, false);
    return Init(cx, nullptr, json);
  }

  Dict mMemberDict;
private:
  // Disallow copy-construction
  DictContainingDict(const DictContainingDict&) MOZ_DELETE;
  static bool InitIds(JSContext* cx);
  static bool initedIds;
  static jsid memberDict_id;
};
struct DictContainingDictInitializer : public DictContainingDict {
  DictContainingDictInitializer() {
    // Safe to pass a null context if we pass a null value
    Init(nullptr, nullptr, JS::NullValue());
  }
};

class TestCallback : public CallbackFunction
{
public:
  inline TestCallback(JSContext* cx, JSObject* aOwner, JSObject* aCallable, bool* aInited)
    : CallbackFunction(cx, aOwner, aCallable, aInited)
  {
  }

  explicit inline TestCallback(CallbackFunction* aOther)
    : CallbackFunction(aOther)
  {
  }

  template <typename T>
  inline void
  Call(const T& thisObj, ErrorResult& aRv)
  {
    CallSetup s(mCallable);
    if (!s.GetContext()) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    JSObject* thisObjJS = WrapCallThisObject(s.GetContext(), mCallable, thisObj);
    if (!thisObjJS) {
      aRv.Throw(NS_ERROR_FAILURE);
      return;
    }
    return Call(s.GetContext(), thisObjJS, aRv);
  }

  inline void
  Call(ErrorResult& aRv)
  {
    CallSetup s(mCallable);
    if (!s.GetContext()) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    return Call(s.GetContext(), nullptr, aRv);
  }

private:
  void Call(JSContext* cx, JSObject* aThisObj, ErrorResult& aRv);
};


class TestTreatAsNullCallback : public CallbackFunction
{
public:
  inline TestTreatAsNullCallback(JSContext* cx, JSObject* aOwner, JSObject* aCallable, bool* aInited)
    : CallbackFunction(cx, aOwner, aCallable, aInited)
  {
  }

  explicit inline TestTreatAsNullCallback(CallbackFunction* aOther)
    : CallbackFunction(aOther)
  {
  }

  template <typename T>
  inline void
  Call(const T& thisObj, ErrorResult& aRv)
  {
    CallSetup s(mCallable);
    if (!s.GetContext()) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    JSObject* thisObjJS = WrapCallThisObject(s.GetContext(), mCallable, thisObj);
    if (!thisObjJS) {
      aRv.Throw(NS_ERROR_FAILURE);
      return;
    }
    return Call(s.GetContext(), thisObjJS, aRv);
  }

  inline void
  Call(ErrorResult& aRv)
  {
    CallSetup s(mCallable);
    if (!s.GetContext()) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    return Call(s.GetContext(), nullptr, aRv);
  }

private:
  void Call(JSContext* cx, JSObject* aThisObj, ErrorResult& aRv);
};


class TestIntegerReturn : public CallbackFunction
{
public:
  inline TestIntegerReturn(JSContext* cx, JSObject* aOwner, JSObject* aCallable, bool* aInited)
    : CallbackFunction(cx, aOwner, aCallable, aInited)
  {
  }

  explicit inline TestIntegerReturn(CallbackFunction* aOther)
    : CallbackFunction(aOther)
  {
  }

  template <typename T>
  inline int32_t
  Call(const T& thisObj, ErrorResult& aRv)
  {
    CallSetup s(mCallable);
    if (!s.GetContext()) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return int32_t(0);
    }
    JSObject* thisObjJS = WrapCallThisObject(s.GetContext(), mCallable, thisObj);
    if (!thisObjJS) {
      aRv.Throw(NS_ERROR_FAILURE);
      return int32_t(0);
    }
    return Call(s.GetContext(), thisObjJS, aRv);
  }

  inline int32_t
  Call(ErrorResult& aRv)
  {
    CallSetup s(mCallable);
    if (!s.GetContext()) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return int32_t(0);
    }
    return Call(s.GetContext(), nullptr, aRv);
  }

private:
  int32_t Call(JSContext* cx, JSObject* aThisObj, ErrorResult& aRv);
};


class TestNullableIntegerReturn : public CallbackFunction
{
public:
  inline TestNullableIntegerReturn(JSContext* cx, JSObject* aOwner, JSObject* aCallable, bool* aInited)
    : CallbackFunction(cx, aOwner, aCallable, aInited)
  {
  }

  explicit inline TestNullableIntegerReturn(CallbackFunction* aOther)
    : CallbackFunction(aOther)
  {
  }

  template <typename T>
  inline Nullable<int32_t>
  Call(const T& thisObj, ErrorResult& aRv)
  {
    CallSetup s(mCallable);
    if (!s.GetContext()) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return Nullable<int32_t>();
    }
    JSObject* thisObjJS = WrapCallThisObject(s.GetContext(), mCallable, thisObj);
    if (!thisObjJS) {
      aRv.Throw(NS_ERROR_FAILURE);
      return Nullable<int32_t>();
    }
    return Call(s.GetContext(), thisObjJS, aRv);
  }

  inline Nullable<int32_t>
  Call(ErrorResult& aRv)
  {
    CallSetup s(mCallable);
    if (!s.GetContext()) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return Nullable<int32_t>();
    }
    return Call(s.GetContext(), nullptr, aRv);
  }

private:
  Nullable<int32_t> Call(JSContext* cx, JSObject* aThisObj, ErrorResult& aRv);
};


class TestBooleanReturn : public CallbackFunction
{
public:
  inline TestBooleanReturn(JSContext* cx, JSObject* aOwner, JSObject* aCallable, bool* aInited)
    : CallbackFunction(cx, aOwner, aCallable, aInited)
  {
  }

  explicit inline TestBooleanReturn(CallbackFunction* aOther)
    : CallbackFunction(aOther)
  {
  }

  template <typename T>
  inline bool
  Call(const T& thisObj, ErrorResult& aRv)
  {
    CallSetup s(mCallable);
    if (!s.GetContext()) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return bool(0);
    }
    JSObject* thisObjJS = WrapCallThisObject(s.GetContext(), mCallable, thisObj);
    if (!thisObjJS) {
      aRv.Throw(NS_ERROR_FAILURE);
      return bool(0);
    }
    return Call(s.GetContext(), thisObjJS, aRv);
  }

  inline bool
  Call(ErrorResult& aRv)
  {
    CallSetup s(mCallable);
    if (!s.GetContext()) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return bool(0);
    }
    return Call(s.GetContext(), nullptr, aRv);
  }

private:
  bool Call(JSContext* cx, JSObject* aThisObj, ErrorResult& aRv);
};


class TestFloatReturn : public CallbackFunction
{
public:
  inline TestFloatReturn(JSContext* cx, JSObject* aOwner, JSObject* aCallable, bool* aInited)
    : CallbackFunction(cx, aOwner, aCallable, aInited)
  {
  }

  explicit inline TestFloatReturn(CallbackFunction* aOther)
    : CallbackFunction(aOther)
  {
  }

  template <typename T>
  inline float
  Call(const T& thisObj, ErrorResult& aRv)
  {
    CallSetup s(mCallable);
    if (!s.GetContext()) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return float(0);
    }
    JSObject* thisObjJS = WrapCallThisObject(s.GetContext(), mCallable, thisObj);
    if (!thisObjJS) {
      aRv.Throw(NS_ERROR_FAILURE);
      return float(0);
    }
    return Call(s.GetContext(), thisObjJS, aRv);
  }

  inline float
  Call(ErrorResult& aRv)
  {
    CallSetup s(mCallable);
    if (!s.GetContext()) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return float(0);
    }
    return Call(s.GetContext(), nullptr, aRv);
  }

private:
  float Call(JSContext* cx, JSObject* aThisObj, ErrorResult& aRv);
};


class TestStringReturn : public CallbackFunction
{
public:
  inline TestStringReturn(JSContext* cx, JSObject* aOwner, JSObject* aCallable, bool* aInited)
    : CallbackFunction(cx, aOwner, aCallable, aInited)
  {
  }

  explicit inline TestStringReturn(CallbackFunction* aOther)
    : CallbackFunction(aOther)
  {
  }

  template <typename T>
  inline void
  Call(const T& thisObj, int32_t arg, nsString& retval, ErrorResult& aRv)
  {
    CallSetup s(mCallable);
    if (!s.GetContext()) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    JSObject* thisObjJS = WrapCallThisObject(s.GetContext(), mCallable, thisObj);
    if (!thisObjJS) {
      aRv.Throw(NS_ERROR_FAILURE);
      return;
    }
    return Call(s.GetContext(), thisObjJS, arg, retval, aRv);
  }

  inline void
  Call(int32_t arg, nsString& retval, ErrorResult& aRv)
  {
    CallSetup s(mCallable);
    if (!s.GetContext()) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    return Call(s.GetContext(), nullptr, arg, retval, aRv);
  }

private:
  void Call(JSContext* cx, JSObject* aThisObj, int32_t arg, nsString& retval, ErrorResult& aRv);
};


class TestEnumReturn : public CallbackFunction
{
public:
  inline TestEnumReturn(JSContext* cx, JSObject* aOwner, JSObject* aCallable, bool* aInited)
    : CallbackFunction(cx, aOwner, aCallable, aInited)
  {
  }

  explicit inline TestEnumReturn(CallbackFunction* aOther)
    : CallbackFunction(aOther)
  {
  }

  template <typename T>
  inline TestEnum
  Call(const T& thisObj, ErrorResult& aRv)
  {
    CallSetup s(mCallable);
    if (!s.GetContext()) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return TestEnum(0);
    }
    JSObject* thisObjJS = WrapCallThisObject(s.GetContext(), mCallable, thisObj);
    if (!thisObjJS) {
      aRv.Throw(NS_ERROR_FAILURE);
      return TestEnum(0);
    }
    return Call(s.GetContext(), thisObjJS, aRv);
  }

  inline TestEnum
  Call(ErrorResult& aRv)
  {
    CallSetup s(mCallable);
    if (!s.GetContext()) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return TestEnum(0);
    }
    return Call(s.GetContext(), nullptr, aRv);
  }

private:
  TestEnum Call(JSContext* cx, JSObject* aThisObj, ErrorResult& aRv);
};


class TestInterfaceReturn : public CallbackFunction
{
public:
  inline TestInterfaceReturn(JSContext* cx, JSObject* aOwner, JSObject* aCallable, bool* aInited)
    : CallbackFunction(cx, aOwner, aCallable, aInited)
  {
  }

  explicit inline TestInterfaceReturn(CallbackFunction* aOther)
    : CallbackFunction(aOther)
  {
  }

  template <typename T>
  inline already_AddRefed<TestInterface>
  Call(const T& thisObj, ErrorResult& aRv)
  {
    CallSetup s(mCallable);
    if (!s.GetContext()) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    JSObject* thisObjJS = WrapCallThisObject(s.GetContext(), mCallable, thisObj);
    if (!thisObjJS) {
      aRv.Throw(NS_ERROR_FAILURE);
      return nullptr;
    }
    return Call(s.GetContext(), thisObjJS, aRv);
  }

  inline already_AddRefed<TestInterface>
  Call(ErrorResult& aRv)
  {
    CallSetup s(mCallable);
    if (!s.GetContext()) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    return Call(s.GetContext(), nullptr, aRv);
  }

private:
  already_AddRefed<TestInterface> Call(JSContext* cx, JSObject* aThisObj, ErrorResult& aRv);
};


class TestNullableInterfaceReturn : public CallbackFunction
{
public:
  inline TestNullableInterfaceReturn(JSContext* cx, JSObject* aOwner, JSObject* aCallable, bool* aInited)
    : CallbackFunction(cx, aOwner, aCallable, aInited)
  {
  }

  explicit inline TestNullableInterfaceReturn(CallbackFunction* aOther)
    : CallbackFunction(aOther)
  {
  }

  template <typename T>
  inline already_AddRefed<TestInterface>
  Call(const T& thisObj, ErrorResult& aRv)
  {
    CallSetup s(mCallable);
    if (!s.GetContext()) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    JSObject* thisObjJS = WrapCallThisObject(s.GetContext(), mCallable, thisObj);
    if (!thisObjJS) {
      aRv.Throw(NS_ERROR_FAILURE);
      return nullptr;
    }
    return Call(s.GetContext(), thisObjJS, aRv);
  }

  inline already_AddRefed<TestInterface>
  Call(ErrorResult& aRv)
  {
    CallSetup s(mCallable);
    if (!s.GetContext()) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    return Call(s.GetContext(), nullptr, aRv);
  }

private:
  already_AddRefed<TestInterface> Call(JSContext* cx, JSObject* aThisObj, ErrorResult& aRv);
};


class TestExternalInterfaceReturn : public CallbackFunction
{
public:
  inline TestExternalInterfaceReturn(JSContext* cx, JSObject* aOwner, JSObject* aCallable, bool* aInited)
    : CallbackFunction(cx, aOwner, aCallable, aInited)
  {
  }

  explicit inline TestExternalInterfaceReturn(CallbackFunction* aOther)
    : CallbackFunction(aOther)
  {
  }

  template <typename T>
  inline already_AddRefed<TestExternalInterface>
  Call(const T& thisObj, ErrorResult& aRv)
  {
    CallSetup s(mCallable);
    if (!s.GetContext()) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    JSObject* thisObjJS = WrapCallThisObject(s.GetContext(), mCallable, thisObj);
    if (!thisObjJS) {
      aRv.Throw(NS_ERROR_FAILURE);
      return nullptr;
    }
    return Call(s.GetContext(), thisObjJS, aRv);
  }

  inline already_AddRefed<TestExternalInterface>
  Call(ErrorResult& aRv)
  {
    CallSetup s(mCallable);
    if (!s.GetContext()) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    return Call(s.GetContext(), nullptr, aRv);
  }

private:
  already_AddRefed<TestExternalInterface> Call(JSContext* cx, JSObject* aThisObj, ErrorResult& aRv);
};


class TestNullableExternalInterfaceReturn : public CallbackFunction
{
public:
  inline TestNullableExternalInterfaceReturn(JSContext* cx, JSObject* aOwner, JSObject* aCallable, bool* aInited)
    : CallbackFunction(cx, aOwner, aCallable, aInited)
  {
  }

  explicit inline TestNullableExternalInterfaceReturn(CallbackFunction* aOther)
    : CallbackFunction(aOther)
  {
  }

  template <typename T>
  inline already_AddRefed<TestExternalInterface>
  Call(const T& thisObj, ErrorResult& aRv)
  {
    CallSetup s(mCallable);
    if (!s.GetContext()) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    JSObject* thisObjJS = WrapCallThisObject(s.GetContext(), mCallable, thisObj);
    if (!thisObjJS) {
      aRv.Throw(NS_ERROR_FAILURE);
      return nullptr;
    }
    return Call(s.GetContext(), thisObjJS, aRv);
  }

  inline already_AddRefed<TestExternalInterface>
  Call(ErrorResult& aRv)
  {
    CallSetup s(mCallable);
    if (!s.GetContext()) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    return Call(s.GetContext(), nullptr, aRv);
  }

private:
  already_AddRefed<TestExternalInterface> Call(JSContext* cx, JSObject* aThisObj, ErrorResult& aRv);
};


class TestCallbackInterfaceReturn : public CallbackFunction
{
public:
  inline TestCallbackInterfaceReturn(JSContext* cx, JSObject* aOwner, JSObject* aCallable, bool* aInited)
    : CallbackFunction(cx, aOwner, aCallable, aInited)
  {
  }

  explicit inline TestCallbackInterfaceReturn(CallbackFunction* aOther)
    : CallbackFunction(aOther)
  {
  }

  template <typename T>
  inline already_AddRefed<TestCallbackInterface>
  Call(const T& thisObj, ErrorResult& aRv)
  {
    CallSetup s(mCallable);
    if (!s.GetContext()) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    JSObject* thisObjJS = WrapCallThisObject(s.GetContext(), mCallable, thisObj);
    if (!thisObjJS) {
      aRv.Throw(NS_ERROR_FAILURE);
      return nullptr;
    }
    return Call(s.GetContext(), thisObjJS, aRv);
  }

  inline already_AddRefed<TestCallbackInterface>
  Call(ErrorResult& aRv)
  {
    CallSetup s(mCallable);
    if (!s.GetContext()) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    return Call(s.GetContext(), nullptr, aRv);
  }

private:
  already_AddRefed<TestCallbackInterface> Call(JSContext* cx, JSObject* aThisObj, ErrorResult& aRv);
};


class TestNullableCallbackInterfaceReturn : public CallbackFunction
{
public:
  inline TestNullableCallbackInterfaceReturn(JSContext* cx, JSObject* aOwner, JSObject* aCallable, bool* aInited)
    : CallbackFunction(cx, aOwner, aCallable, aInited)
  {
  }

  explicit inline TestNullableCallbackInterfaceReturn(CallbackFunction* aOther)
    : CallbackFunction(aOther)
  {
  }

  template <typename T>
  inline already_AddRefed<TestCallbackInterface>
  Call(const T& thisObj, ErrorResult& aRv)
  {
    CallSetup s(mCallable);
    if (!s.GetContext()) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    JSObject* thisObjJS = WrapCallThisObject(s.GetContext(), mCallable, thisObj);
    if (!thisObjJS) {
      aRv.Throw(NS_ERROR_FAILURE);
      return nullptr;
    }
    return Call(s.GetContext(), thisObjJS, aRv);
  }

  inline already_AddRefed<TestCallbackInterface>
  Call(ErrorResult& aRv)
  {
    CallSetup s(mCallable);
    if (!s.GetContext()) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    return Call(s.GetContext(), nullptr, aRv);
  }

private:
  already_AddRefed<TestCallbackInterface> Call(JSContext* cx, JSObject* aThisObj, ErrorResult& aRv);
};


class TestCallbackReturn : public CallbackFunction
{
public:
  inline TestCallbackReturn(JSContext* cx, JSObject* aOwner, JSObject* aCallable, bool* aInited)
    : CallbackFunction(cx, aOwner, aCallable, aInited)
  {
  }

  explicit inline TestCallbackReturn(CallbackFunction* aOther)
    : CallbackFunction(aOther)
  {
  }

  template <typename T>
  inline already_AddRefed<TestCallback>
  Call(const T& thisObj, ErrorResult& aRv)
  {
    CallSetup s(mCallable);
    if (!s.GetContext()) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    JSObject* thisObjJS = WrapCallThisObject(s.GetContext(), mCallable, thisObj);
    if (!thisObjJS) {
      aRv.Throw(NS_ERROR_FAILURE);
      return nullptr;
    }
    return Call(s.GetContext(), thisObjJS, aRv);
  }

  inline already_AddRefed<TestCallback>
  Call(ErrorResult& aRv)
  {
    CallSetup s(mCallable);
    if (!s.GetContext()) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    return Call(s.GetContext(), nullptr, aRv);
  }

private:
  already_AddRefed<TestCallback> Call(JSContext* cx, JSObject* aThisObj, ErrorResult& aRv);
};


class TestNullableCallbackReturn : public CallbackFunction
{
public:
  inline TestNullableCallbackReturn(JSContext* cx, JSObject* aOwner, JSObject* aCallable, bool* aInited)
    : CallbackFunction(cx, aOwner, aCallable, aInited)
  {
  }

  explicit inline TestNullableCallbackReturn(CallbackFunction* aOther)
    : CallbackFunction(aOther)
  {
  }

  template <typename T>
  inline already_AddRefed<TestCallback>
  Call(const T& thisObj, ErrorResult& aRv)
  {
    CallSetup s(mCallable);
    if (!s.GetContext()) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    JSObject* thisObjJS = WrapCallThisObject(s.GetContext(), mCallable, thisObj);
    if (!thisObjJS) {
      aRv.Throw(NS_ERROR_FAILURE);
      return nullptr;
    }
    return Call(s.GetContext(), thisObjJS, aRv);
  }

  inline already_AddRefed<TestCallback>
  Call(ErrorResult& aRv)
  {
    CallSetup s(mCallable);
    if (!s.GetContext()) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    return Call(s.GetContext(), nullptr, aRv);
  }

private:
  already_AddRefed<TestCallback> Call(JSContext* cx, JSObject* aThisObj, ErrorResult& aRv);
};


class TestObjectReturn : public CallbackFunction
{
public:
  inline TestObjectReturn(JSContext* cx, JSObject* aOwner, JSObject* aCallable, bool* aInited)
    : CallbackFunction(cx, aOwner, aCallable, aInited)
  {
  }

  explicit inline TestObjectReturn(CallbackFunction* aOther)
    : CallbackFunction(aOther)
  {
  }

  template <typename T>
  inline JSObject*
  Call(const T& thisObj, ErrorResult& aRv)
  {
    CallSetup s(mCallable);
    if (!s.GetContext()) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    JSObject* thisObjJS = WrapCallThisObject(s.GetContext(), mCallable, thisObj);
    if (!thisObjJS) {
      aRv.Throw(NS_ERROR_FAILURE);
      return nullptr;
    }
    return Call(s.GetContext(), thisObjJS, aRv);
  }

  inline JSObject*
  Call(ErrorResult& aRv)
  {
    CallSetup s(mCallable);
    if (!s.GetContext()) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    return Call(s.GetContext(), nullptr, aRv);
  }

private:
  JSObject* Call(JSContext* cx, JSObject* aThisObj, ErrorResult& aRv);
};


class TestNullableObjectReturn : public CallbackFunction
{
public:
  inline TestNullableObjectReturn(JSContext* cx, JSObject* aOwner, JSObject* aCallable, bool* aInited)
    : CallbackFunction(cx, aOwner, aCallable, aInited)
  {
  }

  explicit inline TestNullableObjectReturn(CallbackFunction* aOther)
    : CallbackFunction(aOther)
  {
  }

  template <typename T>
  inline JSObject*
  Call(const T& thisObj, ErrorResult& aRv)
  {
    CallSetup s(mCallable);
    if (!s.GetContext()) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    JSObject* thisObjJS = WrapCallThisObject(s.GetContext(), mCallable, thisObj);
    if (!thisObjJS) {
      aRv.Throw(NS_ERROR_FAILURE);
      return nullptr;
    }
    return Call(s.GetContext(), thisObjJS, aRv);
  }

  inline JSObject*
  Call(ErrorResult& aRv)
  {
    CallSetup s(mCallable);
    if (!s.GetContext()) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    return Call(s.GetContext(), nullptr, aRv);
  }

private:
  JSObject* Call(JSContext* cx, JSObject* aThisObj, ErrorResult& aRv);
};


class TestTypedArrayReturn : public CallbackFunction
{
public:
  inline TestTypedArrayReturn(JSContext* cx, JSObject* aOwner, JSObject* aCallable, bool* aInited)
    : CallbackFunction(cx, aOwner, aCallable, aInited)
  {
  }

  explicit inline TestTypedArrayReturn(CallbackFunction* aOther)
    : CallbackFunction(aOther)
  {
  }

  template <typename T>
  inline JSObject*
  Call(const T& thisObj, ErrorResult& aRv)
  {
    CallSetup s(mCallable);
    if (!s.GetContext()) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    JSObject* thisObjJS = WrapCallThisObject(s.GetContext(), mCallable, thisObj);
    if (!thisObjJS) {
      aRv.Throw(NS_ERROR_FAILURE);
      return nullptr;
    }
    return Call(s.GetContext(), thisObjJS, aRv);
  }

  inline JSObject*
  Call(ErrorResult& aRv)
  {
    CallSetup s(mCallable);
    if (!s.GetContext()) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    return Call(s.GetContext(), nullptr, aRv);
  }

private:
  JSObject* Call(JSContext* cx, JSObject* aThisObj, ErrorResult& aRv);
};


class TestNullableTypedArrayReturn : public CallbackFunction
{
public:
  inline TestNullableTypedArrayReturn(JSContext* cx, JSObject* aOwner, JSObject* aCallable, bool* aInited)
    : CallbackFunction(cx, aOwner, aCallable, aInited)
  {
  }

  explicit inline TestNullableTypedArrayReturn(CallbackFunction* aOther)
    : CallbackFunction(aOther)
  {
  }

  template <typename T>
  inline JSObject*
  Call(const T& thisObj, ErrorResult& aRv)
  {
    CallSetup s(mCallable);
    if (!s.GetContext()) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    JSObject* thisObjJS = WrapCallThisObject(s.GetContext(), mCallable, thisObj);
    if (!thisObjJS) {
      aRv.Throw(NS_ERROR_FAILURE);
      return nullptr;
    }
    return Call(s.GetContext(), thisObjJS, aRv);
  }

  inline JSObject*
  Call(ErrorResult& aRv)
  {
    CallSetup s(mCallable);
    if (!s.GetContext()) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    return Call(s.GetContext(), nullptr, aRv);
  }

private:
  JSObject* Call(JSContext* cx, JSObject* aThisObj, ErrorResult& aRv);
};


class TestSequenceReturn : public CallbackFunction
{
public:
  inline TestSequenceReturn(JSContext* cx, JSObject* aOwner, JSObject* aCallable, bool* aInited)
    : CallbackFunction(cx, aOwner, aCallable, aInited)
  {
  }

  explicit inline TestSequenceReturn(CallbackFunction* aOther)
    : CallbackFunction(aOther)
  {
  }

  template <typename T>
  inline void
  Call(const T& thisObj, nsTArray< bool >& retval, ErrorResult& aRv)
  {
    CallSetup s(mCallable);
    if (!s.GetContext()) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    JSObject* thisObjJS = WrapCallThisObject(s.GetContext(), mCallable, thisObj);
    if (!thisObjJS) {
      aRv.Throw(NS_ERROR_FAILURE);
      return;
    }
    return Call(s.GetContext(), thisObjJS, retval, aRv);
  }

  inline void
  Call(nsTArray< bool >& retval, ErrorResult& aRv)
  {
    CallSetup s(mCallable);
    if (!s.GetContext()) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    return Call(s.GetContext(), nullptr, retval, aRv);
  }

private:
  void Call(JSContext* cx, JSObject* aThisObj, nsTArray< bool >& retval, ErrorResult& aRv);
};


class TestNullableSequenceReturn : public CallbackFunction
{
public:
  inline TestNullableSequenceReturn(JSContext* cx, JSObject* aOwner, JSObject* aCallable, bool* aInited)
    : CallbackFunction(cx, aOwner, aCallable, aInited)
  {
  }

  explicit inline TestNullableSequenceReturn(CallbackFunction* aOther)
    : CallbackFunction(aOther)
  {
  }

  template <typename T>
  inline void
  Call(const T& thisObj, Nullable< nsTArray< bool > >& retval, ErrorResult& aRv)
  {
    CallSetup s(mCallable);
    if (!s.GetContext()) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    JSObject* thisObjJS = WrapCallThisObject(s.GetContext(), mCallable, thisObj);
    if (!thisObjJS) {
      aRv.Throw(NS_ERROR_FAILURE);
      return;
    }
    return Call(s.GetContext(), thisObjJS, retval, aRv);
  }

  inline void
  Call(Nullable< nsTArray< bool > >& retval, ErrorResult& aRv)
  {
    CallSetup s(mCallable);
    if (!s.GetContext()) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    return Call(s.GetContext(), nullptr, retval, aRv);
  }

private:
  void Call(JSContext* cx, JSObject* aThisObj, Nullable< nsTArray< bool > >& retval, ErrorResult& aRv);
};


class TestIntegerArguments : public CallbackFunction
{
public:
  inline TestIntegerArguments(JSContext* cx, JSObject* aOwner, JSObject* aCallable, bool* aInited)
    : CallbackFunction(cx, aOwner, aCallable, aInited)
  {
  }

  explicit inline TestIntegerArguments(CallbackFunction* aOther)
    : CallbackFunction(aOther)
  {
  }

  template <typename T>
  inline void
  Call(const T& thisObj, int32_t arg1, const Nullable< int32_t >& arg2, const Sequence< int32_t >& arg3, const Nullable< Sequence< Nullable< int32_t > > >& arg4, nsTArray< int32_t >& retval, ErrorResult& aRv)
  {
    CallSetup s(mCallable);
    if (!s.GetContext()) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    JSObject* thisObjJS = WrapCallThisObject(s.GetContext(), mCallable, thisObj);
    if (!thisObjJS) {
      aRv.Throw(NS_ERROR_FAILURE);
      return;
    }
    return Call(s.GetContext(), thisObjJS, arg1, arg2, arg3, arg4, retval, aRv);
  }

  inline void
  Call(int32_t arg1, const Nullable< int32_t >& arg2, const Sequence< int32_t >& arg3, const Nullable< Sequence< Nullable< int32_t > > >& arg4, nsTArray< int32_t >& retval, ErrorResult& aRv)
  {
    CallSetup s(mCallable);
    if (!s.GetContext()) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    return Call(s.GetContext(), nullptr, arg1, arg2, arg3, arg4, retval, aRv);
  }

private:
  void Call(JSContext* cx, JSObject* aThisObj, int32_t arg1, const Nullable< int32_t >& arg2, const Sequence< int32_t >& arg3, const Nullable< Sequence< Nullable< int32_t > > >& arg4, nsTArray< int32_t >& retval, ErrorResult& aRv);
};


class TestInterfaceArguments : public CallbackFunction
{
public:
  inline TestInterfaceArguments(JSContext* cx, JSObject* aOwner, JSObject* aCallable, bool* aInited)
    : CallbackFunction(cx, aOwner, aCallable, aInited)
  {
  }

  explicit inline TestInterfaceArguments(CallbackFunction* aOther)
    : CallbackFunction(aOther)
  {
  }

  template <typename T>
  inline void
  Call(const T& thisObj, mozilla::dom::TestInterface& arg1, mozilla::dom::TestInterface* arg2, mozilla::dom::TestExternalInterface* arg3, mozilla::dom::TestExternalInterface* arg4, mozilla::dom::TestCallbackInterface& arg5, mozilla::dom::TestCallbackInterface* arg6, const Sequence< OwningNonNull<mozilla::dom::TestInterface> >& arg7, const Nullable< Sequence< nsRefPtr<mozilla::dom::TestInterface> > >& arg8, const Sequence< nsRefPtr<mozilla::dom::TestExternalInterface> >& arg9, const Nullable< Sequence< nsRefPtr<mozilla::dom::TestExternalInterface> > >& arg10, const Sequence< OwningNonNull<mozilla::dom::TestCallbackInterface> >& arg11, const Nullable< Sequence< nsRefPtr<mozilla::dom::TestCallbackInterface> > >& arg12, ErrorResult& aRv)
  {
    CallSetup s(mCallable);
    if (!s.GetContext()) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    JSObject* thisObjJS = WrapCallThisObject(s.GetContext(), mCallable, thisObj);
    if (!thisObjJS) {
      aRv.Throw(NS_ERROR_FAILURE);
      return;
    }
    return Call(s.GetContext(), thisObjJS, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, aRv);
  }

  inline void
  Call(mozilla::dom::TestInterface& arg1, mozilla::dom::TestInterface* arg2, mozilla::dom::TestExternalInterface* arg3, mozilla::dom::TestExternalInterface* arg4, mozilla::dom::TestCallbackInterface& arg5, mozilla::dom::TestCallbackInterface* arg6, const Sequence< OwningNonNull<mozilla::dom::TestInterface> >& arg7, const Nullable< Sequence< nsRefPtr<mozilla::dom::TestInterface> > >& arg8, const Sequence< nsRefPtr<mozilla::dom::TestExternalInterface> >& arg9, const Nullable< Sequence< nsRefPtr<mozilla::dom::TestExternalInterface> > >& arg10, const Sequence< OwningNonNull<mozilla::dom::TestCallbackInterface> >& arg11, const Nullable< Sequence< nsRefPtr<mozilla::dom::TestCallbackInterface> > >& arg12, ErrorResult& aRv)
  {
    CallSetup s(mCallable);
    if (!s.GetContext()) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    return Call(s.GetContext(), nullptr, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, aRv);
  }

private:
  void Call(JSContext* cx, JSObject* aThisObj, mozilla::dom::TestInterface& arg1, mozilla::dom::TestInterface* arg2, mozilla::dom::TestExternalInterface* arg3, mozilla::dom::TestExternalInterface* arg4, mozilla::dom::TestCallbackInterface& arg5, mozilla::dom::TestCallbackInterface* arg6, const Sequence< OwningNonNull<mozilla::dom::TestInterface> >& arg7, const Nullable< Sequence< nsRefPtr<mozilla::dom::TestInterface> > >& arg8, const Sequence< nsRefPtr<mozilla::dom::TestExternalInterface> >& arg9, const Nullable< Sequence< nsRefPtr<mozilla::dom::TestExternalInterface> > >& arg10, const Sequence< OwningNonNull<mozilla::dom::TestCallbackInterface> >& arg11, const Nullable< Sequence< nsRefPtr<mozilla::dom::TestCallbackInterface> > >& arg12, ErrorResult& aRv);
};


class TestStringEnumArguments : public CallbackFunction
{
public:
  inline TestStringEnumArguments(JSContext* cx, JSObject* aOwner, JSObject* aCallable, bool* aInited)
    : CallbackFunction(cx, aOwner, aCallable, aInited)
  {
  }

  explicit inline TestStringEnumArguments(CallbackFunction* aOther)
    : CallbackFunction(aOther)
  {
  }

  template <typename T>
  inline void
  Call(const T& thisObj, const nsAString& myString, const nsAString& nullString, TestEnum myEnum, ErrorResult& aRv)
  {
    CallSetup s(mCallable);
    if (!s.GetContext()) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    JSObject* thisObjJS = WrapCallThisObject(s.GetContext(), mCallable, thisObj);
    if (!thisObjJS) {
      aRv.Throw(NS_ERROR_FAILURE);
      return;
    }
    return Call(s.GetContext(), thisObjJS, myString, nullString, myEnum, aRv);
  }

  inline void
  Call(const nsAString& myString, const nsAString& nullString, TestEnum myEnum, ErrorResult& aRv)
  {
    CallSetup s(mCallable);
    if (!s.GetContext()) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    return Call(s.GetContext(), nullptr, myString, nullString, myEnum, aRv);
  }

private:
  void Call(JSContext* cx, JSObject* aThisObj, const nsAString& myString, const nsAString& nullString, TestEnum myEnum, ErrorResult& aRv);
};


class TestObjectArguments : public CallbackFunction
{
public:
  inline TestObjectArguments(JSContext* cx, JSObject* aOwner, JSObject* aCallable, bool* aInited)
    : CallbackFunction(cx, aOwner, aCallable, aInited)
  {
  }

  explicit inline TestObjectArguments(CallbackFunction* aOther)
    : CallbackFunction(aOther)
  {
  }

  template <typename T>
  inline void
  Call(const T& thisObj, JSObject* anObj, JSObject* anotherObj, JSObject* buf, JSObject* buf2, ErrorResult& aRv)
  {
    CallSetup s(mCallable);
    if (!s.GetContext()) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    JSObject* thisObjJS = WrapCallThisObject(s.GetContext(), mCallable, thisObj);
    if (!thisObjJS) {
      aRv.Throw(NS_ERROR_FAILURE);
      return;
    }
    return Call(s.GetContext(), thisObjJS, anObj, anotherObj, buf, buf2, aRv);
  }

  inline void
  Call(JSObject* anObj, JSObject* anotherObj, JSObject* buf, JSObject* buf2, ErrorResult& aRv)
  {
    CallSetup s(mCallable);
    if (!s.GetContext()) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    return Call(s.GetContext(), nullptr, anObj, anotherObj, buf, buf2, aRv);
  }

private:
  void Call(JSContext* cx, JSObject* aThisObj, JSObject* anObj, JSObject* anotherObj, JSObject* buf, JSObject* buf2, ErrorResult& aRv);
};


class TestOptionalArguments : public CallbackFunction
{
public:
  inline TestOptionalArguments(JSContext* cx, JSObject* aOwner, JSObject* aCallable, bool* aInited)
    : CallbackFunction(cx, aOwner, aCallable, aInited)
  {
  }

  explicit inline TestOptionalArguments(CallbackFunction* aOther)
    : CallbackFunction(aOther)
  {
  }

  template <typename T>
  inline void
  Call(const T& thisObj, const Optional< nsAString >& aString, const Optional< JSObject* >& something, const Optional< Sequence< OwningNonNull<mozilla::dom::TestInterface> > >& aSeq, const Optional< mozilla::dom::TestInterface* >& anInterface, const Optional< NonNull<mozilla::dom::TestInterface> >& anotherInterface, const Optional< int32_t >& aLong, ErrorResult& aRv)
  {
    CallSetup s(mCallable);
    if (!s.GetContext()) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    JSObject* thisObjJS = WrapCallThisObject(s.GetContext(), mCallable, thisObj);
    if (!thisObjJS) {
      aRv.Throw(NS_ERROR_FAILURE);
      return;
    }
    return Call(s.GetContext(), thisObjJS, aString, something, aSeq, anInterface, anotherInterface, aLong, aRv);
  }

  inline void
  Call(const Optional< nsAString >& aString, const Optional< JSObject* >& something, const Optional< Sequence< OwningNonNull<mozilla::dom::TestInterface> > >& aSeq, const Optional< mozilla::dom::TestInterface* >& anInterface, const Optional< NonNull<mozilla::dom::TestInterface> >& anotherInterface, const Optional< int32_t >& aLong, ErrorResult& aRv)
  {
    CallSetup s(mCallable);
    if (!s.GetContext()) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    return Call(s.GetContext(), nullptr, aString, something, aSeq, anInterface, anotherInterface, aLong, aRv);
  }

private:
  void Call(JSContext* cx, JSObject* aThisObj, const Optional< nsAString >& aString, const Optional< JSObject* >& something, const Optional< Sequence< OwningNonNull<mozilla::dom::TestInterface> > >& aSeq, const Optional< mozilla::dom::TestInterface* >& anInterface, const Optional< NonNull<mozilla::dom::TestInterface> >& anotherInterface, const Optional< int32_t >& aLong, ErrorResult& aRv);
};


namespace OnlyForUseInConstructorBinding {

  extern const NativePropertyHooks sNativePropertyHooks;

  void
  CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray);

  inline JSObject* GetProtoObject(JSContext* aCx, JSObject* aGlobal)
  {

    /* Get the interface prototype object for this class.  This will create the
       object as needed. */

    /* Make sure our global is sane.  Hopefully we can remove this sometime */
    if (!(js::GetObjectClass(aGlobal)->flags & JSCLASS_DOM_GLOBAL)) {
      return NULL;
    }
    /* Check to see whether the interface objects are already installed */
    JSObject** protoAndIfaceArray = GetProtoAndIfaceArray(aGlobal);
    JSObject* cachedObject = protoAndIfaceArray[prototypes::id::OnlyForUseInConstructor];
    if (!cachedObject) {
      CreateInterfaceObjects(aCx, aGlobal, protoAndIfaceArray);
      cachedObject = protoAndIfaceArray[prototypes::id::OnlyForUseInConstructor];
    }

    /* cachedObject might _still_ be null, but that's OK */
    return cachedObject;
  }

  inline JSObject* GetConstructorObject(JSContext* aCx, JSObject* aGlobal)
  {

    /* Get the interface object for this class.  This will create the object as
       needed. */

    /* Make sure our global is sane.  Hopefully we can remove this sometime */
    if (!(js::GetObjectClass(aGlobal)->flags & JSCLASS_DOM_GLOBAL)) {
      return NULL;
    }
    /* Check to see whether the interface objects are already installed */
    JSObject** protoAndIfaceArray = GetProtoAndIfaceArray(aGlobal);
    JSObject* cachedObject = protoAndIfaceArray[constructors::id::OnlyForUseInConstructor];
    if (!cachedObject) {
      CreateInterfaceObjects(aCx, aGlobal, protoAndIfaceArray);
      cachedObject = protoAndIfaceArray[constructors::id::OnlyForUseInConstructor];
    }

    /* cachedObject might _still_ be null, but that's OK */
    return cachedObject;
  }

  JSObject*
  DefineDOMInterface(JSContext* aCx, JSObject* aGlobal, bool* aEnabled);

  extern DOMJSClass Class;

  JSObject*
  Wrap(JSContext* aCx, JSObject* aScope, mozilla::dom::OnlyForUseInConstructor* aObject, nsWrapperCache* aCache, bool* aTriedToWrap);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, JSObject* aScope, T* aObject, bool* aTriedToWrap)
  {
    return Wrap(aCx, aScope, aObject, aObject, aTriedToWrap);
  }

} // namespace OnlyForUseInConstructorBinding



namespace TestChildInterfaceBinding {

  extern const NativePropertyHooks sNativePropertyHooks;

  void
  CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray);

  inline JSObject* GetProtoObject(JSContext* aCx, JSObject* aGlobal)
  {

    /* Get the interface prototype object for this class.  This will create the
       object as needed. */

    /* Make sure our global is sane.  Hopefully we can remove this sometime */
    if (!(js::GetObjectClass(aGlobal)->flags & JSCLASS_DOM_GLOBAL)) {
      return NULL;
    }
    /* Check to see whether the interface objects are already installed */
    JSObject** protoAndIfaceArray = GetProtoAndIfaceArray(aGlobal);
    JSObject* cachedObject = protoAndIfaceArray[prototypes::id::TestChildInterface];
    if (!cachedObject) {
      CreateInterfaceObjects(aCx, aGlobal, protoAndIfaceArray);
      cachedObject = protoAndIfaceArray[prototypes::id::TestChildInterface];
    }

    /* cachedObject might _still_ be null, but that's OK */
    return cachedObject;
  }

  inline JSObject* GetConstructorObject(JSContext* aCx, JSObject* aGlobal)
  {

    /* Get the interface object for this class.  This will create the object as
       needed. */

    /* Make sure our global is sane.  Hopefully we can remove this sometime */
    if (!(js::GetObjectClass(aGlobal)->flags & JSCLASS_DOM_GLOBAL)) {
      return NULL;
    }
    /* Check to see whether the interface objects are already installed */
    JSObject** protoAndIfaceArray = GetProtoAndIfaceArray(aGlobal);
    JSObject* cachedObject = protoAndIfaceArray[constructors::id::TestChildInterface];
    if (!cachedObject) {
      CreateInterfaceObjects(aCx, aGlobal, protoAndIfaceArray);
      cachedObject = protoAndIfaceArray[constructors::id::TestChildInterface];
    }

    /* cachedObject might _still_ be null, but that's OK */
    return cachedObject;
  }

  JSObject*
  DefineDOMInterface(JSContext* aCx, JSObject* aGlobal, bool* aEnabled);

  extern DOMJSClass Class;

  JSObject*
  Wrap(JSContext* aCx, JSObject* aScope, mozilla::dom::TestChildInterface* aObject, nsWrapperCache* aCache, bool* aTriedToWrap);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, JSObject* aScope, T* aObject, bool* aTriedToWrap)
  {
    return Wrap(aCx, aScope, aObject, aObject, aTriedToWrap);
  }

} // namespace TestChildInterfaceBinding



namespace TestCppKeywordNamedMethodsInterfaceBinding {

  extern const NativePropertyHooks sNativePropertyHooks;

  void
  CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray);

  inline JSObject* GetProtoObject(JSContext* aCx, JSObject* aGlobal)
  {

    /* Get the interface prototype object for this class.  This will create the
       object as needed. */

    /* Make sure our global is sane.  Hopefully we can remove this sometime */
    if (!(js::GetObjectClass(aGlobal)->flags & JSCLASS_DOM_GLOBAL)) {
      return NULL;
    }
    /* Check to see whether the interface objects are already installed */
    JSObject** protoAndIfaceArray = GetProtoAndIfaceArray(aGlobal);
    JSObject* cachedObject = protoAndIfaceArray[prototypes::id::TestCppKeywordNamedMethodsInterface];
    if (!cachedObject) {
      CreateInterfaceObjects(aCx, aGlobal, protoAndIfaceArray);
      cachedObject = protoAndIfaceArray[prototypes::id::TestCppKeywordNamedMethodsInterface];
    }

    /* cachedObject might _still_ be null, but that's OK */
    return cachedObject;
  }

  inline JSObject* GetConstructorObject(JSContext* aCx, JSObject* aGlobal)
  {

    /* Get the interface object for this class.  This will create the object as
       needed. */

    /* Make sure our global is sane.  Hopefully we can remove this sometime */
    if (!(js::GetObjectClass(aGlobal)->flags & JSCLASS_DOM_GLOBAL)) {
      return NULL;
    }
    /* Check to see whether the interface objects are already installed */
    JSObject** protoAndIfaceArray = GetProtoAndIfaceArray(aGlobal);
    JSObject* cachedObject = protoAndIfaceArray[constructors::id::TestCppKeywordNamedMethodsInterface];
    if (!cachedObject) {
      CreateInterfaceObjects(aCx, aGlobal, protoAndIfaceArray);
      cachedObject = protoAndIfaceArray[constructors::id::TestCppKeywordNamedMethodsInterface];
    }

    /* cachedObject might _still_ be null, but that's OK */
    return cachedObject;
  }

  JSObject*
  DefineDOMInterface(JSContext* aCx, JSObject* aGlobal, bool* aEnabled);

  extern DOMJSClass Class;

  JSObject*
  Wrap(JSContext* aCx, JSObject* aScope, mozilla::dom::TestCppKeywordNamedMethodsInterface* aObject, nsWrapperCache* aCache, bool* aTriedToWrap);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, JSObject* aScope, T* aObject, bool* aTriedToWrap)
  {
    return Wrap(aCx, aScope, aObject, aObject, aTriedToWrap);
  }

} // namespace TestCppKeywordNamedMethodsInterfaceBinding



namespace TestIndexedAndNamedDeleterInterfaceBinding {

  extern const NativePropertyHooks sNativePropertyHooks;

  void
  CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray);

  inline JSObject* GetProtoObject(JSContext* aCx, JSObject* aGlobal)
  {

    /* Get the interface prototype object for this class.  This will create the
       object as needed. */

    /* Make sure our global is sane.  Hopefully we can remove this sometime */
    if (!(js::GetObjectClass(aGlobal)->flags & JSCLASS_DOM_GLOBAL)) {
      return NULL;
    }
    /* Check to see whether the interface objects are already installed */
    JSObject** protoAndIfaceArray = GetProtoAndIfaceArray(aGlobal);
    JSObject* cachedObject = protoAndIfaceArray[prototypes::id::TestIndexedAndNamedDeleterInterface];
    if (!cachedObject) {
      CreateInterfaceObjects(aCx, aGlobal, protoAndIfaceArray);
      cachedObject = protoAndIfaceArray[prototypes::id::TestIndexedAndNamedDeleterInterface];
    }

    /* cachedObject might _still_ be null, but that's OK */
    return cachedObject;
  }

  inline JSObject* GetConstructorObject(JSContext* aCx, JSObject* aGlobal)
  {

    /* Get the interface object for this class.  This will create the object as
       needed. */

    /* Make sure our global is sane.  Hopefully we can remove this sometime */
    if (!(js::GetObjectClass(aGlobal)->flags & JSCLASS_DOM_GLOBAL)) {
      return NULL;
    }
    /* Check to see whether the interface objects are already installed */
    JSObject** protoAndIfaceArray = GetProtoAndIfaceArray(aGlobal);
    JSObject* cachedObject = protoAndIfaceArray[constructors::id::TestIndexedAndNamedDeleterInterface];
    if (!cachedObject) {
      CreateInterfaceObjects(aCx, aGlobal, protoAndIfaceArray);
      cachedObject = protoAndIfaceArray[constructors::id::TestIndexedAndNamedDeleterInterface];
    }

    /* cachedObject might _still_ be null, but that's OK */
    return cachedObject;
  }

  bool
  ResolveOwnProperty(JSContext* cx, JSObject* wrapper, JSObject* obj, jsid id, JSPropertyDescriptor* desc, unsigned flags);

  bool
  EnumerateOwnProperties(JSContext* cx, JSObject* wrapper, JSObject* obj, JS::AutoIdVector& props);

  JSObject*
  DefineDOMInterface(JSContext* aCx, JSObject* aGlobal, bool* aEnabled);

  extern const DOMClass Class;

  class DOMProxyHandler : public mozilla::dom::DOMProxyHandler
  {
    inline DOMProxyHandler();

  public:
    bool
    getOwnPropertyDescriptor(JSContext* cx, JSObject* proxy, jsid id, JSPropertyDescriptor* desc, unsigned flags);

    bool
    getOwnPropertyNames(JSContext* cx, JSObject* proxy, JS::AutoIdVector& props);

    bool
    hasOwn(JSContext* cx, JSObject* proxy, jsid id, bool* bp);

    bool
    get(JSContext* cx, JSObject* proxy, JSObject* receiver, jsid id, JS::Value* vp);

    JSString*
    obj_toString(JSContext* cx, JSObject* proxy);

    void
    finalize(JSFreeOp* fop, JSObject* proxy);

    bool
    getElementIfPresent(JSContext* cx, JSObject* proxy, JSObject* receiver, uint32_t index, JS::Value* vp, bool* present);

    static DOMProxyHandler*
    getInstance();

    bool
    delete_(JSContext* cx, JSObject* proxy, jsid id, bool* bp);
  };

  bool
  Is(JSObject* obj);

  JSObject*
  Wrap(JSContext* aCx, JSObject* aScope, mozilla::dom::TestIndexedAndNamedDeleterInterface* aObject, nsWrapperCache* aCache, bool* aTriedToWrap);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, JSObject* aScope, T* aObject, bool* aTriedToWrap)
  {
    return Wrap(aCx, aScope, aObject, aObject, aTriedToWrap);
  }

} // namespace TestIndexedAndNamedDeleterInterfaceBinding



namespace TestIndexedAndNamedGetterAndSetterInterfaceBinding {

  extern const NativePropertyHooks sNativePropertyHooks;

  void
  CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray);

  inline JSObject* GetProtoObject(JSContext* aCx, JSObject* aGlobal)
  {

    /* Get the interface prototype object for this class.  This will create the
       object as needed. */

    /* Make sure our global is sane.  Hopefully we can remove this sometime */
    if (!(js::GetObjectClass(aGlobal)->flags & JSCLASS_DOM_GLOBAL)) {
      return NULL;
    }
    /* Check to see whether the interface objects are already installed */
    JSObject** protoAndIfaceArray = GetProtoAndIfaceArray(aGlobal);
    JSObject* cachedObject = protoAndIfaceArray[prototypes::id::TestIndexedAndNamedGetterAndSetterInterface];
    if (!cachedObject) {
      CreateInterfaceObjects(aCx, aGlobal, protoAndIfaceArray);
      cachedObject = protoAndIfaceArray[prototypes::id::TestIndexedAndNamedGetterAndSetterInterface];
    }

    /* cachedObject might _still_ be null, but that's OK */
    return cachedObject;
  }

  inline JSObject* GetConstructorObject(JSContext* aCx, JSObject* aGlobal)
  {

    /* Get the interface object for this class.  This will create the object as
       needed. */

    /* Make sure our global is sane.  Hopefully we can remove this sometime */
    if (!(js::GetObjectClass(aGlobal)->flags & JSCLASS_DOM_GLOBAL)) {
      return NULL;
    }
    /* Check to see whether the interface objects are already installed */
    JSObject** protoAndIfaceArray = GetProtoAndIfaceArray(aGlobal);
    JSObject* cachedObject = protoAndIfaceArray[constructors::id::TestIndexedAndNamedGetterAndSetterInterface];
    if (!cachedObject) {
      CreateInterfaceObjects(aCx, aGlobal, protoAndIfaceArray);
      cachedObject = protoAndIfaceArray[constructors::id::TestIndexedAndNamedGetterAndSetterInterface];
    }

    /* cachedObject might _still_ be null, but that's OK */
    return cachedObject;
  }

  bool
  ResolveOwnProperty(JSContext* cx, JSObject* wrapper, JSObject* obj, jsid id, JSPropertyDescriptor* desc, unsigned flags);

  bool
  EnumerateOwnProperties(JSContext* cx, JSObject* wrapper, JSObject* obj, JS::AutoIdVector& props);

  JSObject*
  DefineDOMInterface(JSContext* aCx, JSObject* aGlobal, bool* aEnabled);

  extern const DOMClass Class;

  class DOMProxyHandler : public mozilla::dom::DOMProxyHandler
  {
    inline DOMProxyHandler();

  public:
    bool
    getOwnPropertyDescriptor(JSContext* cx, JSObject* proxy, jsid id, JSPropertyDescriptor* desc, unsigned flags);

    bool
    defineProperty(JSContext* cx, JSObject* proxy, jsid id, JSPropertyDescriptor* desc);

    bool
    getOwnPropertyNames(JSContext* cx, JSObject* proxy, JS::AutoIdVector& props);

    bool
    hasOwn(JSContext* cx, JSObject* proxy, jsid id, bool* bp);

    bool
    get(JSContext* cx, JSObject* proxy, JSObject* receiver, jsid id, JS::Value* vp);

    JSString*
    obj_toString(JSContext* cx, JSObject* proxy);

    void
    finalize(JSFreeOp* fop, JSObject* proxy);

    bool
    getElementIfPresent(JSContext* cx, JSObject* proxy, JSObject* receiver, uint32_t index, JS::Value* vp, bool* present);

    static DOMProxyHandler*
    getInstance();

    bool
    delete_(JSContext* cx, JSObject* proxy, jsid id, bool* bp);
  };

  bool
  Is(JSObject* obj);

  JSObject*
  Wrap(JSContext* aCx, JSObject* aScope, mozilla::dom::TestIndexedAndNamedGetterAndSetterInterface* aObject, nsWrapperCache* aCache, bool* aTriedToWrap);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, JSObject* aScope, T* aObject, bool* aTriedToWrap)
  {
    return Wrap(aCx, aScope, aObject, aObject, aTriedToWrap);
  }

} // namespace TestIndexedAndNamedGetterAndSetterInterfaceBinding



namespace TestIndexedAndNamedGetterInterfaceBinding {

  extern const NativePropertyHooks sNativePropertyHooks;

  void
  CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray);

  inline JSObject* GetProtoObject(JSContext* aCx, JSObject* aGlobal)
  {

    /* Get the interface prototype object for this class.  This will create the
       object as needed. */

    /* Make sure our global is sane.  Hopefully we can remove this sometime */
    if (!(js::GetObjectClass(aGlobal)->flags & JSCLASS_DOM_GLOBAL)) {
      return NULL;
    }
    /* Check to see whether the interface objects are already installed */
    JSObject** protoAndIfaceArray = GetProtoAndIfaceArray(aGlobal);
    JSObject* cachedObject = protoAndIfaceArray[prototypes::id::TestIndexedAndNamedGetterInterface];
    if (!cachedObject) {
      CreateInterfaceObjects(aCx, aGlobal, protoAndIfaceArray);
      cachedObject = protoAndIfaceArray[prototypes::id::TestIndexedAndNamedGetterInterface];
    }

    /* cachedObject might _still_ be null, but that's OK */
    return cachedObject;
  }

  inline JSObject* GetConstructorObject(JSContext* aCx, JSObject* aGlobal)
  {

    /* Get the interface object for this class.  This will create the object as
       needed. */

    /* Make sure our global is sane.  Hopefully we can remove this sometime */
    if (!(js::GetObjectClass(aGlobal)->flags & JSCLASS_DOM_GLOBAL)) {
      return NULL;
    }
    /* Check to see whether the interface objects are already installed */
    JSObject** protoAndIfaceArray = GetProtoAndIfaceArray(aGlobal);
    JSObject* cachedObject = protoAndIfaceArray[constructors::id::TestIndexedAndNamedGetterInterface];
    if (!cachedObject) {
      CreateInterfaceObjects(aCx, aGlobal, protoAndIfaceArray);
      cachedObject = protoAndIfaceArray[constructors::id::TestIndexedAndNamedGetterInterface];
    }

    /* cachedObject might _still_ be null, but that's OK */
    return cachedObject;
  }

  bool
  ResolveOwnProperty(JSContext* cx, JSObject* wrapper, JSObject* obj, jsid id, JSPropertyDescriptor* desc, unsigned flags);

  bool
  EnumerateOwnProperties(JSContext* cx, JSObject* wrapper, JSObject* obj, JS::AutoIdVector& props);

  JSObject*
  DefineDOMInterface(JSContext* aCx, JSObject* aGlobal, bool* aEnabled);

  extern const DOMClass Class;

  class DOMProxyHandler : public mozilla::dom::DOMProxyHandler
  {
    inline DOMProxyHandler();

  public:
    bool
    getOwnPropertyDescriptor(JSContext* cx, JSObject* proxy, jsid id, JSPropertyDescriptor* desc, unsigned flags);

    bool
    getOwnPropertyNames(JSContext* cx, JSObject* proxy, JS::AutoIdVector& props);

    bool
    hasOwn(JSContext* cx, JSObject* proxy, jsid id, bool* bp);

    bool
    get(JSContext* cx, JSObject* proxy, JSObject* receiver, jsid id, JS::Value* vp);

    JSString*
    obj_toString(JSContext* cx, JSObject* proxy);

    void
    finalize(JSFreeOp* fop, JSObject* proxy);

    bool
    getElementIfPresent(JSContext* cx, JSObject* proxy, JSObject* receiver, uint32_t index, JS::Value* vp, bool* present);

    static DOMProxyHandler*
    getInstance();

    bool
    delete_(JSContext* cx, JSObject* proxy, jsid id, bool* bp);
  };

  bool
  Is(JSObject* obj);

  JSObject*
  Wrap(JSContext* aCx, JSObject* aScope, mozilla::dom::TestIndexedAndNamedGetterInterface* aObject, nsWrapperCache* aCache, bool* aTriedToWrap);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, JSObject* aScope, T* aObject, bool* aTriedToWrap)
  {
    return Wrap(aCx, aScope, aObject, aObject, aTriedToWrap);
  }

} // namespace TestIndexedAndNamedGetterInterfaceBinding



namespace TestIndexedAndNamedSetterInterfaceBinding {

  extern const NativePropertyHooks sNativePropertyHooks;

  void
  CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray);

  inline JSObject* GetProtoObject(JSContext* aCx, JSObject* aGlobal)
  {

    /* Get the interface prototype object for this class.  This will create the
       object as needed. */

    /* Make sure our global is sane.  Hopefully we can remove this sometime */
    if (!(js::GetObjectClass(aGlobal)->flags & JSCLASS_DOM_GLOBAL)) {
      return NULL;
    }
    /* Check to see whether the interface objects are already installed */
    JSObject** protoAndIfaceArray = GetProtoAndIfaceArray(aGlobal);
    JSObject* cachedObject = protoAndIfaceArray[prototypes::id::TestIndexedAndNamedSetterInterface];
    if (!cachedObject) {
      CreateInterfaceObjects(aCx, aGlobal, protoAndIfaceArray);
      cachedObject = protoAndIfaceArray[prototypes::id::TestIndexedAndNamedSetterInterface];
    }

    /* cachedObject might _still_ be null, but that's OK */
    return cachedObject;
  }

  inline JSObject* GetConstructorObject(JSContext* aCx, JSObject* aGlobal)
  {

    /* Get the interface object for this class.  This will create the object as
       needed. */

    /* Make sure our global is sane.  Hopefully we can remove this sometime */
    if (!(js::GetObjectClass(aGlobal)->flags & JSCLASS_DOM_GLOBAL)) {
      return NULL;
    }
    /* Check to see whether the interface objects are already installed */
    JSObject** protoAndIfaceArray = GetProtoAndIfaceArray(aGlobal);
    JSObject* cachedObject = protoAndIfaceArray[constructors::id::TestIndexedAndNamedSetterInterface];
    if (!cachedObject) {
      CreateInterfaceObjects(aCx, aGlobal, protoAndIfaceArray);
      cachedObject = protoAndIfaceArray[constructors::id::TestIndexedAndNamedSetterInterface];
    }

    /* cachedObject might _still_ be null, but that's OK */
    return cachedObject;
  }

  bool
  ResolveOwnProperty(JSContext* cx, JSObject* wrapper, JSObject* obj, jsid id, JSPropertyDescriptor* desc, unsigned flags);

  bool
  EnumerateOwnProperties(JSContext* cx, JSObject* wrapper, JSObject* obj, JS::AutoIdVector& props);

  JSObject*
  DefineDOMInterface(JSContext* aCx, JSObject* aGlobal, bool* aEnabled);

  extern const DOMClass Class;

  class DOMProxyHandler : public mozilla::dom::DOMProxyHandler
  {
    inline DOMProxyHandler();

  public:
    bool
    getOwnPropertyDescriptor(JSContext* cx, JSObject* proxy, jsid id, JSPropertyDescriptor* desc, unsigned flags);

    bool
    defineProperty(JSContext* cx, JSObject* proxy, jsid id, JSPropertyDescriptor* desc);

    bool
    getOwnPropertyNames(JSContext* cx, JSObject* proxy, JS::AutoIdVector& props);

    bool
    hasOwn(JSContext* cx, JSObject* proxy, jsid id, bool* bp);

    bool
    get(JSContext* cx, JSObject* proxy, JSObject* receiver, jsid id, JS::Value* vp);

    JSString*
    obj_toString(JSContext* cx, JSObject* proxy);

    void
    finalize(JSFreeOp* fop, JSObject* proxy);

    bool
    getElementIfPresent(JSContext* cx, JSObject* proxy, JSObject* receiver, uint32_t index, JS::Value* vp, bool* present);

    static DOMProxyHandler*
    getInstance();

    bool
    delete_(JSContext* cx, JSObject* proxy, jsid id, bool* bp);
  };

  bool
  Is(JSObject* obj);

  JSObject*
  Wrap(JSContext* aCx, JSObject* aScope, mozilla::dom::TestIndexedAndNamedSetterInterface* aObject, nsWrapperCache* aCache, bool* aTriedToWrap);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, JSObject* aScope, T* aObject, bool* aTriedToWrap)
  {
    return Wrap(aCx, aScope, aObject, aObject, aTriedToWrap);
  }

} // namespace TestIndexedAndNamedSetterInterfaceBinding



namespace TestIndexedDeleterInterfaceBinding {

  extern const NativePropertyHooks sNativePropertyHooks;

  void
  CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray);

  inline JSObject* GetProtoObject(JSContext* aCx, JSObject* aGlobal)
  {

    /* Get the interface prototype object for this class.  This will create the
       object as needed. */

    /* Make sure our global is sane.  Hopefully we can remove this sometime */
    if (!(js::GetObjectClass(aGlobal)->flags & JSCLASS_DOM_GLOBAL)) {
      return NULL;
    }
    /* Check to see whether the interface objects are already installed */
    JSObject** protoAndIfaceArray = GetProtoAndIfaceArray(aGlobal);
    JSObject* cachedObject = protoAndIfaceArray[prototypes::id::TestIndexedDeleterInterface];
    if (!cachedObject) {
      CreateInterfaceObjects(aCx, aGlobal, protoAndIfaceArray);
      cachedObject = protoAndIfaceArray[prototypes::id::TestIndexedDeleterInterface];
    }

    /* cachedObject might _still_ be null, but that's OK */
    return cachedObject;
  }

  inline JSObject* GetConstructorObject(JSContext* aCx, JSObject* aGlobal)
  {

    /* Get the interface object for this class.  This will create the object as
       needed. */

    /* Make sure our global is sane.  Hopefully we can remove this sometime */
    if (!(js::GetObjectClass(aGlobal)->flags & JSCLASS_DOM_GLOBAL)) {
      return NULL;
    }
    /* Check to see whether the interface objects are already installed */
    JSObject** protoAndIfaceArray = GetProtoAndIfaceArray(aGlobal);
    JSObject* cachedObject = protoAndIfaceArray[constructors::id::TestIndexedDeleterInterface];
    if (!cachedObject) {
      CreateInterfaceObjects(aCx, aGlobal, protoAndIfaceArray);
      cachedObject = protoAndIfaceArray[constructors::id::TestIndexedDeleterInterface];
    }

    /* cachedObject might _still_ be null, but that's OK */
    return cachedObject;
  }

  bool
  ResolveOwnProperty(JSContext* cx, JSObject* wrapper, JSObject* obj, jsid id, JSPropertyDescriptor* desc, unsigned flags);

  bool
  EnumerateOwnProperties(JSContext* cx, JSObject* wrapper, JSObject* obj, JS::AutoIdVector& props);

  JSObject*
  DefineDOMInterface(JSContext* aCx, JSObject* aGlobal, bool* aEnabled);

  extern const DOMClass Class;

  class DOMProxyHandler : public mozilla::dom::DOMProxyHandler
  {
    inline DOMProxyHandler();

  public:
    bool
    getOwnPropertyDescriptor(JSContext* cx, JSObject* proxy, jsid id, JSPropertyDescriptor* desc, unsigned flags);

    bool
    getOwnPropertyNames(JSContext* cx, JSObject* proxy, JS::AutoIdVector& props);

    bool
    hasOwn(JSContext* cx, JSObject* proxy, jsid id, bool* bp);

    bool
    get(JSContext* cx, JSObject* proxy, JSObject* receiver, jsid id, JS::Value* vp);

    JSString*
    obj_toString(JSContext* cx, JSObject* proxy);

    void
    finalize(JSFreeOp* fop, JSObject* proxy);

    bool
    getElementIfPresent(JSContext* cx, JSObject* proxy, JSObject* receiver, uint32_t index, JS::Value* vp, bool* present);

    static DOMProxyHandler*
    getInstance();

    bool
    delete_(JSContext* cx, JSObject* proxy, jsid id, bool* bp);
  };

  bool
  Is(JSObject* obj);

  JSObject*
  Wrap(JSContext* aCx, JSObject* aScope, mozilla::dom::TestIndexedDeleterInterface* aObject, nsWrapperCache* aCache, bool* aTriedToWrap);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, JSObject* aScope, T* aObject, bool* aTriedToWrap)
  {
    return Wrap(aCx, aScope, aObject, aObject, aTriedToWrap);
  }

} // namespace TestIndexedDeleterInterfaceBinding



namespace TestIndexedDeleterWithRetvalInterfaceBinding {

  extern const NativePropertyHooks sNativePropertyHooks;

  void
  CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray);

  inline JSObject* GetProtoObject(JSContext* aCx, JSObject* aGlobal)
  {

    /* Get the interface prototype object for this class.  This will create the
       object as needed. */

    /* Make sure our global is sane.  Hopefully we can remove this sometime */
    if (!(js::GetObjectClass(aGlobal)->flags & JSCLASS_DOM_GLOBAL)) {
      return NULL;
    }
    /* Check to see whether the interface objects are already installed */
    JSObject** protoAndIfaceArray = GetProtoAndIfaceArray(aGlobal);
    JSObject* cachedObject = protoAndIfaceArray[prototypes::id::TestIndexedDeleterWithRetvalInterface];
    if (!cachedObject) {
      CreateInterfaceObjects(aCx, aGlobal, protoAndIfaceArray);
      cachedObject = protoAndIfaceArray[prototypes::id::TestIndexedDeleterWithRetvalInterface];
    }

    /* cachedObject might _still_ be null, but that's OK */
    return cachedObject;
  }

  inline JSObject* GetConstructorObject(JSContext* aCx, JSObject* aGlobal)
  {

    /* Get the interface object for this class.  This will create the object as
       needed. */

    /* Make sure our global is sane.  Hopefully we can remove this sometime */
    if (!(js::GetObjectClass(aGlobal)->flags & JSCLASS_DOM_GLOBAL)) {
      return NULL;
    }
    /* Check to see whether the interface objects are already installed */
    JSObject** protoAndIfaceArray = GetProtoAndIfaceArray(aGlobal);
    JSObject* cachedObject = protoAndIfaceArray[constructors::id::TestIndexedDeleterWithRetvalInterface];
    if (!cachedObject) {
      CreateInterfaceObjects(aCx, aGlobal, protoAndIfaceArray);
      cachedObject = protoAndIfaceArray[constructors::id::TestIndexedDeleterWithRetvalInterface];
    }

    /* cachedObject might _still_ be null, but that's OK */
    return cachedObject;
  }

  bool
  ResolveOwnProperty(JSContext* cx, JSObject* wrapper, JSObject* obj, jsid id, JSPropertyDescriptor* desc, unsigned flags);

  bool
  EnumerateOwnProperties(JSContext* cx, JSObject* wrapper, JSObject* obj, JS::AutoIdVector& props);

  JSObject*
  DefineDOMInterface(JSContext* aCx, JSObject* aGlobal, bool* aEnabled);

  extern const DOMClass Class;

  class DOMProxyHandler : public mozilla::dom::DOMProxyHandler
  {
    inline DOMProxyHandler();

  public:
    bool
    getOwnPropertyDescriptor(JSContext* cx, JSObject* proxy, jsid id, JSPropertyDescriptor* desc, unsigned flags);

    bool
    getOwnPropertyNames(JSContext* cx, JSObject* proxy, JS::AutoIdVector& props);

    bool
    hasOwn(JSContext* cx, JSObject* proxy, jsid id, bool* bp);

    bool
    get(JSContext* cx, JSObject* proxy, JSObject* receiver, jsid id, JS::Value* vp);

    JSString*
    obj_toString(JSContext* cx, JSObject* proxy);

    void
    finalize(JSFreeOp* fop, JSObject* proxy);

    bool
    getElementIfPresent(JSContext* cx, JSObject* proxy, JSObject* receiver, uint32_t index, JS::Value* vp, bool* present);

    static DOMProxyHandler*
    getInstance();

    bool
    delete_(JSContext* cx, JSObject* proxy, jsid id, bool* bp);
  };

  bool
  Is(JSObject* obj);

  JSObject*
  Wrap(JSContext* aCx, JSObject* aScope, mozilla::dom::TestIndexedDeleterWithRetvalInterface* aObject, nsWrapperCache* aCache, bool* aTriedToWrap);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, JSObject* aScope, T* aObject, bool* aTriedToWrap)
  {
    return Wrap(aCx, aScope, aObject, aObject, aTriedToWrap);
  }

} // namespace TestIndexedDeleterWithRetvalInterfaceBinding



namespace TestIndexedGetterAndSetterAndNamedGetterInterfaceBinding {

  extern const NativePropertyHooks sNativePropertyHooks;

  void
  CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray);

  inline JSObject* GetProtoObject(JSContext* aCx, JSObject* aGlobal)
  {

    /* Get the interface prototype object for this class.  This will create the
       object as needed. */

    /* Make sure our global is sane.  Hopefully we can remove this sometime */
    if (!(js::GetObjectClass(aGlobal)->flags & JSCLASS_DOM_GLOBAL)) {
      return NULL;
    }
    /* Check to see whether the interface objects are already installed */
    JSObject** protoAndIfaceArray = GetProtoAndIfaceArray(aGlobal);
    JSObject* cachedObject = protoAndIfaceArray[prototypes::id::TestIndexedGetterAndSetterAndNamedGetterInterface];
    if (!cachedObject) {
      CreateInterfaceObjects(aCx, aGlobal, protoAndIfaceArray);
      cachedObject = protoAndIfaceArray[prototypes::id::TestIndexedGetterAndSetterAndNamedGetterInterface];
    }

    /* cachedObject might _still_ be null, but that's OK */
    return cachedObject;
  }

  inline JSObject* GetConstructorObject(JSContext* aCx, JSObject* aGlobal)
  {

    /* Get the interface object for this class.  This will create the object as
       needed. */

    /* Make sure our global is sane.  Hopefully we can remove this sometime */
    if (!(js::GetObjectClass(aGlobal)->flags & JSCLASS_DOM_GLOBAL)) {
      return NULL;
    }
    /* Check to see whether the interface objects are already installed */
    JSObject** protoAndIfaceArray = GetProtoAndIfaceArray(aGlobal);
    JSObject* cachedObject = protoAndIfaceArray[constructors::id::TestIndexedGetterAndSetterAndNamedGetterInterface];
    if (!cachedObject) {
      CreateInterfaceObjects(aCx, aGlobal, protoAndIfaceArray);
      cachedObject = protoAndIfaceArray[constructors::id::TestIndexedGetterAndSetterAndNamedGetterInterface];
    }

    /* cachedObject might _still_ be null, but that's OK */
    return cachedObject;
  }

  bool
  ResolveOwnProperty(JSContext* cx, JSObject* wrapper, JSObject* obj, jsid id, JSPropertyDescriptor* desc, unsigned flags);

  bool
  EnumerateOwnProperties(JSContext* cx, JSObject* wrapper, JSObject* obj, JS::AutoIdVector& props);

  JSObject*
  DefineDOMInterface(JSContext* aCx, JSObject* aGlobal, bool* aEnabled);

  extern const DOMClass Class;

  class DOMProxyHandler : public mozilla::dom::DOMProxyHandler
  {
    inline DOMProxyHandler();

  public:
    bool
    getOwnPropertyDescriptor(JSContext* cx, JSObject* proxy, jsid id, JSPropertyDescriptor* desc, unsigned flags);

    bool
    defineProperty(JSContext* cx, JSObject* proxy, jsid id, JSPropertyDescriptor* desc);

    bool
    getOwnPropertyNames(JSContext* cx, JSObject* proxy, JS::AutoIdVector& props);

    bool
    hasOwn(JSContext* cx, JSObject* proxy, jsid id, bool* bp);

    bool
    get(JSContext* cx, JSObject* proxy, JSObject* receiver, jsid id, JS::Value* vp);

    JSString*
    obj_toString(JSContext* cx, JSObject* proxy);

    void
    finalize(JSFreeOp* fop, JSObject* proxy);

    bool
    getElementIfPresent(JSContext* cx, JSObject* proxy, JSObject* receiver, uint32_t index, JS::Value* vp, bool* present);

    static DOMProxyHandler*
    getInstance();

    bool
    delete_(JSContext* cx, JSObject* proxy, jsid id, bool* bp);
  };

  bool
  Is(JSObject* obj);

  JSObject*
  Wrap(JSContext* aCx, JSObject* aScope, mozilla::dom::TestIndexedGetterAndSetterAndNamedGetterInterface* aObject, nsWrapperCache* aCache, bool* aTriedToWrap);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, JSObject* aScope, T* aObject, bool* aTriedToWrap)
  {
    return Wrap(aCx, aScope, aObject, aObject, aTriedToWrap);
  }

} // namespace TestIndexedGetterAndSetterAndNamedGetterInterfaceBinding



namespace TestIndexedGetterInterfaceBinding {

  extern const NativePropertyHooks sNativePropertyHooks;

  void
  CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray);

  inline JSObject* GetProtoObject(JSContext* aCx, JSObject* aGlobal)
  {

    /* Get the interface prototype object for this class.  This will create the
       object as needed. */

    /* Make sure our global is sane.  Hopefully we can remove this sometime */
    if (!(js::GetObjectClass(aGlobal)->flags & JSCLASS_DOM_GLOBAL)) {
      return NULL;
    }
    /* Check to see whether the interface objects are already installed */
    JSObject** protoAndIfaceArray = GetProtoAndIfaceArray(aGlobal);
    JSObject* cachedObject = protoAndIfaceArray[prototypes::id::TestIndexedGetterInterface];
    if (!cachedObject) {
      CreateInterfaceObjects(aCx, aGlobal, protoAndIfaceArray);
      cachedObject = protoAndIfaceArray[prototypes::id::TestIndexedGetterInterface];
    }

    /* cachedObject might _still_ be null, but that's OK */
    return cachedObject;
  }

  inline JSObject* GetConstructorObject(JSContext* aCx, JSObject* aGlobal)
  {

    /* Get the interface object for this class.  This will create the object as
       needed. */

    /* Make sure our global is sane.  Hopefully we can remove this sometime */
    if (!(js::GetObjectClass(aGlobal)->flags & JSCLASS_DOM_GLOBAL)) {
      return NULL;
    }
    /* Check to see whether the interface objects are already installed */
    JSObject** protoAndIfaceArray = GetProtoAndIfaceArray(aGlobal);
    JSObject* cachedObject = protoAndIfaceArray[constructors::id::TestIndexedGetterInterface];
    if (!cachedObject) {
      CreateInterfaceObjects(aCx, aGlobal, protoAndIfaceArray);
      cachedObject = protoAndIfaceArray[constructors::id::TestIndexedGetterInterface];
    }

    /* cachedObject might _still_ be null, but that's OK */
    return cachedObject;
  }

  bool
  ResolveOwnProperty(JSContext* cx, JSObject* wrapper, JSObject* obj, jsid id, JSPropertyDescriptor* desc, unsigned flags);

  bool
  EnumerateOwnProperties(JSContext* cx, JSObject* wrapper, JSObject* obj, JS::AutoIdVector& props);

  JSObject*
  DefineDOMInterface(JSContext* aCx, JSObject* aGlobal, bool* aEnabled);

  extern const DOMClass Class;

  class DOMProxyHandler : public mozilla::dom::DOMProxyHandler
  {
    inline DOMProxyHandler();

  public:
    bool
    getOwnPropertyDescriptor(JSContext* cx, JSObject* proxy, jsid id, JSPropertyDescriptor* desc, unsigned flags);

    bool
    getOwnPropertyNames(JSContext* cx, JSObject* proxy, JS::AutoIdVector& props);

    bool
    hasOwn(JSContext* cx, JSObject* proxy, jsid id, bool* bp);

    bool
    get(JSContext* cx, JSObject* proxy, JSObject* receiver, jsid id, JS::Value* vp);

    JSString*
    obj_toString(JSContext* cx, JSObject* proxy);

    void
    finalize(JSFreeOp* fop, JSObject* proxy);

    bool
    getElementIfPresent(JSContext* cx, JSObject* proxy, JSObject* receiver, uint32_t index, JS::Value* vp, bool* present);

    static DOMProxyHandler*
    getInstance();

    bool
    delete_(JSContext* cx, JSObject* proxy, jsid id, bool* bp);
  };

  bool
  Is(JSObject* obj);

  JSObject*
  Wrap(JSContext* aCx, JSObject* aScope, mozilla::dom::TestIndexedGetterInterface* aObject, nsWrapperCache* aCache, bool* aTriedToWrap);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, JSObject* aScope, T* aObject, bool* aTriedToWrap)
  {
    return Wrap(aCx, aScope, aObject, aObject, aTriedToWrap);
  }

} // namespace TestIndexedGetterInterfaceBinding



namespace TestIndexedSetterInterfaceBinding {

  extern const NativePropertyHooks sNativePropertyHooks;

  void
  CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray);

  inline JSObject* GetProtoObject(JSContext* aCx, JSObject* aGlobal)
  {

    /* Get the interface prototype object for this class.  This will create the
       object as needed. */

    /* Make sure our global is sane.  Hopefully we can remove this sometime */
    if (!(js::GetObjectClass(aGlobal)->flags & JSCLASS_DOM_GLOBAL)) {
      return NULL;
    }
    /* Check to see whether the interface objects are already installed */
    JSObject** protoAndIfaceArray = GetProtoAndIfaceArray(aGlobal);
    JSObject* cachedObject = protoAndIfaceArray[prototypes::id::TestIndexedSetterInterface];
    if (!cachedObject) {
      CreateInterfaceObjects(aCx, aGlobal, protoAndIfaceArray);
      cachedObject = protoAndIfaceArray[prototypes::id::TestIndexedSetterInterface];
    }

    /* cachedObject might _still_ be null, but that's OK */
    return cachedObject;
  }

  inline JSObject* GetConstructorObject(JSContext* aCx, JSObject* aGlobal)
  {

    /* Get the interface object for this class.  This will create the object as
       needed. */

    /* Make sure our global is sane.  Hopefully we can remove this sometime */
    if (!(js::GetObjectClass(aGlobal)->flags & JSCLASS_DOM_GLOBAL)) {
      return NULL;
    }
    /* Check to see whether the interface objects are already installed */
    JSObject** protoAndIfaceArray = GetProtoAndIfaceArray(aGlobal);
    JSObject* cachedObject = protoAndIfaceArray[constructors::id::TestIndexedSetterInterface];
    if (!cachedObject) {
      CreateInterfaceObjects(aCx, aGlobal, protoAndIfaceArray);
      cachedObject = protoAndIfaceArray[constructors::id::TestIndexedSetterInterface];
    }

    /* cachedObject might _still_ be null, but that's OK */
    return cachedObject;
  }

  bool
  ResolveOwnProperty(JSContext* cx, JSObject* wrapper, JSObject* obj, jsid id, JSPropertyDescriptor* desc, unsigned flags);

  bool
  EnumerateOwnProperties(JSContext* cx, JSObject* wrapper, JSObject* obj, JS::AutoIdVector& props);

  JSObject*
  DefineDOMInterface(JSContext* aCx, JSObject* aGlobal, bool* aEnabled);

  extern const DOMClass Class;

  class DOMProxyHandler : public mozilla::dom::DOMProxyHandler
  {
    inline DOMProxyHandler();

  public:
    bool
    getOwnPropertyDescriptor(JSContext* cx, JSObject* proxy, jsid id, JSPropertyDescriptor* desc, unsigned flags);

    bool
    defineProperty(JSContext* cx, JSObject* proxy, jsid id, JSPropertyDescriptor* desc);

    bool
    getOwnPropertyNames(JSContext* cx, JSObject* proxy, JS::AutoIdVector& props);

    bool
    hasOwn(JSContext* cx, JSObject* proxy, jsid id, bool* bp);

    bool
    get(JSContext* cx, JSObject* proxy, JSObject* receiver, jsid id, JS::Value* vp);

    JSString*
    obj_toString(JSContext* cx, JSObject* proxy);

    void
    finalize(JSFreeOp* fop, JSObject* proxy);

    bool
    getElementIfPresent(JSContext* cx, JSObject* proxy, JSObject* receiver, uint32_t index, JS::Value* vp, bool* present);

    static DOMProxyHandler*
    getInstance();

    bool
    delete_(JSContext* cx, JSObject* proxy, jsid id, bool* bp);
  };

  bool
  Is(JSObject* obj);

  JSObject*
  Wrap(JSContext* aCx, JSObject* aScope, mozilla::dom::TestIndexedSetterInterface* aObject, nsWrapperCache* aCache, bool* aTriedToWrap);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, JSObject* aScope, T* aObject, bool* aTriedToWrap)
  {
    return Wrap(aCx, aScope, aObject, aObject, aTriedToWrap);
  }

} // namespace TestIndexedSetterInterfaceBinding



namespace TestInterfaceBinding {

  extern const NativePropertyHooks sNativePropertyHooks;

  void
  CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray);

  inline JSObject* GetProtoObject(JSContext* aCx, JSObject* aGlobal)
  {

    /* Get the interface prototype object for this class.  This will create the
       object as needed. */

    /* Make sure our global is sane.  Hopefully we can remove this sometime */
    if (!(js::GetObjectClass(aGlobal)->flags & JSCLASS_DOM_GLOBAL)) {
      return NULL;
    }
    /* Check to see whether the interface objects are already installed */
    JSObject** protoAndIfaceArray = GetProtoAndIfaceArray(aGlobal);
    JSObject* cachedObject = protoAndIfaceArray[prototypes::id::TestInterface];
    if (!cachedObject) {
      CreateInterfaceObjects(aCx, aGlobal, protoAndIfaceArray);
      cachedObject = protoAndIfaceArray[prototypes::id::TestInterface];
    }

    /* cachedObject might _still_ be null, but that's OK */
    return cachedObject;
  }

  inline JSObject* GetConstructorObject(JSContext* aCx, JSObject* aGlobal)
  {

    /* Get the interface object for this class.  This will create the object as
       needed. */

    /* Make sure our global is sane.  Hopefully we can remove this sometime */
    if (!(js::GetObjectClass(aGlobal)->flags & JSCLASS_DOM_GLOBAL)) {
      return NULL;
    }
    /* Check to see whether the interface objects are already installed */
    JSObject** protoAndIfaceArray = GetProtoAndIfaceArray(aGlobal);
    JSObject* cachedObject = protoAndIfaceArray[constructors::id::TestInterface];
    if (!cachedObject) {
      CreateInterfaceObjects(aCx, aGlobal, protoAndIfaceArray);
      cachedObject = protoAndIfaceArray[constructors::id::TestInterface];
    }

    /* cachedObject might _still_ be null, but that's OK */
    return cachedObject;
  }

  JSObject*
  DefineDOMInterface(JSContext* aCx, JSObject* aGlobal, bool* aEnabled);

  extern DOMJSClass Class;

  JSObject*
  Wrap(JSContext* aCx, JSObject* aScope, mozilla::dom::TestInterface* aObject, nsWrapperCache* aCache, bool* aTriedToWrap);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, JSObject* aScope, T* aObject, bool* aTriedToWrap)
  {
    return Wrap(aCx, aScope, aObject, aObject, aTriedToWrap);
  }

} // namespace TestInterfaceBinding



namespace TestNamedDeleterInterfaceBinding {

  extern const NativePropertyHooks sNativePropertyHooks;

  void
  CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray);

  inline JSObject* GetProtoObject(JSContext* aCx, JSObject* aGlobal)
  {

    /* Get the interface prototype object for this class.  This will create the
       object as needed. */

    /* Make sure our global is sane.  Hopefully we can remove this sometime */
    if (!(js::GetObjectClass(aGlobal)->flags & JSCLASS_DOM_GLOBAL)) {
      return NULL;
    }
    /* Check to see whether the interface objects are already installed */
    JSObject** protoAndIfaceArray = GetProtoAndIfaceArray(aGlobal);
    JSObject* cachedObject = protoAndIfaceArray[prototypes::id::TestNamedDeleterInterface];
    if (!cachedObject) {
      CreateInterfaceObjects(aCx, aGlobal, protoAndIfaceArray);
      cachedObject = protoAndIfaceArray[prototypes::id::TestNamedDeleterInterface];
    }

    /* cachedObject might _still_ be null, but that's OK */
    return cachedObject;
  }

  inline JSObject* GetConstructorObject(JSContext* aCx, JSObject* aGlobal)
  {

    /* Get the interface object for this class.  This will create the object as
       needed. */

    /* Make sure our global is sane.  Hopefully we can remove this sometime */
    if (!(js::GetObjectClass(aGlobal)->flags & JSCLASS_DOM_GLOBAL)) {
      return NULL;
    }
    /* Check to see whether the interface objects are already installed */
    JSObject** protoAndIfaceArray = GetProtoAndIfaceArray(aGlobal);
    JSObject* cachedObject = protoAndIfaceArray[constructors::id::TestNamedDeleterInterface];
    if (!cachedObject) {
      CreateInterfaceObjects(aCx, aGlobal, protoAndIfaceArray);
      cachedObject = protoAndIfaceArray[constructors::id::TestNamedDeleterInterface];
    }

    /* cachedObject might _still_ be null, but that's OK */
    return cachedObject;
  }

  bool
  ResolveOwnProperty(JSContext* cx, JSObject* wrapper, JSObject* obj, jsid id, JSPropertyDescriptor* desc, unsigned flags);

  bool
  EnumerateOwnProperties(JSContext* cx, JSObject* wrapper, JSObject* obj, JS::AutoIdVector& props);

  JSObject*
  DefineDOMInterface(JSContext* aCx, JSObject* aGlobal, bool* aEnabled);

  extern const DOMClass Class;

  class DOMProxyHandler : public mozilla::dom::DOMProxyHandler
  {
    inline DOMProxyHandler();

  public:
    bool
    getOwnPropertyDescriptor(JSContext* cx, JSObject* proxy, jsid id, JSPropertyDescriptor* desc, unsigned flags);

    bool
    getOwnPropertyNames(JSContext* cx, JSObject* proxy, JS::AutoIdVector& props);

    bool
    hasOwn(JSContext* cx, JSObject* proxy, jsid id, bool* bp);

    bool
    get(JSContext* cx, JSObject* proxy, JSObject* receiver, jsid id, JS::Value* vp);

    JSString*
    obj_toString(JSContext* cx, JSObject* proxy);

    void
    finalize(JSFreeOp* fop, JSObject* proxy);

    bool
    getElementIfPresent(JSContext* cx, JSObject* proxy, JSObject* receiver, uint32_t index, JS::Value* vp, bool* present);

    static DOMProxyHandler*
    getInstance();

    bool
    delete_(JSContext* cx, JSObject* proxy, jsid id, bool* bp);
  };

  bool
  Is(JSObject* obj);

  JSObject*
  Wrap(JSContext* aCx, JSObject* aScope, mozilla::dom::TestNamedDeleterInterface* aObject, nsWrapperCache* aCache, bool* aTriedToWrap);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, JSObject* aScope, T* aObject, bool* aTriedToWrap)
  {
    return Wrap(aCx, aScope, aObject, aObject, aTriedToWrap);
  }

} // namespace TestNamedDeleterInterfaceBinding



namespace TestNamedDeleterWithRetvalInterfaceBinding {

  extern const NativePropertyHooks sNativePropertyHooks;

  void
  CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray);

  inline JSObject* GetProtoObject(JSContext* aCx, JSObject* aGlobal)
  {

    /* Get the interface prototype object for this class.  This will create the
       object as needed. */

    /* Make sure our global is sane.  Hopefully we can remove this sometime */
    if (!(js::GetObjectClass(aGlobal)->flags & JSCLASS_DOM_GLOBAL)) {
      return NULL;
    }
    /* Check to see whether the interface objects are already installed */
    JSObject** protoAndIfaceArray = GetProtoAndIfaceArray(aGlobal);
    JSObject* cachedObject = protoAndIfaceArray[prototypes::id::TestNamedDeleterWithRetvalInterface];
    if (!cachedObject) {
      CreateInterfaceObjects(aCx, aGlobal, protoAndIfaceArray);
      cachedObject = protoAndIfaceArray[prototypes::id::TestNamedDeleterWithRetvalInterface];
    }

    /* cachedObject might _still_ be null, but that's OK */
    return cachedObject;
  }

  inline JSObject* GetConstructorObject(JSContext* aCx, JSObject* aGlobal)
  {

    /* Get the interface object for this class.  This will create the object as
       needed. */

    /* Make sure our global is sane.  Hopefully we can remove this sometime */
    if (!(js::GetObjectClass(aGlobal)->flags & JSCLASS_DOM_GLOBAL)) {
      return NULL;
    }
    /* Check to see whether the interface objects are already installed */
    JSObject** protoAndIfaceArray = GetProtoAndIfaceArray(aGlobal);
    JSObject* cachedObject = protoAndIfaceArray[constructors::id::TestNamedDeleterWithRetvalInterface];
    if (!cachedObject) {
      CreateInterfaceObjects(aCx, aGlobal, protoAndIfaceArray);
      cachedObject = protoAndIfaceArray[constructors::id::TestNamedDeleterWithRetvalInterface];
    }

    /* cachedObject might _still_ be null, but that's OK */
    return cachedObject;
  }

  bool
  ResolveOwnProperty(JSContext* cx, JSObject* wrapper, JSObject* obj, jsid id, JSPropertyDescriptor* desc, unsigned flags);

  bool
  EnumerateOwnProperties(JSContext* cx, JSObject* wrapper, JSObject* obj, JS::AutoIdVector& props);

  JSObject*
  DefineDOMInterface(JSContext* aCx, JSObject* aGlobal, bool* aEnabled);

  extern const DOMClass Class;

  class DOMProxyHandler : public mozilla::dom::DOMProxyHandler
  {
    inline DOMProxyHandler();

  public:
    bool
    getOwnPropertyDescriptor(JSContext* cx, JSObject* proxy, jsid id, JSPropertyDescriptor* desc, unsigned flags);

    bool
    getOwnPropertyNames(JSContext* cx, JSObject* proxy, JS::AutoIdVector& props);

    bool
    hasOwn(JSContext* cx, JSObject* proxy, jsid id, bool* bp);

    bool
    get(JSContext* cx, JSObject* proxy, JSObject* receiver, jsid id, JS::Value* vp);

    JSString*
    obj_toString(JSContext* cx, JSObject* proxy);

    void
    finalize(JSFreeOp* fop, JSObject* proxy);

    bool
    getElementIfPresent(JSContext* cx, JSObject* proxy, JSObject* receiver, uint32_t index, JS::Value* vp, bool* present);

    static DOMProxyHandler*
    getInstance();

    bool
    delete_(JSContext* cx, JSObject* proxy, jsid id, bool* bp);
  };

  bool
  Is(JSObject* obj);

  JSObject*
  Wrap(JSContext* aCx, JSObject* aScope, mozilla::dom::TestNamedDeleterWithRetvalInterface* aObject, nsWrapperCache* aCache, bool* aTriedToWrap);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, JSObject* aScope, T* aObject, bool* aTriedToWrap)
  {
    return Wrap(aCx, aScope, aObject, aObject, aTriedToWrap);
  }

} // namespace TestNamedDeleterWithRetvalInterfaceBinding



namespace TestNamedGetterInterfaceBinding {

  extern const NativePropertyHooks sNativePropertyHooks;

  void
  CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray);

  inline JSObject* GetProtoObject(JSContext* aCx, JSObject* aGlobal)
  {

    /* Get the interface prototype object for this class.  This will create the
       object as needed. */

    /* Make sure our global is sane.  Hopefully we can remove this sometime */
    if (!(js::GetObjectClass(aGlobal)->flags & JSCLASS_DOM_GLOBAL)) {
      return NULL;
    }
    /* Check to see whether the interface objects are already installed */
    JSObject** protoAndIfaceArray = GetProtoAndIfaceArray(aGlobal);
    JSObject* cachedObject = protoAndIfaceArray[prototypes::id::TestNamedGetterInterface];
    if (!cachedObject) {
      CreateInterfaceObjects(aCx, aGlobal, protoAndIfaceArray);
      cachedObject = protoAndIfaceArray[prototypes::id::TestNamedGetterInterface];
    }

    /* cachedObject might _still_ be null, but that's OK */
    return cachedObject;
  }

  inline JSObject* GetConstructorObject(JSContext* aCx, JSObject* aGlobal)
  {

    /* Get the interface object for this class.  This will create the object as
       needed. */

    /* Make sure our global is sane.  Hopefully we can remove this sometime */
    if (!(js::GetObjectClass(aGlobal)->flags & JSCLASS_DOM_GLOBAL)) {
      return NULL;
    }
    /* Check to see whether the interface objects are already installed */
    JSObject** protoAndIfaceArray = GetProtoAndIfaceArray(aGlobal);
    JSObject* cachedObject = protoAndIfaceArray[constructors::id::TestNamedGetterInterface];
    if (!cachedObject) {
      CreateInterfaceObjects(aCx, aGlobal, protoAndIfaceArray);
      cachedObject = protoAndIfaceArray[constructors::id::TestNamedGetterInterface];
    }

    /* cachedObject might _still_ be null, but that's OK */
    return cachedObject;
  }

  bool
  ResolveOwnProperty(JSContext* cx, JSObject* wrapper, JSObject* obj, jsid id, JSPropertyDescriptor* desc, unsigned flags);

  bool
  EnumerateOwnProperties(JSContext* cx, JSObject* wrapper, JSObject* obj, JS::AutoIdVector& props);

  JSObject*
  DefineDOMInterface(JSContext* aCx, JSObject* aGlobal, bool* aEnabled);

  extern const DOMClass Class;

  class DOMProxyHandler : public mozilla::dom::DOMProxyHandler
  {
    inline DOMProxyHandler();

  public:
    bool
    getOwnPropertyDescriptor(JSContext* cx, JSObject* proxy, jsid id, JSPropertyDescriptor* desc, unsigned flags);

    bool
    getOwnPropertyNames(JSContext* cx, JSObject* proxy, JS::AutoIdVector& props);

    bool
    hasOwn(JSContext* cx, JSObject* proxy, jsid id, bool* bp);

    bool
    get(JSContext* cx, JSObject* proxy, JSObject* receiver, jsid id, JS::Value* vp);

    JSString*
    obj_toString(JSContext* cx, JSObject* proxy);

    void
    finalize(JSFreeOp* fop, JSObject* proxy);

    bool
    getElementIfPresent(JSContext* cx, JSObject* proxy, JSObject* receiver, uint32_t index, JS::Value* vp, bool* present);

    static DOMProxyHandler*
    getInstance();

    bool
    delete_(JSContext* cx, JSObject* proxy, jsid id, bool* bp);
  };

  bool
  Is(JSObject* obj);

  JSObject*
  Wrap(JSContext* aCx, JSObject* aScope, mozilla::dom::TestNamedGetterInterface* aObject, nsWrapperCache* aCache, bool* aTriedToWrap);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, JSObject* aScope, T* aObject, bool* aTriedToWrap)
  {
    return Wrap(aCx, aScope, aObject, aObject, aTriedToWrap);
  }

} // namespace TestNamedGetterInterfaceBinding



namespace TestNamedSetterInterfaceBinding {

  extern const NativePropertyHooks sNativePropertyHooks;

  void
  CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray);

  inline JSObject* GetProtoObject(JSContext* aCx, JSObject* aGlobal)
  {

    /* Get the interface prototype object for this class.  This will create the
       object as needed. */

    /* Make sure our global is sane.  Hopefully we can remove this sometime */
    if (!(js::GetObjectClass(aGlobal)->flags & JSCLASS_DOM_GLOBAL)) {
      return NULL;
    }
    /* Check to see whether the interface objects are already installed */
    JSObject** protoAndIfaceArray = GetProtoAndIfaceArray(aGlobal);
    JSObject* cachedObject = protoAndIfaceArray[prototypes::id::TestNamedSetterInterface];
    if (!cachedObject) {
      CreateInterfaceObjects(aCx, aGlobal, protoAndIfaceArray);
      cachedObject = protoAndIfaceArray[prototypes::id::TestNamedSetterInterface];
    }

    /* cachedObject might _still_ be null, but that's OK */
    return cachedObject;
  }

  inline JSObject* GetConstructorObject(JSContext* aCx, JSObject* aGlobal)
  {

    /* Get the interface object for this class.  This will create the object as
       needed. */

    /* Make sure our global is sane.  Hopefully we can remove this sometime */
    if (!(js::GetObjectClass(aGlobal)->flags & JSCLASS_DOM_GLOBAL)) {
      return NULL;
    }
    /* Check to see whether the interface objects are already installed */
    JSObject** protoAndIfaceArray = GetProtoAndIfaceArray(aGlobal);
    JSObject* cachedObject = protoAndIfaceArray[constructors::id::TestNamedSetterInterface];
    if (!cachedObject) {
      CreateInterfaceObjects(aCx, aGlobal, protoAndIfaceArray);
      cachedObject = protoAndIfaceArray[constructors::id::TestNamedSetterInterface];
    }

    /* cachedObject might _still_ be null, but that's OK */
    return cachedObject;
  }

  bool
  ResolveOwnProperty(JSContext* cx, JSObject* wrapper, JSObject* obj, jsid id, JSPropertyDescriptor* desc, unsigned flags);

  bool
  EnumerateOwnProperties(JSContext* cx, JSObject* wrapper, JSObject* obj, JS::AutoIdVector& props);

  JSObject*
  DefineDOMInterface(JSContext* aCx, JSObject* aGlobal, bool* aEnabled);

  extern const DOMClass Class;

  class DOMProxyHandler : public mozilla::dom::DOMProxyHandler
  {
    inline DOMProxyHandler();

  public:
    bool
    getOwnPropertyDescriptor(JSContext* cx, JSObject* proxy, jsid id, JSPropertyDescriptor* desc, unsigned flags);

    bool
    defineProperty(JSContext* cx, JSObject* proxy, jsid id, JSPropertyDescriptor* desc);

    bool
    getOwnPropertyNames(JSContext* cx, JSObject* proxy, JS::AutoIdVector& props);

    bool
    hasOwn(JSContext* cx, JSObject* proxy, jsid id, bool* bp);

    bool
    get(JSContext* cx, JSObject* proxy, JSObject* receiver, jsid id, JS::Value* vp);

    JSString*
    obj_toString(JSContext* cx, JSObject* proxy);

    void
    finalize(JSFreeOp* fop, JSObject* proxy);

    bool
    getElementIfPresent(JSContext* cx, JSObject* proxy, JSObject* receiver, uint32_t index, JS::Value* vp, bool* present);

    static DOMProxyHandler*
    getInstance();

    bool
    delete_(JSContext* cx, JSObject* proxy, jsid id, bool* bp);
  };

  bool
  Is(JSObject* obj);

  JSObject*
  Wrap(JSContext* aCx, JSObject* aScope, mozilla::dom::TestNamedSetterInterface* aObject, nsWrapperCache* aCache, bool* aTriedToWrap);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, JSObject* aScope, T* aObject, bool* aTriedToWrap)
  {
    return Wrap(aCx, aScope, aObject, aObject, aTriedToWrap);
  }

} // namespace TestNamedSetterInterfaceBinding



namespace TestNonCastableInterfaceBinding {

  extern const NativePropertyHooks sNativePropertyHooks;

  void
  CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray);

  inline JSObject* GetProtoObject(JSContext* aCx, JSObject* aGlobal)
  {

    /* Get the interface prototype object for this class.  This will create the
       object as needed. */

    /* Make sure our global is sane.  Hopefully we can remove this sometime */
    if (!(js::GetObjectClass(aGlobal)->flags & JSCLASS_DOM_GLOBAL)) {
      return NULL;
    }
    /* Check to see whether the interface objects are already installed */
    JSObject** protoAndIfaceArray = GetProtoAndIfaceArray(aGlobal);
    JSObject* cachedObject = protoAndIfaceArray[prototypes::id::TestNonCastableInterface];
    if (!cachedObject) {
      CreateInterfaceObjects(aCx, aGlobal, protoAndIfaceArray);
      cachedObject = protoAndIfaceArray[prototypes::id::TestNonCastableInterface];
    }

    /* cachedObject might _still_ be null, but that's OK */
    return cachedObject;
  }

  inline JSObject* GetConstructorObject(JSContext* aCx, JSObject* aGlobal)
  {

    /* Get the interface object for this class.  This will create the object as
       needed. */

    /* Make sure our global is sane.  Hopefully we can remove this sometime */
    if (!(js::GetObjectClass(aGlobal)->flags & JSCLASS_DOM_GLOBAL)) {
      return NULL;
    }
    /* Check to see whether the interface objects are already installed */
    JSObject** protoAndIfaceArray = GetProtoAndIfaceArray(aGlobal);
    JSObject* cachedObject = protoAndIfaceArray[constructors::id::TestNonCastableInterface];
    if (!cachedObject) {
      CreateInterfaceObjects(aCx, aGlobal, protoAndIfaceArray);
      cachedObject = protoAndIfaceArray[constructors::id::TestNonCastableInterface];
    }

    /* cachedObject might _still_ be null, but that's OK */
    return cachedObject;
  }

  JSObject*
  DefineDOMInterface(JSContext* aCx, JSObject* aGlobal, bool* aEnabled);

  extern DOMJSClass Class;

  JSObject*
  Wrap(JSContext* aCx, JSObject* aScope, mozilla::dom::TestNonCastableInterface* aObject, nsWrapperCache* aCache, bool* aTriedToWrap);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, JSObject* aScope, T* aObject, bool* aTriedToWrap)
  {
    return Wrap(aCx, aScope, aObject, aObject, aTriedToWrap);
  }

} // namespace TestNonCastableInterfaceBinding



namespace TestNonWrapperCacheInterfaceBinding {

  extern const NativePropertyHooks sNativePropertyHooks;

  void
  CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray);

  inline JSObject* GetProtoObject(JSContext* aCx, JSObject* aGlobal)
  {

    /* Get the interface prototype object for this class.  This will create the
       object as needed. */

    /* Make sure our global is sane.  Hopefully we can remove this sometime */
    if (!(js::GetObjectClass(aGlobal)->flags & JSCLASS_DOM_GLOBAL)) {
      return NULL;
    }
    /* Check to see whether the interface objects are already installed */
    JSObject** protoAndIfaceArray = GetProtoAndIfaceArray(aGlobal);
    JSObject* cachedObject = protoAndIfaceArray[prototypes::id::TestNonWrapperCacheInterface];
    if (!cachedObject) {
      CreateInterfaceObjects(aCx, aGlobal, protoAndIfaceArray);
      cachedObject = protoAndIfaceArray[prototypes::id::TestNonWrapperCacheInterface];
    }

    /* cachedObject might _still_ be null, but that's OK */
    return cachedObject;
  }

  inline JSObject* GetConstructorObject(JSContext* aCx, JSObject* aGlobal)
  {

    /* Get the interface object for this class.  This will create the object as
       needed. */

    /* Make sure our global is sane.  Hopefully we can remove this sometime */
    if (!(js::GetObjectClass(aGlobal)->flags & JSCLASS_DOM_GLOBAL)) {
      return NULL;
    }
    /* Check to see whether the interface objects are already installed */
    JSObject** protoAndIfaceArray = GetProtoAndIfaceArray(aGlobal);
    JSObject* cachedObject = protoAndIfaceArray[constructors::id::TestNonWrapperCacheInterface];
    if (!cachedObject) {
      CreateInterfaceObjects(aCx, aGlobal, protoAndIfaceArray);
      cachedObject = protoAndIfaceArray[constructors::id::TestNonWrapperCacheInterface];
    }

    /* cachedObject might _still_ be null, but that's OK */
    return cachedObject;
  }

  JSObject*
  DefineDOMInterface(JSContext* aCx, JSObject* aGlobal, bool* aEnabled);

  extern DOMJSClass Class;

  JSObject*
  Wrap(JSContext* aCx, JSObject* aScope, mozilla::dom::TestNonWrapperCacheInterface* aObject);

} // namespace TestNonWrapperCacheInterfaceBinding



namespace TestRenamedInterfaceBinding {

  extern const NativePropertyHooks sNativePropertyHooks;

  void
  CreateInterfaceObjects(JSContext* aCx, JSObject* aGlobal, JSObject** protoAndIfaceArray);

  inline JSObject* GetProtoObject(JSContext* aCx, JSObject* aGlobal)
  {

    /* Get the interface prototype object for this class.  This will create the
       object as needed. */

    /* Make sure our global is sane.  Hopefully we can remove this sometime */
    if (!(js::GetObjectClass(aGlobal)->flags & JSCLASS_DOM_GLOBAL)) {
      return NULL;
    }
    /* Check to see whether the interface objects are already installed */
    JSObject** protoAndIfaceArray = GetProtoAndIfaceArray(aGlobal);
    JSObject* cachedObject = protoAndIfaceArray[prototypes::id::TestRenamedInterface];
    if (!cachedObject) {
      CreateInterfaceObjects(aCx, aGlobal, protoAndIfaceArray);
      cachedObject = protoAndIfaceArray[prototypes::id::TestRenamedInterface];
    }

    /* cachedObject might _still_ be null, but that's OK */
    return cachedObject;
  }

  inline JSObject* GetConstructorObject(JSContext* aCx, JSObject* aGlobal)
  {

    /* Get the interface object for this class.  This will create the object as
       needed. */

    /* Make sure our global is sane.  Hopefully we can remove this sometime */
    if (!(js::GetObjectClass(aGlobal)->flags & JSCLASS_DOM_GLOBAL)) {
      return NULL;
    }
    /* Check to see whether the interface objects are already installed */
    JSObject** protoAndIfaceArray = GetProtoAndIfaceArray(aGlobal);
    JSObject* cachedObject = protoAndIfaceArray[constructors::id::TestRenamedInterface];
    if (!cachedObject) {
      CreateInterfaceObjects(aCx, aGlobal, protoAndIfaceArray);
      cachedObject = protoAndIfaceArray[constructors::id::TestRenamedInterface];
    }

    /* cachedObject might _still_ be null, but that's OK */
    return cachedObject;
  }

  JSObject*
  DefineDOMInterface(JSContext* aCx, JSObject* aGlobal, bool* aEnabled);

  extern DOMJSClass Class;

  JSObject*
  Wrap(JSContext* aCx, JSObject* aScope, nsRenamedInterface* aObject, nsWrapperCache* aCache, bool* aTriedToWrap);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, JSObject* aScope, T* aObject, bool* aTriedToWrap)
  {
    return Wrap(aCx, aScope, aObject, aObject, aTriedToWrap);
  }

} // namespace TestRenamedInterfaceBinding



} // namespace dom
} // namespace mozilla

#endif // mozilla_dom_TestCodeGenBinding_h__
